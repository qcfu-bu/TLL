notation ( |> ) := (%2 %1)
notation ( @@ ) := (%1 %2)
notation ( = ) := eq %1 %2
notation ( ` ) := sing %1
notation ( && ) := and
notation ( || ) := or
notation ( + ) := add %1 %2
notation ( - ) := sub %1 %2
notation ( * ) := mul %1 %2
notation ( / ) := div %1 %2
notation ( % ) := rem %1 %2
notation ( ^ ) := pow %1 %2
notation ( < ) := lt %1 %2
notation ( > ) := gt %1 %2
notation ( <= ) := lte %1 %2
notation ( >= ) := gte %1 %2
notation ( ** ) := prod1 %1 %2
notation ( :: ) := cons %1 %2

#[logical]
inductive eq<s> ?(A : Type‹s›) (m : A) : A -> U where
  | refl : m = m

inductive unit<s> : Type<s> where
  | tt : unit

inductive bool : L where
  | true  : bool
  | false : bool

inductive nat : L where
  | zero : nat
  | succ (pred : nat) : nat

inductive sing ?(A : L) : A -> L where
  | just (m : A) : `m

def sing_elim ?{A : L} ?{x : A} : `x -> A
  | (just x) => x

#[logical]
def sing_uniq ?(A : L) ?(x0 : A) : forall (x : `x0) -> x0 = sing_elim x
  | (just _) => refl




-- dependent additive pair
inductive apair ?(A : L) (B : A -> L) : L where
  | apair_intro
    ?{x : A}
    (select : forall (b : bool) -o
                match b with
                | true  => `x
                | false => B x) : apair B

notation ( ( , ) ) :=
  apair_intro
    (function  
     | true  => just %1
     | false => %2)

def proj1 ?{A : L} ?{B : A -> L} : @apair A B -> A
  | (apair_intro _ select) => sing_elim (select true)

def proj2 ?{A : L} ?{B : A -> L} : forall (x : @apair A B) -> B (proj1 x)
  | (apair_intro x select) => 
    match {x}                       as x0 -- x is matched to introduce flex variable x0
        , {select true}             as a0 : `x
        , {sing_uniq (select true)} as _  : x0 = sing_elim a0
        , select false              as _  : B x0
      in B (sing_elim a0)
    with
    | _, _, refl, b => b




def bool2nat : bool -> nat
  | true  => succ zero
  | false => zero

def free_bool : bool -> unit<U>
  | true  => tt
  | false => tt

def free_nat : nat -> unit<U>
  | zero => tt
  | (succ n) => free_nat n

def my_apair : apair (fn (b : bool) => match b with true => unit<L> | false => nat) :=
  let my_val := false in
  (my_val, bool2nat my_val)

def _ : unit<U> := free_bool (proj1 my_apair)

-- def _ : unit<U> := free_nat (proj2 my_apair)
