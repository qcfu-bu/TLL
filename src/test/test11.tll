notation ( = ) := eq %1 %2
notation ( ` ) := sing %1

#[logical]
inductive eq<s> ?(A : Type<s>) (m : A) : A -> U where
  | refl : m = m

def rwl<s,r> ?{A : Type<s>} ?{m n : A} {B : A -> Type<r>} : {m = n} -> B m -> B n
  | refl x => x

def rwr<s,r> ?{A : Type<s>} ?{m n : A} {B : A -> Type<r>} : {m = n} -> B n -> B m
  | refl x => x

inductive sing<s> ?(A : Type<s>) : A -> Type<s> where
  | just (m : A) : `m

inductive unit : U where
  | tt : unit

inductive bool : U where
  | true  : bool
  | false : bool

inductive nat : U where
  | zero : nat
  | succ (n : nat) : nat

inductive list<s,t> (A : Type<s>) : Type<t> where
  | nil : list A
  | cons (hd : A) (tl : list<_,t> A) : list A

inductive exists0<s,r> ?(A : Type<s>) (B : A -> Type<r>) : L where
  | ex0 {m : A} (n : B m) : @exists0 A B

inductive exists1<s,r> ?(A : Type<s>) (B : A -> Type<r>) : L where
  | ex1 (m : A) (n : B m) : @exists1 A B

#[logical] def prod0<s,r> (A : Type<s>) (B : Type<r>) := @exists0 A (fn _ => B)
#[logical] def prod1<s,r> (A : Type<s>) (B : Type<r>) := @exists1 A (fn _ => B)

def not : bool -> bool
  | true  => false
  | false => true

def xor : bool -> bool -o bool
  | true  true  => false
  | false false => false
  | _     _     => true

def lte : nat -> nat -> bool
  | zero     _        => true
  | _        zero     => false
  | (succ x) (succ y) => lte x y

def lt (x : nat) (y : nat) : bool := lte (succ x) y

def pred : nat -> nat
  | zero => zero
  | (succ x) => x

def add : nat -> nat -> nat
  | zero     y => y 
  | (succ x) y => succ (add x y)

def sub : nat -> nat -> nat
  | x zero     => x
  | x (succ y) => sub (pred x) y

def mul : nat -> nat -> nat
  | zero     _ => zero
  | (succ x) y => add y (mul x y)

def div (x : nat) (y : nat) :=
  match lt x y with
  | true  => zero
  | false => succ (div (sub x y) y)

def rem (x : nat) (y : nat) :=
  sub x (mul (div x y) y)

def pow : nat -> nat -> nat
  | _ zero     => succ zero
  | x (succ y) => mul x (pow x y)

#[logical] extern proto : U
#[logical] extern act0<s> (b : bool) ?(A : Type<s>) (B : A -> proto) : proto
#[logical] extern act1<s> (b : bool) ?(A : Type<s>) (B : A -> proto) : proto
#[logical] extern endp : proto
#[logical] extern ch : bool -> proto -> L

extern close ?{b : bool} : ch b endp -> IO unit 
extern send0<s> ?{b1 b2 : bool} ?{A : Type<s>} ?{B : A -> proto} : {eq (xor b1 b2) false} -> (ch b1 (act0 b2 B)) -> ∀ {x : A} -o IO (ch b1 (B x))
extern send1<s> ?{b1 b2 : bool} ?{A : Type<s>} ?{B : A -> proto} : {eq (xor b1 b2) false} -> (ch b1 (act1 b2 B)) -> ∀ (x : A) -o IO (ch b1 (B x))
extern recv0<s> ?{b1 b2 : bool} ?{A : Type<s>} ?{B : A -> proto} : {eq (xor b1 b2) true} -> (ch b1 (act0 b2 B)) -> IO (exists0 fn (x : A) => ch b1 (B x))
extern recv1<s> ?{b1 b2 : bool} ?{A : Type<s>} ?{B : A -> proto} : {eq (xor b1 b2) true} -> (ch b1 (act1 b2 B)) -> IO (exists1 fn (x : A) => ch b1 (B x))
extern fork ?{b : bool} {P : proto} : (ch b P -o IO unit) -> IO (ch (not b) P)

def split<t> : list<_,t> nat -> prod1 (list<_,t> nat) (list<_,t> nat)
  | nil                  => ex1 nil nil
  | (cons x nil)         => ex1 (cons x nil) nil
  | (cons x (cons y zs)) =>
    match split zs with
    | ex1 xs ys => ex1 (cons x xs) (cons y ys)

def merge<t> : list<_,t> nat -> list<_,t> nat -o list<_,t> nat
  | nil         ys          => ys
  | xs          nil         => xs
  | (cons x xs) (cons y ys) =>
    match lte x y with
    | true  => cons x (merge xs (cons y ys))
    | false => cons y (merge (cons x xs) ys)

def msort<t> : list<_,t> nat -> list<_,t> nat 
  | nil          => nil
  | (cons z nil) => cons z nil
  | zs           =>
    match split zs with
    | ex1 xs ys => merge (msort xs) (msort ys)

#[logical]
def cmsort_ch<t> (xs :  list<_,t> nat) : L :=
  ch true (act1 true fn (_ : sing (msort xs)) => endp)

def cmsort_worker<t> : nat -> forall (zs : list<_,t> nat) -> cmsort_ch<t> zs -o IO unit
  | zero     zs           c => let* c := send1 refl c (just (msort zs))   in close c
  | (succ n) nil          c => let* c := send1 refl c (just nil)          in close c
  | (succ n) (cons z nil) c => let* c := send1 refl c (just (cons z nil)) in close c
  | (succ n) zs           c => 
    match split zs as h1
        , {refl}   as _ : eq (match h1 with ex1 xs ys => merge (msort xs) (msort ys))
                             (match split zs with ex1 xs ys => merge (msort xs) (msort ys))
    with
    | ex1 xs0 ys0, pf => 
      let* r1 := fork _ (ln c1 => cmsort_worker n xs0 c1) in
      let* r2 := fork _ (ln c2 => cmsort_worker n ys0 c2) in
      let* r1 := recv1 refl r1 in match r1 with ex1 xs1 c1 =>
      let* r2 := recv1 refl r2 in match r2 with ex1 ys1 c2 =>
      match xs1, ys1 with
      | just xs1, just ys1 =>
        let zs1 : sing (merge (msort xs0) (msort ys0)) := just (merge xs1 ys1) in
        let zs1 : sing (msort zs) := rwl (fn x => sing x) pf zs1 in
        let* c := send1 refl c zs1 in
        let* _ := close c1 in
        let* _ := close c2 in
        let* _ := close c in
        return tt
