def split‹t› : list‹_,t› int -> list‹_,t› int × list‹_,t› int
  | nil          => ⟨nil, nil⟩
  | x :: nil     => ⟨x :: nil, nil⟩
  | x :: y :: zs =>
    let ⟨xs, ys⟩ := split zs in
    ⟨x :: xs, y :: ys⟩

def merge‹t› : list‹_,t› int -> list‹_,t› int -o list‹_,t› int
  | nil    , ys      => ys
  | xs     , nil     => xs
  | x :: xs, y :: ys =>
    match x <= y with
    | true  => x :: merge xs (y :: ys)
    | false => y :: merge (x :: xs) ys

def msort‹t› : list‹_,t› int -> list‹_,t› int 
  | nil      => nil
  | z :: nil => z :: nil
  | zs       =>
    let ⟨xs, ys⟩ := split zs in
    merge (msort xs) (msort ys)

/-
#[logical]
def cmsort_ch‹t› (xs :  list‹_,t› int) : L :=
  ch true (act1 true fn (_ : `msort xs) => endp)

def cmsort_worker‹t› : int -> forall (zs : list‹_,t› int) -> cmsort_ch‹t› zs -o IO unit
  | zero  , zs      , c => let* c := send1 refl c (just (msort zs)) in close c
  | succ n, nil     , c => let* c := send1 refl c (just nil)        in close c
  | succ n, z :: nil, c => let* c := send1 refl c (just (z :: nil)) in close c
  | succ n, zs      , c => 
    match split zs as h1
        , {refl}   as _ : (let ⟨xs, ys⟩ := h1 in merge (msort xs) (msort ys)) =
                          (let ⟨xs, ys⟩ := split zs in merge (msort xs) (msort ys))
    with
    | ⟨xs0, ys0⟩, pf => 
      let* r1 := fork ln c1 => cmsort_worker n xs0 c1 in
      let* r2 := fork ln c2 => cmsort_worker n ys0 c2 in
      let* ⟨xs1, c1⟩ := recv1 refl r1 in close c1;
      let* ⟨ys1, c2⟩ := recv1 refl r2 in close c2;
      match xs1, ys1 with
      | just xs1, just ys1 =>
        let zs1 : `merge (msort xs0) (msort ys0) := just (merge xs1 ys1) in
        let zs1 : `msort zs := rwl (fn x => `x) pf zs1 in
        let* c := send1 refl c zs1 in close c;
        return tt
-/
