#[logical]
inductive eq<s> ?(A : Type‹s›) (m : A) : A -> U where
  | refl : eq m m

inductive unit : U where
  | tt : unit

inductive bool : U where
  | true  : bool
  | false : bool

inductive nat : U where
  | zero : nat
  | succ (n : nat) : nat

inductive list<s,t> (A : Type<s>) : Type<t> where
  | nil : list A
  | cons (hd : A) (tl : list A) : list A

inductive exists0<s,r> ?(A : Type<s>) (B : A -> Type<r>) : L where
  | ex0 {m : A} (n : B m) : @exists0 A B

inductive exists1<s,r> ?(A : Type<s>) (B : A -> Type<r>) : L where
  | ex1 (m : A) (n : B m) : @exists1 A B

def xor : bool -> bool -o bool
  | true  true  => false
  | false false => false
  | _     _     => true

def lte : nat -> nat -> bool
  | zero     _        => true
  | _        zero     => false
  | (succ x) (succ y) => lte x y

def lt (x : nat) (y : nat) : bool := lte (succ x) y

def pred : nat -> nat
  | zero => zero
  | (succ x) => x

def add : nat -> nat -> nat
  | zero     y => y 
  | (succ x) y => succ (add x y)

def sub : nat -> nat -> nat
  | x zero     => x
  | x (succ y) => sub (pred x) y

def mul : nat -> nat -> nat
  | zero     _ => zero
  | (succ x) y => add y (mul x y)

def div (x : nat) (y : nat) :=
  match lt x y with
  | true  => zero
  | false => succ (div (sub x y) y)

def rem (x : nat) (y : nat) :=
  sub x (mul (div x y) y)

def pow : nat -> nat -> nat
  | _ zero     => succ zero
  | x (succ y) => mul x (pow x y)

#[logical] extern proto : U
#[logical] extern act0<s> (b : bool) ?(A : Type<s>) (B : A -> proto) : proto
#[logical] extern act1<s> (b : bool) ?(A : Type<s>) (B : A -> proto) : proto
#[logical] extern endp : proto
#[logical] extern ch : bool -> proto -> L

extern close ?{b : bool} : ch b endp -> IO unit 
extern send0<s> ?{b1 b2 : bool} ?{A : Type<s>} ?{B : A -> proto} : {eq (xor b1 b2) false} -> (ch b1 (act0 b2 B)) -> ∀ {x : A} -o IO (ch b1 (B x))
extern send1<s> ?{b1 b2 : bool} ?{A : Type<s>} ?{B : A -> proto} : {eq (xor b1 b2) false} -> (ch b1 (act1 b2 B)) -> ∀ (x : A) -o IO (ch b1 (B x))
extern recv0<s> ?{b1 b2 : bool} ?{A : Type<s>} ?{B : A -> proto} : {eq (xor b1 b2) true} -> (ch b1 (act0 b2 B)) -> IO (exists0 fn (x : A) => ch b1 (B x))
extern recv1<s> ?{b1 b2 : bool} ?{A : Type<s>} ?{B : A -> proto} : {eq (xor b1 b2) true} -> (ch b1 (act1 b2 B)) -> IO (exists1 fn (x : A) => ch b1 (B x))
extern fork {P : proto} : (ch false P -o IO unit) -> IO (ch true P)

#[logical]
def DH (p g : nat) : proto :=
  act0 true  fn (a : nat) => act1 true  fn (A : nat) => act0 true  fn (_ : eq A (rem (pow g a) p)) =>
  act0 false fn (b : nat) => act1 false fn (B : nat) => act0 false fn (_ : eq B (rem (pow g b) p)) =>
  endp

#[logical] def DH_ch (p g : nat) := ch true  (DH p g)
#[logical] def DH_hc (p g : nat) := ch false (DH p g)

def alice (a : nat) (p g : nat) (c : DH_ch p g) : IO unit :=
  let* c := send0 refl c a in 
  let* c := send1 refl c (rem (pow g a) p) in
  let* c := send0 refl c refl in
  let* r := recv0 refl c in match r with ex0 b c =>
  let* r := recv1 refl c in match r with ex1 B c =>
  let* r := recv0 refl c in match r with ex0 pf c =>
  close c

def bob (b : nat) (p g : nat) (c : DH_hc p g) : IO unit :=
  let* r := recv0 refl c in match r with ex0 a c =>
  let* r := recv1 refl c in match r with ex1 A c =>
  let* r := recv0 refl c in match r with ex0 pf c =>
  let* c := send0 refl c b in
  let* c := send1 refl c (rem (pow g b) p) in
  let* c := send0 refl c refl in
  close c
