* Inference
#+begin_src 
(m : A)
_
#+end_src

* Core
#+begin_src 
U L
x, y, z
#+end_src

#+begin_src 
∀ (x : A) → B 
∀ (x : A) ⊸ B 
A → B
A ⊸ B

∀ {x : A} → B 
∀ {x : A} ⊸ B 
{A} → B
{A} ⊸ B
#+end_src

#+begin_src 
λ (x : A) → m
λ (x : A) ⊸ m
λ x → m
λ x ⊸ m

λ {x : A} → m
λ {x : A} ⊸ m
λ {x} → m
λ {x} ⊸ m
#+end_src

#+begin_src 
fix f x → m
let x = m in n
let fix f x = m in n
#+end_src

* Data
#+begin_src 
∃ (x : A) × B 
∃ (x : A) ⊗ B
A × B
A ⊗ B

∃ {x : A} × B 
∃ {x : A} ⊗ B
{A} × B
{A} ⊗ B
#+end_src

#+begin_src 
(m, n)
⟨m, n⟩

({m}, n)
⟨{m}, n⟩
#+end_src

#+begin_src 
match m as [x0, D x1 x2] A with
| C x3 x4 → m
#+end_src

* Equality
#+begin_src
m ≡ n
refl m
eq_elim P as [x, p] A in H
#+end_src

* Monadic
#+begin_src 
IO A
return m
let x ⇐ m in n
#+end_src

* Session
#+begin_src 
proto 
end

!(x : A) → B
?(x : A) → B
!A → B
?A → B

!{x : A} → B
?{x : A} → B
!{A} → B
?{A} → B

ch‹A›
hc‹A›
#+end_src

#+begin_src
fork (x : A) in m

recv c
send c

{recv} c
{send} c

close c
#+end_src

* Effectful
#+begin_src 
l ↦ A
(l; m)
ptr_elim (l1; x) = m as [l2, c] A in n
#+end_src
