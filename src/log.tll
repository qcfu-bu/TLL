[Inductive {name = "unit"; relv = R;
   body =
   (Binder ([],
      (PBase
         ((TBase (Type U)), [(DMul ("tt", (TBase (Id ("unit", I))), []))]))
      ));
   view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DMul ("true", (TBase (Id ("bool", I))), []));
             (DMul ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DMul ("zero", (TBase (Id ("nat", I))), []));
             (DMul ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DMul ("refl",
                           (TBase
                              (App
                                 [(Id ("eq", I)); (Id ("m", I));
                                   (Id ("m", I))])),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "exists"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DMul ("ex",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (N,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("pf",
                                       (TBase
                                          (App
                                             [(Id ("exists", I));
                                               (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "s"))))))),
                 [(DMul ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m",
                           (TBase (App [(Id ("sing", I)); (Id ("m", I))]))))
                        )),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "list"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type U)),
                 [(DMul ("nil",
                     (TBase (App [(Id ("list", I)); (Id ("A", I))])), 
                     []));
                   (DMul ("cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (App [(Id ("list", I)); (Id ("A", I))]),
                               (Binder ("tl",
                                  (TBase
                                     (App [(Id ("list", I)); (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Inductive {name = "vec"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("nat", I)), (Binder ("_", (TBase (Type U))))
                    )),
                 [(DMul ("vnil",
                     (TBase
                        (App
                           [(Id ("vec", I)); (Id ("A", I)); (Id ("zero", I))])),
                     []));
                   (DMul ("vcons",
                      (TBind (N, (Id ("nat", I)),
                         (Binder ("n",
                            (TBind (R, (Id ("A", I)),
                               (Binder ("hd",
                                  (TBind (R,
                                     (App
                                        [(Inst ("vec", [(SId "s")], I));
                                          (Id ("A", I)); (Id ("n", I))]),
                                     (Binder ("tl",
                                        (TBase
                                           (App
                                              [(Id ("vec", I));
                                                (Id ("A", I));
                                                (App
                                                   [(Id ("succ", I));
                                                     (Id ("n", I))])
                                                ]))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         )),
                      [I; E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Definition {name = "uncons2"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("nat", I)),
                    (Binder ("n",
                       (Pi (R, U,
                          (App
                             [(Id ("vec", I)); (Id ("A", I)); (Id ("n", I))]),
                          (Binder ("_",
                             (Pi (R, U,
                                (App
                                   [(Id ("vec", I)); (Id ("A", I));
                                     (Id ("n", I))]),
                                (Binder ("_", (Id ("unit", I))))))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "uncons2"),
              [([(PId "A"); (PId "n"); (PId "vnil"); (PId "vnil")],
                (Some (Id ("tt", I))));
                ([(PId "A"); (PId "n"); (PId "vnil"); PAbsurd], None);
                ([(PId "A"); (PId "n");
                   (PMul ("vcons", [(PId "_"); (PId "_"); (PId "_")]));
                   (PMul ("vcons", [(PId "_"); (PId "_"); (PId "_")]))],
                 (Some (Id ("tt", I))));
                ([(PId "A"); (PId "n");
                   (PMul ("vcons", [(PId "_"); (PId "_"); (PId "_")]));
                   PAbsurd],
                 None)
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("nat", I)),
                 (Binder ("n",
                    (Pi (R, U,
                       (App [(Id ("vec", I)); (Id ("A", I)); (Id ("n", I))]),
                       (Binder ("_",
                          (Pi (R, U,
                             (App
                                [(Id ("vec", I)); (Id ("A", I));
                                  (Id ("n", I))]),
                             (Binder ("_", (Id ("unit", I))))))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]}
  ]

-----------------------------------------

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_73 : nat_3) : nat_3

#[logical]
inductive eq_4‹s_74› (A_75 : Type‹s_74›) (m_76 : A_75): A_75 -> U
where
| refl_6 : (eq_4‹??_1› ?_1 m_76 m_76)

#[program]
inductive exists_5‹s_78,r_79,t_80› (A_81 : Type‹s_78›) (B_82 : 
A_81 -> Type‹r_79›): Type‹t_80› where
| ex_7
    (m_84 : A_81) {pf_85 : ((B_82) m_84)}
    : (exists_5‹??_2,??_3,??_4› ?_2 B_82)

#[program]
inductive sing_6‹s_86› (A_87 : Type‹s_86›): A_87 -> Type‹s_86›
where
| just_8 (m_89 : A_87) : (sing_6‹??_5› ?_3 m_89)

#[program]
inductive list_7‹s_90› (A_91 : Type‹s_90›): U where
| nil_9 : (list_7‹??_6› A_91)
| cons_10
    (hd_92 : A_91) (tl_93 : (list_7‹??_7› A_91))
    : (list_7‹??_8› A_91)

#[program]
inductive vec_8‹s_94› (A_95 : Type‹s_94›): nat_3 -> U where
| vnil_11 : (vec_8‹??_9› A_95 zero_4)
| vcons_12
    {n_97 : nat_3} (hd_98 : A_95) (tl_99 : (vec_8‹s_94› A_95 n_97))
    : (vec_8‹??_10› A_95 (succ_5‹› n_97))

#[program]
def uncons2_1‹s_100› :
  ∀ {A_101 : Type‹s_100›} ->
    ∀ {n_102 : nat_3} ->
      (vec_8‹??_13› A_101 n_102) ->
        (vec_8‹??_14› A_101 n_102) -> unit_1
:=
  function uncons2_105 :
    ∀ {A_106 : Type‹s_100›} ->
      ∀ {n_107 : nat_3} ->
        (vec_8‹??_11› A_106 n_107) ->
          (vec_8‹??_12› A_106 n_107) -> unit_1
  | A_110 n_111 vnil_11 vnil_11 => tt_1
  | A_112 n_113 vnil_11 !! =>
  | A_114 n_115 (vcons_12 _116 _117 _118) (vcons_12 _119 _120 _121) => tt_1
  | A_122 n_123 (vcons_12 _124 _125 _126) !! =>

-----------------------------------------

inductive-------------------------
infer_tm(unit_1)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(bool_2)
infer_tm(bool_2)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(nat_3)
infer_tm(nat_3)
infer_tm(nat_3)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(Type‹s_129›)
infer_tm(A_130)
infer_tm(A_130)
infer_tm(Type‹s_133›)
infer_tm(A_134)
assert_equal1( A_134, ?_1)
assert_equal1( m_135, m_135)
infer_tm((eq_4‹??_1› ?_1 m_135 m_135))
check_tm( ?_1, Type‹??_1›)
check_tm( m_135, ?_1)
infer_tm(m_135)
assert_equal1( ?_1, A_134)
check_tm( m_135, ?_1)
infer_tm(m_135)
assert_equal1( ?_1, A_134)
simpl_tm ~expand:false( ?_1, A_134)
simpl_tm ~expand:false( A_134, A_134)
simpl_tm ~expand:false( A_134, A_134)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_136
    
  |}
  imeta_meta {|
    ?_1 <= A_139
    
  |}
  eqns {|
    
  |}
end_dump
infer_tm(Type‹s_133›)
check_tm( A_134, Type‹s_133›)
infer_tm(A_134)
assert_equal1( Type‹s_133›, Type‹s_133›)
----------------------------------

inductive-------------------------
infer_tm(Type‹s_151›)
infer_tm(A_154 -> Type‹r_152›)
infer_tm(A_154)
infer_tm(Type‹r_152›)
infer_tm(Type‹s_158›)
infer_tm(A_161 -> Type‹r_159›)
infer_tm(A_161)
infer_tm(Type‹r_159›)
infer_tm(A_161)
infer_tm(((B_162) m_165))
infer_tm(B_162)
check_tm( m_165, A_161)
infer_tm(m_165)
assert_equal1( A_161, A_161)
assert_equal1( A_161, ?_2)
assert_equal1( B_162, B_162)
infer_tm((exists_5‹??_2,??_3,??_4› ?_2 B_162))
check_tm( ?_2, Type‹??_2›)
check_tm( B_162, ?_2 -> Type‹??_3›)
infer_tm(B_162)
assert_equal1( ?_2 -> Type‹??_3›, A_161 -> Type‹r_159›)
simpl_tm ~expand:false( ?_2 -> Type‹??_3›, A_161 -> Type‹r_159›)
simpl_tm ~expand:false( ?_2, A_161)
simpl_tm ~expand:false( Type‹??_3›, Type‹r_159›)
simpl_tm ~expand:false( A_161, A_161)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_176
    ??_2 <= s_179
    ??_3 <= r_181
    ??_4 <= t_183
    
  |}
  imeta_meta {|
    ?_1 <= A_188
    ?_2 <= A_195
    
  |}
  eqns {|
    
  |}
end_dump
infer_tm(Type‹s_158›)
check_tm( A_161, Type‹s_158›)
infer_tm(A_161)
assert_equal1( Type‹s_158›, Type‹s_158›)
----------------------------------

inductive-------------------------
infer_tm(Type‹s_228›)
infer_tm(A_229)
infer_tm(Type‹s_231›)
infer_tm(A_232)
assert_equal1( A_232, ?_3)
infer_tm((sing_6‹??_5› ?_3 m_233))
check_tm( ?_3, Type‹??_5›)
check_tm( m_233, ?_3)
infer_tm(m_233)
assert_equal1( ?_3, A_232)
simpl_tm ~expand:false( ?_3, A_232)
simpl_tm ~expand:false( A_232, A_232)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_234
    ??_2 <= s_237
    ??_3 <= r_239
    ??_4 <= t_241
    ??_5 <= s_244
    
  |}
  imeta_meta {|
    ?_1 <= A_247
    ?_2 <= A_254
    ?_3 <= A_257
    
  |}
  eqns {|
    
  |}
end_dump
infer_tm(Type‹s_231›)
check_tm( A_232, Type‹s_231›)
infer_tm(A_232)
assert_equal1( Type‹s_231›, Type‹s_231›)
----------------------------------

inductive-------------------------
infer_tm(Type‹s_270›)
infer_tm(Type‹s_272›)
assert_equal1( A_273, A_273)
infer_tm((list_7‹??_6› A_273))
check_tm( A_273, Type‹??_6›)
infer_tm(A_273)
assert_equal1( Type‹??_6›, Type‹s_272›)
simpl_tm ~expand:false( Type‹??_6›, Type‹s_272›)
infer_tm(Type‹s_274›)
infer_tm(A_275)
infer_tm((list_7‹??_7› A_275))
check_tm( A_275, Type‹??_7›)
infer_tm(A_275)
assert_equal1( Type‹??_7›, Type‹s_274›)
simpl_tm ~expand:false( Type‹??_7›, Type‹s_274›)
assert_equal1( A_275, A_275)
infer_tm((list_7‹??_8› A_275))
check_tm( A_275, Type‹??_8›)
infer_tm(A_275)
assert_equal1( Type‹??_8›, Type‹s_274›)
simpl_tm ~expand:false( Type‹??_8›, Type‹s_274›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_278
    ??_2 <= s_281
    ??_3 <= r_283
    ??_4 <= t_285
    ??_5 <= s_288
    ??_6 <= s_289
    ??_7 <= s_290
    ??_8 <= s_291
    
  |}
  imeta_meta {|
    ?_1 <= A_294
    ?_2 <= A_301
    ?_3 <= A_304
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(Type‹s_320›)
infer_tm(nat_3)
infer_tm(Type‹s_323›)
assert_equal1( A_324, A_324)
infer_tm((vec_8‹??_9› A_324 zero_4))
check_tm( A_324, Type‹??_9›)
infer_tm(A_324)
assert_equal1( Type‹??_9›, Type‹s_323›)
check_tm( zero_4, nat_3)
infer_tm(zero_4)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_9›, Type‹s_323›)
infer_tm(Type‹s_325›)
infer_tm(nat_3)
infer_tm(A_326)
infer_tm((vec_8‹s_325› A_326 n_327))
check_tm( A_326, Type‹s_325›)
infer_tm(A_326)
assert_equal1( Type‹s_325›, Type‹s_325›)
check_tm( n_327, nat_3)
infer_tm(n_327)
assert_equal1( nat_3, nat_3)
assert_equal1( A_326, A_326)
infer_tm((vec_8‹??_10› A_326 (succ_5‹› n_327)))
check_tm( A_326, Type‹??_10›)
infer_tm(A_326)
assert_equal1( Type‹??_10›, Type‹s_325›)
check_tm( (succ_5‹› n_327), nat_3)
infer_tm((succ_5‹› n_327))
check_tm( n_327, nat_3)
infer_tm(n_327)
assert_equal1( nat_3, nat_3)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_10›, Type‹s_325›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_330
    ??_2 <= s_333
    ??_3 <= r_335
    ??_4 <= t_337
    ??_5 <= s_340
    ??_6 <= s_341
    ??_7 <= s_342
    ??_8 <= s_343
    ??_9 <= s_344
    ??_10 <= s_345
    
  |}
  imeta_meta {|
    ?_1 <= A_348
    ?_2 <= A_355
    ?_3 <= A_358
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

definition-------------------------
infer_tm(∀ {A_381 : Type‹s_380›} ->
           ∀ {n_382 : nat_3} ->
             (vec_8‹??_13› A_381 n_382) ->
               (vec_8‹??_14› A_381 n_382) -> unit_1)
infer_tm(Type‹s_380›)
infer_tm(∀ {n_386 : nat_3} ->
           (vec_8‹??_13› A_385 n_386) ->
             (vec_8‹??_14› A_385 n_386) -> unit_1)
infer_tm(nat_3)
infer_tm((vec_8‹??_13› A_385 n_389) ->
           (vec_8‹??_14› A_385 n_389) -> unit_1)
infer_tm((vec_8‹??_13› A_385 n_389))
check_tm( A_385, Type‹??_13›)
infer_tm(A_385)
assert_equal1( Type‹??_13›, Type‹s_380›)
check_tm( n_389, nat_3)
infer_tm(n_389)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_13›, Type‹s_380›)
infer_tm((vec_8‹??_14› A_385 n_389) -> unit_1)
infer_tm((vec_8‹??_14› A_385 n_389))
check_tm( A_385, Type‹??_14›)
infer_tm(A_385)
assert_equal1( Type‹??_14›, Type‹s_380›)
check_tm( n_389, nat_3)
infer_tm(n_389)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_14›, Type‹s_380›)
infer_tm(unit_1)
check_tm(
  function uncons2_395 :
    ∀ {A_396 : Type‹s_380›} ->
      ∀ {n_397 : nat_3} ->
        (vec_8‹??_11› A_396 n_397) ->
          (vec_8‹??_12› A_396 n_397) -> unit_1
  | A_400 n_401 vnil_11 vnil_11 => tt_1
  | A_402 n_403 vnil_11 !! =>
  | A_404 n_405 (vcons_12 _406 _407 _408) (vcons_12 _409 _410 _411) => tt_1
  | A_412 n_413 (vcons_12 _414 _415 _416) !! =>,
  ∀ {A_417 : Type‹s_380›} ->
    ∀ {n_418 : nat_3} ->
      (vec_8‹??_13› A_417 n_418) ->
        (vec_8‹??_14› A_417 n_418) -> unit_1)
infer_tm(∀ {A_422 : Type‹s_380›} ->
           ∀ {n_423 : nat_3} ->
             (vec_8‹??_11› A_422 n_423) ->
               (vec_8‹??_12› A_422 n_423) -> unit_1)
infer_tm(Type‹s_380›)
infer_tm(∀ {n_427 : nat_3} ->
           (vec_8‹??_11› A_426 n_427) ->
             (vec_8‹??_12› A_426 n_427) -> unit_1)
infer_tm(nat_3)
infer_tm((vec_8‹??_11› A_426 n_430) ->
           (vec_8‹??_12› A_426 n_430) -> unit_1)
infer_tm((vec_8‹??_11› A_426 n_430))
check_tm( A_426, Type‹??_11›)
infer_tm(A_426)
assert_equal1( Type‹??_11›, Type‹s_380›)
check_tm( n_430, nat_3)
infer_tm(n_430)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_11›, Type‹s_380›)
infer_tm((vec_8‹??_12› A_426 n_430) -> unit_1)
infer_tm((vec_8‹??_12› A_426 n_430))
check_tm( A_426, Type‹??_12›)
infer_tm(A_426)
assert_equal1( Type‹??_12›, Type‹s_380›)
check_tm( n_430, nat_3)
infer_tm(n_430)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_12›, Type‹s_380›)
infer_tm(unit_1)
assert_equal1(
  ∀ {A_436 : Type‹s_380›} ->
    ∀ {n_437 : nat_3} ->
      (vec_8‹??_13› A_436 n_437) ->
        (vec_8‹??_14› A_436 n_437) -> unit_1,
  ∀ {A_440 : Type‹s_380›} ->
    ∀ {n_441 : nat_3} ->
      (vec_8‹??_11› A_440 n_441) ->
        (vec_8‹??_12› A_440 n_441) -> unit_1)
simpl_tm ~expand:false(
  ∀ {A_485 : Type‹s_380›} ->
    ∀ {n_486 : nat_3} ->
      (vec_8‹s_380› A_485 n_486) ->
        (vec_8‹s_380› A_485 n_486) -> unit_1,
  ∀ {A_489 : Type‹s_380›} ->
    ∀ {n_490 : nat_3} ->
      (vec_8‹s_380› A_489 n_490) ->
        (vec_8‹s_380› A_489 n_490) -> unit_1)
simpl_tm ~expand:false( Type‹s_380›, Type‹s_380›)
simpl_tm ~expand:false(
  ∀ {n_494 : nat_3} ->
    (vec_8‹s_380› A_493 n_494) ->
      (vec_8‹s_380› A_493 n_494) -> unit_1,
  ∀ {n_497 : nat_3} ->
    (vec_8‹s_380› A_493 n_497) ->
      (vec_8‹s_380› A_493 n_497) -> unit_1)
simpl_tm ~expand:false( nat_3, nat_3)
simpl_tm ~expand:false(
  (vec_8‹s_380› A_493 n_500) -> (vec_8‹s_380› A_493 n_500) -> unit_1,
  (vec_8‹s_380› A_493 n_500) -> (vec_8‹s_380› A_493 n_500) -> unit_1)
simpl_tm ~expand:false( (vec_8‹s_380› A_493 n_500),
  (vec_8‹s_380› A_493 n_500))
simpl_tm ~expand:false( A_493, A_493)
simpl_tm ~expand:false( n_500, n_500)
simpl_tm ~expand:false( (vec_8‹s_380› A_493 n_500) -> unit_1,
  (vec_8‹s_380› A_493 n_500) -> unit_1)
simpl_tm ~expand:false( (vec_8‹s_380› A_493 n_500),
  (vec_8‹s_380› A_493 n_500))
simpl_tm ~expand:false( A_493, A_493)
simpl_tm ~expand:false( n_500, n_500)
simpl_tm ~expand:false( unit_1, unit_1)
check_cls {|
  prblm {| ;
    {|  ::: [A_454, n_455, vnil_11, vnil_11] =>? tt_1 |}
    () ::: [A_456, n_457, vnil_11, !!] =>? !!
    {|  ::: [A_458, n_459, (vcons_12 _460 _461 _462), (vcons_12 _463 _464 _465)] =>?
         tt_1
    |} () ::: [A_466, n_467, (vcons_12 _468 _469 _470), !!] =>? !!
  |}
|}
case_intro
case_intro
case_intro
case_intro
case_splitting
splitting_on(vnil_11)
case_splitting
splitting_on(vnil_11)
case_coverage{|
  prblm {|
    eq_term?( (vec_8‹s_380› #A_516 #n_517),
      (vec_8‹s_380› #A_516 zero_4))
    eq_term?( (vec_8‹s_380› #A_516 #n_517),
      (vec_8‹s_380› #A_516 zero_4));
    {| eq_pat?( #A_516, A_454 : Type‹s_380›)
       eq_pat?( #n_517, n_455 : nat_3) ::: [] =>? tt_1
    |}
    (eq_pat?( #A_516, A_456 : Type‹s_380›)
     eq_pat?( #n_517, n_457 : nat_3)
     eq_pat?( vnil_11‹s_380›, !! : (vec_8‹s_380› #A_516 #n_517))) ::: [] =>? !!
  |}
|}
unify_pprbm(
  eq_term?( (vec_8‹s_380› #A_516 #n_517),
    (vec_8‹s_380› #A_516 zero_4))
  eq_term?( (vec_8‹s_380› #A_516 #n_517),
    (vec_8‹s_380› #A_516 zero_4))
  eq_pat?( #A_516, A_454 : Type‹s_380›)
  eq_pat?( #n_517, n_455 : nat_3)
)
simpl_pprbm ~expand:false( (vec_8‹s_380› #A_516 #n_517),
  (vec_8‹s_380› #A_516 zero_4))
simpl_pprbm ~expand:false( #A_516, #A_516)
simpl_pprbm ~expand:false( #n_517, zero_4)
simpl_pprbm ~expand:false( (vec_8‹s_380› #A_516 #n_517),
  (vec_8‹s_380› #A_516 zero_4))
simpl_pprbm ~expand:false( #A_516, #A_516)
simpl_pprbm ~expand:false( #n_517, zero_4)
simpl_pprbm ~expand:false( #A_516, #A_454)
simpl_pprbm ~expand:false( #n_517, #n_455)
simpl_pprbm ~expand:false( zero_4, #n_517)
simpl_pprbm ~expand:false( zero_4, zero_4)
simpl_pprbm ~expand:false( #A_516, #A_454)
simpl_pprbm ~expand:false( zero_4, #n_455)
case_coverage_ok( tt_1, unit_1)
check_tm( tt_1, unit_1)
infer_tm(tt_1)
assert_equal1( unit_1, unit_1)
splitting_on(vcons_12)
case_coverage{|
  prblm {|
    eq_term?( (vec_8‹s_380› #A_516 #n_517),
      (vec_8‹s_380› #A_516 (succ_5‹› #n_541)))
    eq_term?( (vec_8‹s_380› #A_516 #n_517),
      (vec_8‹s_380› #A_516 zero_4));
    (eq_pat?( #A_516, A_456 : Type‹s_380›)
     eq_pat?( #n_517, n_457 : nat_3)
     eq_pat?( (vcons_12‹s_380› #n_541 #hd_542 #tl_543), !! :
       (vec_8‹s_380› #A_516 #n_517))) ::: [] =>? !!
  |}
|}
unify_pprbm(
  eq_term?( (vec_8‹s_380› #A_516 #n_517),
    (vec_8‹s_380› #A_516 (succ_5‹› #n_541)))
  eq_term?( (vec_8‹s_380› #A_516 #n_517),
    (vec_8‹s_380› #A_516 zero_4))
)
simpl_pprbm ~expand:false( (vec_8‹s_380› #A_516 #n_517),
  (vec_8‹s_380› #A_516 (succ_5‹› #n_541)))
simpl_pprbm ~expand:false( #A_516, #A_516)
simpl_pprbm ~expand:false( #n_517, (succ_5‹› #n_541))
simpl_pprbm ~expand:false( (vec_8‹s_380› #A_516 #n_517),
  (vec_8‹s_380› #A_516 zero_4))
simpl_pprbm ~expand:false( #A_516, #A_516)
simpl_pprbm ~expand:false( #n_517, zero_4)
simpl_pprbm ~expand:false( (succ_5‹› #n_541), #n_517)
simpl_pprbm ~expand:false( zero_4, (succ_5‹› #n_541))
simpl_pprbm ~expand:true( zero_4, (succ_5‹› #n_541))
splitting_on(vcons_12)
case_splitting
splitting_on(vnil_11)
case_coverage{|
  prblm {|
    eq_term?( (vec_8‹s_380› #A_516 #n_517),
      (vec_8‹s_380› #A_516 zero_4))
    eq_term?( (vec_8‹s_380› #A_516 #n_517),
      (vec_8‹s_380› #A_516 (succ_5‹› #n_551)));
    (eq_pat?( #A_516, A_466 : Type‹s_380›)
     eq_pat?( #n_517, n_467 : nat_3)
     eq_pat?( #n_551, _468 : nat_3)
     eq_pat?( #hd_552, _469 : #A_516)
     eq_pat?( #tl_553, _470 : (vec_8‹s_380› #A_516 #n_551))
     eq_pat?( vnil_11‹s_380›, !! : (vec_8‹s_380› #A_516 #n_517))) ::: [] =>? !!
  |}
|}
unify_pprbm(
  eq_term?( (vec_8‹s_380› #A_516 #n_517),
    (vec_8‹s_380› #A_516 zero_4))
  eq_term?( (vec_8‹s_380› #A_516 #n_517),
    (vec_8‹s_380› #A_516 (succ_5‹› #n_551)))
)
simpl_pprbm ~expand:false( (vec_8‹s_380› #A_516 #n_517),
  (vec_8‹s_380› #A_516 zero_4))
simpl_pprbm ~expand:false( #A_516, #A_516)
simpl_pprbm ~expand:false( #n_517, zero_4)
simpl_pprbm ~expand:false( (vec_8‹s_380› #A_516 #n_517),
  (vec_8‹s_380› #A_516 (succ_5‹› #n_551)))
simpl_pprbm ~expand:false( #A_516, #A_516)
simpl_pprbm ~expand:false( #n_517, (succ_5‹› #n_551))
simpl_pprbm ~expand:false( zero_4, #n_517)
simpl_pprbm ~expand:false( (succ_5‹› #n_551), zero_4)
simpl_pprbm ~expand:true( (succ_5‹› #n_551), zero_4)
splitting_on(vcons_12)
case_coverage{|
  prblm {|
    eq_term?( (vec_8‹s_380› #A_516 #n_517),
      (vec_8‹s_380› #A_516 (succ_5‹› #n_568)))
    eq_term?( (vec_8‹s_380› #A_516 #n_517),
      (vec_8‹s_380› #A_516 (succ_5‹› #n_551)));
    {| eq_pat?( #A_516, A_458 : Type‹s_380›)
       eq_pat?( #n_517, n_459 : nat_3)
       eq_pat?( #n_551, _460 : nat_3)
       eq_pat?( #hd_552, _461 : #A_516)
       eq_pat?( #tl_553, _462 : (vec_8‹s_380› #A_516 #n_551))
       eq_pat?( #n_568, _463 : nat_3)
       eq_pat?( #hd_569, _464 : #A_516)
       eq_pat?( #tl_570, _465 : (vec_8‹s_380› #A_516 #n_568)) ::: [] =>?
         tt_1
    |}
    (eq_pat?( #A_516, A_466 : Type‹s_380›)
     eq_pat?( #n_517, n_467 : nat_3)
     eq_pat?( #n_551, _468 : nat_3)
     eq_pat?( #hd_552, _469 : #A_516)
     eq_pat?( #tl_553, _470 : (vec_8‹s_380› #A_516 #n_551))
     eq_pat?( (vcons_12‹s_380› #n_568 #hd_569 #tl_570), !! :
       (vec_8‹s_380› #A_516 #n_517))) ::: [] =>? !!
  |}
|}
unify_pprbm(
  eq_term?( (vec_8‹s_380› #A_516 #n_517),
    (vec_8‹s_380› #A_516 (succ_5‹› #n_568)))
  eq_term?( (vec_8‹s_380› #A_516 #n_517),
    (vec_8‹s_380› #A_516 (succ_5‹› #n_551)))
  eq_pat?( #A_516, A_458 : Type‹s_380›)
  eq_pat?( #n_517, n_459 : nat_3)
  eq_pat?( #n_551, _460 : nat_3)
  eq_pat?( #hd_552, _461 : #A_516)
  eq_pat?( #tl_553, _462 : (vec_8‹s_380› #A_516 #n_551))
  eq_pat?( #n_568, _463 : nat_3)
  eq_pat?( #hd_569, _464 : #A_516)
  eq_pat?( #tl_570, _465 : (vec_8‹s_380› #A_516 #n_568))
)
simpl_pprbm ~expand:false( (vec_8‹s_380› #A_516 #n_517),
  (vec_8‹s_380› #A_516 (succ_5‹› #n_568)))
simpl_pprbm ~expand:false( #A_516, #A_516)
simpl_pprbm ~expand:false( #n_517, (succ_5‹› #n_568))
simpl_pprbm ~expand:false( (vec_8‹s_380› #A_516 #n_517),
  (vec_8‹s_380› #A_516 (succ_5‹› #n_551)))
simpl_pprbm ~expand:false( #A_516, #A_516)
simpl_pprbm ~expand:false( #n_517, (succ_5‹› #n_551))
simpl_pprbm ~expand:false( #A_516, #A_458)
simpl_pprbm ~expand:false( #n_517, #n_459)
simpl_pprbm ~expand:false( #n_551, #_460)
simpl_pprbm ~expand:false( #hd_552, #_461)
simpl_pprbm ~expand:false( #tl_553, #_462)
simpl_pprbm ~expand:false( #n_568, #_463)
simpl_pprbm ~expand:false( #hd_569, #_464)
simpl_pprbm ~expand:false( #tl_570, #_465)
simpl_pprbm ~expand:false( (succ_5‹› #n_568), #n_517)
simpl_pprbm ~expand:false( (succ_5‹› #n_551), (succ_5‹› #n_568))
simpl_pprbm ~expand:false( #n_551, #n_568)
simpl_pprbm ~expand:false( #A_516, #A_458)
simpl_pprbm ~expand:false( (succ_5‹› #n_568), #n_459)
simpl_pprbm ~expand:false( #n_568, #_460)
simpl_pprbm ~expand:false( #hd_552, #_461)
simpl_pprbm ~expand:false( #tl_553, #_462)
simpl_pprbm ~expand:false( #n_568, #_463)
simpl_pprbm ~expand:false( #hd_569, #_464)
simpl_pprbm ~expand:false( #tl_570, #_465)
case_coverage_ok( tt_1, unit_1)
check_tm( tt_1, unit_1)
infer_tm(tt_1)
assert_equal1( unit_1, unit_1)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_585
    ??_2 <= s_588
    ??_3 <= r_590
    ??_4 <= t_592
    ??_5 <= s_595
    ??_6 <= s_596
    ??_7 <= s_597
    ??_8 <= s_598
    ??_9 <= s_599
    ??_10 <= s_600
    ??_11 <= s_601
    ??_12 <= s_602
    ??_13 <= s_603
    ??_14 <= s_604
    
  |}
  imeta_meta {|
    ?_1 <= A_607
    ?_2 <= A_614
    ?_3 <= A_617
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

smeta_meta {|
  ??_1 <= s_657
  ??_2 <= s_660
  ??_3 <= r_662
  ??_4 <= t_664
  ??_5 <= s_667
  ??_6 <= s_668
  ??_7 <= s_669
  ??_8 <= s_670
  ??_9 <= s_671
  ??_10 <= s_672
  ??_11 <= s_673
  ??_12 <= s_674
  ??_13 <= s_675
  ??_14 <= s_676
  
|}
imeta_meta {|
  ?_1 <= A_679
  ?_2 <= A_686
  ?_3 <= A_689
  
|}
#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_820 : nat_3) : nat_3

#[logical]
inductive eq_4‹s_821› (A_822 : Type‹s_821›) (m_823 : A_822):
  A_822 -> U
where
| refl_6 : (eq_4‹s_821› A_822 m_823 m_823)

#[program]
inductive exists_5‹s_825,r_826,t_827› (A_828 : Type‹s_825›) (B_829 : 
A_828 -> Type‹r_826›): Type‹t_827› where
| ex_7
    (m_831 : A_828) {pf_832 : ((B_829) m_831)}
    : (exists_5‹s_825,r_826,t_827› A_828 B_829)

#[program]
inductive sing_6‹s_833› (A_834 : Type‹s_833›):
  A_834 -> Type‹s_833›
where
| just_8 (m_836 : A_834) : (sing_6‹s_833› A_834 m_836)

#[program]
inductive list_7‹s_837› (A_838 : Type‹s_837›): U where
| nil_9 : (list_7‹s_837› A_838)
| cons_10
    (hd_839 : A_838) (tl_840 : (list_7‹s_837› A_838))
    : (list_7‹s_837› A_838)

#[program]
inductive vec_8‹s_841› (A_842 : Type‹s_841›): nat_3 -> U where
| vnil_11 : (vec_8‹s_841› A_842 zero_4)
| vcons_12
    {n_844 : nat_3} (hd_845 : A_842)
    (tl_846 : (vec_8‹s_841› A_842 n_844))
    : (vec_8‹s_841› A_842 (succ_5‹› n_844))

#[program]
def uncons2_1‹s_847› :
  ∀ {A_848 : Type‹s_847›} ->
    ∀ {n_849 : nat_3} ->
      (vec_8‹s_847› A_848 n_849) ->
        (vec_8‹s_847› A_848 n_849) -> unit_1
:=
  function uncons2_852 :
    ∀ {A_853 : Type‹s_847›} ->
      ∀ {n_854 : nat_3} ->
        (vec_8‹s_847› A_853 n_854) ->
          (vec_8‹s_847› A_853 n_854) -> unit_1
  | A_857 n_858 vnil_11 vnil_11 => tt_1
  | A_859 n_860 vnil_11 !! =>
  | A_861 n_862 (vcons_12 _863 _864 _865) (vcons_12 _866 _867 _868) => tt_1
  | A_869 n_870 (vcons_12 _871 _872 _873) !! =>

-----------------------------------------

