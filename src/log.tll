[Notation {name = "|>"; body = (App [(Hole 2); (Hole 1)])};
  Notation {name = "@@"; body = (App [(Hole 1); (Hole 2)])};
  Notation {name = "="; body = (App [(Id ("eq", I)); (Hole 1); (Hole 2)])};
  Notation {name = "`"; body = (App [(Id ("sing", I)); (Hole 1)])};
  Notation {name = "&&"; body = (App [(Id ("and", I)); (Hole 1); (Hole 2)])};
  Notation {name = "||"; body = (App [(Id ("or", I)); (Hole 1); (Hole 2)])};
  Notation {name = "+"; body = (App [(Id ("add", I)); (Hole 1); (Hole 2)])};
  Notation {name = "-"; body = (App [(Id ("sub", I)); (Hole 1); (Hole 2)])};
  Notation {name = "*"; body = (App [(Id ("mul", I)); (Hole 1); (Hole 2)])};
  Notation {name = "/"; body = (App [(Id ("div", I)); (Hole 1); (Hole 2)])};
  Notation {name = "%"; body = (App [(Id ("rem", I)); (Hole 1); (Hole 2)])};
  Notation {name = "^"; body = (App [(Id ("pow", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<"; body = (App [(Id ("lt", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">"; body = (App [(Id ("gt", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<="; body = (App [(Id ("lte", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">="; body = (App [(Id ("gte", I)); (Hole 1); (Hole 2)])};
  Notation {name = "\195\151";
    body = (App [(Id ("prod1", I)); (Hole 1); (Hole 2)])};
  Notation {name = "::"; body = (App [(Id ("cons", I)); (Hole 1); (Hole 2)])};
  Notation {name = ";";
    body = (MLet ((Hole 1), (Binder ((PId "_"), (Hole 2)))))};
  Notation {name = "\226\159\168{},\226\159\169";
    body = (App [(Id ("ex0", I)); (Hole 1); (Hole 2)])};
  Notation {name = "\226\159\168,\226\159\169";
    body = (App [(Id ("ex1", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase (BOpr ("=", (Id ("m", I)), (Id ("m", I))))),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "rwl"; relv = R;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (N, U, (Id ("A", I)),
                          (Binder ("n",
                             (Pi (N, U,
                                (Pi (R, U, (Id ("A", I)),
                                   (Binder ("_", (Type (SId "r")))))),
                                (Binder ("B",
                                   (Pi (N, U,
                                      (BOpr ("=", (Id ("m", I)),
                                         (Id ("n", I)))),
                                      (Binder ("_",
                                         (Pi (R, U,
                                            (App
                                               [(Id ("B", I)); (Id ("m", I))]),
                                            (Binder ("_",
                                               (App
                                                  [(Id ("B", I));
                                                    (Id ("n", I))])
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "rwl"),
              [([(PId "A"); (PId "m"); (PId "n"); (PId "B"); (PId "refl");
                  (PId "x")],
                (Some (Id ("x", I))))]
              )),
           [I; I; I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (N, U, (Id ("A", I)),
                       (Binder ("n",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Type (SId "r")))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=", (Id ("m", I)), (Id ("n", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App [(Id ("B", I)); (Id ("m", I))]),
                                         (Binder ("_",
                                            (App
                                               [(Id ("B", I)); (Id ("n", I))])
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; E]};
  Definition {name = "rwr"; relv = R;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (N, U, (Id ("A", I)),
                          (Binder ("n",
                             (Pi (N, U,
                                (Pi (R, U, (Id ("A", I)),
                                   (Binder ("_", (Type (SId "r")))))),
                                (Binder ("B",
                                   (Pi (N, U,
                                      (BOpr ("=", (Id ("m", I)),
                                         (Id ("n", I)))),
                                      (Binder ("_",
                                         (Pi (R, U,
                                            (App
                                               [(Id ("B", I)); (Id ("n", I))]),
                                            (Binder ("_",
                                               (App
                                                  [(Id ("B", I));
                                                    (Id ("m", I))])
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "rwr"),
              [([(PId "A"); (PId "m"); (PId "n"); (PId "B"); (PId "refl");
                  (PId "x")],
                (Some (Id ("x", I))))]
              )),
           [I; I; I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (N, U, (Id ("A", I)),
                       (Binder ("n",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Type (SId "r")))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=", (Id ("m", I)), (Id ("n", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App [(Id ("B", I)); (Id ("n", I))]),
                                         (Binder ("_",
                                            (App
                                               [(Id ("B", I)); (Id ("m", I))])
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "s"))))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m", (TBase (UOpr ("`", (Id ("m", I))))))))),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "unit"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)), [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
       ));
    view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("n", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "list"; relv = R;
    body =
    (Binder (["s"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type (SId "t"))),
                 [(DConstr ("nil",
                     (TBase (App [(Id ("list", I)); (Id ("A", I))])), 
                     []));
                   (DConstr ("cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (App
                                  [(Inst ("list", [(SId "_"); (SId "t")], I));
                                    (Id ("A", I))]),
                               (Binder ("tl",
                                  (TBase
                                     (App [(Id ("list", I)); (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Inductive {name = "exists0"; relv = R;
    body =
    (Binder (["s"; "r"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("ex0",
                           (TBind (N, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("exists0", E));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "exists1"; relv = R;
    body =
    (Binder (["s"; "r"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("ex1",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("exists1", E));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "prod0"; relv = N;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (R, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))))
              )),
           (Binder ((Some "prod0"),
              [([(PId "A"); (PId "B")],
                (Some (App
                         [(Id ("exists0", E)); (Id ("A", I));
                           (Fun ((Pi (R, U, IMeta, (Binder ("_", IMeta)))),
                              (Binder (None,
                                 [([(PId "_")], (Some (Id ("B", I))))])),
                              []))
                           ])))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Type (SId "s")),
           (Binder ("A", (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "prod1"; relv = N;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (R, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))))
              )),
           (Binder ((Some "prod1"),
              [([(PId "A"); (PId "B")],
                (Some (App
                         [(Id ("exists1", E)); (Id ("A", I));
                           (Fun ((Pi (R, U, IMeta, (Binder ("_", IMeta)))),
                              (Binder (None,
                                 [([(PId "_")], (Some (Id ("B", I))))])),
                              []))
                           ])))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Type (SId "s")),
           (Binder ("A", (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "not"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I)))))),
           (Binder ((Some "not"),
              [([(PId "true")], (Some (Id ("false", I))));
                ([(PId "false")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I)))))))
       ));
    view = []};
  Definition {name = "and"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "and"),
              [([(PId "true"); (PId "true")], (Some (Id ("true", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("false", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "or"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "or"),
              [([(PId "false"); (PId "false")], (Some (Id ("false", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "xor"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, L, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "xor"),
              [([(PId "true"); (PId "true")], (Some (Id ("false", I))));
                ([(PId "false"); (PId "false")], (Some (Id ("false", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, L, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "lte"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("bool", I))))
                    ))
                 ))
              )),
           (Binder ((Some "lte"),
              [([(PId "zero"); (PId "_")], (Some (Id ("true", I))));
                ([(PId "_"); (PId "zero")], (Some (Id ("false", I))));
                ([(PConstr ("succ", [(PId "x")]));
                   (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("<=", (Id ("x", I)), (Id ("y", I))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "lt"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", (Id ("bool", I))))
                    ))
                 ))
              )),
           (Binder ((Some "lt"),
              [([(PId "x"); (PId "y")],
                (Some (BOpr ("<=", (App [(Id ("succ", I)); (Id ("x", I))]),
                         (Id ("y", I))))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x",
              (Pi (R, U, (Id ("nat", I)), (Binder ("y", (Id ("bool", I))))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "pred"; relv = R;
    body =
    (Binder ([],
       ((Fun ((Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I)))))),
           (Binder ((Some "pred"),
              [([(PId "zero")], (Some (Id ("zero", I))));
                ([(PConstr ("succ", [(PId "x")]))], (Some (Id ("x", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I)))))))
       ));
    view = []};
  Definition {name = "add"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "add"),
              [([(PId "zero"); (PId "y")], (Some (Id ("y", I))));
                ([(PConstr ("succ", [(PId "x")])); (PId "y")],
                 (Some (App
                          [(Id ("succ", I));
                            (BOpr ("+", (Id ("x", I)), (Id ("y", I))))])))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "sub"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "sub"),
              [([(PId "x"); (PId "zero")], (Some (Id ("x", I))));
                ([(PId "x"); (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("-", (App [(Id ("pred", I)); (Id ("x", I))]),
                          (Id ("y", I))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "mul"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "mul"),
              [([(PId "zero"); (PId "_")], (Some (Id ("zero", I))));
                ([(PConstr ("succ", [(PId "x")])); (PId "y")],
                 (Some (BOpr ("+", (Id ("y", I)),
                          (BOpr ("*", (Id ("x", I)), (Id ("y", I))))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "div"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))))
              )),
           (Binder ((Some "div"),
              [([(PId "x"); (PId "y")],
                (Some (Match (
                         [(R,
                           (App
                              [(Id ("lt", I)); (Id ("x", I)); (Id ("y", I))]),
                           None)],
                         None,
                         [([(PId "true")], (Some (Id ("zero", I))));
                           ([(PId "false")],
                            (Some (Let (R,
                                     (Fun (
                                        (Pi (R, U, (Id ("nat", I)),
                                           (Binder ("x",
                                              (Pi (R, U, (Id ("nat", I)),
                                                 (Binder ("y", IMeta))))
                                              ))
                                           )),
                                        (Binder ((Some "loop"),
                                           [([(PId "x"); (PId "y")],
                                             (Some (Match (
                                                      [(R,
                                                        (BOpr ("-",
                                                           (Id ("x", I)),
                                                           (App
                                                              [(Id ("pred", I
                                                                  ));
                                                                (Id ("y", I))
                                                                ])
                                                           )),
                                                        None)],
                                                      None,
                                                      [([(PId "zero")],
                                                        (Some (Id ("zero", I
                                                                 ))));
                                                        ([(PConstr ("succ",
                                                             [(PId "x")]))
                                                           ],
                                                         (Some (App
                                                                  [(Id (
                                                                    "succ", I
                                                                    ));
                                                                    (
                                                                    App
                                                                    [(Id (
                                                                    "loop", I
                                                                    ));
                                                                    (Id ("x",
                                                                    I));
                                                                    (Id ("y",
                                                                    I))])])))
                                                        ]
                                                      ))))
                                             ]
                                           )),
                                        [])),
                                     (Binder ((PId "loop"),
                                        (App
                                           [(Id ("loop", I)); (Id ("x", I));
                                             (Id ("y", I))])
                                        ))
                                     ))))
                           ]
                         ))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x", (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "rem"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))))
              )),
           (Binder ((Some "rem"),
              [([(PId "x"); (PId "y")],
                (Some (BOpr ("-", (Id ("x", I)),
                         (BOpr ("*",
                            (BOpr ("/", (Id ("x", I)), (Id ("y", I)))),
                            (Id ("y", I))))
                         ))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x", (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "pow"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "pow"),
              [([(PId "_"); (PId "zero")],
                (Some (App [(Id ("succ", I)); (Id ("zero", I))])));
                ([(PId "x"); (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("*", (Id ("x", I)),
                          (BOpr ("^", (Id ("x", I)), (Id ("y", I))))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "loc"; relv = N;
    body = (Binder ([], ((Id ("nat", I)), (Type U)))); view = []};
  Inductive {name = "at"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("loc", I)),
                (Binder ("l",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("at_intro",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBase
                                    (App
                                       [(Id ("at", I)); (Id ("A", I));
                                         (Id ("l", I))]))
                                 ))
                              )),
                           [E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [E; E]};
  Notation {name = "@"; body = (App [(Id ("at", I)); (Hole 1); (Hole 2)])};
  Extern {name = "alloc"; relv = R;
    body =
    (Binder ([],
       (None,
        (Pi (R, U, (Id ("unit", I)),
           (Binder ("_",
              (IO
                 (App
                    [(Id ("exists1", I));
                      (Fun ((Pi (R, U, IMeta, (Binder ("l", IMeta)))),
                         (Binder (None,
                            [([(PId "l")],
                              (Some (BOpr ("@", (Id ("unit", I)),
                                       (Id ("l", I))))))
                              ]
                            )),
                         []))
                      ]))
              ))
           )))
       ));
    view = [E]};
  Extern {name = "getU"; relv = R;
    body =
    (Binder ([],
       ((Some (Fun (
                 (Pi (N, U, (Type U),
                    (Binder ("A",
                       (Pi (R, U, (Id ("loc", I)),
                          (Binder ("l",
                             (Pi (R, U,
                                (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                                (Binder ("pf",
                                   (App
                                      [(Id ("prod1", I)); (Id ("A", I));
                                        (BOpr ("@", (Id ("A", I)),
                                           (Id ("l", I))))
                                        ])
                                   ))
                                ))
                             ))
                          ))
                       ))
                    )),
                 (Binder ((Some "getU"),
                    [([(PId "A"); (PId "l"); (PId "pf")],
                      (Some (Match ([(R, (Id ("pf", I)), None)], None,
                               [([(PConstr ("at_intro", [(PId "v")]))],
                                 (Some (BOpr ("\226\159\168,\226\159\169",
                                          (Id ("v", I)), (Id ("pf", I))))))
                                 ]
                               ))))
                      ]
                    )),
                 [I; E; E]))),
        (Pi (N, U, (Type U),
           (Binder ("A",
              (Pi (R, U, (Id ("loc", I)),
                 (Binder ("l",
                    (Pi (R, U, (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                       (Binder ("pf",
                          (App
                             [(Id ("prod1", I)); (Id ("A", I));
                               (BOpr ("@", (Id ("A", I)), (Id ("l", I))))])
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; E; E]};
  Extern {name = "getL"; relv = R;
    body =
    (Binder ([],
       ((Some (Fun (
                 (Pi (N, U, (Type L),
                    (Binder ("A",
                       (Pi (R, U, (Id ("loc", I)),
                          (Binder ("l",
                             (Pi (R, U,
                                (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                                (Binder ("pf",
                                   (App
                                      [(Id ("prod1", I)); (Id ("A", I));
                                        (BOpr ("@", (Id ("unit", I)),
                                           (Id ("l", I))))
                                        ])
                                   ))
                                ))
                             ))
                          ))
                       ))
                    )),
                 (Binder ((Some "getL"),
                    [([(PId "A"); (PId "l"); (PId "pf")],
                      (Some (Match ([(R, (Id ("pf", I)), None)], None,
                               [([(PConstr ("at_intro", [(PId "v")]))],
                                 (Some (BOpr ("\226\159\168,\226\159\169",
                                          (Id ("v", I)),
                                          (App
                                             [(Id ("at_intro", I));
                                               (Id ("tt", I))])
                                          ))))
                                 ]
                               ))))
                      ]
                    )),
                 [I; E; E]))),
        (Pi (N, U, (Type L),
           (Binder ("A",
              (Pi (R, U, (Id ("loc", I)),
                 (Binder ("l",
                    (Pi (R, U, (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                       (Binder ("pf",
                          (App
                             [(Id ("prod1", I)); (Id ("A", I));
                               (BOpr ("@", (Id ("unit", I)), (Id ("l", I))))])
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; E; E]};
  Extern {name = "set"; relv = R;
    body =
    (Binder (["s"],
       ((Some (Fun (
                 (Pi (N, U, (Type U),
                    (Binder ("A",
                       (Pi (N, U, (Type (SId "s")),
                          (Binder ("B",
                             (Pi (R, U, (Id ("loc", I)),
                                (Binder ("l",
                                   (Pi (R, U, (Id ("B", I)),
                                      (Binder ("m",
                                         (Pi (R, U,
                                            (BOpr ("@", (Id ("A", I)),
                                               (Id ("l", I)))),
                                            (Binder ("pf",
                                               (BOpr ("@", (Id ("B", I)),
                                                  (Id ("l", I))))
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    )),
                 (Binder ((Some "set"),
                    [([(PId "A"); (PId "B"); (PId "l"); (PId "m"); (PId "pf")
                        ],
                      (Some (Match ([(R, (Id ("pf", I)), None)], None,
                               [([(PConstr ("at_intro", [(PId "_")]))],
                                 (Some (App
                                          [(Id ("at_intro", I));
                                            (Id ("m", I))])))
                                 ]
                               ))))
                      ]
                    )),
                 [I; I; E; E; E]))),
        (Pi (N, U, (Type U),
           (Binder ("A",
              (Pi (N, U, (Type (SId "s")),
                 (Binder ("B",
                    (Pi (R, U, (Id ("loc", I)),
                       (Binder ("l",
                          (Pi (R, U, (Id ("B", I)),
                             (Binder ("m",
                                (Pi (R, U,
                                   (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                                   (Binder ("pf",
                                      (BOpr ("@", (Id ("B", I)),
                                         (Id ("l", I))))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; E; E; E]};
  Extern {name = "free"; relv = R;
    body =
    (Binder ([],
       ((Some (Fun (
                 (Pi (N, U, (Type U),
                    (Binder ("A",
                       (Pi (R, U, (Id ("loc", I)),
                          (Binder ("l",
                             (Pi (R, U,
                                (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                                (Binder ("pf", (Id ("unit", I))))))
                             ))
                          ))
                       ))
                    )),
                 (Binder ((Some "free"),
                    [([(PId "A"); (PId "l"); (PId "pf")],
                      (Some (Match ([(R, (Id ("pf", I)), None)], None,
                               [([(PConstr ("at_intro", [(PId "_")]))],
                                 (Some (Id ("tt", I))))]
                               ))))
                      ]
                    )),
                 [I; E; E]))),
        (Pi (N, U, (Type U),
           (Binder ("A",
              (Pi (R, U, (Id ("loc", I)),
                 (Binder ("l",
                    (Pi (R, U, (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                       (Binder ("pf", (Id ("unit", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; E; E]};
  Definition {name = "set_get_law"; relv = N;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (R, U, (Type U),
              (Binder ("A",
                 (Pi (R, U, (Id ("loc", I)),
                    (Binder ("l",
                       (Pi (R, U, (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                          (Binder ("pf",
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("v0",
                                   (Let (R,
                                      (App
                                         [(Id ("set", I)); (Id ("l", I));
                                           (Id ("v0", I)); (Id ("pf", I))]),
                                      (Binder ((PId "pf"),
                                         (Let (R,
                                            (App
                                               [(Id ("getU", I));
                                                 (Id ("l", I));
                                                 (Id ("pf", I))]),
                                            (Binder (
                                               (PBOpr (
                                                  "\226\159\168,\226\159\169",
                                                  (PId "v1"), (PId "pf"))),
                                               (BOpr ("=", (Id ("v0", I)),
                                                  (Id ("v1", I))))
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "set_get_law"),
              [([(PId "A"); (PId "l"); (PId "pf"); (PId "v0")],
                (Some (Match ([(R, (Id ("pf", I)), (Some ("pf0", IMeta)))],
                         (Some (Let (R,
                                  (App
                                     [(Id ("set", I)); (Id ("l", I));
                                       (Id ("v0", I)); (Id ("pf0", I))]),
                                  (Binder ((PId "pf0"),
                                     (Let (R,
                                        (App
                                           [(Id ("getU", I)); (Id ("l", I));
                                             (Id ("pf0", I))]),
                                        (Binder (
                                           (PBOpr (
                                              "\226\159\168,\226\159\169",
                                              (PId "v1"), (PId "pf0"))),
                                           (BOpr ("=", (Id ("v0", I)),
                                              (Id ("v1", I))))
                                           ))
                                        ))
                                     ))
                                  ))),
                         [([(PConstr ("at_intro", [(PId "v")]))],
                           (Some (Id ("refl", I))))]
                         ))))
                ]
              )),
           [I; E; E; E])),
        (Pi (R, U, (Type U),
           (Binder ("A",
              (Pi (R, U, (Id ("loc", I)),
                 (Binder ("l",
                    (Pi (R, U, (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                       (Binder ("pf",
                          (Pi (R, U, (Id ("A", I)),
                             (Binder ("v0",
                                (Let (R,
                                   (App
                                      [(Id ("set", I)); (Id ("l", I));
                                        (Id ("v0", I)); (Id ("pf", I))]),
                                   (Binder ((PId "pf"),
                                      (Let (R,
                                         (App
                                            [(Id ("getU", I)); (Id ("l", I));
                                              (Id ("pf", I))]),
                                         (Binder (
                                            (PBOpr (
                                               "\226\159\168,\226\159\169",
                                               (PId "v1"), (PId "pf"))),
                                            (BOpr ("=", (Id ("v0", I)),
                                               (Id ("v1", I))))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; E; E; E]};
  Definition {name = "main"; relv = R;
    body =
    (Binder ([],
       ((MLet ((App [(Id ("alloc", I)); (Id ("tt", I))]),
           (Binder (
              (PBOpr ("\226\159\168,\226\159\169", (PId "l"), (PId "pf"))),
              (Let (R,
                 (App
                    [(Id ("set", I)); (Id ("l", I)); (Id ("zero", I));
                      (Id ("pf", I))]),
                 (Binder ((PId "pf"),
                    (Let (R,
                       (App [(Id ("free", I)); (Id ("l", I)); (Id ("pf", I))]),
                       (Binder ((PId "_"), (Return (Id ("tt", I)))))))
                    ))
                 ))
              ))
           )),
        (IO (Id ("unit", I))))
       ));
    view = []}
  ]

-----------------------------------------

#[logical]
inductive eq_1‹s_329› (A_330 : Type‹s_329›) (m_331 : A_330):
  A_330 -> U
where
| refl_1 : (eq_1‹??_1› ?_1[0;0] m_331 m_331)

#[program]
def rwl_1‹s_333,r_334› :
  ∀ {A_335 : Type‹s_333›} ->
    ∀ {m_336 : A_335} ->
      ∀ {n_337 : A_335} ->
        ∀ {B_338 : A_335 -> Type‹r_334›} ->
          {(eq_1‹??_3› ?_3[0;0] m_336 n_337)} ->
            ((B_338) m_336) -> ((B_338) n_337)
:=
  function rwl_342 :
    ∀ {A_343 : Type‹s_333›} ->
      ∀ {m_344 : A_343} ->
        ∀ {n_345 : A_343} ->
          ∀ {B_346 : A_343 -> Type‹r_334›} ->
            {(eq_1‹??_2› ?_2[0;0] m_344 n_345)} ->
              ((B_346) m_344) -> ((B_346) n_345)
  | A_350 m_351 n_352 B_353 refl_1 x_354 => x_354

#[program]
def rwr_2‹s_355,r_356› :
  ∀ {A_357 : Type‹s_355›} ->
    ∀ {m_358 : A_357} ->
      ∀ {n_359 : A_357} ->
        ∀ {B_360 : A_357 -> Type‹r_356›} ->
          {(eq_1‹??_5› ?_5[0;0] m_358 n_359)} ->
            ((B_360) n_359) -> ((B_360) m_358)
:=
  function rwr_364 :
    ∀ {A_365 : Type‹s_355›} ->
      ∀ {m_366 : A_365} ->
        ∀ {n_367 : A_365} ->
          ∀ {B_368 : A_365 -> Type‹r_356›} ->
            {(eq_1‹??_4› ?_4[0;0] m_366 n_367)} ->
              ((B_368) n_367) -> ((B_368) m_366)
  | A_372 m_373 n_374 B_375 refl_1 x_376 => x_376

#[program]
inductive sing_2‹s_377› (A_378 : Type‹s_377›):
  A_378 -> Type‹s_377›
where
| just_2 (m_380 : A_378) : (sing_2‹??_6› ?_6[0;0] m_380)

#[program]
inductive unit_3‹› : U where
| tt_3 : unit_3

#[program]
inductive bool_4‹› : U where
| true_4 : bool_4
| false_5 : bool_4

#[program]
inductive nat_5‹› : U where
| zero_6 : nat_5
| succ_7 (n_381 : nat_5) : nat_5

#[program]
inductive list_6‹s_382,t_383› (A_384 : Type‹s_382›): Type‹t_383›
where
| nil_8 : (list_6‹??_7,??_8› A_384)
| cons_9
    (hd_385 : A_384) (tl_386 : (list_6‹??_9,t_383› A_384))
    : (list_6‹??_10,??_11› A_384)

#[program]
inductive exists0_7‹s_387,r_388› (A_389 : Type‹s_387›) (B_390 : 
A_389 -> Type‹r_388›): L where
| ex0_10
    {m_392 : A_389} (n_393 : ((B_390) m_392))
    : (exists0_7‹??_12,??_13› A_389 B_390)

#[program]
inductive exists1_8‹s_394,r_395› (A_396 : Type‹s_394›) (B_397 : 
A_396 -> Type‹r_395›): L where
| ex1_11
    (m_399 : A_396) (n_400 : ((B_397) m_399))
    : (exists1_8‹??_14,??_15› A_396 B_397)

#[logical]
def prod0_3‹s_401,r_402› :
  Type‹s_401› -> Type‹r_402› -> ?_10[0;0]
:=
  function prod0_405 : Type‹s_401› -> Type‹r_402› -> ?_7[0;0]
  | A_408 B_409 =>
    (exists0_7‹??_16,??_17›
      A_408 function _410 : ?_8[0;0] -> ?_9[0;0]
            | _412 => B_409)

#[logical]
def prod1_4‹s_413,r_414› :
  Type‹s_413› -> Type‹r_414› -> ?_14[0;0]
:=
  function prod1_417 : Type‹s_413› -> Type‹r_414› -> ?_11[0;0]
  | A_420 B_421 =>
    (exists1_8‹??_18,??_19›
      A_420 function _422 : ?_12[0;0] -> ?_13[0;0]
            | _424 => B_421)

#[program]
def not_5‹› : bool_4 -> bool_4 :=
  function not_426 : bool_4 -> bool_4
  | true_4 => false_5
  | false_5 => true_4

#[program]
def and_6‹› : bool_4 -> bool_4 -> bool_4 :=
  function and_430 : bool_4 -> bool_4 -> bool_4
  | true_4 true_4 => true_4
  | _433 _434 => false_5

#[program]
def or_7‹› : bool_4 -> bool_4 -> bool_4 :=
  function or_437 : bool_4 -> bool_4 -> bool_4
  | false_5 false_5 => false_5
  | _440 _441 => true_4

#[program]
def xor_8‹› : bool_4 -> bool_4 -o bool_4 :=
  function xor_444 : bool_4 -> bool_4 -o bool_4
  | true_4 true_4 => false_5
  | false_5 false_5 => false_5
  | _447 _448 => true_4

#[program]
def lte_9‹› : nat_5 -> nat_5 -> bool_4 :=
  function lte_451 : nat_5 -> nat_5 -> bool_4
  | zero_6 _454 => true_4
  | _455 zero_6 => false_5
  | (succ_7 x_456) (succ_7 y_457) => ((lte_451) x_456 y_457)

#[program]
def lt_10‹› : nat_5 -> nat_5 -> bool_4 :=
  function lt_460 : nat_5 -> nat_5 -> bool_4
  | x_463 y_464 => ((lte_9) (succ_7‹› x_463) y_464)

#[program]
def pred_11‹› : nat_5 -> nat_5 :=
  function pred_466 : nat_5 -> nat_5
  | zero_6 => zero_6
  | (succ_7 x_468) => x_468

#[program]
def add_12‹› : nat_5 -> nat_5 -> nat_5 :=
  function add_471 : nat_5 -> nat_5 -> nat_5
  | zero_6 y_474 => y_474
  | (succ_7 x_475) y_476 => (succ_7‹› ((add_471) x_475 y_476))

#[program]
def sub_13‹› : nat_5 -> nat_5 -> nat_5 :=
  function sub_479 : nat_5 -> nat_5 -> nat_5
  | x_482 zero_6 => x_482
  | x_483 (succ_7 y_484) => ((sub_479) ((pred_11) x_483) y_484)

#[program]
def mul_14‹› : nat_5 -> nat_5 -> nat_5 :=
  function mul_487 : nat_5 -> nat_5 -> nat_5
  | zero_6 _490 => zero_6
  | (succ_7 x_491) y_492 => ((add_12) y_492 ((mul_487) x_491 y_492))

#[program]
def div_15‹› : nat_5 -> nat_5 -> ?_21[0;0] :=
  function div_495 : nat_5 -> nat_5 -> ?_15[0;0]
  | x_498 y_499 =>
    match ((lt_10) x_498 y_499) in ?_16[0;0] -o ?_17[0;0] with
    | true_4 => zero_6
    | false_5 =>
      let loop_501 :=
        function loop_502 : nat_5 -> nat_5 -> ?_18[0;0]
        | x_505 y_506 =>
          match ((sub_13) x_505 ((pred_11) y_506)) in ?_19[0;0] -o ?_20[0;0]
          with
          | zero_6 => zero_6
          | (succ_7 x_508) => (succ_7‹› ((loop_502) x_508 y_506))
      in ((loop_501) x_498 y_499)

#[program]
def rem_16‹› : nat_5 -> nat_5 -> ?_23[0;0] :=
  function rem_511 : nat_5 -> nat_5 -> ?_22[0;0]
  | x_514 y_515 => ((sub_13) x_514 ((mul_14) ((div_15) x_514 y_515) y_515))

#[program]
def pow_17‹› : nat_5 -> nat_5 -> nat_5 :=
  function pow_518 : nat_5 -> nat_5 -> nat_5
  | _521 zero_6 => (succ_7‹› zero_6)
  | x_522 (succ_7 y_523) => ((mul_14) x_522 ((pow_518) x_522 y_523))

#[logical]
def loc_18‹› : U := nat_5

#[logical]
inductive at_9‹s_524› (A_525 : Type‹s_524›) (l_526 : loc_18): 
L where
| at_intro_12 (m_527 : A_525) : (at_9‹??_20› A_525 l_526)

#[program]
extern alloc_19‹› :
  unit_3 ->
    IO (exists1_8‹??_22,??_23›
         ?_26[0;0]
         function _529 : ?_24[0;0] -> ?_25[0;0]
         | l_531 => (at_9‹??_21› unit_3 l_531))

#[program]
extern getU_20‹› :
  ∀ {A_532 : U} ->
    ∀ (l_533 : loc_18) ->
      (at_9‹??_30› A_532 l_533) ->
        ((prod1_4‹??_32,??_33›) A_532 (at_9‹??_31› A_532 l_533))
:=
  function getU_535 :
    ∀ {A_536 : U} ->
      ∀ (l_537 : loc_18) ->
        (at_9‹??_24› A_536 l_537) ->
          ((prod1_4‹??_26,??_27›) A_536 (at_9‹??_25› A_536 l_537))
  | A_539 l_540 pf_541 =>
    match pf_541 in ?_27[0;0] -o ?_28[0;0] with
    | (at_intro_12 v_543) =>
      (ex1_11‹??_28,??_29› ?_29[0;0] ?_30[0;0] v_543 pf_541)

#[program]
extern getL_21‹› :
  ∀ {A_544 : L} ->
    ∀ (l_545 : loc_18) ->
      (at_9‹??_41› A_544 l_545) ->
        ((prod1_4‹??_43,??_44›) A_544 (at_9‹??_42› unit_3 l_545))
:=
  function getL_547 :
    ∀ {A_548 : L} ->
      ∀ (l_549 : loc_18) ->
        (at_9‹??_34› A_548 l_549) ->
          ((prod1_4‹??_36,??_37›) A_548 (at_9‹??_35› unit_3 l_549))
  | A_551 l_552 pf_553 =>
    match pf_553 in ?_31[0;0] -o ?_32[0;0] with
    | (at_intro_12 v_555) =>
      (ex1_11‹??_39,??_40›
        ?_35[0;0] ?_36[0;0] v_555
        (at_intro_12‹??_38› ?_33[0;0] ?_34[0;0] tt_3))

#[program]
extern set_22‹s_556› :
  ∀ {A_557 : U} ->
    ∀ {B_558 : Type‹s_556›} ->
      ∀ (l_559 : loc_18) ->
        B_558 ->
          (at_9‹??_48› A_557 l_559) -> (at_9‹??_49› B_558 l_559)
:=
  function set_562 :
    ∀ {A_563 : U} ->
      ∀ {B_564 : Type‹s_556›} ->
        ∀ (l_565 : loc_18) ->
          B_564 ->
            (at_9‹??_45› A_563 l_565) -> (at_9‹??_46› B_564 l_565)
  | A_568 B_569 l_570 m_571 pf_572 =>
    match pf_572 in ?_37[0;0] -o ?_38[0;0] with
    | (at_intro_12 _574) =>
      (at_intro_12‹??_47› ?_39[0;0] ?_40[0;0] m_571)

#[program]
extern free_23‹› :
  ∀ {A_575 : U} ->
    ∀ (l_576 : loc_18) -> (at_9‹??_51› A_575 l_576) -> unit_3
:=
  function free_578 :
    ∀ {A_579 : U} ->
      ∀ (l_580 : loc_18) -> (at_9‹??_50› A_579 l_580) -> unit_3
  | A_582 l_583 pf_584 =>
    match pf_584 in ?_41[0;0] -o ?_42[0;0] with
    | (at_intro_12 _586) => tt_3

#[logical]
def set_get_law_24‹s_587› :
  ∀ (A_588 : U) ->
    ∀ (l_589 : loc_18) ->
      ∀ (pf_590 : (at_9‹??_58› A_588 l_589)) ->
        ∀ (v0_591 : A_588) ->
          let pf_592 :=
            ((set_22‹??_59›) ?_59[0;0] ?_58[0;0] l_589 v0_591 pf_590)
          in
          match ((getU_20) ?_60[0;0] l_589 pf_592) in ?_63[0;0] -o ?_62[0;0]
          with
          | (ex1_11 v1_594 pf_595) =>
            (eq_1‹??_60› ?_61[0;0] v0_591 v1_594)
:=
  function set_get_law_596 :
    ∀ (A_597 : U) ->
      ∀ (l_598 : loc_18) ->
        ∀ (pf_599 : (at_9‹??_52› A_597 l_598)) ->
          ∀ (v0_600 : A_597) ->
            let pf_601 :=
              ((set_22‹??_53›) ?_44[0;0] ?_43[0;0] l_598 v0_600 pf_599)
            in
            match ((getU_20) ?_45[0;0] l_598 pf_601) in
              ?_48[0;0] -o ?_47[0;0]
            with
            | (ex1_11 v1_603 pf_604) =>
              (eq_1‹??_54› ?_46[0;0] v0_600 v1_603)
  | A_605 l_606 pf_607 v0_608 =>
    match pf_607 in
      ∀ (pf0_609 : ?_49[0;0]) -o
        let pf0_610 :=
          ((set_22‹??_55›) ?_51[0;0] ?_50[0;0] l_606 v0_608 pf0_609)
        in
        match ((getU_20) ?_52[0;0] l_606 pf0_610) in ?_55[0;0] -o ?_54[0;0]
        with
        | (ex1_11 v1_612 pf0_613) =>
          (eq_1‹??_56› ?_53[0;0] v0_608 v1_612)
    with
    | (at_intro_12 v_614) => (refl_1‹??_57› ?_56[0;0] ?_57[0;0])

#[program]
def main_25‹› : IO unit_3 :=
  let* _615 := ((alloc_19) tt_3) in
  match _615 in ?_68[0;0] -o ?_67[0;0] with
  | (ex1_11 l_617 pf_618) =>
    let pf_619 :=
      ((set_22‹??_61›) ?_65[0;0] ?_64[0;0] l_617 zero_6 pf_618)
    in let __620 := ((free_23) ?_66[0;0] l_617 pf_619) in return tt_3

-----------------------------------------

#[logical]
inductive eq_1‹s_5675› (A_5676 : Type‹s_5675›) (m_5677 : A_5676):
  A_5676 -> U
where
| refl_1 : (eq_1‹s_5675› A_5676 m_5677 m_5677)

#[program]
def rwl_1‹s_5679,r_5680› :
  ∀ {A_5681 : Type‹s_5679›} ->
    ∀ {m_5682 : A_5681} ->
      ∀ {n_5683 : A_5681} ->
        ∀ {B_5684 : A_5681 -> Type‹r_5680›} ->
          {(eq_1‹s_5679› A_5681 m_5682 n_5683)} ->
            ((B_5684) m_5682) -> ((B_5684) n_5683)
:=
  function rwl_5688 :
    ∀ {A_5689 : Type‹s_5679›} ->
      ∀ {m_5690 : A_5689} ->
        ∀ {n_5691 : A_5689} ->
          ∀ {B_5692 : A_5689 -> Type‹r_5680›} ->
            {(eq_1‹s_5679› A_5689 m_5690 n_5691)} ->
              ((B_5692) m_5690) -> ((B_5692) n_5691)
  | A_5696 m_5697 n_5698 B_5699 refl_1 __5700 => __5700

#[program]
def rwr_2‹s_5701,r_5702› :
  ∀ {A_5703 : Type‹s_5701›} ->
    ∀ {m_5704 : A_5703} ->
      ∀ {n_5705 : A_5703} ->
        ∀ {B_5706 : A_5703 -> Type‹r_5702›} ->
          {(eq_1‹s_5701› A_5703 m_5704 n_5705)} ->
            ((B_5706) n_5705) -> ((B_5706) m_5704)
:=
  function rwr_5710 :
    ∀ {A_5711 : Type‹s_5701›} ->
      ∀ {m_5712 : A_5711} ->
        ∀ {n_5713 : A_5711} ->
          ∀ {B_5714 : A_5711 -> Type‹r_5702›} ->
            {(eq_1‹s_5701› A_5711 m_5712 n_5713)} ->
              ((B_5714) n_5713) -> ((B_5714) m_5712)
  | A_5718 m_5719 n_5720 B_5721 refl_1 __5722 => __5722

#[program]
inductive sing_2‹s_5723› (A_5724 : Type‹s_5723›):
  A_5724 -> Type‹s_5723›
where
| just_2 (m_5726 : A_5724) : (sing_2‹s_5723› A_5724 m_5726)

#[program]
inductive unit_3‹› : U where
| tt_3 : unit_3

#[program]
inductive bool_4‹› : U where
| true_4 : bool_4
| false_5 : bool_4

#[program]
inductive nat_5‹› : U where
| zero_6 : nat_5
| succ_7 (n_5727 : nat_5) : nat_5

#[program]
inductive list_6‹s_5728,t_5729› (A_5730 : Type‹s_5728›):
  Type‹t_5729›
where
| nil_8 : (list_6‹s_5728,t_5729› A_5730)
| cons_9
    (hd_5731 : A_5730) (tl_5732 : (list_6‹s_5728,t_5729› A_5730))
    : (list_6‹s_5728,t_5729› A_5730)

#[program]
inductive exists0_7‹s_5733,r_5734› (A_5735 : Type‹s_5733›) (B_5736 : 
A_5735 -> Type‹r_5734›): L where
| ex0_10
    {m_5738 : A_5735} (n_5739 : ((B_5736) m_5738))
    : (exists0_7‹s_5733,r_5734› A_5735 B_5736)

#[program]
inductive exists1_8‹s_5740,r_5741› (A_5742 : Type‹s_5740›) (B_5743 : 
A_5742 -> Type‹r_5741›): L where
| ex1_11
    (m_5745 : A_5742) (n_5746 : ((B_5743) m_5745))
    : (exists1_8‹s_5740,r_5741› A_5742 B_5743)

#[logical]
def prod0_3‹s_5747,r_5748› : Type‹s_5747› -> Type‹r_5748› -> L :=
  function prod0_5751 : Type‹s_5747› -> Type‹r_5748› -> L
  | A_5754 B_5755 =>
    (exists0_7‹s_5747,r_5748›
      A_5754 function _5756 : A_5754 -> Type‹r_5748›
             | __5758 => B_5755)

#[logical]
def prod1_4‹s_5759,r_5760› : Type‹s_5759› -> Type‹r_5760› -> L :=
  function prod1_5763 : Type‹s_5759› -> Type‹r_5760› -> L
  | A_5766 B_5767 =>
    (exists1_8‹s_5759,r_5760›
      A_5766 function _5768 : A_5766 -> Type‹r_5760›
             | __5770 => B_5767)

#[program]
def not_5‹› : bool_4 -> bool_4 :=
  function not_5772 : bool_4 -> bool_4
  | true_4 => false_5
  | false_5 => true_4

#[program]
def and_6‹› : bool_4 -> bool_4 -> bool_4 :=
  function and_5776 : bool_4 -> bool_4 -> bool_4
  | true_4 true_4 => true_4
  | true_4 false_5 => false_5
  | false_5 __5779 => false_5

#[program]
def or_7‹› : bool_4 -> bool_4 -> bool_4 :=
  function or_5782 : bool_4 -> bool_4 -> bool_4
  | true_4 __5785 => true_4
  | false_5 true_4 => true_4
  | false_5 false_5 => false_5

#[program]
def xor_8‹› : bool_4 -> bool_4 -o bool_4 :=
  function xor_5788 : bool_4 -> bool_4 -o bool_4
  | true_4 true_4 => false_5
  | true_4 false_5 => true_4
  | false_5 true_4 => true_4
  | false_5 false_5 => false_5

#[program]
def lte_9‹› : nat_5 -> nat_5 -> bool_4 :=
  function lte_5793 : nat_5 -> nat_5 -> bool_4
  | zero_6 __5796 => true_4
  | (succ_7 n_5797) zero_6 => false_5
  | (succ_7 n_5798) (succ_7 n_5799) => ((lte_5793) n_5798 n_5799)

#[program]
def lt_10‹› : nat_5 -> nat_5 -> bool_4 :=
  function lt_5802 : nat_5 -> nat_5 -> bool_4
  | x_5805 y_5806 => ((lte_9) (succ_7‹› x_5805) y_5806)

#[program]
def pred_11‹› : nat_5 -> nat_5 :=
  function pred_5808 : nat_5 -> nat_5
  | zero_6 => zero_6
  | (succ_7 n_5810) => n_5810

#[program]
def add_12‹› : nat_5 -> nat_5 -> nat_5 :=
  function add_5813 : nat_5 -> nat_5 -> nat_5
  | zero_6 __5816 => __5816
  | (succ_7 n_5817) __5818 => (succ_7‹› ((add_5813) n_5817 __5818))

#[program]
def sub_13‹› : nat_5 -> nat_5 -> nat_5 :=
  function sub_5821 : nat_5 -> nat_5 -> nat_5
  | __5824 zero_6 => __5824
  | __5825 (succ_7 n_5826) => ((sub_5821) ((pred_11) __5825) n_5826)

#[program]
def mul_14‹› : nat_5 -> nat_5 -> nat_5 :=
  function mul_5829 : nat_5 -> nat_5 -> nat_5
  | zero_6 __5832 => zero_6
  | (succ_7 n_5833) __5834 => ((add_12) __5834 ((mul_5829) n_5833 __5834))

#[program]
def div_15‹› : nat_5 -> nat_5 -> nat_5 :=
  function div_5837 : nat_5 -> nat_5 -> nat_5
  | x_5840 y_5841 =>
    match ((lt_10) x_5840 y_5841) in bool_4 -o nat_5 with
    | true_4 => zero_6
    | false_5 =>
      let loop_5843 :=
        function loop_5844 : nat_5 -> nat_5 -> nat_5
        | x_5847 y_5848 =>
          match ((sub_13) x_5847 ((pred_11) y_5848)) in nat_5 -o nat_5 with
          | zero_6 => zero_6
          | (succ_7 n_5850) => (succ_7‹› ((loop_5844) n_5850 y_5848))
      in ((loop_5843) x_5840 y_5841)

#[program]
def rem_16‹› : nat_5 -> nat_5 -> nat_5 :=
  function rem_5853 : nat_5 -> nat_5 -> nat_5
  | x_5856 y_5857 =>
    ((sub_13) x_5856 ((mul_14) ((div_15) x_5856 y_5857) y_5857))

#[program]
def pow_17‹› : nat_5 -> nat_5 -> nat_5 :=
  function pow_5860 : nat_5 -> nat_5 -> nat_5
  | __5863 zero_6 => (succ_7‹› zero_6)
  | __5864 (succ_7 n_5865) => ((mul_14) __5864 ((pow_5860) __5864 n_5865))

#[logical]
def loc_18‹› : U := nat_5

#[logical]
inductive at_9‹s_5866› (A_5867 : Type‹s_5866›) (l_5868 : loc_18): 
L where
| at_intro_12 (m_5869 : A_5867) : (at_9‹s_5866› A_5867 l_5868)

#[program]
extern alloc_19‹› :
  unit_3 ->
    IO (exists1_8‹U,L›
         loc_18
         function _5871 : loc_18 -> L
         | __5873 => (at_9‹U› unit_3 __5873))

#[program]
extern getU_20‹› :
  ∀ {A_5874 : U} ->
    ∀ (l_5875 : loc_18) ->
      (at_9‹U› A_5874 l_5875) ->
        ((prod1_4‹U,L›) A_5874 (at_9‹U› A_5874 l_5875))
:=
  function getU_5877 :
    ∀ {A_5878 : U} ->
      ∀ (l_5879 : loc_18) ->
        (at_9‹U› A_5878 l_5879) ->
          ((prod1_4‹U,L›) A_5878 (at_9‹U› A_5878 l_5879))
  | A_5881 l_5882 pf_5883 =>
    match pf_5883 in
      (at_9‹U› A_5881 l_5882) -o
        ((prod1_4‹U,L›) A_5881 (at_9‹U› A_5881 l_5882))
    with
    | (at_intro_12 m_5885) =>
      (ex1_11‹U,L›
        A_5881
        function _5886 : A_5881 -> L
        | __5888 => (at_9‹U› A_5881 l_5882) m_5885 pf_5883)

#[program]
extern getL_21‹› :
  ∀ {A_5889 : L} ->
    ∀ (l_5890 : loc_18) ->
      (at_9‹L› A_5889 l_5890) ->
        ((prod1_4‹L,L›) A_5889 (at_9‹U› unit_3 l_5890))
:=
  function getL_5892 :
    ∀ {A_5893 : L} ->
      ∀ (l_5894 : loc_18) ->
        (at_9‹L› A_5893 l_5894) ->
          ((prod1_4‹L,L›) A_5893 (at_9‹U› unit_3 l_5894))
  | A_5896 l_5897 pf_5898 =>
    match pf_5898 in
      (at_9‹L› A_5896 l_5897) -o
        ((prod1_4‹L,L›) A_5896 (at_9‹U› unit_3 l_5897))
    with
    | (at_intro_12 m_5900) =>
      (ex1_11‹L,L›
        A_5896
        function _5901 : A_5896 -> L
        | __5903 => (at_9‹U› unit_3 l_5897) m_5900
        (at_intro_12‹U› unit_3 l_5897 tt_3))

#[program]
extern set_22‹s_5904› :
  ∀ {A_5905 : U} ->
    ∀ {B_5906 : Type‹s_5904›} ->
      ∀ (l_5907 : loc_18) ->
        B_5906 ->
          (at_9‹U› A_5905 l_5907) -> (at_9‹s_5904› B_5906 l_5907)
:=
  function set_5910 :
    ∀ {A_5911 : U} ->
      ∀ {B_5912 : Type‹s_5904›} ->
        ∀ (l_5913 : loc_18) ->
          B_5912 ->
            (at_9‹U› A_5911 l_5913) -> (at_9‹s_5904› B_5912 l_5913)
  | A_5916 B_5917 l_5918 m_5919 pf_5920 =>
    match pf_5920 in
      (at_9‹U› A_5916 l_5918) -o (at_9‹s_5904› B_5917 l_5918)
    with
    | (at_intro_12 m_5922) => (at_intro_12‹s_5904› B_5917 l_5918 m_5919)

#[program]
extern free_23‹› :
  ∀ {A_5923 : U} ->
    ∀ (l_5924 : loc_18) -> (at_9‹U› A_5923 l_5924) -> unit_3
:=
  function free_5926 :
    ∀ {A_5927 : U} ->
      ∀ (l_5928 : loc_18) -> (at_9‹U› A_5927 l_5928) -> unit_3
  | A_5930 l_5931 pf_5932 =>
    match pf_5932 in (at_9‹U› A_5930 l_5931) -o unit_3 with
    | (at_intro_12 m_5934) => tt_3

#[logical]
def set_get_law_24‹s_5935› :
  ∀ (A_5936 : U) ->
    ∀ (l_5937 : loc_18) ->
      ∀ (pf_5938 : (at_9‹U› A_5936 l_5937)) ->
        ∀ (v0_5939 : A_5936) ->
          let pf_5940 :=
            ((set_22‹U›) A_5936 A_5936 l_5937 v0_5939 pf_5938)
          in
          match ((getU_20) A_5936 l_5937 pf_5940) in
            ((prod1_4‹U,L›) A_5936 (at_9‹U› A_5936 l_5937)) -o U
          with
          | (ex1_11 m_5942 n_5943) => (eq_1‹U› A_5936 v0_5939 m_5942)
:=
  function set_get_law_5944 :
    ∀ (A_5945 : U) ->
      ∀ (l_5946 : loc_18) ->
        ∀ (pf_5947 : (at_9‹U› A_5945 l_5946)) ->
          ∀ (v0_5948 : A_5945) ->
            let pf_5949 :=
              ((set_22‹U›) A_5945 A_5945 l_5946 v0_5948 pf_5947)
            in
            match ((getU_20) A_5945 l_5946 pf_5949) in
              ((prod1_4‹U,L›) A_5945 (at_9‹U› A_5945 l_5946)) -o U
            with
            | (ex1_11 m_5951 n_5952) => (eq_1‹U› A_5945 v0_5948 m_5951)
  | A_5953 l_5954 pf_5955 v0_5956 =>
    match pf_5955 in
      ∀ (pf0_5957 : (at_9‹U› A_5953 l_5954)) -o
        let pf0_5958 :=
          ((set_22‹U›) A_5953 A_5953 l_5954 v0_5956 pf0_5957)
        in
        match ((getU_20) A_5953 l_5954 pf0_5958) in
          ((prod1_4‹U,L›) A_5953 (at_9‹U› A_5953 l_5954)) -o U
        with
        | (ex1_11 m_5960 n_5961) => (eq_1‹U› A_5953 v0_5956 m_5960)
    with
    | (at_intro_12 m_5962) => (refl_1‹U› A_5953 v0_5956)

#[program]
def main_25‹› : IO unit_3 :=
  let* _5963 := ((alloc_19) tt_3) in
  match _5963 in
    (exists1_8‹U,L›
      loc_18
      function _5965 : loc_18 -> L
      | __5967 => (at_9‹U› unit_3 __5967)) -o IO unit_3
  with
  | (ex1_11 m_5968 n_5969) =>
    let pf_5970 := ((set_22‹U›) unit_3 nat_5 m_5968 zero_6 n_5969) in
    let __5971 := ((free_23) nat_5 m_5968 pf_5970) in return tt_3

-----------------------------------------

#[logical]
inductive eqU_11 where
| reflU_14 of layout[]

#[logical]
inductive eqL_10 where
| reflL_13 of layout[]

#[program]
def rwlUU_29 :=
  fun rwl_8490 {A_8491} -> {m_8492} -> {n_8493} -> {B_8494} -> {__8495} ->
  (__8496) ->
    match {NULL} with
    | reflU_14  => __8496
    end

#[program]
def rwlUL_28 :=
  fun rwl_8497 {A_8498} -> {m_8499} -> {n_8500} -> {B_8501} -> {__8502} ->
  (__8503) ->
    match {NULL} with
    | reflU_14  => __8503
    end

#[program]
def rwlLU_27 :=
  fun rwl_8504 {A_8505} -> {m_8506} -> {n_8507} -> {B_8508} -> {__8509} ->
  (__8510) ->
    match {NULL} with
    | reflL_13  => __8510
    end

#[program]
def rwlLL_26 :=
  fun rwl_8511 {A_8512} -> {m_8513} -> {n_8514} -> {B_8515} -> {__8516} ->
  (__8517) ->
    match {NULL} with
    | reflL_13  => __8517
    end

#[program]
def rwrUU_33 :=
  fun rwr_8518 {A_8519} -> {m_8520} -> {n_8521} -> {B_8522} -> {__8523} ->
  (__8524) ->
    match {NULL} with
    | reflU_14  => __8524
    end

#[program]
def rwrUL_32 :=
  fun rwr_8525 {A_8526} -> {m_8527} -> {n_8528} -> {B_8529} -> {__8530} ->
  (__8531) ->
    match {NULL} with
    | reflU_14  => __8531
    end

#[program]
def rwrLU_31 :=
  fun rwr_8532 {A_8533} -> {m_8534} -> {n_8535} -> {B_8536} -> {__8537} ->
  (__8538) ->
    match {NULL} with
    | reflL_13  => __8538
    end

#[program]
def rwrLL_30 :=
  fun rwr_8539 {A_8540} -> {m_8541} -> {n_8542} -> {B_8543} -> {__8544} ->
  (__8545) ->
    match {NULL} with
    | reflL_13  => __8545
    end

#[program]
inductive singU_13 where
| justU_16 of layout[R]

#[program]
inductive singL_12 where
| justL_15 of layout[R]

#[program]
inductive unit_3 where
| tt_3 of layout[]

#[program]
inductive bool_4 where
| true_4 of layout[]
| false_5 of layout[]

#[program]
inductive nat_5 where
| zero_6 of layout[]
| succ_7 of layout[R]

#[program]
inductive listUU_17 where
| nilUU_23 of layout[]
| consUU_24 of layout[R, R]

#[program]
inductive listUL_16 where
| nilUL_21 of layout[]
| consUL_22 of layout[R, R]

#[program]
inductive listLU_15 where
| nilLU_19 of layout[]

#[program]
inductive listLL_14 where
| nilLL_17 of layout[]
| consLL_18 of layout[R, R]

#[program]
inductive exists0UU_21 where
| ex0UU_28 of layout[N, R]

#[program]
inductive exists0UL_20 where
| ex0UL_27 of layout[N, R]

#[program]
inductive exists0LU_19 where
| ex0LU_26 of layout[N, R]

#[program]
inductive exists0LL_18 where
| ex0LL_25 of layout[N, R]

#[program]
inductive exists1UU_25 where
| ex1UU_32 of layout[R, R]

#[program]
inductive exists1UL_24 where
| ex1UL_31 of layout[R, R]

#[program]
inductive exists1LU_23 where
| ex1LU_30 of layout[R, R]

#[program]
inductive exists1LL_22 where
| ex1LL_29 of layout[R, R]

#[logical]
def prod0UU_37 := NULL

#[logical]
def prod0UL_36 := NULL

#[logical]
def prod0LU_35 := NULL

#[logical]
def prod0LL_34 := NULL

#[logical]
def prod1UU_41 := NULL

#[logical]
def prod1UL_40 := NULL

#[logical]
def prod1LU_39 := NULL

#[logical]
def prod1LL_38 := NULL

#[program]
def not_5 :=
  fun not_8546 (__8547) ->
    match __8547 with
    | true_4  => false_5 | false_5  => true_4
    end

#[program]
def and_6 :=
  fun and_8548 (__8549) -> (__8550) ->
    match __8549 with
    | true_4  =>
      match __8550 with
      | true_4  => true_4 | false_5  => false_5
      end
    | false_5  => false_5
    end

#[program]
def or_7 :=
  fun or_8551 (__8552) -> (__8553) ->
    match __8552 with
    | true_4  => true_4
    | false_5  =>
      match __8553 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def xor_8 :=
  fun xor_8554 (__8555) -> (__8556) -o
    match __8555 with
    | true_4  =>
      match __8556 with
      | true_4  => false_5 | false_5  => true_4
      end
    | false_5  =>
      match __8556 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def lte_9 :=
  fun lte_8557 (__8558) -> (__8559) ->
    match __8558 with
    | zero_6  => true_4
    | succ_7 n_8560 =>
      match __8559 with
      | zero_6  => false_5 | succ_7 n_8561 => ((lte_8557) n_8560 n_8561)
      end
    end

#[program]
def lt_10 :=
  fun lt_8562 (x_8563) -> (y_8564) ->
    ((lte_9) (succ_7 x_8563) y_8564)

#[program]
def pred_11 :=
  fun pred_8565 (__8566) ->
    match __8566 with
    | zero_6  => zero_6 | succ_7 n_8567 => n_8567
    end

#[program]
def add_12 :=
  fun add_8568 (__8569) -> (__8570) ->
    match __8569 with
    | zero_6  => __8570
    | succ_7 n_8571 => (succ_7 ((add_8568) n_8571 __8570))
    end

#[program]
def sub_13 :=
  fun sub_8572 (__8573) -> (__8574) ->
    match __8574 with
    | zero_6  => __8573
    | succ_7 n_8575 => ((sub_8572) ((pred_11) __8573) n_8575)
    end

#[program]
def mul_14 :=
  fun mul_8576 (__8577) -> (__8578) ->
    match __8577 with
    | zero_6  => zero_6
    | succ_7 n_8579 => ((add_12) __8578 ((mul_8576) n_8579 __8578))
    end

#[program]
def div_15 :=
  fun div_8580 (x_8581) -> (y_8582) ->
    match ((lt_10) x_8581 y_8582) with
    | true_4  => zero_6
    | false_5  =>
      let loop_8583 :=
        fun loop_8584 (x_8585) -> (y_8586) ->
          match ((sub_13) x_8585 ((pred_11) y_8586)) with
          | zero_6  => zero_6
          | succ_7 n_8587 => (succ_7 ((loop_8584) n_8587 y_8586))
          end
      in ((loop_8583) x_8581 y_8582)
    end

#[program]
def rem_16 :=
  fun rem_8588 (x_8589) -> (y_8590) ->
    ((sub_13) x_8589 ((mul_14) ((div_15) x_8589 y_8590) y_8590))

#[program]
def pow_17 :=
  fun pow_8591 (__8592) -> (__8593) ->
    match __8593 with
    | zero_6  => (succ_7 zero_6)
    | succ_7 n_8594 => ((mul_14) __8592 ((pow_8591) __8592 n_8594))
    end

#[logical]
def loc_18 := NULL

#[logical]
inductive atU_27 where
| at_introU_34 of layout[R]

#[logical]
inductive atL_26 where
| at_introL_33 of layout[R]

#[program]
extern alloc_19

#[program]
extern getU_20

#[program]
extern getL_21

#[program]
extern setU_43

#[program]
extern setL_42

#[program]
extern free_23

#[logical]
def set_get_lawU_45 := NULL

#[logical]
def set_get_lawL_44 := NULL

#[program]
def main :=
  let* _8595 := ((alloc_19) tt_3) in
  match _8595 with
  | ex1UL_31 m_8596 n_8597 =>
    let pf_8598 := ((setU_43) NULL NULL m_8596 zero_6 n_8597) in
    let __8599 := ((free_23) NULL m_8596 pf_8598) in return tt_3
  end

-----------------------------------------

#[logical]
inductive eqU_11 where
| reflU_14 of layout[]

#[logical]
inductive eqL_10 where
| reflL_13 of layout[]

#[program]
def rwlUU_29 :=
  fun rwl_8710 {A_8711} -> {m_8712} -> {n_8713} -> {B_8714} -> {__8715} ->
  (__8716) ->
    __8716

#[program]
def rwlUL_28 :=
  fun rwl_8717 {A_8718} -> {m_8719} -> {n_8720} -> {B_8721} -> {__8722} ->
  (__8723) ->
    __8723

#[program]
def rwlLU_27 :=
  fun rwl_8724 {A_8725} -> {m_8726} -> {n_8727} -> {B_8728} -> {__8729} ->
  (__8730) ->
    __8730

#[program]
def rwlLL_26 :=
  fun rwl_8731 {A_8732} -> {m_8733} -> {n_8734} -> {B_8735} -> {__8736} ->
  (__8737) ->
    __8737

#[program]
def rwrUU_33 :=
  fun rwr_8738 {A_8739} -> {m_8740} -> {n_8741} -> {B_8742} -> {__8743} ->
  (__8744) ->
    __8744

#[program]
def rwrUL_32 :=
  fun rwr_8745 {A_8746} -> {m_8747} -> {n_8748} -> {B_8749} -> {__8750} ->
  (__8751) ->
    __8751

#[program]
def rwrLU_31 :=
  fun rwr_8752 {A_8753} -> {m_8754} -> {n_8755} -> {B_8756} -> {__8757} ->
  (__8758) ->
    __8758

#[program]
def rwrLL_30 :=
  fun rwr_8759 {A_8760} -> {m_8761} -> {n_8762} -> {B_8763} -> {__8764} ->
  (__8765) ->
    __8765

#[program]
inductive singU_13 where
| justU_16 of layout[R]

#[program]
inductive singL_12 where
| justL_15 of layout[R]

#[program]
inductive unit_3 where
| tt_3 of layout[]

#[program]
inductive bool_4 where
| true_4 of layout[]
| false_5 of layout[]

#[program]
inductive nat_5 where
| zero_6 of layout[]
| succ_7 of layout[R]

#[program]
inductive listUU_17 where
| nilUU_23 of layout[]
| consUU_24 of layout[R, R]

#[program]
inductive listUL_16 where
| nilUL_21 of layout[]
| consUL_22 of layout[R, R]

#[program]
inductive listLU_15 where
| nilLU_19 of layout[]

#[program]
inductive listLL_14 where
| nilLL_17 of layout[]
| consLL_18 of layout[R, R]

#[program]
inductive exists0UU_21 where
| ex0UU_28 of layout[N, R]

#[program]
inductive exists0UL_20 where
| ex0UL_27 of layout[N, R]

#[program]
inductive exists0LU_19 where
| ex0LU_26 of layout[N, R]

#[program]
inductive exists0LL_18 where
| ex0LL_25 of layout[N, R]

#[program]
inductive exists1UU_25 where
| ex1UU_32 of layout[R, R]

#[program]
inductive exists1UL_24 where
| ex1UL_31 of layout[R, R]

#[program]
inductive exists1LU_23 where
| ex1LU_30 of layout[R, R]

#[program]
inductive exists1LL_22 where
| ex1LL_29 of layout[R, R]

#[logical]
def prod0UU_37 := NULL

#[logical]
def prod0UL_36 := NULL

#[logical]
def prod0LU_35 := NULL

#[logical]
def prod0LL_34 := NULL

#[logical]
def prod1UU_41 := NULL

#[logical]
def prod1UL_40 := NULL

#[logical]
def prod1LU_39 := NULL

#[logical]
def prod1LL_38 := NULL

#[program]
def not_5 :=
  fun not_8766 (__8767) ->
    match __8767 with
    | true_4  => false_5 | false_5  => true_4
    end

#[program]
def and_6 :=
  fun and_8768 (__8769) -> (__8770) ->
    match __8769 with
    | true_4  =>
      match __8770 with
      | true_4  => true_4 | false_5  => false_5
      end
    | false_5  => false_5
    end

#[program]
def or_7 :=
  fun or_8771 (__8772) -> (__8773) ->
    match __8772 with
    | true_4  => true_4
    | false_5  =>
      match __8773 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def xor_8 :=
  fun xor_8774 (__8775) -> (__8776) -o
    match __8775 with
    | true_4  =>
      match __8776 with
      | true_4  => false_5 | false_5  => true_4
      end
    | false_5  =>
      match __8776 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def lte_9 :=
  fun lte_8777 (__8778) -> (__8779) ->
    match __8778 with
    | zero_6  => true_4
    | succ_7 n_8780 =>
      match __8779 with
      | zero_6  => false_5 | succ_7 n_8781 => ((lte_8777) n_8780 n_8781)
      end
    end

#[program]
def lt_10 :=
  fun lt_8782 (x_8783) -> (y_8784) ->
    ((lte_9) (succ_7 x_8783) y_8784)

#[program]
def pred_11 :=
  fun pred_8785 (__8786) ->
    match __8786 with
    | zero_6  => zero_6 | succ_7 n_8787 => n_8787
    end

#[program]
def add_12 :=
  fun add_8788 (__8789) -> (__8790) ->
    match __8789 with
    | zero_6  => __8790
    | succ_7 n_8791 => (succ_7 ((add_8788) n_8791 __8790))
    end

#[program]
def sub_13 :=
  fun sub_8792 (__8793) -> (__8794) ->
    match __8794 with
    | zero_6  => __8793
    | succ_7 n_8795 => ((sub_8792) ((pred_11) __8793) n_8795)
    end

#[program]
def mul_14 :=
  fun mul_8796 (__8797) -> (__8798) ->
    match __8797 with
    | zero_6  => zero_6
    | succ_7 n_8799 => ((add_12) __8798 ((mul_8796) n_8799 __8798))
    end

#[program]
def div_15 :=
  fun div_8800 (x_8801) -> (y_8802) ->
    match ((lt_10) x_8801 y_8802) with
    | true_4  => zero_6
    | false_5  =>
      let loop_8803 :=
        fun loop_8804 (x_8805) -> (y_8806) ->
          match ((sub_13) x_8805 ((pred_11) y_8806)) with
          | zero_6  => zero_6
          | succ_7 n_8807 => (succ_7 ((loop_8804) n_8807 y_8806))
          end
      in ((loop_8803) x_8801 y_8802)
    end

#[program]
def rem_16 :=
  fun rem_8808 (x_8809) -> (y_8810) ->
    ((sub_13) x_8809 ((mul_14) ((div_15) x_8809 y_8810) y_8810))

#[program]
def pow_17 :=
  fun pow_8811 (__8812) -> (__8813) ->
    match __8813 with
    | zero_6  => (succ_7 zero_6)
    | succ_7 n_8814 => ((mul_14) __8812 ((pow_8811) __8812 n_8814))
    end

#[logical]
def loc_18 := NULL

#[logical]
inductive atU_27 where
| at_introU_34 of layout[R]

#[logical]
inductive atL_26 where
| at_introL_33 of layout[R]

#[program]
extern alloc_19

#[program]
extern getU_20

#[program]
extern getL_21

#[program]
extern setU_43

#[program]
extern setL_42

#[program]
extern free_23

#[logical]
def set_get_lawU_45 := NULL

#[logical]
def set_get_lawL_44 := NULL

#[program]
def main :=
  let* _8815 := ((alloc_19) tt_3) in
  match _8815 with
  | ex1UL_31 m_8816 n_8817 =>
    let pf_8818 := ((setU_43) NULL NULL m_8816 zero_6 n_8817) in
    let __8819 := ((free_23) NULL m_8816 pf_8818) in return tt_3
  end

-----------------------------------------

def rwlUU_29 := fun rwl_8930 () -> () -> () -> () -> () -> (__8931) -> __8931

def rwlUL_28 := fun rwl_8932 () -> () -> () -> () -> () -> (__8933) -> __8933

def rwlLU_27 := fun rwl_8934 () -> () -> () -> () -> () -> (__8935) -> __8935

def rwlLL_26 := fun rwl_8936 () -> () -> () -> () -> () -> (__8937) -> __8937

def rwrUU_33 := fun rwr_8938 () -> () -> () -> () -> () -> (__8939) -> __8939

def rwrUL_32 := fun rwr_8940 () -> () -> () -> () -> () -> (__8941) -> __8941

def rwrLU_31 := fun rwr_8942 () -> () -> () -> () -> () -> (__8943) -> __8943

def rwrLL_30 := fun rwr_8944 () -> () -> () -> () -> () -> (__8945) -> __8945

def not_5 :=
  fun not_8946 (__8947) ->
    match __8947 with
    | true_4 => false_5 | false_5 => true_4
    end

def and_6 :=
  fun and_8948 (__8949) -> (__8950) ->
    match __8949 with
    | true_4 => match __8950 with
                | true_4 => true_4 | false_5 => false_5
                end
    | false_5 => false_5
    end

def or_7 :=
  fun or_8951 (__8952) -> (__8953) ->
    match __8952 with
    | true_4 => true_4
    | false_5 =>
      match __8953 with
      | true_4 => true_4 | false_5 => false_5
      end
    end

def xor_8 :=
  fun xor_8954 (__8955) -> (__8956) -o
    match __8955 with
    | true_4 => match __8956 with
                | true_4 => false_5 | false_5 => true_4
                end
    | false_5 =>
      match __8956 with
      | true_4 => true_4 | false_5 => false_5
      end
    end

def lte_9 :=
  fun lte_8957 (__8958) -> (__8959) ->
    match __8958 with
    | zero_6  => true_4
    | succ_7 n_8960 =>
      match __8959 with
      | zero_6  => false_5 | succ_7 n_8961 => ((lte_8957) n_8960 n_8961)
      end
    end

def lt_10 :=
  fun lt_8962 (x_8963) -> (y_8964) -> ((lte_9) (succ_7 x_8963) y_8964)

def pred_11 :=
  fun pred_8965 (__8966) ->
    match __8966 with
    | zero_6  => (zero_6 ) | succ_7 n_8967 => n_8967
    end

def add_12 :=
  fun add_8968 (__8969) -> (__8970) ->
    match __8969 with
    | zero_6  => __8970
    | succ_7 n_8971 => (succ_7 ((add_8968) n_8971 __8970))
    end

def sub_13 :=
  fun sub_8972 (__8973) -> (__8974) ->
    match __8974 with
    | zero_6  => __8973
    | succ_7 n_8975 => ((sub_8972) ((pred_11) __8973) n_8975)
    end

def mul_14 :=
  fun mul_8976 (__8977) -> (__8978) ->
    match __8977 with
    | zero_6  => (zero_6 )
    | succ_7 n_8979 => ((add_12) __8978 ((mul_8976) n_8979 __8978))
    end

def div_15 :=
  fun div_8980 (x_8981) -> (y_8982) ->
    match ((lt_10) x_8981 y_8982) with
    | true_4 => (zero_6 )
    | false_5 =>
      let loop_8983 :=
        fun loop_8984 (x_8985) -> (y_8986) ->
          match ((sub_13) x_8985 ((pred_11) y_8986)) with
          | zero_6  => (zero_6 )
          | succ_7 n_8987 => (succ_7 ((loop_8984) n_8987 y_8986))
          end
        in
      ((loop_8983) x_8981 y_8982)
    end

def rem_16 :=
  fun rem_8988 (x_8989) -> (y_8990) ->
    ((sub_13) x_8989 ((mul_14) ((div_15) x_8989 y_8990) y_8990))

def pow_17 :=
  fun pow_8991 (__8992) -> (__8993) ->
    match __8993 with
    | zero_6  => (succ_7 (zero_6 ))
    | succ_7 n_8994 => ((mul_14) __8992 ((pow_8991) __8992 n_8994))
    end

def main :=
  lam () -o
    let _8995 := ((alloc_19) tt_3 ()) in
    match _8995 with
    | ex1UL_31 m_8996 n_8997 =>
      let pf_8998 := ((setU_43) () () m_8996 (zero_6 ) n_8997) in
      let __8999 := ((free_23) () m_8996 pf_8998) in lam () -o tt_3
    end

-----------------------------------------

