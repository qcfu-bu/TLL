[Definition {name = "loc"; relv = N;
   body = (Binder ([], ((Id ("nat", I)), (Type U)))); view = []};
  Inductive {name = "at"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("loc", I)),
                (Binder ("l",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("at_intro",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBase
                                    (App
                                       [(Id ("at", I)); (Id ("A", I));
                                         (Id ("l", I))]))
                                 ))
                              )),
                           [E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [E; E]};
  Notation {name = "@"; body = (App [(Id ("at", I)); (Hole 1); (Hole 2)])};
  Extern {name = "alloc"; relv = R;
    body =
    (Binder ([],
       (None,
        (Pi (R, U, (Id ("unit", I)),
           (Binder ("_",
              (IO
                 (App
                    [(Id ("exists1", I));
                      (Fun ((Pi (R, U, IMeta, (Binder ("l", IMeta)))),
                         (Binder (None,
                            [([(PId "l")],
                              (Some (BOpr ("@", (Id ("unit", I)),
                                       (Id ("l", I))))))
                              ]
                            )),
                         []))
                      ]))
              ))
           )))
       ));
    view = [E]};
  Extern {name = "getU"; relv = R;
    body =
    (Binder ([],
       ((Some (Fun (
                 (Pi (N, U, (Type U),
                    (Binder ("A",
                       (Pi (R, U, (Id ("loc", I)),
                          (Binder ("l",
                             (Pi (R, U,
                                (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                                (Binder ("pf",
                                   (App
                                      [(Id ("prod1", I)); (Id ("A", I));
                                        (BOpr ("@", (Id ("A", I)),
                                           (Id ("l", I))))
                                        ])
                                   ))
                                ))
                             ))
                          ))
                       ))
                    )),
                 (Binder ((Some "getU"),
                    [([(PId "A"); (PId "l"); (PId "pf")],
                      (Some (Let (R, (Id ("pf", I)),
                               (Binder ((PConstr ("at_intro", [(PId "v")])),
                                  (BOpr ("\226\159\168,\226\159\169",
                                     (Id ("v", I)), (Id ("pf", I))))
                                  ))
                               ))))
                      ]
                    )),
                 [I; E; E]))),
        (Pi (N, U, (Type U),
           (Binder ("A",
              (Pi (R, U, (Id ("loc", I)),
                 (Binder ("l",
                    (Pi (R, U, (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                       (Binder ("pf",
                          (App
                             [(Id ("prod1", I)); (Id ("A", I));
                               (BOpr ("@", (Id ("A", I)), (Id ("l", I))))])
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; E; E]};
  Extern {name = "getL"; relv = R;
    body =
    (Binder ([],
       ((Some (Fun (
                 (Pi (N, U, (Type L),
                    (Binder ("A",
                       (Pi (R, U, (Id ("loc", I)),
                          (Binder ("l",
                             (Pi (R, U,
                                (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                                (Binder ("pf",
                                   (App
                                      [(Id ("prod1", I)); (Id ("A", I));
                                        (BOpr ("@", (Id ("unit", I)),
                                           (Id ("l", I))))
                                        ])
                                   ))
                                ))
                             ))
                          ))
                       ))
                    )),
                 (Binder ((Some "getL"),
                    [([(PId "A"); (PId "l"); (PId "pf")],
                      (Some (Let (R, (Id ("pf", I)),
                               (Binder ((PConstr ("at_intro", [(PId "v")])),
                                  (BOpr ("\226\159\168,\226\159\169",
                                     (Id ("v", I)),
                                     (App
                                        [(Id ("at_intro", I)); (Id ("tt", I))
                                          ])
                                     ))
                                  ))
                               ))))
                      ]
                    )),
                 [I; E; E]))),
        (Pi (N, U, (Type L),
           (Binder ("A",
              (Pi (R, U, (Id ("loc", I)),
                 (Binder ("l",
                    (Pi (R, U, (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                       (Binder ("pf",
                          (App
                             [(Id ("prod1", I)); (Id ("A", I));
                               (BOpr ("@", (Id ("unit", I)), (Id ("l", I))))])
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; E; E]};
  Extern {name = "set"; relv = R;
    body =
    (Binder (["s"],
       ((Some (Fun (
                 (Pi (N, U, (Type U),
                    (Binder ("A",
                       (Pi (N, U, (Type (SId "s")),
                          (Binder ("B",
                             (Pi (R, U, (Id ("loc", I)),
                                (Binder ("l",
                                   (Pi (R, U, (Id ("B", I)),
                                      (Binder ("m",
                                         (Pi (R, U,
                                            (BOpr ("@", (Id ("A", I)),
                                               (Id ("l", I)))),
                                            (Binder ("pf",
                                               (BOpr ("@", (Id ("B", I)),
                                                  (Id ("l", I))))
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    )),
                 (Binder ((Some "set"),
                    [([(PId "A"); (PId "B"); (PId "l"); (PId "m"); (PId "pf")
                        ],
                      (Some (Let (R, (Id ("pf", I)),
                               (Binder ((PConstr ("at_intro", [(PId "_")])),
                                  (App [(Id ("at_intro", I)); (Id ("m", I))])
                                  ))
                               ))))
                      ]
                    )),
                 [I; I; E; E; E]))),
        (Pi (N, U, (Type U),
           (Binder ("A",
              (Pi (N, U, (Type (SId "s")),
                 (Binder ("B",
                    (Pi (R, U, (Id ("loc", I)),
                       (Binder ("l",
                          (Pi (R, U, (Id ("B", I)),
                             (Binder ("m",
                                (Pi (R, U,
                                   (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                                   (Binder ("pf",
                                      (BOpr ("@", (Id ("B", I)),
                                         (Id ("l", I))))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; E; E; E]};
  Extern {name = "free"; relv = R;
    body =
    (Binder ([],
       ((Some (Fun (
                 (Pi (N, U, (Type U),
                    (Binder ("A",
                       (Pi (R, U, (Id ("loc", I)),
                          (Binder ("l",
                             (Pi (R, U,
                                (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                                (Binder ("pf", (Id ("unit", I))))))
                             ))
                          ))
                       ))
                    )),
                 (Binder ((Some "free"),
                    [([(PId "A"); (PId "l"); (PId "pf")],
                      (Some (Let (R, (Id ("pf", I)),
                               (Binder ((PConstr ("at_intro", [(PId "_")])),
                                  (Id ("tt", I))))
                               ))))
                      ]
                    )),
                 [I; E; E]))),
        (Pi (N, U, (Type U),
           (Binder ("A",
              (Pi (R, U, (Id ("loc", I)),
                 (Binder ("l",
                    (Pi (R, U, (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                       (Binder ("pf", (Id ("unit", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; E; E]};
  Definition {name = "set_get_law"; relv = N;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (R, U, (Type U),
              (Binder ("A",
                 (Pi (R, U, (Id ("loc", I)),
                    (Binder ("l",
                       (Pi (R, U, (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                          (Binder ("pf",
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("v0",
                                   (Let (R,
                                      (App
                                         [(Id ("set", I)); (Id ("l", I));
                                           (Id ("v0", I)); (Id ("pf", I))]),
                                      (Binder ((PId "pf"),
                                         (Let (R,
                                            (App
                                               [(Id ("getU", I));
                                                 (Id ("l", I));
                                                 (Id ("pf", I))]),
                                            (Binder (
                                               (PBOpr (
                                                  "\226\159\168,\226\159\169",
                                                  (PId "v1"), (PId "pf"))),
                                               (BOpr ("=", (Id ("v0", I)),
                                                  (Id ("v1", I))))
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "set_get_law"),
              [([(PId "A"); (PId "l"); (PId "pf"); (PId "v0")],
                (Some (Match ([(R, (Id ("pf", I)), (Some ("pf0", IMeta)))],
                         (Some (Let (R,
                                  (App
                                     [(Id ("set", I)); (Id ("l", I));
                                       (Id ("v0", I)); (Id ("pf0", I))]),
                                  (Binder ((PId "pf0"),
                                     (Let (R,
                                        (App
                                           [(Id ("getU", I)); (Id ("l", I));
                                             (Id ("pf0", I))]),
                                        (Binder (
                                           (PBOpr (
                                              "\226\159\168,\226\159\169",
                                              (PId "v1"), (PId "pf0"))),
                                           (BOpr ("=", (Id ("v0", I)),
                                              (Id ("v1", I))))
                                           ))
                                        ))
                                     ))
                                  ))),
                         [([(PConstr ("at_intro", [(PId "v")]))],
                           (Some (Id ("refl", I))))]
                         ))))
                ]
              )),
           [I; E; E; E])),
        (Pi (R, U, (Type U),
           (Binder ("A",
              (Pi (R, U, (Id ("loc", I)),
                 (Binder ("l",
                    (Pi (R, U, (BOpr ("@", (Id ("A", I)), (Id ("l", I)))),
                       (Binder ("pf",
                          (Pi (R, U, (Id ("A", I)),
                             (Binder ("v0",
                                (Let (R,
                                   (App
                                      [(Id ("set", I)); (Id ("l", I));
                                        (Id ("v0", I)); (Id ("pf", I))]),
                                   (Binder ((PId "pf"),
                                      (Let (R,
                                         (App
                                            [(Id ("getU", I)); (Id ("l", I));
                                              (Id ("pf", I))]),
                                         (Binder (
                                            (PBOpr (
                                               "\226\159\168,\226\159\169",
                                               (PId "v1"), (PId "pf"))),
                                            (BOpr ("=", (Id ("v0", I)),
                                               (Id ("v1", I))))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; E; E; E]};
  Definition {name = "main"; relv = R;
    body =
    (Binder ([],
       ((MLet ((App [(Id ("alloc", I)); (Id ("tt", I))]),
           (Binder (
              (PBOpr ("\226\159\168,\226\159\169", (PId "l"), (PId "pf"))),
              (Let (R,
                 (App
                    [(Id ("set", I)); (Id ("l", I)); (Id ("zero", I));
                      (Id ("pf", I))]),
                 (Binder ((PId "pf"),
                    (Let (R,
                       (App [(Id ("free", I)); (Id ("l", I)); (Id ("pf", I))]),
                       (Binder ((PId "_"), (Return (Id ("tt", I)))))))
                    ))
                 ))
              ))
           )),
        (IO (Id ("unit", I))))
       ));
    view = []}
  ]

[parse success]

-----------------------------------------

#[logical]
def loc_33‹› : U := nat_5

#[logical]
inductive at_10‹s_501› (A_502 : Type‹s_501›) (l_503 : loc_33): 
L where
| at_intro_13 (m_504 : A_502) : (at_10‹??_54› A_502 l_503)

#[program]
extern alloc_34‹› :
  unit_9 ->
    IO (exists1_9‹??_56,??_57›
         ?_71[0;0]
         fun _506 : ?_69[0;0] -> ?_70[0;0]
         | l_508 => (at_10‹??_55› unit_9 l_508))

#[program]
extern getU_35‹› :
  ∀ {A_509 : U} ->
    ∀ (l_510 : loc_33) ->
      (at_10‹??_64› A_509 l_510) ->
        ((prod1_25‹??_66,??_67›) A_509 (at_10‹??_65› A_509 l_510))
:=
  fun getU_512 :
    ∀ {A_513 : U} ->
      ∀ (l_514 : loc_33) ->
        (at_10‹??_58› A_513 l_514) ->
          ((prod1_25‹??_60,??_61›) A_513 (at_10‹??_59› A_513 l_514))
  | A_516, l_517, pf_518 =>
    match pf_518 in ?_75[0;0] -o ?_74[0;0] with
    | (at_intro_13 v_520) =>
      (ex1_12‹??_62,??_63› ?_72[0;0] ?_73[0;0] v_520 pf_518)

#[program]
extern getL_36‹› :
  ∀ {A_521 : L} ->
    ∀ (l_522 : loc_33) ->
      (at_10‹??_76› A_521 l_522) ->
        ((prod1_25‹??_78,??_79›) A_521 (at_10‹??_77› unit_9 l_522))
:=
  fun getL_524 :
    ∀ {A_525 : L} ->
      ∀ (l_526 : loc_33) ->
        (at_10‹??_68› A_525 l_526) ->
          ((prod1_25‹??_70,??_71›) A_525 (at_10‹??_69› unit_9 l_526))
  | A_528, l_529, pf_530 =>
    match pf_530 in ?_81[0;0] -o ?_80[0;0] with
    | (at_intro_13 v_532) =>
      (ex1_12‹??_74,??_75›
        ?_78[0;0] ?_79[0;0] v_532
        (at_intro_13‹??_73› ?_76[0;0] ?_77[0;0] tt_3‹??_72›))

#[program]
extern set_37‹s_533› :
  ∀ {A_534 : U} ->
    ∀ {B_535 : Type‹s_533›} ->
      ∀ (l_536 : loc_33) ->
        B_535 ->
          (at_10‹??_83› A_534 l_536) -> (at_10‹??_84› B_535 l_536)
:=
  fun set_539 :
    ∀ {A_540 : U} ->
      ∀ {B_541 : Type‹s_533›} ->
        ∀ (l_542 : loc_33) ->
          B_541 ->
            (at_10‹??_80› A_540 l_542) -> (at_10‹??_81› B_541 l_542)
  | A_545, B_546, l_547, m_548, pf_549 =>
    match pf_549 in ?_85[0;0] -o ?_84[0;0] with
    | (at_intro_13 _551) =>
      (at_intro_13‹??_82› ?_82[0;0] ?_83[0;0] m_548)

#[program]
extern free_38‹› :
  ∀ {A_552 : U} ->
    ∀ (l_553 : loc_33) -> (at_10‹??_87› A_552 l_553) -> unit_9
:=
  fun free_555 :
    ∀ {A_556 : U} ->
      ∀ (l_557 : loc_33) -> (at_10‹??_85› A_556 l_557) -> unit_9
  | A_559, l_560, pf_561 =>
    match pf_561 in ?_87[0;0] -o ?_86[0;0] with
    | (at_intro_13 _563) => tt_3‹??_86›

#[logical]
def set_get_law_39‹s_564› :
  ∀ (A_565 : U) ->
    ∀ (l_566 : loc_33) ->
      ∀ (pf_567 : (at_10‹??_94› A_565 l_566)) ->
        ∀ (v0_568 : A_565) ->
          let pf_569 :=
            ((set_37‹??_95›) ?_104[0;0] ?_103[0;0] l_566 v0_568 pf_567)
          in
          match ((getU_35) ?_105[0;0] l_566 pf_569) in
            ?_108[0;0] -o ?_107[0;0]
          with
          | (ex1_12 v1_571 pf_572) =>
            (eq_1‹??_96› ?_106[0;0] v0_568 v1_571)
:=
  fun set_get_law_573 :
    ∀ (A_574 : U) ->
      ∀ (l_575 : loc_33) ->
        ∀ (pf_576 : (at_10‹??_88› A_574 l_575)) ->
          ∀ (v0_577 : A_574) ->
            let pf_578 :=
              ((set_37‹??_89›) ?_89[0;0] ?_88[0;0] l_575 v0_577 pf_576)
            in
            match ((getU_35) ?_90[0;0] l_575 pf_578) in
              ?_93[0;0] -o ?_92[0;0]
            with
            | (ex1_12 v1_580 pf_581) =>
              (eq_1‹??_90› ?_91[0;0] v0_577 v1_580)
  | A_582, l_583, pf_584, v0_585 =>
    match pf_584 in
      ∀ (pf0_586 : ?_94[0;0]) -o
        let pf0_587 :=
          ((set_37‹??_91›) ?_96[0;0] ?_95[0;0] l_583 v0_585 pf0_586)
        in
        match ((getU_35) ?_97[0;0] l_583 pf0_587) in ?_100[0;0] -o ?_99[0;0]
        with
        | (ex1_12 v1_589 pf0_590) =>
          (eq_1‹??_92› ?_98[0;0] v0_585 v1_589)
    with
    | (at_intro_13 v_591) => (refl_1‹??_93› ?_101[0;0] ?_102[0;0])

#[program]
def main_40‹› : IO unit_9 :=
  let* _592 := ((alloc_34) tt_3‹??_97›) in
  match _592 in ?_113[0;0] -o ?_112[0;0] with
  | (ex1_12 l_594 pf_595) =>
    let pf_596 :=
      ((set_37‹??_98›) ?_110[0;0] ?_109[0;0] l_594 zero_6 pf_595)
    in
    let __597 := ((free_38) ?_111[0;0] l_594 pf_596) in
    return tt_3‹??_99›

[trans01 success]

-----------------------------------------

#[program]
def id_1‹s_7808› : ∀ (A_7809 : Type‹s_7808›) -> A_7809 -> A_7809 :=
  fun id_7811 : ∀ (A_7812 : Type‹s_7808›) -> A_7812 -> A_7812
  | A_7814, m_7815 => m_7815

#[logical]
inductive eq_1‹s_7816› (A_7817 : Type‹s_7816›) (m_7818 : A_7817):
  A_7817 -> U
where
| refl_1 : (eq_1‹s_7816› A_7817 m_7818 m_7818)

#[program]
def rwl_2‹s_7820,r_7821› :
  ∀ {A_7822 : Type‹s_7820›} ->
    ∀ {m_7823 : A_7822} ->
      ∀ {n_7824 : A_7822} ->
        ∀ {B_7825 : A_7822 -> Type‹r_7821›} ->
          {(eq_1‹s_7820› A_7822 m_7823 n_7824)} ->
            ((B_7825) m_7823) -> ((B_7825) n_7824)
:=
  fun rwl_7829 :
    ∀ {A_7830 : Type‹s_7820›} ->
      ∀ {m_7831 : A_7830} ->
        ∀ {n_7832 : A_7830} ->
          ∀ {B_7833 : A_7830 -> Type‹r_7821›} ->
            {(eq_1‹s_7820› A_7830 m_7831 n_7832)} ->
              ((B_7833) m_7831) -> ((B_7833) n_7832)
  | A_7837, m_7838, n_7839, B_7840, refl_1, __7841 => __7841

#[program]
def rwr_3‹s_7842,r_7843› :
  ∀ {A_7844 : Type‹s_7842›} ->
    ∀ {m_7845 : A_7844} ->
      ∀ {n_7846 : A_7844} ->
        ∀ {B_7847 : A_7844 -> Type‹r_7843›} ->
          {(eq_1‹s_7842› A_7844 m_7845 n_7846)} ->
            ((B_7847) n_7846) -> ((B_7847) m_7845)
:=
  fun rwr_7851 :
    ∀ {A_7852 : Type‹s_7842›} ->
      ∀ {m_7853 : A_7852} ->
        ∀ {n_7854 : A_7852} ->
          ∀ {B_7855 : A_7852 -> Type‹r_7843›} ->
            {(eq_1‹s_7842› A_7852 m_7853 n_7854)} ->
              ((B_7855) n_7854) -> ((B_7855) m_7853)
  | A_7859, m_7860, n_7861, B_7862, refl_1, __7863 => __7863

#[logical]
def congr_4‹s_7864,r_7865,t_7866› :
  ∀ (A_7867 : Type‹s_7864›) ->
    ∀ (B_7868 : Type‹r_7865›) ->
      ∀ (m_7869 : A_7867) ->
        ∀ (n_7870 : A_7867) ->
          ∀ (f_7871 : forall‹t_7866›(__7872 : A_7867), B_7868) ->
            (eq_1‹s_7864› A_7867 m_7869 n_7870) ->
              (eq_1‹r_7865› B_7868 ((f_7871) m_7869) ((f_7871) n_7870))
:=
  fun congr_7874 :
    ∀ (A_7875 : Type‹s_7864›) ->
      ∀ (B_7876 : Type‹r_7865›) ->
        ∀ (m_7877 : A_7875) ->
          ∀ (n_7878 : A_7875) ->
            ∀ (f_7879 : forall‹t_7866›(__7880 : A_7875), B_7876) ->
              (eq_1‹s_7864› A_7875 m_7877 n_7878) ->
                (eq_1‹r_7865› B_7876 ((f_7879) m_7877) ((f_7879) n_7878))
  | A_7882, B_7883, m_7884, n_7885, f_7886, refl_1 =>
    (refl_1‹r_7865› B_7883 ((f_7886) n_7885))

#[logical]
def axiom_K_5‹› :
  ∀ {A_7887 : U} ->
    ∀ {m_7888 : A_7887} ->
      ∀ (x_7889 : (eq_1‹U› A_7887 m_7888 m_7888)) ->
        (eq_1‹U›
          (eq_1‹U› A_7887 m_7888 m_7888) x_7889
          (refl_1‹U› A_7887 m_7888))
:=
  fun axiom_K_7890 :
    ∀ {A_7891 : U} ->
      ∀ {m_7892 : A_7891} ->
        ∀ (x_7893 : (eq_1‹U› A_7891 m_7892 m_7892)) ->
          (eq_1‹U›
            (eq_1‹U› A_7891 m_7892 m_7892) x_7893
            (refl_1‹U› A_7891 m_7892))
  | A_7894, m_7895, refl_1 =>
    (refl_1‹U›
      (eq_1‹U› A_7894 m_7895 m_7895) (refl_1‹U› A_7894 m_7895))

#[program]
inductive sing_2‹s_7896,t_7897› (A_7898 : Type‹s_7896›):
  A_7898 -> Type‹t_7897›
where
| just_2 (m_7900 : A_7898) : (sing_2‹s_7896,t_7897› A_7898 m_7900)

#[logical]
def ssing_6‹s_7901› :
  ∀ (A_7902 : Type‹s_7901›) -> A_7902 -> Type‹s_7901›
:=
  fun ssing_7904 :
    ∀ (A_7905 : Type‹s_7901›) -> A_7905 -> Type‹s_7901›
  | A_7907, m_7908 => (sing_2‹s_7901,s_7901› A_7907 m_7908)

#[program]
def sing_elim_7‹s_7909,t_7910› :
  ∀ {A_7911 : Type‹s_7909›} ->
    ∀ {x_7912 : A_7911} ->
      (sing_2‹s_7909,t_7910› A_7911 x_7912) -> A_7911
:=
  fun sing_elim_7914 :
    ∀ {A_7915 : Type‹s_7909›} ->
      ∀ {x_7916 : A_7915} ->
        (sing_2‹s_7909,t_7910› A_7915 x_7916) -> A_7915
  | A_7918, x_7919, (just_2 m_7920) => m_7920

#[logical]
def sing_uniq_8‹s_7921,t_7922› :
  ∀ (A_7923 : Type‹s_7921›) ->
    ∀ (x0_7924 : A_7923) ->
      ∀ (x_7925 : (sing_2‹s_7921,t_7922› A_7923 x0_7924)) ->
        (eq_1‹s_7921›
          A_7923 x0_7924
          ((sing_elim_7‹s_7921,t_7922›) A_7923 x0_7924 x_7925))
:=
  fun sing_uniq_7926 :
    ∀ (A_7927 : Type‹s_7921›) ->
      ∀ (x0_7928 : A_7927) ->
        ∀ (x_7929 : (sing_2‹s_7921,t_7922› A_7927 x0_7928)) ->
          (eq_1‹s_7921›
            A_7927 x0_7928
            ((sing_elim_7‹s_7921,t_7922›) A_7927 x0_7928 x_7929))
  | A_7930, x0_7931, (just_2 m_7932) => (refl_1‹s_7921› A_7930 m_7932)

#[program]
inductive base_3‹s_7933› : Type‹s_7933› where
| tt_3 : base_3‹s_7933›

#[logical]
def unit_9‹› : U := base_3‹U›

#[logical]
def unit_eta_10‹› :
  ∀ (x_7934 : unit_9) -> (eq_1‹U› base_3‹U› x_7934 tt_3‹U›)
:=
  fun unit_eta_7935 :
    ∀ (x_7936 : unit_9) -> (eq_1‹U› base_3‹U› x_7936 tt_3‹U›)
  | x_7937 =>
    match x_7937 in
      ∀ (x0_7938 : base_3‹U›) -o
        (eq_1‹U› base_3‹U› x0_7938 tt_3‹U›)
    with
    | tt_3 => (refl_1‹U› base_3‹U› tt_3‹U›)

#[program]
inductive bool_4‹› : U where
| true_4 : bool_4
| false_5 : bool_4

#[program]
def not_11‹› : bool_4 -> bool_4 :=
  fun not_7940 : bool_4 -> bool_4
  | true_4 => false_5
  | false_5 => true_4

#[program]
def and_12‹› : bool_4 -> bool_4 -> bool_4 :=
  fun and_7944 : bool_4 -> bool_4 -> bool_4
  | true_4, true_4 => true_4
  | true_4, false_5 => false_5
  | false_5, __7947 => false_5

#[program]
def or_13‹› : bool_4 -> bool_4 -> bool_4 :=
  fun or_7950 : bool_4 -> bool_4 -> bool_4
  | true_4, __7953 => true_4
  | false_5, true_4 => true_4
  | false_5, false_5 => false_5

#[program]
def xor_14‹› : bool_4 -> bool_4 -> bool_4 :=
  fun xor_7956 : bool_4 -> bool_4 -> bool_4
  | true_4, true_4 => false_5
  | true_4, false_5 => true_4
  | false_5, true_4 => true_4
  | false_5, false_5 => false_5

#[program]
inductive nat_5‹› : U where
| zero_6 : nat_5
| succ_7 (n_7959 : nat_5) : nat_5

#[program]
def lte_15‹› : nat_5 -> nat_5 -> bool_4 :=
  fun lte_7962 : nat_5 -> nat_5 -> bool_4
  | zero_6, __7965 => true_4
  | (succ_7 n_7966), zero_6 => false_5
  | (succ_7 n_7967), (succ_7 n_7968) => ((lte_7962) n_7967 n_7968)

#[program]
def lt_16‹› : nat_5 -> nat_5 -> bool_4 :=
  fun lt_7971 : nat_5 -> nat_5 -> bool_4
  | x_7974, y_7975 => ((lte_15) (succ_7‹› x_7974) y_7975)

#[program]
def pred_17‹› : nat_5 -> nat_5 :=
  fun pred_7977 : nat_5 -> nat_5
  | zero_6 => zero_6
  | (succ_7 n_7979) => n_7979

#[program]
def add_18‹› : nat_5 -> nat_5 -> nat_5 :=
  fun add_7982 : nat_5 -> nat_5 -> nat_5
  | zero_6, __7985 => __7985
  | (succ_7 n_7986), __7987 => (succ_7‹› ((add_7982) n_7986 __7987))

#[program]
def sub_19‹› : nat_5 -> nat_5 -> nat_5 :=
  fun sub_7990 : nat_5 -> nat_5 -> nat_5
  | __7993, zero_6 => __7993
  | __7994, (succ_7 n_7995) => ((sub_7990) ((pred_17) __7994) n_7995)

#[program]
def mul_20‹› : nat_5 -> nat_5 -> nat_5 :=
  fun mul_7998 : nat_5 -> nat_5 -> nat_5
  | zero_6, __8001 => zero_6
  | (succ_7 n_8002), __8003 => ((add_18) __8003 ((mul_7998) n_8002 __8003))

#[program]
def div_21‹› : nat_5 -> nat_5 -> nat_5 :=
  fun div_8006 : nat_5 -> nat_5 -> nat_5
  | x_8009, y_8010 =>
    match ((lt_16) x_8009 y_8010) in bool_4 -o nat_5 with
    | true_4 => zero_6
    | false_5 =>
      let loop_8012 :=
        fun loop_8013 : nat_5 -> nat_5 -> nat_5
        | x_8016, y_8017 =>
          match ((sub_19) x_8016 ((pred_17) y_8017)) in nat_5 -o nat_5 with
          | zero_6 => zero_6
          | (succ_7 n_8019) => (succ_7‹› ((loop_8013) n_8019 y_8017))
      in ((loop_8012) x_8009 y_8010)

#[program]
def rem_22‹› : nat_5 -> nat_5 -> nat_5 :=
  fun rem_8022 : nat_5 -> nat_5 -> nat_5
  | x_8025, y_8026 =>
    ((sub_19) x_8025 ((mul_20) ((div_21) x_8025 y_8026) y_8026))

#[program]
inductive list_6‹s_8027,t_8028› (A_8029 : Type‹s_8027›):
  Type‹t_8028›
where
| nil_8 : (list_6‹s_8027,t_8028› A_8029)
| cons_9
    (hd_8030 : A_8029) (tl_8031 : (list_6‹s_8027,t_8028› A_8029))
    : (list_6‹s_8027,t_8028› A_8029)

#[program]
def free_list_23‹s_8032,t_8033› :
  ∀ {A_8034 : Type‹s_8032›} ->
    A_8034 -> unit_9 -> (list_6‹s_8032,t_8033› A_8034) -> unit_9
:=
  fun free_list_8038 :
    ∀ {A_8039 : Type‹s_8032›} ->
      A_8039 -> unit_9 -> (list_6‹s_8032,t_8033› A_8039) -> unit_9
  | A_8043, f_8044, nil_8 => tt_3‹U›
  | A_8045, f_8046, (cons_9 hd_8047 tl_8048) =>
    let __8049 := ((f_8046) hd_8047) in
    ((free_list_8038) A_8045 f_8046 tl_8048)

#[program]
inductive exists_7‹s_8050,r_8051› (A_8052 : Type‹s_8050›) (B_8053 : 
A_8052 -> Type‹r_8051›): L where
| ex_10
    (m_8055 : A_8052) {n_8056 : ((B_8053) m_8055)}
    : (exists_7‹s_8050,r_8051› A_8052 B_8053)

#[program]
inductive exists0_8‹s_8057,r_8058› (A_8059 : Type‹s_8057›) (B_8060 : 
A_8059 -> Type‹r_8058›): L where
| ex0_11
    {m_8062 : A_8059} (n_8063 : ((B_8060) m_8062))
    : (exists0_8‹s_8057,r_8058› A_8059 B_8060)

#[program]
inductive exists1_9‹s_8064,r_8065› (A_8066 : Type‹s_8064›) (B_8067 : 
A_8066 -> Type‹r_8065›): L where
| ex1_12
    (m_8069 : A_8066) (n_8070 : ((B_8067) m_8069))
    : (exists1_9‹s_8064,r_8065› A_8066 B_8067)

#[logical]
def prod0_24‹s_8071,r_8072› : Type‹s_8071› -> Type‹r_8072› -> L
:=
  fun prod0_8075 : Type‹s_8071› -> Type‹r_8072› -> L
  | A_8078, B_8079 =>
    (exists0_8‹s_8071,r_8072›
      A_8078 fun _8080 : A_8078 -> Type‹r_8072›
             | __8082 => B_8079)

#[logical]
def prod1_25‹s_8083,r_8084› : Type‹s_8083› -> Type‹r_8084› -> L
:=
  fun prod1_8087 : Type‹s_8083› -> Type‹r_8084› -> L
  | A_8090, B_8091 =>
    (exists1_9‹s_8083,r_8084›
      A_8090 fun _8092 : A_8090 -> Type‹r_8084›
             | __8094 => B_8091)

#[program]
def pow_26‹› : int -> int -> int :=
  fun pow_8097 : int -> int -> int
  | x_8100, y_8101 =>
    let loop_8102 :=
      fun loop_8103 : int -> int -> int
      | acc_8106, y_8107 =>
        match (__lte__ y_8107 0) in bool_4 -o int with
        | true_4 => acc_8106
        | false_5 =>
          ((loop_8103) (__mul__ x_8100 acc_8106) (__sub__ y_8107 1))
    in ((loop_8102) 1 y_8101)

#[program]
def powm_27‹› : int -> int -> int -> int :=
  fun powm_8112 : int -> int -> int -> int
  | x_8116, y_8117, m_8118 =>
    let loop_8119 :=
      fun loop_8120 : int -> int -> int
      | acc_8123, y_8124 =>
        match (__lte__ y_8124 0) in bool_4 -o int with
        | true_4 => acc_8123
        | false_5 =>
          ((loop_8120)
            (__mod__ (__mul__ x_8116 acc_8123) m_8118) (__sub__ y_8124 1))
    in ((loop_8119) 1 y_8117)

#[program]
def ord_28‹› : char -> int :=
  fun ord_8127 : char -> int
  | c_8129 => (__ord__ c_8129)

#[program]
def chr_29‹› : int -> char :=
  fun chr_8131 : int -> char
  | i_8133 => (__chr__ i_8133)

#[program]
def str_30‹› : char -> string :=
  fun str_8135 : char -> string
  | c_8137 => (__push__ "" c_8137)

#[program]
def strlen_31‹› : string -> int :=
  fun strlen_8139 : string -> int
  | s_8141 => (__size__ s_8141)

#[program]
def string_of_int_32‹› : int -> string :=
  fun string_of_int_8143 : int -> string
  | i_8145 =>
    let aux_8146 :=
      fun aux_8147 : int -> string
      | i_8149 =>
        match (__lte__ 10 i_8149) in bool_4 -o string with
        | true_4 =>
          let r_8151 := (__mod__ i_8149 10) in
          let i_8152 := (__div__ i_8149 10) in
          (__push__ ((aux_8147) i_8152)
            ((chr_29) (__add__ r_8151 ((ord_28) 0))))
        | false_5 => ((str_30) ((chr_29) (__add__ i_8149 ((ord_28) 0))))
    in
    match (__lte__ 0 i_8145) in bool_4 -o string with
    | true_4 => ((aux_8146) i_8145)
    | false_5 => (__cat__ "~" ((aux_8146) (__neg__ i_8145)))

#[logical]
def loc_33‹› : U := nat_5

#[logical]
inductive at_10‹s_8154› (A_8155 : Type‹s_8154›) (l_8156 : loc_33): 
L where
| at_intro_13 (m_8157 : A_8155) : (at_10‹s_8154› A_8155 l_8156)

#[program]
extern alloc_34‹› :
  unit_9 ->
    IO (exists1_9‹U,L›
         loc_33
         fun _8159 : loc_33 -> L
         | __8161 => (at_10‹U› unit_9 __8161))

#[program]
extern getU_35‹› :
  ∀ {A_8162 : U} ->
    ∀ (l_8163 : loc_33) ->
      (at_10‹U› A_8162 l_8163) ->
        ((prod1_25‹U,L›) A_8162 (at_10‹U› A_8162 l_8163))
:=
  fun getU_8165 :
    ∀ {A_8166 : U} ->
      ∀ (l_8167 : loc_33) ->
        (at_10‹U› A_8166 l_8167) ->
          ((prod1_25‹U,L›) A_8166 (at_10‹U› A_8166 l_8167))
  | A_8169, l_8170, pf_8171 =>
    match pf_8171 in
      (at_10‹U› A_8169 l_8170) -o
        ((prod1_25‹U,L›) A_8169 (at_10‹U› A_8169 l_8170))
    with
    | (at_intro_13 m_8173) =>
      (ex1_12‹U,L›
        A_8169
        fun _8174 : A_8169 -> L
        | __8176 => (at_10‹U› A_8169 l_8170) m_8173 pf_8171)

#[program]
extern getL_36‹› :
  ∀ {A_8177 : L} ->
    ∀ (l_8178 : loc_33) ->
      (at_10‹L› A_8177 l_8178) ->
        ((prod1_25‹L,L›) A_8177 (at_10‹U› unit_9 l_8178))
:=
  fun getL_8180 :
    ∀ {A_8181 : L} ->
      ∀ (l_8182 : loc_33) ->
        (at_10‹L› A_8181 l_8182) ->
          ((prod1_25‹L,L›) A_8181 (at_10‹U› unit_9 l_8182))
  | A_8184, l_8185, pf_8186 =>
    match pf_8186 in
      (at_10‹L› A_8184 l_8185) -o
        ((prod1_25‹L,L›) A_8184 (at_10‹U› unit_9 l_8185))
    with
    | (at_intro_13 m_8188) =>
      (ex1_12‹L,L›
        A_8184
        fun _8189 : A_8184 -> L
        | __8191 => (at_10‹U› unit_9 l_8185) m_8188
        (at_intro_13‹U› unit_9 l_8185 tt_3‹U›))

#[program]
extern set_37‹s_8192› :
  ∀ {A_8193 : U} ->
    ∀ {B_8194 : Type‹s_8192›} ->
      ∀ (l_8195 : loc_33) ->
        B_8194 ->
          (at_10‹U› A_8193 l_8195) -> (at_10‹s_8192› B_8194 l_8195)
:=
  fun set_8198 :
    ∀ {A_8199 : U} ->
      ∀ {B_8200 : Type‹s_8192›} ->
        ∀ (l_8201 : loc_33) ->
          B_8200 ->
            (at_10‹U› A_8199 l_8201) -> (at_10‹s_8192› B_8200 l_8201)
  | A_8204, B_8205, l_8206, m_8207, pf_8208 =>
    match pf_8208 in
      (at_10‹U› A_8204 l_8206) -o (at_10‹s_8192› B_8205 l_8206)
    with
    | (at_intro_13 m_8210) => (at_intro_13‹s_8192› B_8205 l_8206 m_8207)

#[program]
extern free_38‹› :
  ∀ {A_8211 : U} ->
    ∀ (l_8212 : loc_33) -> (at_10‹U› A_8211 l_8212) -> unit_9
:=
  fun free_8214 :
    ∀ {A_8215 : U} ->
      ∀ (l_8216 : loc_33) -> (at_10‹U› A_8215 l_8216) -> unit_9
  | A_8218, l_8219, pf_8220 =>
    match pf_8220 in (at_10‹U› A_8218 l_8219) -o unit_9 with
    | (at_intro_13 m_8222) => tt_3‹U›

#[logical]
def set_get_law_39‹s_8223› :
  ∀ (A_8224 : U) ->
    ∀ (l_8225 : loc_33) ->
      ∀ (pf_8226 : (at_10‹U› A_8224 l_8225)) ->
        ∀ (v0_8227 : A_8224) ->
          let pf_8228 :=
            ((set_37‹U›) A_8224 A_8224 l_8225 v0_8227 pf_8226)
          in
          match ((getU_35) A_8224 l_8225 pf_8228) in
            ((prod1_25‹U,L›) A_8224 (at_10‹U› A_8224 l_8225)) -o U
          with
          | (ex1_12 m_8230 n_8231) => (eq_1‹U› A_8224 v0_8227 m_8230)
:=
  fun set_get_law_8232 :
    ∀ (A_8233 : U) ->
      ∀ (l_8234 : loc_33) ->
        ∀ (pf_8235 : (at_10‹U› A_8233 l_8234)) ->
          ∀ (v0_8236 : A_8233) ->
            let pf_8237 :=
              ((set_37‹U›) A_8233 A_8233 l_8234 v0_8236 pf_8235)
            in
            match ((getU_35) A_8233 l_8234 pf_8237) in
              ((prod1_25‹U,L›) A_8233 (at_10‹U› A_8233 l_8234)) -o U
            with
            | (ex1_12 m_8239 n_8240) => (eq_1‹U› A_8233 v0_8236 m_8239)
  | A_8241, l_8242, pf_8243, v0_8244 =>
    match pf_8243 in
      ∀ (pf0_8245 : (at_10‹U› A_8241 l_8242)) -o
        let pf0_8246 :=
          ((set_37‹U›) A_8241 A_8241 l_8242 v0_8244 pf0_8245)
        in
        match ((getU_35) A_8241 l_8242 pf0_8246) in
          ((prod1_25‹U,L›) A_8241 (at_10‹U› A_8241 l_8242)) -o U
        with
        | (ex1_12 m_8248 n_8249) => (eq_1‹U› A_8241 v0_8244 m_8248)
    with
    | (at_intro_13 m_8250) => (refl_1‹U› A_8241 v0_8244)

#[program]
def main_40‹› : IO unit_9 :=
  let* _8251 := ((alloc_34) tt_3‹U›) in
  match _8251 in
    (exists1_9‹U,L›
      loc_33 fun _8253 : loc_33 -> L
             | __8255 => (at_10‹U› unit_9 __8255)) -o
      IO base_3‹U›
  with
  | (ex1_12 m_8256 n_8257) =>
    let pf_8258 := ((set_37‹U›) unit_9 nat_5 m_8256 zero_6 n_8257) in
    let __8259 := ((free_38) nat_5 m_8256 pf_8258) in return tt_3‹U›

[trans1e success]

-----------------------------------------

#[program]
def idU_42 := fun id_12480 (A_12481) -> (m_12482) ->
                m_12482

#[program]
def idL_41 := fun id_12483 (A_12484) -> (m_12485) ->
                m_12485

#[logical]
inductive eqU_12 where
| reflU_15 of layout[]

#[logical]
inductive eqL_11 where
| reflL_14 of layout[]

#[program]
def rwlUU_46 :=
  fun rwl_12486 {A_12487} -> {m_12488} -> {n_12489} -> {B_12490} ->
  {__12491} -> (__12492) ->
    match {NULL} with
    | reflU_15  => __12492
    end

#[program]
def rwlUL_45 :=
  fun rwl_12493 {A_12494} -> {m_12495} -> {n_12496} -> {B_12497} ->
  {__12498} -> (__12499) ->
    match {NULL} with
    | reflU_15  => __12499
    end

#[program]
def rwlLU_44 :=
  fun rwl_12500 {A_12501} -> {m_12502} -> {n_12503} -> {B_12504} ->
  {__12505} -> (__12506) ->
    match {NULL} with
    | reflL_14  => __12506
    end

#[program]
def rwlLL_43 :=
  fun rwl_12507 {A_12508} -> {m_12509} -> {n_12510} -> {B_12511} ->
  {__12512} -> (__12513) ->
    match {NULL} with
    | reflL_14  => __12513
    end

#[program]
def rwrUU_50 :=
  fun rwr_12514 {A_12515} -> {m_12516} -> {n_12517} -> {B_12518} ->
  {__12519} -> (__12520) ->
    match {NULL} with
    | reflU_15  => __12520
    end

#[program]
def rwrUL_49 :=
  fun rwr_12521 {A_12522} -> {m_12523} -> {n_12524} -> {B_12525} ->
  {__12526} -> (__12527) ->
    match {NULL} with
    | reflU_15  => __12527
    end

#[program]
def rwrLU_48 :=
  fun rwr_12528 {A_12529} -> {m_12530} -> {n_12531} -> {B_12532} ->
  {__12533} -> (__12534) ->
    match {NULL} with
    | reflL_14  => __12534
    end

#[program]
def rwrLL_47 :=
  fun rwr_12535 {A_12536} -> {m_12537} -> {n_12538} -> {B_12539} ->
  {__12540} -> (__12541) ->
    match {NULL} with
    | reflL_14  => __12541
    end

#[logical]
def congrUUU_58 := NULL

#[logical]
def congrUUL_57 := NULL

#[logical]
def congrULU_56 := NULL

#[logical]
def congrULL_55 := NULL

#[logical]
def congrLUU_54 := NULL

#[logical]
def congrLUL_53 := NULL

#[logical]
def congrLLU_52 := NULL

#[logical]
def congrLLL_51 := NULL

#[logical]
def axiom_K_5 := NULL

#[program]
inductive singUU_16 where
| justUU_19 of layout[R]

#[program]
inductive singUL_15 where
| justUL_18 of layout[R]

#[program]
inductive singLU_14 where


#[program]
inductive singLL_13 where
| justLL_16 of layout[R]

#[logical]
def ssingU_60 := NULL

#[logical]
def ssingL_59 := NULL

#[program]
def sing_elimUU_64 :=
  fun sing_elim_12542 {A_12543} -> {x_12544} -> (__12545) ->
    match __12545 with
    | justUU_19 m_12546 => m_12546
    end

#[program]
def sing_elimUL_63 :=
  fun sing_elim_12547 {A_12548} -> {x_12549} -> (__12550) ->
    match __12550 with
    | justUL_18 m_12551 => m_12551
    end

#[program]
def sing_elimLU_62 :=
  fun sing_elim_12552 {A_12553} -> {x_12554} -> (__12555) ->
    match __12555 with
    
    end

#[program]
def sing_elimLL_61 :=
  fun sing_elim_12556 {A_12557} -> {x_12558} -> (__12559) ->
    match __12559 with
    | justLL_16 m_12560 => m_12560
    end

#[logical]
def sing_uniqUU_68 := NULL

#[logical]
def sing_uniqUL_67 := NULL

#[logical]
def sing_uniqLU_66 := NULL

#[logical]
def sing_uniqLL_65 := NULL

#[program]
inductive baseU_18 where
| ttU_21 of layout[]

#[program]
inductive baseL_17 where
| ttL_20 of layout[]

#[logical]
def unit_9 := NULL

#[logical]
def unit_eta_10 := NULL

#[program]
inductive bool_4 where
| true_4 of layout[]
| false_5 of layout[]

#[program]
def not_11 :=
  fun not_12561 (__12562) ->
    match __12562 with
    | true_4  => false_5 | false_5  => true_4
    end

#[program]
def and_12 :=
  fun and_12563 (__12564) -> (__12565) ->
    match __12564 with
    | true_4  =>
      match __12565 with
      | true_4  => true_4 | false_5  => false_5
      end
    | false_5  => false_5
    end

#[program]
def or_13 :=
  fun or_12566 (__12567) -> (__12568) ->
    match __12567 with
    | true_4  => true_4
    | false_5  =>
      match __12568 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def xor_14 :=
  fun xor_12569 (__12570) -> (__12571) ->
    match __12570 with
    | true_4  =>
      match __12571 with
      | true_4  => false_5 | false_5  => true_4
      end
    | false_5  =>
      match __12571 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
inductive nat_5 where
| zero_6 of layout[]
| succ_7 of layout[R]

#[program]
def lte_15 :=
  fun lte_12572 (__12573) -> (__12574) ->
    match __12573 with
    | zero_6  => true_4
    | succ_7 n_12575 =>
      match __12574 with
      | zero_6  => false_5 | succ_7 n_12576 => ((lte_12572) n_12575 n_12576)
      end
    end

#[program]
def lt_16 :=
  fun lt_12577 (x_12578) -> (y_12579) ->
    ((lte_15) (succ_7 x_12578) y_12579)

#[program]
def pred_17 :=
  fun pred_12580 (__12581) ->
    match __12581 with
    | zero_6  => zero_6 | succ_7 n_12582 => n_12582
    end

#[program]
def add_18 :=
  fun add_12583 (__12584) -> (__12585) ->
    match __12584 with
    | zero_6  => __12585
    | succ_7 n_12586 => (succ_7 ((add_12583) n_12586 __12585))
    end

#[program]
def sub_19 :=
  fun sub_12587 (__12588) -> (__12589) ->
    match __12589 with
    | zero_6  => __12588
    | succ_7 n_12590 => ((sub_12587) ((pred_17) __12588) n_12590)
    end

#[program]
def mul_20 :=
  fun mul_12591 (__12592) -> (__12593) ->
    match __12592 with
    | zero_6  => zero_6
    | succ_7 n_12594 => ((add_18) __12593 ((mul_12591) n_12594 __12593))
    end

#[program]
def div_21 :=
  fun div_12595 (x_12596) -> (y_12597) ->
    match ((lt_16) x_12596 y_12597) with
    | true_4  => zero_6
    | false_5  =>
      let loop_12598 :=
        fun loop_12599 (x_12600) -> (y_12601) ->
          match ((sub_19) x_12600 ((pred_17) y_12601)) with
          | zero_6  => zero_6
          | succ_7 n_12602 => (succ_7 ((loop_12599) n_12602 y_12601))
          end
      in ((loop_12598) x_12596 y_12597)
    end

#[program]
def rem_22 :=
  fun rem_12603 (x_12604) -> (y_12605) ->
    ((sub_19) x_12604 ((mul_20) ((div_21) x_12604 y_12605) y_12605))

#[program]
inductive listUU_22 where
| nilUU_28 of layout[]
| consUU_29 of layout[R, R]

#[program]
inductive listUL_21 where
| nilUL_26 of layout[]
| consUL_27 of layout[R, R]

#[program]
inductive listLU_20 where
| nilLU_24 of layout[]

#[program]
inductive listLL_19 where
| nilLL_22 of layout[]
| consLL_23 of layout[R, R]

#[program]
def free_listUU_72 :=
  fun free_list_12606 {A_12607} -> (f_12608) -> (__12609) ->
    match __12609 with
    | nilUU_28  => ttU_21
    | consUU_29 hd_12610 tl_12611 =>
      let __12612 := ((f_12608) hd_12610) in
      ((free_list_12606) NULL f_12608 tl_12611)
    end

#[program]
def free_listUL_71 :=
  fun free_list_12613 {A_12614} -> (f_12615) -> (__12616) ->
    match __12616 with
    | nilUL_26  => ttU_21
    | consUL_27 hd_12617 tl_12618 =>
      let __12619 := ((f_12615) hd_12617) in
      ((free_list_12613) NULL f_12615 tl_12618)
    end

#[program]
def free_listLL_69 :=
  fun free_list_12620 {A_12621} -> (f_12622) -> (__12623) ->
    match __12623 with
    | nilLL_22  => ttU_21
    | consLL_23 hd_12624 tl_12625 =>
      let __12626 := ((f_12622) hd_12624) in
      ((free_list_12620) NULL f_12622 tl_12625)
    end

#[program]
inductive existsUU_26 where
| exUU_33 of layout[R, N]

#[program]
inductive existsUL_25 where
| exUL_32 of layout[R, N]

#[program]
inductive existsLU_24 where
| exLU_31 of layout[R, N]

#[program]
inductive existsLL_23 where
| exLL_30 of layout[R, N]

#[program]
inductive exists0UU_30 where
| ex0UU_37 of layout[N, R]

#[program]
inductive exists0UL_29 where
| ex0UL_36 of layout[N, R]

#[program]
inductive exists0LU_28 where
| ex0LU_35 of layout[N, R]

#[program]
inductive exists0LL_27 where
| ex0LL_34 of layout[N, R]

#[program]
inductive exists1UU_34 where
| ex1UU_41 of layout[R, R]

#[program]
inductive exists1UL_33 where
| ex1UL_40 of layout[R, R]

#[program]
inductive exists1LU_32 where
| ex1LU_39 of layout[R, R]

#[program]
inductive exists1LL_31 where
| ex1LL_38 of layout[R, R]

#[logical]
def prod0UU_76 := NULL

#[logical]
def prod0UL_75 := NULL

#[logical]
def prod0LU_74 := NULL

#[logical]
def prod0LL_73 := NULL

#[logical]
def prod1UU_80 := NULL

#[logical]
def prod1UL_79 := NULL

#[logical]
def prod1LU_78 := NULL

#[logical]
def prod1LL_77 := NULL

#[program]
def pow_26 :=
  fun pow_12627 (x_12628) -> (y_12629) ->
    let loop_12630 :=
      fun loop_12631 (acc_12632) -> (y_12633) ->
        match (__lte__ y_12633 0) with
        | true_4  => acc_12632
        | false_5  =>
          ((loop_12631) (__mul__ x_12628 acc_12632) (__sub__ y_12633 1))
        end
    in ((loop_12630) 1 y_12629)

#[program]
def powm_27 :=
  fun powm_12634 (x_12635) -> (y_12636) -> (m_12637) ->
    let loop_12638 :=
      fun loop_12639 (acc_12640) -> (y_12641) ->
        match (__lte__ y_12641 0) with
        | true_4  => acc_12640
        | false_5  =>
          ((loop_12639)
            (__mod__ (__mul__ x_12635 acc_12640) m_12637) (__sub__ y_12641 1))
        end
    in ((loop_12638) 1 y_12636)

#[program]
def ord_28 := fun ord_12642 (c_12643) ->
                (__ord__ c_12643)

#[program]
def chr_29 := fun chr_12644 (i_12645) ->
                (__chr__ i_12645)

#[program]
def str_30 := fun str_12646 (c_12647) ->
                (__push__ "" c_12647)

#[program]
def strlen_31 := fun strlen_12648 (s_12649) ->
                   (__size__ s_12649)

#[program]
def string_of_int_32 :=
  fun string_of_int_12650 (i_12651) ->
    let aux_12652 :=
      fun aux_12653 (i_12654) ->
        match (__lte__ 10 i_12654) with
        | true_4  =>
          let r_12655 := (__mod__ i_12654 10) in
          let i_12656 := (__div__ i_12654 10) in
          (__push__ ((aux_12653) i_12656)
            ((chr_29) (__add__ r_12655 ((ord_28) 0))))
        | false_5  => ((str_30) ((chr_29) (__add__ i_12654 ((ord_28) 0))))
        end
    in
    match (__lte__ 0 i_12651) with
    | true_4  => ((aux_12652) i_12651)
    | false_5  => (__cat__ "~" ((aux_12652) (__neg__ i_12651)))
    end

#[logical]
def loc_33 := NULL

#[logical]
inductive atU_36 where
| at_introU_43 of layout[R]

#[logical]
inductive atL_35 where
| at_introL_42 of layout[R]

#[program]
extern alloc_34

#[program]
extern getU_35

#[program]
extern getL_36

#[program]
extern setU_82

#[program]
extern setL_81

#[program]
extern free_38

#[logical]
def set_get_lawU_84 := NULL

#[logical]
def set_get_lawL_83 := NULL

#[program]
def main :=
  let* _12657 := ((alloc_34) ttU_21) in
  match _12657 with
  | ex1UL_40 m_12658 n_12659 =>
    let pf_12660 := ((setU_82) NULL NULL m_12658 zero_6 n_12659) in
    let __12661 := ((free_38) NULL m_12658 pf_12660) in return ttU_21
  end

[trans12 success]

-----------------------------------------

#[program]
def idU_42 := fun id_12844 (A_12845) -> (m_12846) ->
                m_12846

#[program]
def idL_41 := fun id_12847 (A_12848) -> (m_12849) ->
                m_12849

#[logical]
inductive eqU_12 where
| reflU_15 of layout[]

#[logical]
inductive eqL_11 where
| reflL_14 of layout[]

#[program]
def rwlUU_46 :=
  fun rwl_12850 {A_12851} -> {m_12852} -> {n_12853} -> {B_12854} ->
  {__12855} -> (__12856) ->
    __12856

#[program]
def rwlUL_45 :=
  fun rwl_12857 {A_12858} -> {m_12859} -> {n_12860} -> {B_12861} ->
  {__12862} -> (__12863) ->
    __12863

#[program]
def rwlLU_44 :=
  fun rwl_12864 {A_12865} -> {m_12866} -> {n_12867} -> {B_12868} ->
  {__12869} -> (__12870) ->
    __12870

#[program]
def rwlLL_43 :=
  fun rwl_12871 {A_12872} -> {m_12873} -> {n_12874} -> {B_12875} ->
  {__12876} -> (__12877) ->
    __12877

#[program]
def rwrUU_50 :=
  fun rwr_12878 {A_12879} -> {m_12880} -> {n_12881} -> {B_12882} ->
  {__12883} -> (__12884) ->
    __12884

#[program]
def rwrUL_49 :=
  fun rwr_12885 {A_12886} -> {m_12887} -> {n_12888} -> {B_12889} ->
  {__12890} -> (__12891) ->
    __12891

#[program]
def rwrLU_48 :=
  fun rwr_12892 {A_12893} -> {m_12894} -> {n_12895} -> {B_12896} ->
  {__12897} -> (__12898) ->
    __12898

#[program]
def rwrLL_47 :=
  fun rwr_12899 {A_12900} -> {m_12901} -> {n_12902} -> {B_12903} ->
  {__12904} -> (__12905) ->
    __12905

#[logical]
def congrUUU_58 := NULL

#[logical]
def congrUUL_57 := NULL

#[logical]
def congrULU_56 := NULL

#[logical]
def congrULL_55 := NULL

#[logical]
def congrLUU_54 := NULL

#[logical]
def congrLUL_53 := NULL

#[logical]
def congrLLU_52 := NULL

#[logical]
def congrLLL_51 := NULL

#[logical]
def axiom_K_5 := NULL

#[program]
inductive singUU_16 where
| justUU_19 of layout[R]

#[program]
inductive singUL_15 where
| justUL_18 of layout[R]

#[program]
inductive singLU_14 where


#[program]
inductive singLL_13 where
| justLL_16 of layout[R]

#[logical]
def ssingU_60 := NULL

#[logical]
def ssingL_59 := NULL

#[program]
def sing_elimUU_64 :=
  fun sing_elim_12906 {A_12907} -> {x_12908} -> (__12909) ->
    match __12909 with
    | justUU_19 m_12910 => m_12910
    end

#[program]
def sing_elimUL_63 :=
  fun sing_elim_12911 {A_12912} -> {x_12913} -> (__12914) ->
    match __12914 with
    | justUL_18 m_12915 => m_12915
    end

#[program]
def sing_elimLU_62 :=
  fun sing_elim_12916 {A_12917} -> {x_12918} -> (__12919) ->
    !!

#[program]
def sing_elimLL_61 :=
  fun sing_elim_12920 {A_12921} -> {x_12922} -> (__12923) ->
    match __12923 with
    | justLL_16 m_12924 => m_12924
    end

#[logical]
def sing_uniqUU_68 := NULL

#[logical]
def sing_uniqUL_67 := NULL

#[logical]
def sing_uniqLU_66 := NULL

#[logical]
def sing_uniqLL_65 := NULL

#[program]
inductive baseU_18 where
| ttU_21 of layout[]

#[program]
inductive baseL_17 where
| ttL_20 of layout[]

#[logical]
def unit_9 := NULL

#[logical]
def unit_eta_10 := NULL

#[program]
inductive bool_4 where
| true_4 of layout[]
| false_5 of layout[]

#[program]
def not_11 :=
  fun not_12925 (__12926) ->
    match __12926 with
    | true_4  => false_5 | false_5  => true_4
    end

#[program]
def and_12 :=
  fun and_12927 (__12928) -> (__12929) ->
    match __12928 with
    | true_4  =>
      match __12929 with
      | true_4  => true_4 | false_5  => false_5
      end
    | false_5  => false_5
    end

#[program]
def or_13 :=
  fun or_12930 (__12931) -> (__12932) ->
    match __12931 with
    | true_4  => true_4
    | false_5  =>
      match __12932 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def xor_14 :=
  fun xor_12933 (__12934) -> (__12935) ->
    match __12934 with
    | true_4  =>
      match __12935 with
      | true_4  => false_5 | false_5  => true_4
      end
    | false_5  =>
      match __12935 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
inductive nat_5 where
| zero_6 of layout[]
| succ_7 of layout[R]

#[program]
def lte_15 :=
  fun lte_12936 (__12937) -> (__12938) ->
    match __12937 with
    | zero_6  => true_4
    | succ_7 n_12939 =>
      match __12938 with
      | zero_6  => false_5 | succ_7 n_12940 => ((lte_12936) n_12939 n_12940)
      end
    end

#[program]
def lt_16 :=
  fun lt_12941 (x_12942) -> (y_12943) ->
    ((lte_15) (succ_7 x_12942) y_12943)

#[program]
def pred_17 :=
  fun pred_12944 (__12945) ->
    match __12945 with
    | zero_6  => zero_6 | succ_7 n_12946 => n_12946
    end

#[program]
def add_18 :=
  fun add_12947 (__12948) -> (__12949) ->
    match __12948 with
    | zero_6  => __12949
    | succ_7 n_12950 => (succ_7 ((add_12947) n_12950 __12949))
    end

#[program]
def sub_19 :=
  fun sub_12951 (__12952) -> (__12953) ->
    match __12953 with
    | zero_6  => __12952
    | succ_7 n_12954 => ((sub_12951) ((pred_17) __12952) n_12954)
    end

#[program]
def mul_20 :=
  fun mul_12955 (__12956) -> (__12957) ->
    match __12956 with
    | zero_6  => zero_6
    | succ_7 n_12958 => ((add_18) __12957 ((mul_12955) n_12958 __12957))
    end

#[program]
def div_21 :=
  fun div_12959 (x_12960) -> (y_12961) ->
    match ((lt_16) x_12960 y_12961) with
    | true_4  => zero_6
    | false_5  =>
      let loop_12962 :=
        fun loop_12963 (x_12964) -> (y_12965) ->
          match ((sub_19) x_12964 ((pred_17) y_12965)) with
          | zero_6  => zero_6
          | succ_7 n_12966 => (succ_7 ((loop_12963) n_12966 y_12965))
          end
      in ((loop_12962) x_12960 y_12961)
    end

#[program]
def rem_22 :=
  fun rem_12967 (x_12968) -> (y_12969) ->
    ((sub_19) x_12968 ((mul_20) ((div_21) x_12968 y_12969) y_12969))

#[program]
inductive listUU_22 where
| nilUU_28 of layout[]
| consUU_29 of layout[R, R]

#[program]
inductive listUL_21 where
| nilUL_26 of layout[]
| consUL_27 of layout[R, R]

#[program]
inductive listLU_20 where
| nilLU_24 of layout[]

#[program]
inductive listLL_19 where
| nilLL_22 of layout[]
| consLL_23 of layout[R, R]

#[program]
def free_listUU_72 :=
  fun free_list_12970 {A_12971} -> (f_12972) -> (__12973) ->
    match __12973 with
    | nilUU_28  => ttU_21
    | consUU_29 hd_12974 tl_12975 =>
      let __12976 := ((f_12972) hd_12974) in
      ((free_list_12970) NULL f_12972 tl_12975)
    end

#[program]
def free_listUL_71 :=
  fun free_list_12977 {A_12978} -> (f_12979) -> (__12980) ->
    match __12980 with
    | nilUL_26  => ttU_21
    | consUL_27 hd_12981 tl_12982 =>
      let __12983 := ((f_12979) hd_12981) in
      ((free_list_12977) NULL f_12979 tl_12982)
    end

#[program]
def free_listLL_69 :=
  fun free_list_12984 {A_12985} -> (f_12986) -> (__12987) ->
    match __12987 with
    | nilLL_22  => ttU_21
    | consLL_23 hd_12988 tl_12989 =>
      let __12990 := ((f_12986) hd_12988) in
      ((free_list_12984) NULL f_12986 tl_12989)
    end

#[program]
inductive existsUU_26 where
| exUU_33 of layout[R, N]

#[program]
inductive existsUL_25 where
| exUL_32 of layout[R, N]

#[program]
inductive existsLU_24 where
| exLU_31 of layout[R, N]

#[program]
inductive existsLL_23 where
| exLL_30 of layout[R, N]

#[program]
inductive exists0UU_30 where
| ex0UU_37 of layout[N, R]

#[program]
inductive exists0UL_29 where
| ex0UL_36 of layout[N, R]

#[program]
inductive exists0LU_28 where
| ex0LU_35 of layout[N, R]

#[program]
inductive exists0LL_27 where
| ex0LL_34 of layout[N, R]

#[program]
inductive exists1UU_34 where
| ex1UU_41 of layout[R, R]

#[program]
inductive exists1UL_33 where
| ex1UL_40 of layout[R, R]

#[program]
inductive exists1LU_32 where
| ex1LU_39 of layout[R, R]

#[program]
inductive exists1LL_31 where
| ex1LL_38 of layout[R, R]

#[logical]
def prod0UU_76 := NULL

#[logical]
def prod0UL_75 := NULL

#[logical]
def prod0LU_74 := NULL

#[logical]
def prod0LL_73 := NULL

#[logical]
def prod1UU_80 := NULL

#[logical]
def prod1UL_79 := NULL

#[logical]
def prod1LU_78 := NULL

#[logical]
def prod1LL_77 := NULL

#[program]
def pow_26 :=
  fun pow_12991 (x_12992) -> (y_12993) ->
    let loop_12994 :=
      fun loop_12995 (acc_12996) -> (y_12997) ->
        match (__lte__ y_12997 0) with
        | true_4  => acc_12996
        | false_5  =>
          ((loop_12995) (__mul__ x_12992 acc_12996) (__sub__ y_12997 1))
        end
    in ((loop_12994) 1 y_12993)

#[program]
def powm_27 :=
  fun powm_12998 (x_12999) -> (y_13000) -> (m_13001) ->
    let loop_13002 :=
      fun loop_13003 (acc_13004) -> (y_13005) ->
        match (__lte__ y_13005 0) with
        | true_4  => acc_13004
        | false_5  =>
          ((loop_13003)
            (__mod__ (__mul__ x_12999 acc_13004) m_13001) (__sub__ y_13005 1))
        end
    in ((loop_13002) 1 y_13000)

#[program]
def ord_28 := fun ord_13006 (c_13007) ->
                (__ord__ c_13007)

#[program]
def chr_29 := fun chr_13008 (i_13009) ->
                (__chr__ i_13009)

#[program]
def str_30 := fun str_13010 (c_13011) ->
                (__push__ "" c_13011)

#[program]
def strlen_31 := fun strlen_13012 (s_13013) ->
                   (__size__ s_13013)

#[program]
def string_of_int_32 :=
  fun string_of_int_13014 (i_13015) ->
    let aux_13016 :=
      fun aux_13017 (i_13018) ->
        match (__lte__ 10 i_13018) with
        | true_4  =>
          let r_13019 := (__mod__ i_13018 10) in
          let i_13020 := (__div__ i_13018 10) in
          (__push__ ((aux_13017) i_13020)
            ((chr_29) (__add__ r_13019 ((ord_28) 0))))
        | false_5  => ((str_30) ((chr_29) (__add__ i_13018 ((ord_28) 0))))
        end
    in
    match (__lte__ 0 i_13015) with
    | true_4  => ((aux_13016) i_13015)
    | false_5  => (__cat__ "~" ((aux_13016) (__neg__ i_13015)))
    end

#[logical]
def loc_33 := NULL

#[logical]
inductive atU_36 where
| at_introU_43 of layout[R]

#[logical]
inductive atL_35 where
| at_introL_42 of layout[R]

#[program]
extern alloc_34

#[program]
extern getU_35

#[program]
extern getL_36

#[program]
extern setU_82

#[program]
extern setL_81

#[program]
extern free_38

#[logical]
def set_get_lawU_84 := NULL

#[logical]
def set_get_lawL_83 := NULL

#[program]
def main :=
  let* _13021 := ((alloc_34) ttU_21) in
  match _13021 with
  | ex1UL_40 m_13022 n_13023 =>
    let pf_13024 := ((setU_82) NULL NULL m_13022 zero_6 n_13023) in
    let __13025 := ((free_38) NULL m_13022 pf_13024) in return ttU_21
  end

[trans2e success]

-----------------------------------------

def idU_42 := fun id_13208 (A_13209) -> (m_13210) -> m_13210

def idL_41 := fun id_13211 (A_13212) -> (m_13213) -> m_13213

def rwlUU_46 :=
  fun rwl_13214 (A_13215) -> (m_13216) -> (n_13217) -> (B_13218) ->
  (__13219) -> (__13220) -> __13220

def rwlUL_45 :=
  fun rwl_13221 (A_13222) -> (m_13223) -> (n_13224) -> (B_13225) ->
  (__13226) -> (__13227) -> __13227

def rwlLU_44 :=
  fun rwl_13228 (A_13229) -> (m_13230) -> (n_13231) -> (B_13232) ->
  (__13233) -> (__13234) -> __13234

def rwlLL_43 :=
  fun rwl_13235 (A_13236) -> (m_13237) -> (n_13238) -> (B_13239) ->
  (__13240) -> (__13241) -> __13241

def rwrUU_50 :=
  fun rwr_13242 (A_13243) -> (m_13244) -> (n_13245) -> (B_13246) ->
  (__13247) -> (__13248) -> __13248

def rwrUL_49 :=
  fun rwr_13249 (A_13250) -> (m_13251) -> (n_13252) -> (B_13253) ->
  (__13254) -> (__13255) -> __13255

def rwrLU_48 :=
  fun rwr_13256 (A_13257) -> (m_13258) -> (n_13259) -> (B_13260) ->
  (__13261) -> (__13262) -> __13262

def rwrLL_47 :=
  fun rwr_13263 (A_13264) -> (m_13265) -> (n_13266) -> (B_13267) ->
  (__13268) -> (__13269) -> __13269

def sing_elimUU_64 :=
  fun sing_elim_13270 (A_13271) -> (x_13272) -> (__13273) -> __13273

def sing_elimUL_63 :=
  fun sing_elim_13274 (A_13275) -> (x_13276) -> (__13277) -> __13277

def sing_elimLU_62 :=
  fun sing_elim_13278 (A_13279) -> (x_13280) -> (__13281) -> !!

def sing_elimLL_61 :=
  fun sing_elim_13282 (A_13283) -> (x_13284) -> (__13285) -> __13285

def not_11 :=
  fun not_13286 (__13287) ->
    match __13287 with
    | true_4 => false_5 | false_5 => true_4
    end

def and_12 :=
  fun and_13288 (__13289) -> (__13290) ->
    match __13289 with
    | true_4 =>
      match __13290 with
      | true_4 => true_4 | false_5 => false_5
      end
    | false_5 => false_5
    end

def or_13 :=
  fun or_13291 (__13292) -> (__13293) ->
    match __13292 with
    | true_4 => true_4
    | false_5 =>
      match __13293 with
      | true_4 => true_4 | false_5 => false_5
      end
    end

def xor_14 :=
  fun xor_13294 (__13295) -> (__13296) ->
    match __13295 with
    | true_4 =>
      match __13296 with
      | true_4 => false_5 | false_5 => true_4
      end
    | false_5 =>
      match __13296 with
      | true_4 => true_4 | false_5 => false_5
      end
    end

def lte_15 :=
  fun lte_13297 (__13298) -> (__13299) ->
    match __13298 with
    | zero_6  => true_4
    | succ_7 n_13300 =>
      match __13299 with
      | zero_6  => false_5 | succ_7 n_13301 => ((lte_13297) n_13300 n_13301)
      end
    end

def lt_16 :=
  fun lt_13302 (x_13303) -> (y_13304) -> ((lte_15) (succ_7 x_13303) y_13304)

def pred_17 :=
  fun pred_13305 (__13306) ->
    match __13306 with
    | zero_6  => (zero_6 ) | succ_7 n_13307 => n_13307
    end

def add_18 :=
  fun add_13308 (__13309) -> (__13310) ->
    match __13309 with
    | zero_6  => __13310
    | succ_7 n_13311 => (succ_7 ((add_13308) n_13311 __13310))
    end

def sub_19 :=
  fun sub_13312 (__13313) -> (__13314) ->
    match __13314 with
    | zero_6  => __13313
    | succ_7 n_13315 => ((sub_13312) ((pred_17) __13313) n_13315)
    end

def mul_20 :=
  fun mul_13316 (__13317) -> (__13318) ->
    match __13317 with
    | zero_6  => (zero_6 )
    | succ_7 n_13319 => ((add_18) __13318 ((mul_13316) n_13319 __13318))
    end

def div_21 :=
  fun div_13320 (x_13321) -> (y_13322) ->
    match ((lt_16) x_13321 y_13322) with
    | true_4 => (zero_6 )
    | false_5 =>
      let loop_13323 :=
        fun loop_13324 (x_13325) -> (y_13326) ->
          match ((sub_19) x_13325 ((pred_17) y_13326)) with
          | zero_6  => (zero_6 )
          | succ_7 n_13327 => (succ_7 ((loop_13324) n_13327 y_13326))
          end
      in ((loop_13323) x_13321 y_13322)
    end

def rem_22 :=
  fun rem_13328 (x_13329) -> (y_13330) ->
    ((sub_19) x_13329 ((mul_20) ((div_21) x_13329 y_13330) y_13330))

def free_listUU_72 :=
  fun free_list_13331 (A_13332) -> (f_13333) -> (__13334) ->
    match __13334 with
    | nilUU_28  => ttU_21
    | consUU_29 hd_13335 tl_13336 =>
      let __13337 := ((f_13333) hd_13335) in
      ((free_list_13331) NULL f_13333 tl_13336)
    end

def free_listUL_71 :=
  fun free_list_13338 (A_13339) -> (f_13340) -> (__13341) ->
    match __13341 with
    | nilUL_26  => ttU_21
    | consUL_27 hd_13342 tl_13343 =>
      let __13344 := ((f_13340) hd_13342) in
      ((free_list_13338) NULL f_13340 tl_13343)
    end

def free_listLL_69 :=
  fun free_list_13345 (A_13346) -> (f_13347) -> (__13348) ->
    match __13348 with
    | nilLL_22  => ttU_21
    | consLL_23 hd_13349 tl_13350 =>
      let __13351 := ((f_13347) hd_13349) in
      ((free_list_13345) NULL f_13347 tl_13350)
    end

def pow_26 :=
  fun pow_13352 (x_13353) -> (y_13354) ->
    let loop_13355 :=
      fun loop_13356 (acc_13357) -> (y_13358) ->
        match (__lte__ y_13358 0) with
        | true_4 => acc_13357
        | false_5 =>
          ((loop_13356) (__mul__ x_13353 acc_13357) (__sub__ y_13358 1))
        end
    in ((loop_13355) 1 y_13354)

def powm_27 :=
  fun powm_13359 (x_13360) -> (y_13361) -> (m_13362) ->
    let loop_13363 :=
      fun loop_13364 (acc_13365) -> (y_13366) ->
        match (__lte__ y_13366 0) with
        | true_4 => acc_13365
        | false_5 =>
          ((loop_13364)
            (__mod__ (__mul__ x_13360 acc_13365) m_13362) (__sub__ y_13366 1))
        end
    in ((loop_13363) 1 y_13361)

def ord_28 := fun ord_13367 (c_13368) -> (__ord__ c_13368)

def chr_29 := fun chr_13369 (i_13370) -> (__chr__ i_13370)

def str_30 := fun str_13371 (c_13372) -> (__push__ "" c_13372)

def strlen_31 := fun strlen_13373 (s_13374) -> (__size__ s_13374)

def string_of_int_32 :=
  fun string_of_int_13375 (i_13376) ->
    let aux_13377 :=
      fun aux_13378 (i_13379) ->
        match (__lte__ 10 i_13379) with
        | true_4 =>
          let r_13380 := (__mod__ i_13379 10) in
          let i_13381 := (__div__ i_13379 10) in
          (__push__ ((aux_13378) i_13381)
            ((chr_29) (__add__ r_13380 ((ord_28) 0))))
        | false_5 => ((str_30) ((chr_29) (__add__ i_13379 ((ord_28) 0))))
        end
    in
    match (__lte__ 0 i_13376) with
    | true_4 => ((aux_13377) i_13376)
    | false_5 => (__cat__ "~" ((aux_13377) (__neg__ i_13376)))
    end

def main :=
  lazy(let _13382 := force(((alloc_34) ttU_21)) in
       force(match _13382 with
             | ex1UL_40 m_13383 n_13384 =>
               let pf_13385 :=
                 ((setU_82) NULL NULL m_13383 (zero_6 ) n_13384)
               in
               let __13386 := ((free_38) NULL m_13383 pf_13385) in
               lazy(ttU_21)
             end))

[trans23 success]

-----------------------------------------

def idU_42 := lam (A_13573) -> (m_13574) -> m_13574

def idL_41 := lam (A_13575) -> (m_13576) -> m_13576

def rwlUU_46 :=
  lam (A_13577) -> (m_13578) -> (n_13579) -> (B_13580) -> (__13581) ->
  (__13582) -> __13582

def rwlUL_45 :=
  lam (A_13583) -> (m_13584) -> (n_13585) -> (B_13586) -> (__13587) ->
  (__13588) -> __13588

def rwlLU_44 :=
  lam (A_13589) -> (m_13590) -> (n_13591) -> (B_13592) -> (__13593) ->
  (__13594) -> __13594

def rwlLL_43 :=
  lam (A_13595) -> (m_13596) -> (n_13597) -> (B_13598) -> (__13599) ->
  (__13600) -> __13600

def rwrUU_50 :=
  lam (A_13601) -> (m_13602) -> (n_13603) -> (B_13604) -> (__13605) ->
  (__13606) -> __13606

def rwrUL_49 :=
  lam (A_13607) -> (m_13608) -> (n_13609) -> (B_13610) -> (__13611) ->
  (__13612) -> __13612

def rwrLU_48 :=
  lam (A_13613) -> (m_13614) -> (n_13615) -> (B_13616) -> (__13617) ->
  (__13618) -> __13618

def rwrLL_47 :=
  lam (A_13619) -> (m_13620) -> (n_13621) -> (B_13622) -> (__13623) ->
  (__13624) -> __13624

def sing_elimUU_64 := lam (A_13625) -> (x_13626) -> (__13627) -> __13627

def sing_elimUL_63 := lam (A_13628) -> (x_13629) -> (__13630) -> __13630

def sing_elimLU_62 := lam (A_13631) -> (x_13632) -> (__13633) -> !!

def sing_elimLL_61 := lam (A_13634) -> (x_13635) -> (__13636) -> __13636

def not_11 :=
  lam (__13637) ->
    match __13637 with
    | true_4 => false_5 | false_5 => true_4
    end

def and_12 :=
  lam (__13638) -> (__13639) ->
    match __13638 with
    | true_4 =>
      match __13639 with
      | true_4 => true_4 | false_5 => false_5
      end
    | false_5 => false_5
    end

def or_13 :=
  lam (__13640) -> (__13641) ->
    match __13640 with
    | true_4 => true_4
    | false_5 =>
      match __13641 with
      | true_4 => true_4 | false_5 => false_5
      end
    end

def xor_14 :=
  lam (__13642) -> (__13643) ->
    match __13642 with
    | true_4 =>
      match __13643 with
      | true_4 => false_5 | false_5 => true_4
      end
    | false_5 =>
      match __13643 with
      | true_4 => true_4 | false_5 => false_5
      end
    end

def lte_15 :=
  fun lte_13644 (__13645) -> (__13646) ->
    match __13645 with
    | zero_6  => true_4
    | succ_7 n_13647 =>
      match __13646 with
      | zero_6  => false_5 | succ_7 n_13648 => ((lte_13644) n_13647 n_13648)
      end
    end

def lt_16 :=
  lam (x_13649) -> (y_13650) -> ((lte_15) (succ_7 x_13649) y_13650)

def pred_17 :=
  lam (__13651) ->
    match __13651 with
    | zero_6  => (zero_6 ) | succ_7 n_13652 => n_13652
    end

def add_18 :=
  fun add_13653 (__13654) -> (__13655) ->
    match __13654 with
    | zero_6  => __13655
    | succ_7 n_13656 => (succ_7 ((add_13653) n_13656 __13655))
    end

def sub_19 :=
  fun sub_13657 (__13658) -> (__13659) ->
    match __13659 with
    | zero_6  => __13658
    | succ_7 n_13660 => ((sub_13657) ((pred_17) __13658) n_13660)
    end

def mul_20 :=
  fun mul_13661 (__13662) -> (__13663) ->
    match __13662 with
    | zero_6  => (zero_6 )
    | succ_7 n_13664 => ((add_18) __13663 ((mul_13661) n_13664 __13663))
    end

def div_21 :=
  lam (x_13665) -> (y_13666) ->
    match ((lt_16) x_13665 y_13666) with
    | true_4 => (zero_6 )
    | false_5 =>
      let loop_13667 :=
        fun loop_13668 (x_13669) -> (y_13670) ->
          match ((sub_19) x_13669 ((pred_17) y_13670)) with
          | zero_6  => (zero_6 )
          | succ_7 n_13671 => (succ_7 ((loop_13668) n_13671 y_13670))
          end
      in ((loop_13667) x_13665 y_13666)
    end

def rem_22 :=
  lam (x_13672) -> (y_13673) ->
    ((sub_19) x_13672 ((mul_20) ((div_21) x_13672 y_13673) y_13673))

def free_listUU_72 :=
  fun free_list_13674 (A_13675) -> (f_13676) -> (__13677) ->
    match __13677 with
    | nilUU_28  => ttU_21
    | consUU_29 hd_13678 tl_13679 =>
      let __13680 := ((f_13676) hd_13678) in
      ((free_list_13674) NULL f_13676 tl_13679)
    end

def free_listUL_71 :=
  fun free_list_13681 (A_13682) -> (f_13683) -> (__13684) ->
    match __13684 with
    | nilUL_26  => ttU_21
    | consUL_27 hd_13685 tl_13686 =>
      let __13687 := ((f_13683) hd_13685) in
      ((free_list_13681) NULL f_13683 tl_13686)
    end

def free_listLL_69 :=
  fun free_list_13688 (A_13689) -> (f_13690) -> (__13691) ->
    match __13691 with
    | nilLL_22  => ttU_21
    | consLL_23 hd_13692 tl_13693 =>
      let __13694 := ((f_13690) hd_13692) in
      ((free_list_13688) NULL f_13690 tl_13693)
    end

def pow_26 :=
  lam (x_13695) -> (y_13696) ->
    let loop_13697 :=
      fun loop_13698 (acc_13699) -> (y_13700) ->
        match (__lte__ y_13700 0) with
        | true_4 => acc_13699
        | false_5 =>
          ((loop_13698) (__mul__ x_13695 acc_13699) (__sub__ y_13700 1))
        end
    in ((loop_13697) 1 y_13696)

def powm_27 :=
  lam (x_13701) -> (y_13702) -> (m_13703) ->
    let loop_13704 :=
      fun loop_13705 (acc_13706) -> (y_13707) ->
        match (__lte__ y_13707 0) with
        | true_4 => acc_13706
        | false_5 =>
          ((loop_13705)
            (__mod__ (__mul__ x_13701 acc_13706) m_13703) (__sub__ y_13707 1))
        end
    in ((loop_13704) 1 y_13702)

def ord_28 := lam (c_13708) -> (__ord__ c_13708)

def chr_29 := lam (i_13709) -> (__chr__ i_13709)

def str_30 := lam (c_13710) -> (__push__ "" c_13710)

def strlen_31 := lam (s_13711) -> (__size__ s_13711)

def string_of_int_32 :=
  lam (i_13712) ->
    let aux_13713 :=
      fun aux_13714 (i_13715) ->
        match (__lte__ 10 i_13715) with
        | true_4 =>
          let r_13716 := (__mod__ i_13715 10) in
          let i_13717 := (__div__ i_13715 10) in
          (__push__ ((aux_13714) i_13717)
            ((chr_29) (__add__ r_13716 ((ord_28) 0))))
        | false_5 => ((str_30) ((chr_29) (__add__ i_13715 ((ord_28) 0))))
        end
    in
    match (__lte__ 0 i_13712) with
    | true_4 => ((aux_13713) i_13712)
    | false_5 => (__cat__ "~" ((aux_13713) (__neg__ i_13712)))
    end

def main :=
  lazy(let _13718 := force(((alloc_34) ttU_21)) in
       match _13718 with
       | ex1UL_40 m_13719 n_13720 =>
         let pf_13721 := ((setU_82) NULL NULL m_13719 (zero_6 ) n_13720) in
         let __13722 := ((free_38) NULL m_13719 pf_13721) in ttU_21
       end)

[trans3e success]

-----------------------------------------

