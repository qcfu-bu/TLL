[Notation {name = "|>"; body = (App [(Hole 2); (Hole 1)])};
  Notation {name = "@@"; body = (App [(Hole 1); (Hole 2)])};
  Notation {name = "="; body = (App [(Id ("eq", I)); (Hole 1); (Hole 2)])};
  Notation {name = "`"; body = (App [(Id ("sing", I)); (Hole 1)])};
  Notation {name = "&&"; body = (Id ("and", I))};
  Notation {name = "||"; body = (Id ("or", I))};
  Notation {name = "+"; body = (App [(Id ("add", I)); (Hole 1); (Hole 2)])};
  Notation {name = "-"; body = (App [(Id ("sub", I)); (Hole 1); (Hole 2)])};
  Notation {name = "*"; body = (App [(Id ("mul", I)); (Hole 1); (Hole 2)])};
  Notation {name = "/"; body = (App [(Id ("div", I)); (Hole 1); (Hole 2)])};
  Notation {name = "%"; body = (App [(Id ("rem", I)); (Hole 1); (Hole 2)])};
  Notation {name = "^"; body = (App [(Id ("pow", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<"; body = (App [(Id ("lt", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">"; body = (App [(Id ("gt", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<="; body = (App [(Id ("lte", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">="; body = (App [(Id ("gte", I)); (Hole 1); (Hole 2)])};
  Notation {name = "**"; body = (App [(Id ("prod1", I)); (Hole 1); (Hole 2)])};
  Notation {name = "::"; body = (App [(Id ("cons", I)); (Hole 1); (Hole 2)])};
  Notation {name = "\226\159\168,\226\159\169";
    body = (App [(Id ("pair", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase (BOpr ("=", (Id ("m", I)), (Id ("m", I))))),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "boxed"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type L)),
                 [(DConstr ("box",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m",
                           (TBase (App [(Id ("boxed", I)); (Id ("A", I))]))))
                        )),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "t"))))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m", (TBase (UOpr ("`", (Id ("m", I))))))))),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "unit"; relv = R;
    body =
    (Binder (["s"],
       (PBase
          ((TBase (Type (SId "s"))),
           [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
       ));
    view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "choice"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type L)),
           [(DConstr ("next", (TBase (Id ("choice", I))), []));
             (DConstr ("free", (TBase (Id ("choice", I))), []))]))
       ));
    view = []};
  Inductive {name = "prod"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Type (SId "r")),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("pair",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R, (Id ("B", I)),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("prod", I));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [E; E]};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("_", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Definition {name = "sing_elim"; relv = R;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("x",
                       (Pi (R, U,
                          (App
                             [(Inst ("sing", [(SId "s"); (SId "t")], I));
                               (Id ("x", I))]),
                          (Binder ("_", (Id ("A", I))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_elim"),
              [([(PId "A"); (PId "x"); (PConstr ("just", [(PId "x")]))],
                (Some (Id ("x", I))))]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("x",
                    (Pi (R, U,
                       (App
                          [(Inst ("sing", [(SId "s"); (SId "t")], I));
                            (Id ("x", I))]),
                       (Binder ("_", (Id ("A", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "sing_uniq"; relv = N;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (R, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (Id ("A", I)),
                    (Binder ("x0",
                       (Pi (R, U,
                          (App
                             [(Inst ("sing", [(SId "s"); (SId "t")], I));
                               (Id ("x0", I))]),
                          (Binder ("x",
                             (BOpr ("=", (Id ("x0", I)),
                                (App [(Id ("sing_elim", I)); (Id ("x", I))])
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_uniq"),
              [([(PId "A"); (PId "x0"); (PConstr ("just", [(PId "_")]))],
                (Some (Id ("refl", I))))]
              )),
           [I; I])),
        (Pi (R, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (R, U, (Id ("A", I)),
                 (Binder ("x0",
                    (Pi (R, U,
                       (App
                          [(Inst ("sing", [(SId "s"); (SId "t")], I));
                            (Id ("x0", I))]),
                       (Binder ("x",
                          (BOpr ("=", (Id ("x0", I)),
                             (App [(Id ("sing_elim", I)); (Id ("x", I))])))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Inductive {name = "stream_node"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type L)),
                 [(DConstr ("stream_cons",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("hd",
                           (TBind (R,
                              (Pi (R, L, (Id ("choice", I)),
                                 (Binder ("x",
                                    (Match ([(R, (Id ("x", I)), None)], None,
                                       [([(PId "next")],
                                         (Some (App
                                                  [(Id ("stream_node", I));
                                                    (Id ("A", I))])));
                                         ([(PId "free")],
                                          (Some (Id ("unit", I))))
                                         ]
                                       ))
                                    ))
                                 )),
                              (Binder ("tl",
                                 (TBase
                                    (App
                                       [(Id ("stream_node", I));
                                         (Id ("A", I))]))
                                 ))
                              ))
                           ))
                        )),
                     [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Definition {name = "stream"; relv = N;
    body =
    (Binder (["s"],
       ((Fun ((Pi (R, U, (Type (SId "s")), (Binder ("A", IMeta)))),
           (Binder ((Some "stream"),
              [([(PId "A")],
                (Some (Pi (R, L, (Id ("choice", I)),
                         (Binder ("x",
                            (Match ([(R, (Id ("x", I)), None)], None,
                               [([(PId "next")],
                                 (Some (App
                                          [(Id ("stream_node", I));
                                            (Id ("A", I))])));
                                 ([(PId "free")], (Some (Id ("unit", I))))]
                               ))
                            ))
                         ))))
                ]
              )),
           [E])),
        (Pi (R, U, (Type (SId "s")), (Binder ("A", IMeta)))))
       ));
    view = [E]};
  Definition {name = "free_stream"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (App [(Id ("stream", I)); (Id ("A", I))]),
                    (Binder ("st", (Inst ("unit", [U], I))))))
                 ))
              )),
           (Binder ((Some "free_stream"),
              [([(PId "A"); (PId "st")],
                (Some (Match (
                         [(R, (App [(Id ("st", I)); (Id ("free", I))]), None)
                           ],
                         None, [([(PId "tt")], (Some (Id ("tt", I))))]))))
                ]
              )),
           [I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (R, U, (App [(Id ("stream", I)); (Id ("A", I))]),
                 (Binder ("st", (Inst ("unit", [U], I))))))
              ))
           )))
       ));
    view = [I; E]};
  Definition {name = "uncons_stream"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (App [(Id ("stream", I)); (Id ("A", I))]),
                    (Binder ("st",
                       (App
                          [(Inst ("prod", [(SId "_"); (SId "_"); L], I));
                            (Id ("A", I));
                            (App [(Id ("stream", I)); (Id ("A", I))])])
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "uncons_stream"),
              [([(PId "A"); (PId "st")],
                (Some (Let (R, (App [(Id ("st", I)); (Id ("next", I))]),
                         (Binder (
                            (PConstr ("stream_cons", [(PId "hd"); (PId "tl")]
                               )),
                            (BOpr ("\226\159\168,\226\159\169",
                               (Id ("hd", I)), (Id ("tl", I))))
                            ))
                         ))))
                ]
              )),
           [I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (R, U, (App [(Id ("stream", I)); (Id ("A", I))]),
                 (Binder ("st",
                    (App
                       [(Inst ("prod", [(SId "_"); (SId "_"); L], I));
                         (Id ("A", I));
                         (App [(Id ("stream", I)); (Id ("A", I))])])
                    ))
                 ))
              ))
           )))
       ));
    view = [I; E]};
  Definition {name = "nat_make"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("n", (App [(Id ("stream", I)); (Id ("nat", I))]))))),
           (Binder ((Some "nat_make"),
              [([(PId "n"); (PId "next")],
                (Some (App
                         [(Id ("stream_cons", I)); (Id ("n", I));
                           (App
                              [(Id ("nat_make", I));
                                (App [(Id ("succ", I)); (Id ("n", I))])])
                           ])));
                ([(PId "n"); (PId "free")], (Some (Id ("tt", I))))]
              )),
           [E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("n", (App [(Id ("stream", I)); (Id ("nat", I))]))))))
       ));
    view = [E]};
  Inductive {name = "apair"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("apair_intro",
                           (TBind (N, (Id ("A", I)),
                              (Binder ("x",
                                 (TBind (R,
                                    (Pi (R, (SId "t"), (Id ("bool", I)),
                                       (Binder ("b",
                                          (Match ([(R, (Id ("b", I)), None)],
                                             None,
                                             [([(PId "true")],
                                               (Some (App
                                                        [(Inst ("sing",
                                                            [(SId "_"); L], I
                                                            ));
                                                          (Id ("x", I))])));
                                               ([(PId "false")],
                                                (Some (App
                                                         [(Id ("boxed", I));
                                                           (App
                                                              [(Id ("B", I));
                                                                (Id ("x", I))
                                                                ])
                                                           ])))
                                               ]
                                             ))
                                          ))
                                       )),
                                    (Binder ("select",
                                       (TBase
                                          (App
                                             [(Id ("apair", I));
                                               (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [I; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Notation {name = "(,)";
    body =
    (App
       [(Id ("apair_intro", I));
         (Fun (IMeta,
            (Binder (None,
               [([(PId "true")], (Some (App [(Id ("just", I)); (Hole 1)])));
                 ([(PId "false")], (Some (App [(Id ("box", I)); (Hole 2)])))]
               )),
            []))
         ])};
  Definition {name = "proj1"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U,
                    (Pi (R, U, (Id ("A", I)),
                       (Binder ("_", (Type (SId "r")))))),
                    (Binder ("B",
                       (Pi (R, U,
                          (App
                             [(Inst ("apair",
                                 [(SId "s"); (SId "r"); (SId "t")], E));
                               (Id ("A", I)); (Id ("B", I))]),
                          (Binder ("_", (Id ("A", I))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "proj1"),
              [([(PId "A"); (PId "B");
                  (PConstr ("apair_intro", [(PId "_"); (PId "select")]))],
                (Some (App
                         [(Id ("sing_elim", I));
                           (App [(Id ("select", I)); (Id ("true", I))])])))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U,
                 (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                 (Binder ("B",
                    (Pi (R, U,
                       (App
                          [(Inst ("apair", [(SId "s"); (SId "r"); (SId "t")],
                              E));
                            (Id ("A", I)); (Id ("B", I))]),
                       (Binder ("_", (Id ("A", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "proj2"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U,
                    (Pi (R, U, (Id ("A", I)),
                       (Binder ("_", (Type (SId "r")))))),
                    (Binder ("B",
                       (Pi (R, U,
                          (App
                             [(Inst ("apair",
                                 [(SId "s"); (SId "r"); (SId "t")], E));
                               (Id ("A", I)); (Id ("B", I))]),
                          (Binder ("x",
                             (App
                                [(Id ("B", I));
                                  (App [(Id ("proj1", I)); (Id ("x", I))])])
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "proj2"),
              [([(PId "A"); (PId "B");
                  (PConstr ("apair_intro", [(PId "x"); (PId "select")]))],
                (Some (Match (
                         [(N, (Id ("x", I)), (Some ("x0", IMeta)));
                           (N, (App [(Id ("select", I)); (Id ("true", I))]),
                            (Some ("a0", (UOpr ("`", (Id ("x", I)))))));
                           (N,
                            (App
                               [(Id ("sing_uniq", I));
                                 (App [(Id ("select", I)); (Id ("true", I))])
                                 ]),
                            (Some ("_",
                                   (BOpr ("=", (Id ("x0", I)),
                                      (App
                                         [(Id ("sing_elim", I));
                                           (Id ("a0", I))])
                                      )))));
                           (R, (App [(Id ("select", I)); (Id ("false", I))]),
                            (Some ("_",
                                   (App
                                      [(Id ("boxed", I));
                                        (App [(Id ("B", I)); (Id ("x0", I))])
                                        ]))))
                           ],
                         (Some (App
                                  [(Id ("B", I));
                                    (App
                                       [(Id ("sing_elim", I)); (Id ("a0", I))
                                         ])
                                    ])),
                         [([(PId "_"); (PId "_"); (PId "refl");
                             (PConstr ("box", [(PId "b")]))],
                           (Some (Id ("b", I))))]
                         ))))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U,
                 (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                 (Binder ("B",
                    (Pi (R, U,
                       (App
                          [(Inst ("apair", [(SId "s"); (SId "r"); (SId "t")],
                              E));
                            (Id ("A", I)); (Id ("B", I))]),
                       (Binder ("x",
                          (App
                             [(Id ("B", I));
                               (App [(Id ("proj1", I)); (Id ("x", I))])])
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "my_apair0"; relv = R;
    body =
    (Binder ([],
       ((BOpr ("(,)", (Id ("zero", I)),
           (App [(Id ("nat_make", I)); (Id ("zero", I))]))),
        (App
           [(Inst ("apair", [(SId "_"); (SId "_"); U], I));
             (Fun ((Pi (R, U, (Id ("nat", I)), (Binder ("n", IMeta)))),
                (Binder (None,
                   [([(PId "n")],
                     (Some (Match ([(R, (Id ("n", I)), None)], None,
                              [([(PId "zero")],
                                (Some (App
                                         [(Id ("stream", I)); (Id ("nat", I))
                                           ])));
                                ([(PConstr ("succ", [(PId "_")]))],
                                 (Some (Inst ("unit", [L], I))))
                                ]
                              ))))
                     ]
                   )),
                []))
             ]))
       ));
    view = []};
  Definition {name = "my_apair1"; relv = R;
    body =
    (Binder ([],
       ((Let (R, (App [(Id ("nat_make", I)); (Id ("zero", I))]),
           (Binder ((PId "nat_stream"),
              (BOpr ("(,)",
                 (Let (R,
                    (App [(Id ("uncons_stream", I)); (Id ("nat_stream", I))]),
                    (Binder (
                       (PBOpr ("\226\159\168,\226\159\169", (PId "hd"),
                          (PId "tl"))),
                       (Let (R,
                          (App [(Id ("free_stream", I)); (Id ("tl", I))]),
                          (Binder ((PId "_"), (Id ("hd", I))))))
                       ))
                    )),
                 (Id ("nat_stream", I))))
              ))
           )),
        (App
           [(Inst ("apair", [(SId "_"); (SId "_"); L], I));
             (Fun ((Pi (R, U, (Id ("nat", I)), (Binder ("n", IMeta)))),
                (Binder (None,
                   [([(PId "n")],
                     (Some (Match ([(R, (Id ("n", I)), None)], None,
                              [([(PId "zero")],
                                (Some (App
                                         [(Id ("stream", I)); (Id ("nat", I))
                                           ])));
                                ([(PConstr ("succ", [(PId "_")]))],
                                 (Some (Inst ("unit", [L], I))))
                                ]
                              ))))
                     ]
                   )),
                []))
             ]))
       ));
    view = []};
  Definition {name = "_"; relv = R;
    body =
    (Binder ([],
       ((App
           [(Id ("free_stream", I));
             (App [(Id ("proj2", I)); (Id ("my_apair1", I))])]),
        (Id ("unit", I)))
       ));
    view = []}
  ]

-----------------------------------------

#[logical]
inductive eq_1‹s_177› (A_178 : Type‹s_177›) (m_179 : A_178):
  A_178 -> U
where
| refl_1 : (eq_1‹??_1› ?_1[0;0] m_179 m_179)

#[program]
inductive boxed_2‹s_181› (A_182 : Type‹s_181›): L where
| box_2 (m_183 : A_182) : (boxed_2‹??_2› A_182)

#[program]
inductive sing_3‹s_184,t_185› (A_186 : Type‹s_184›):
  A_186 -> Type‹t_185›
where
| just_3 (m_188 : A_186) : (sing_3‹??_3,??_4› ?_2[0;0] m_188)

#[program]
inductive unit_4‹s_189› : Type‹s_189› where
| tt_4 : unit_4‹??_5›

#[program]
inductive bool_5‹› : U where
| true_5 : bool_5
| false_6 : bool_5

#[program]
inductive choice_6‹› : L where
| next_7 : choice_6
| free_8 : choice_6

#[program]
inductive prod_7‹s_190,r_191,t_192› (A_193 : Type‹s_190›) (B_194 : Type‹r_191›):
  Type‹t_192›
where
| pair_9
    (m_195 : A_193) (n_196 : B_194)
    : (prod_7‹??_6,??_7,??_8› A_193 B_194)

#[program]
inductive nat_8‹› : U where
| zero_10 : nat_8
| succ_11 (__197 : nat_8) : nat_8

#[program]
def sing_elim_1‹s_198,t_199› :
  ∀ {A_200 : Type‹s_198›} ->
    ∀ {x_201 : A_200} -> (sing_3‹s_198,t_199› ?_4[0;0] x_201) -> A_200
:=
  function sing_elim_203 :
    ∀ {A_204 : Type‹s_198›} ->
      ∀ {x_205 : A_204} ->
        (sing_3‹s_198,t_199› ?_3[0;0] x_205) -> A_204
  | A_207 x_208 (just_3 x_209) => x_209

#[logical]
def sing_uniq_2‹s_210,t_211› :
  ∀ (A_212 : Type‹s_210›) ->
    ∀ (x0_213 : A_212) ->
      ∀ (x_214 : (sing_3‹s_210,t_211› ?_11[0;0] x0_213)) ->
        (eq_1‹??_15›
          ?_14[0;0] x0_213
          ((sing_elim_1‹??_13,??_14›) ?_13[0;0] ?_12[0;0] x_214))
:=
  function sing_uniq_215 :
    ∀ (A_216 : Type‹s_210›) ->
      ∀ (x0_217 : A_216) ->
        ∀ (x_218 : (sing_3‹s_210,t_211› ?_5[0;0] x0_217)) ->
          (eq_1‹??_11›
            ?_8[0;0] x0_217
            ((sing_elim_1‹??_9,??_10›) ?_7[0;0] ?_6[0;0] x_218))
  | A_219 x0_220 (just_3 _221) => (refl_1‹??_12› ?_9[0;0] ?_10[0;0])

#[program]
inductive stream_node_9‹s_222› (A_223 : Type‹s_222›): L where
| stream_cons_12
    (hd_224 : A_223)
    (tl_225 : ∀ (x_226 : choice_6) -o
                match x_226 in ?_15[0;0] -o ?_16[0;0] with
                | next_7 => (stream_node_9‹??_16› A_223)
                | free_8 => unit_4‹??_17›)
    : (stream_node_9‹??_18› A_223)

#[logical]
def stream_3‹s_228› : Type‹s_228› -> ?_20[0;0] :=
  function stream_230 : Type‹s_228› -> ?_17[0;0]
  | A_232 =>
    ∀ (x_233 : choice_6) -o
      match x_233 in ?_18[0;0] -o ?_19[0;0] with
      | next_7 => (stream_node_9‹??_19› A_232)
      | free_8 => unit_4‹??_20›

#[program]
def free_stream_4‹s_235› :
  ∀ {A_236 : Type‹s_235›} ->
    ((stream_3‹??_23›) A_236) -> unit_4‹U›
:=
  function free_stream_238 :
    ∀ {A_239 : Type‹s_235›} ->
      ((stream_3‹??_21›) A_239) -> unit_4‹U›
  | A_241 st_242 =>
    match ((st_242) free_8) in ?_21[0;0] -o ?_22[0;0] with
    | tt_4 => tt_4‹??_22›

#[program]
def uncons_stream_5‹s_244› :
  ∀ {A_245 : Type‹s_244›} ->
    ((stream_3‹??_31›) A_245) ->
      (prod_7‹??_32,??_33,L› A_245 ((stream_3‹??_34›) A_245))
:=
  function uncons_stream_247 :
    ∀ {A_248 : Type‹s_244›} ->
      ((stream_3‹??_24›) A_248) ->
        (prod_7‹??_25,??_26,L› A_248 ((stream_3‹??_27›) A_248))
  | A_250 st_251 =>
    match ((st_251) next_7) in ?_26[0;0] -o ?_25[0;0] with
    | (stream_cons_12 hd_253 tl_254) =>
      (pair_9‹??_28,??_29,??_30› ?_23[0;0] ?_24[0;0] hd_253 tl_254)

#[program]
def nat_make_6‹› : nat_8 -> ((stream_3‹??_38›) nat_8) :=
  function nat_make_256 : nat_8 -> ((stream_3‹??_35›) nat_8)
  | n_258 next_7 =>
    (stream_cons_12‹??_36›
      ?_27[0;0] n_258 ((nat_make_256) (succ_11‹› n_258)))
  | n_259 free_8 => tt_4‹??_37›

#[program]
inductive apair_10‹s_260,r_261,t_262› (A_263 : Type‹s_260›) (B_264 : 
A_263 -> Type‹r_261›): Type‹t_262› where
| apair_intro_13
    {x_266 : A_263}
    (select_267 : forall‹t_262›(b_268 : bool_5),
                    match b_268 in ?_28[0;0] -o ?_29[0;0] with
                    | true_5 => (sing_3‹??_39,L› ?_30[0;0] x_266)
                    | false_6 => (boxed_2‹??_40› ((B_264) x_266)))
    : (apair_10‹??_41,??_42,??_43› ?_31[0;0] B_264)

#[program]
def proj1_7‹s_270,r_271,t_272› :
  ∀ {A_273 : Type‹s_270›} ->
    ∀ {B_274 : A_273 -> Type‹r_271›} ->
      (apair_10‹s_270,r_271,t_272› A_273 B_274) -> A_273
:=
  function proj1_277 :
    ∀ {A_278 : Type‹s_270›} ->
      ∀ {B_279 : A_278 -> Type‹r_271›} ->
        (apair_10‹s_270,r_271,t_272› A_278 B_279) -> A_278
  | A_282 B_283 (apair_intro_13 _284 select_285) =>
    ((sing_elim_1‹??_44,??_45›)
      ?_33[0;0] ?_32[0;0] ((select_285) true_5))

#[program]
def proj2_8‹s_286,r_287,t_288› :
  ∀ {A_289 : Type‹s_286›} ->
    ∀ {B_290 : A_289 -> Type‹r_287›} ->
      ∀ (x_292 : (apair_10‹s_286,r_287,t_288› A_289 B_290)) ->
        ((B_290)
          ((proj1_7‹??_59,??_60,??_61›) ?_46[0;0] ?_45[0;0] x_292))
:=
  function proj2_293 :
    ∀ {A_294 : Type‹s_286›} ->
      ∀ {B_295 : A_294 -> Type‹r_287›} ->
        ∀ (x_297 : (apair_10‹s_286,r_287,t_288› A_294 B_295)) ->
          ((B_295)
            ((proj1_7‹??_46,??_47,??_48›) ?_35[0;0] ?_34[0;0] x_297))
  | A_298 B_299 (apair_intro_13 x_300 select_301) =>
    match x_300, ((select_301) true_5),
    ((sing_uniq_2‹??_49,??_50›)
      ?_37[0;0] ?_36[0;0] ((select_301) true_5)),
    ((select_301) false_6) in
      ∀ {x0_302 : ?_38[0;0]} -o
        ∀ {a0_303 : (sing_3‹??_51,??_52› ?_39[0;0] x_300)} -o
          {(eq_1‹??_55›
             ?_42[0;0] x0_302
             ((sing_elim_1‹??_53,??_54›) ?_41[0;0] ?_40[0;0] a0_303))} -o
            (boxed_2‹??_56› ((B_299) x0_302)) -o
              ((B_299)
                ((sing_elim_1‹??_57,??_58›) ?_44[0;0] ?_43[0;0] a0_303))
    with
    | _306, _307, refl_1, (box_2 b_308) => b_308

#[program]
def my_apair0_9‹› :
  (apair_10‹??_68,??_69,U›
    ?_56[0;0]
    function _309 : nat_8 -> ?_53[0;0]
    | n_311 =>
      match n_311 in ?_54[0;0] -o ?_55[0;0] with
      | zero_10 => ((stream_3‹??_70›) nat_8)
      | (succ_11 _313) => unit_4‹L›)
:=
  (apair_intro_13‹??_65,??_66,??_67›
    ?_51[0;0] ?_52[0;0] ?_50[0;0]
    function _314 : ?_47[0;0]
    | true_5 => (just_3‹??_62,??_63› ?_48[0;0] zero_10)
    | false_6 => (box_2‹??_64› ?_49[0;0] ((nat_make_6) zero_10)))

#[program]
def my_apair1_10‹› :
  (apair_10‹??_79,??_80,L›
    ?_70[0;0]
    function _315 : nat_8 -> ?_67[0;0]
    | n_317 =>
      match n_317 in ?_68[0;0] -o ?_69[0;0] with
      | zero_10 => ((stream_3‹??_81›) nat_8)
      | (succ_11 _319) => unit_4‹L›)
:=
  let nat_stream_320 := ((nat_make_6) zero_10) in
  (apair_intro_13‹??_76,??_77,??_78›
    ?_65[0;0] ?_66[0;0] ?_64[0;0]
    function _321 : ?_57[0;0]
    | true_5 =>
      (just_3‹??_73,??_74›
        ?_62[0;0]
        match ((uncons_stream_5‹??_71›) ?_58[0;0] nat_stream_320) in
          ?_61[0;0] -o ?_60[0;0]
        with
        | (pair_9 hd_323 tl_324) =>
          let __325 := ((free_stream_4‹??_72›) ?_59[0;0] tl_324) in
          hd_323)
    | false_6 => (box_2‹??_75› ?_63[0;0] nat_stream_320))

#[program]
def __11‹› : unit_4‹??_86› :=
  ((free_stream_4‹??_85›)
    ?_73[0;0]
    ((proj2_8‹??_82,??_83,??_84›) ?_72[0;0] ?_71[0;0] my_apair1_10))

-----------------------------------------

#[logical]
inductive eq_1‹s_4387› (A_4388 : Type‹s_4387›) (m_4389 : A_4388):
  A_4388 -> U
where
| refl_1 : (eq_1‹s_4387› A_4388 m_4389 m_4389)

#[program]
inductive boxed_2‹s_4391› (A_4392 : Type‹s_4391›): L where
| box_2 (m_4393 : A_4392) : (boxed_2‹s_4391› A_4392)

#[program]
inductive sing_3‹s_4394,t_4395› (A_4396 : Type‹s_4394›):
  A_4396 -> Type‹t_4395›
where
| just_3 (m_4398 : A_4396) : (sing_3‹s_4394,t_4395› A_4396 m_4398)

#[program]
inductive unit_4‹s_4399› : Type‹s_4399› where
| tt_4 : unit_4‹s_4399›

#[program]
inductive bool_5‹› : U where
| true_5 : bool_5
| false_6 : bool_5

#[program]
inductive choice_6‹› : L where
| next_7 : choice_6
| free_8 : choice_6

#[program]
inductive prod_7‹s_4400,r_4401,t_4402› (A_4403 : Type‹s_4400›) (B_4404 : Type‹r_4401›):
  Type‹t_4402›
where
| pair_9
    (m_4405 : A_4403) (n_4406 : B_4404)
    : (prod_7‹s_4400,r_4401,t_4402› A_4403 B_4404)

#[program]
inductive nat_8‹› : U where
| zero_10 : nat_8
| succ_11 (__4407 : nat_8) : nat_8

#[program]
def sing_elim_1‹s_4408,t_4409› :
  ∀ {A_4410 : Type‹s_4408›} ->
    ∀ {x_4411 : A_4410} ->
      (sing_3‹s_4408,t_4409› A_4410 x_4411) -> A_4410
:=
  function sing_elim_4413 :
    ∀ {A_4414 : Type‹s_4408›} ->
      ∀ {x_4415 : A_4414} ->
        (sing_3‹s_4408,t_4409› A_4414 x_4415) -> A_4414
  | A_4417 x_4418 (just_3 m_4419) => m_4419

#[logical]
def sing_uniq_2‹s_4420,t_4421› :
  ∀ (A_4422 : Type‹s_4420›) ->
    ∀ (x0_4423 : A_4422) ->
      ∀ (x_4424 : (sing_3‹s_4420,t_4421› A_4422 x0_4423)) ->
        (eq_1‹s_4420›
          A_4422 x0_4423
          ((sing_elim_1‹s_4420,t_4421›) A_4422 x0_4423 x_4424))
:=
  function sing_uniq_4425 :
    ∀ (A_4426 : Type‹s_4420›) ->
      ∀ (x0_4427 : A_4426) ->
        ∀ (x_4428 : (sing_3‹s_4420,t_4421› A_4426 x0_4427)) ->
          (eq_1‹s_4420›
            A_4426 x0_4427
            ((sing_elim_1‹s_4420,t_4421›) A_4426 x0_4427 x_4428))
  | A_4429 x0_4430 (just_3 m_4431) => (refl_1‹s_4420› A_4429 m_4431)

#[program]
inductive stream_node_9‹s_4432› (A_4433 : Type‹s_4432›): L where
| stream_cons_12
    (hd_4434 : A_4433)
    (tl_4435 : ∀ (x_4436 : choice_6) -o
                 match x_4436 in choice_6 -o L with
                 | next_7 => (stream_node_9‹s_4432› A_4433)
                 | free_8 => unit_4‹L›)
    : (stream_node_9‹s_4432› A_4433)

#[logical]
def stream_3‹s_4438› : Type‹s_4438› -> L :=
  function stream_4440 : Type‹s_4438› -> L
  | A_4442 =>
    ∀ (x_4443 : choice_6) -o
      match x_4443 in choice_6 -o L with
      | next_7 => (stream_node_9‹s_4438› A_4442)
      | free_8 => unit_4‹L›

#[program]
def free_stream_4‹s_4445› :
  ∀ {A_4446 : Type‹s_4445›} ->
    ((stream_3‹s_4445›) A_4446) -> unit_4‹U›
:=
  function free_stream_4448 :
    ∀ {A_4449 : Type‹s_4445›} ->
      ((stream_3‹s_4445›) A_4449) -> unit_4‹U›
  | A_4451 st_4452 =>
    match ((st_4452) free_8) in unit_4‹L› -o unit_4‹U› with
    | tt_4 => tt_4‹U›

#[program]
def uncons_stream_5‹s_4454› :
  ∀ {A_4455 : Type‹s_4454›} ->
    ((stream_3‹s_4454›) A_4455) ->
      (prod_7‹s_4454,L,L› A_4455 ((stream_3‹s_4454›) A_4455))
:=
  function uncons_stream_4457 :
    ∀ {A_4458 : Type‹s_4454›} ->
      ((stream_3‹s_4454›) A_4458) ->
        (prod_7‹s_4454,L,L› A_4458 ((stream_3‹s_4454›) A_4458))
  | A_4460 st_4461 =>
    match ((st_4461) next_7) in
      (stream_node_9‹s_4454› A_4460) -o
        (prod_7‹s_4454,L,L› A_4460 ((stream_3‹s_4454›) A_4460))
    with
    | (stream_cons_12 hd_4463 tl_4464) =>
      (pair_9‹s_4454,L,L›
        A_4460 ((stream_3‹s_4454›) A_4460) hd_4463 tl_4464)

#[program]
def nat_make_6‹› : nat_8 -> ((stream_3‹U›) nat_8) :=
  function nat_make_4466 : nat_8 -> ((stream_3‹U›) nat_8)
  | n_4468 next_7 =>
    (stream_cons_12‹U›
      nat_8 n_4468 ((nat_make_4466) (succ_11‹› n_4468)))
  | n_4469 free_8 => tt_4‹L›

#[program]
inductive apair_10‹s_4470,r_4471,t_4472› (A_4473 : Type‹s_4470›) (B_4474 : 
A_4473 -> Type‹r_4471›): Type‹t_4472› where
| apair_intro_13
    {x_4476 : A_4473}
    (select_4477 : forall‹t_4472›(b_4478 : bool_5),
                     match b_4478 in bool_5 -o L with
                     | true_5 => (sing_3‹s_4470,L› A_4473 x_4476)
                     | false_6 => (boxed_2‹r_4471› ((B_4474) x_4476)))
    : (apair_10‹s_4470,r_4471,t_4472› A_4473 B_4474)

#[program]
def proj1_7‹s_4480,r_4481,t_4482› :
  ∀ {A_4483 : Type‹s_4480›} ->
    ∀ {B_4484 : A_4483 -> Type‹r_4481›} ->
      (apair_10‹s_4480,r_4481,t_4482› A_4483 B_4484) -> A_4483
:=
  function proj1_4487 :
    ∀ {A_4488 : Type‹s_4480›} ->
      ∀ {B_4489 : A_4488 -> Type‹r_4481›} ->
        (apair_10‹s_4480,r_4481,t_4482› A_4488 B_4489) -> A_4488
  | A_4492 B_4493 (apair_intro_13 x_4494 select_4495) =>
    ((sing_elim_1‹s_4480,L›) A_4492 x_4494 ((select_4495) true_5))

#[program]
def proj2_8‹s_4496,r_4497,t_4498› :
  ∀ {A_4499 : Type‹s_4496›} ->
    ∀ {B_4500 : A_4499 -> Type‹r_4497›} ->
      ∀ (x_4502 : (apair_10‹s_4496,r_4497,t_4498› A_4499 B_4500)) ->
        ((B_4500) ((proj1_7‹s_4496,r_4497,t_4498›) A_4499 B_4500 x_4502))
:=
  function proj2_4503 :
    ∀ {A_4504 : Type‹s_4496›} ->
      ∀ {B_4505 : A_4504 -> Type‹r_4497›} ->
        ∀ (x_4507 : (apair_10‹s_4496,r_4497,t_4498› A_4504 B_4505)) ->
          ((B_4505)
            ((proj1_7‹s_4496,r_4497,t_4498›) A_4504 B_4505 x_4507))
  | A_4508 B_4509 (apair_intro_13 x_4510 select_4511) =>
    match x_4510, ((select_4511) true_5),
    ((sing_uniq_2‹s_4496,L›) A_4508 x_4510 ((select_4511) true_5)),
    ((select_4511) false_6) in
      ∀ {x0_4512 : A_4508} -o
        ∀ {a0_4513 : (sing_3‹s_4496,L› A_4508 x_4510)} -o
          {(eq_1‹s_4496›
             A_4508 x0_4512
             ((sing_elim_1‹s_4496,L›) A_4508 x_4510 a0_4513))} -o
            (boxed_2‹r_4497› ((B_4509) x0_4512)) -o
              ((B_4509) ((sing_elim_1‹s_4496,L›) A_4508 x_4510 a0_4513))
    with
    | x0_4516, a0_4517, refl_1, (box_2 m_4518) => m_4518

#[program]
def my_apair0_9‹› :
  (apair_10‹U,L,U›
    nat_8
    function _4519 : nat_8 -> L
    | __4521 =>
      match __4521 in nat_8 -o L with
      | zero_10 => ((stream_3‹U›) nat_8)
      | (succ_11 __4523) => unit_4‹L›)
:=
  (apair_intro_13‹U,L,U›
    nat_8
    function _4524 : nat_8 -> L
    | __4526 =>
      match __4526 in nat_8 -o L with
      | zero_10 => ((stream_3‹U›) nat_8)
      | (succ_11 __4528) => unit_4‹L›
    zero_10
    function _4529 :
      ∀ (b_4530 : bool_5) ->
        match b_4530 in bool_5 -o L with
        | true_5 => (sing_3‹U,L› nat_8 zero_10)
        | false_6 =>
          (boxed_2‹L›
            ((function _4532 : nat_8 -> L
              | __4534 =>
                match __4534 in nat_8 -o L with
                | zero_10 => ((stream_3‹U›) nat_8)
                | (succ_11 __4536) => unit_4‹L›)
              zero_10))
    | true_5 => (just_3‹U,L› nat_8 zero_10)
    | false_6 =>
      (box_2‹L› ((stream_3‹U›) nat_8) ((nat_make_6) zero_10)))

#[program]
def my_apair1_10‹› :
  (apair_10‹U,L,L›
    nat_8
    function _4537 : nat_8 -> L
    | __4539 =>
      match __4539 in nat_8 -o L with
      | zero_10 => ((stream_3‹U›) nat_8)
      | (succ_11 __4541) => unit_4‹L›)
:=
  let nat_stream_4542 := ((nat_make_6) zero_10) in
  (apair_intro_13‹U,L,L›
    nat_8
    function _4543 : nat_8 -> L
    | __4545 =>
      match __4545 in nat_8 -o L with
      | zero_10 => ((stream_3‹U›) nat_8)
      | (succ_11 __4547) => unit_4‹L›
    match ((uncons_stream_5‹U›) nat_8 nat_stream_4542) in
      (prod_7‹U,L,L› nat_8 ((stream_3‹U›) nat_8)) -o nat_8
    with
    | (pair_9 m_4549 n_4550) =>
      let __4551 := ((free_stream_4‹U›) nat_8 n_4550) in m_4549
    function _4552 :
      ∀ (b_4553 : bool_5) -o
        match b_4553 in bool_5 -o L with
        | true_5 =>
          (sing_3‹U,L›
            nat_8
            match ((uncons_stream_5‹U›) nat_8 nat_stream_4542) in
              (prod_7‹U,L,L› nat_8 ((stream_3‹U›) nat_8)) -o nat_8
            with
            | (pair_9 m_4556 n_4557) =>
              let __4558 := ((free_stream_4‹U›) nat_8 n_4557) in m_4556)
        | false_6 =>
          (boxed_2‹L›
            ((function _4559 : nat_8 -> L
              | __4561 =>
                match __4561 in nat_8 -o L with
                | zero_10 => ((stream_3‹U›) nat_8)
                | (succ_11 __4563) => unit_4‹L›)
              match ((uncons_stream_5‹U›) nat_8 nat_stream_4542) in
                (prod_7‹U,L,L› nat_8 ((stream_3‹U›) nat_8)) -o nat_8
              with
              | (pair_9 m_4565 n_4566) =>
                let __4567 := ((free_stream_4‹U›) nat_8 n_4566) in m_4565))
    | true_5 =>
      (just_3‹U,L›
        nat_8
        match ((uncons_stream_5‹U›) nat_8 nat_stream_4542) in
          (prod_7‹U,L,L› nat_8 ((stream_3‹U›) nat_8)) -o nat_8
        with
        | (pair_9 m_4569 n_4570) =>
          let __4571 := ((free_stream_4‹U›) nat_8 n_4570) in m_4569)
    | false_6 =>
      (box_2‹L›
        match match ((uncons_stream_5‹U›) nat_8 nat_stream_4542) in
                (prod_7‹U,L,L› nat_8 ((stream_3‹U›) nat_8)) -o nat_8
              with
              | (pair_9 m_4573 n_4574) =>
                let __4575 := ((free_stream_4‹U›) nat_8 n_4574) in m_4573 in
          nat_8 -o L
        with
        | zero_10 => ((stream_3‹U›) nat_8)
        | (succ_11 __4577) => unit_4‹L› nat_stream_4542))

#[program]
def __11‹› : unit_4‹U› :=
  ((free_stream_4‹U›)
    nat_8
    ((proj2_8‹U,L,L›)
      nat_8
      function _4578 : nat_8 -> L
      | __4580 =>
        match __4580 in nat_8 -o L with
        | zero_10 => ((stream_3‹U›) nat_8)
        | (succ_11 __4582) => unit_4‹L›
      my_apair1_10))

-----------------------------------------

#[logical]
inductive eqU_12 where
| reflU_15 of layout[]

#[logical]
inductive eqL_11 where
| reflL_14 of layout[]

#[program]
inductive boxedU_14 where
| boxU_17 of layout[R]

#[program]
inductive boxedL_13 where
| boxL_16 of layout[R]

#[program]
inductive singUU_18 where
| justUU_21 of layout[R]

#[program]
inductive singUL_17 where
| justUL_20 of layout[R]

#[program]
inductive singLU_16 where


#[program]
inductive singLL_15 where
| justLL_18 of layout[R]

#[program]
inductive unitU_20 where
| ttU_23 of layout[]

#[program]
inductive unitL_19 where
| ttL_22 of layout[]

#[program]
inductive bool_5 where
| true_5 of layout[]
| false_6 of layout[]

#[program]
inductive choice_6 where
| next_7 of layout[]
| free_8 of layout[]

#[program]
inductive prodUUU_28 where
| pairUUU_31 of layout[R, R]

#[program]
inductive prodUUL_27 where
| pairUUL_30 of layout[R, R]

#[program]
inductive prodULU_26 where


#[program]
inductive prodULL_25 where
| pairULL_28 of layout[R, R]

#[program]
inductive prodLUU_24 where


#[program]
inductive prodLUL_23 where
| pairLUL_26 of layout[R, R]

#[program]
inductive prodLLU_22 where


#[program]
inductive prodLLL_21 where
| pairLLL_24 of layout[R, R]

#[program]
inductive nat_8 where
| zero_10 of layout[]
| succ_11 of layout[R]

#[program]
def sing_elimUU_15 :=
  fun sing_elim_8283 {A_8284} -> {x_8285} -> (__8286) ->
    match __8286 with
    | justUU_21 m_8287 => m_8287
    end

#[program]
def sing_elimUL_14 :=
  fun sing_elim_8288 {A_8289} -> {x_8290} -> (__8291) ->
    match __8291 with
    | justUL_20 m_8292 => m_8292
    end

#[program]
def sing_elimLU_13 :=
  fun sing_elim_8293 {A_8294} -> {x_8295} -> (__8296) ->
    match __8296 with
    
    end

#[program]
def sing_elimLL_12 :=
  fun sing_elim_8297 {A_8298} -> {x_8299} -> (__8300) ->
    match __8300 with
    | justLL_18 m_8301 => m_8301
    end

#[logical]
def sing_uniqUU_19 := NULL

#[logical]
def sing_uniqUL_18 := NULL

#[logical]
def sing_uniqLU_17 := NULL

#[logical]
def sing_uniqLL_16 := NULL

#[program]
inductive stream_nodeU_30 where
| stream_consU_33 of layout[R, R]

#[program]
inductive stream_nodeL_29 where
| stream_consL_32 of layout[R, R]

#[logical]
def streamU_21 := NULL

#[logical]
def streamL_20 := NULL

#[program]
def free_streamU_23 :=
  fun free_stream_8302 {A_8303} -> (st_8304) ->
    match ((st_8304) free_8) with
    | ttL_22  => ttU_23
    end

#[program]
def free_streamL_22 :=
  fun free_stream_8305 {A_8306} -> (st_8307) ->
    match ((st_8307) free_8) with
    | ttL_22  => ttU_23
    end

#[program]
def uncons_streamU_25 :=
  fun uncons_stream_8308 {A_8309} -> (st_8310) ->
    match ((st_8310) next_7) with
    | stream_consU_33 hd_8311 tl_8312 => (pairULL_28 hd_8311 tl_8312)
    end

#[program]
def uncons_streamL_24 :=
  fun uncons_stream_8313 {A_8314} -> (st_8315) ->
    match ((st_8315) next_7) with
    | stream_consL_32 hd_8316 tl_8317 => (pairLLL_24 hd_8316 tl_8317)
    end

#[program]
def nat_make_6 :=
  fun nat_make_8318 (n_8319) -> (x_8320) -o
    match x_8320 with
    | next_7  => (stream_consU_33 n_8319 ((nat_make_8318) (succ_11 n_8319)))
    | free_8  => ttL_22
    end

#[program]
inductive apairUUU_38 where
| apair_introUUU_41 of layout[N, R]

#[program]
inductive apairUUL_37 where
| apair_introUUL_40 of layout[N, R]

#[program]
inductive apairULU_36 where
| apair_introULU_39 of layout[N, R]

#[program]
inductive apairULL_35 where
| apair_introULL_38 of layout[N, R]

#[program]
inductive apairLUU_34 where
| apair_introLUU_37 of layout[N, R]

#[program]
inductive apairLUL_33 where
| apair_introLUL_36 of layout[N, R]

#[program]
inductive apairLLU_32 where
| apair_introLLU_35 of layout[N, R]

#[program]
inductive apairLLL_31 where
| apair_introLLL_34 of layout[N, R]

#[program]
def proj1UUU_33 :=
  fun proj1_8321 {A_8322} -> {B_8323} -> (__8324) ->
    match __8324 with
    | apair_introUUU_41 x_8325 select_8326 =>
      ((sing_elimUL_14) NULL NULL ((select_8326) true_5))
    end

#[program]
def proj1UUL_32 :=
  fun proj1_8327 {A_8328} -> {B_8329} -> (__8330) ->
    match __8330 with
    | apair_introUUL_40 x_8331 select_8332 =>
      ((sing_elimUL_14) NULL NULL ((select_8332) true_5))
    end

#[program]
def proj1ULU_31 :=
  fun proj1_8333 {A_8334} -> {B_8335} -> (__8336) ->
    match __8336 with
    | apair_introULU_39 x_8337 select_8338 =>
      ((sing_elimUL_14) NULL NULL ((select_8338) true_5))
    end

#[program]
def proj1ULL_30 :=
  fun proj1_8339 {A_8340} -> {B_8341} -> (__8342) ->
    match __8342 with
    | apair_introULL_38 x_8343 select_8344 =>
      ((sing_elimUL_14) NULL NULL ((select_8344) true_5))
    end

#[program]
def proj1LUU_29 :=
  fun proj1_8345 {A_8346} -> {B_8347} -> (__8348) ->
    match __8348 with
    | apair_introLUU_37 x_8349 select_8350 =>
      ((sing_elimLL_12) NULL NULL ((select_8350) true_5))
    end

#[program]
def proj1LUL_28 :=
  fun proj1_8351 {A_8352} -> {B_8353} -> (__8354) ->
    match __8354 with
    | apair_introLUL_36 x_8355 select_8356 =>
      ((sing_elimLL_12) NULL NULL ((select_8356) true_5))
    end

#[program]
def proj1LLU_27 :=
  fun proj1_8357 {A_8358} -> {B_8359} -> (__8360) ->
    match __8360 with
    | apair_introLLU_35 x_8361 select_8362 =>
      ((sing_elimLL_12) NULL NULL ((select_8362) true_5))
    end

#[program]
def proj1LLL_26 :=
  fun proj1_8363 {A_8364} -> {B_8365} -> (__8366) ->
    match __8366 with
    | apair_introLLL_34 x_8367 select_8368 =>
      ((sing_elimLL_12) NULL NULL ((select_8368) true_5))
    end

#[program]
def proj2UUU_41 :=
  fun proj2_8369 {A_8370} -> {B_8371} -> (x_8372) ->
    match x_8372 with
    | apair_introUUU_41 x_8373 select_8374 =>
      match {NULL} with
      | reflU_15  =>
        match ((select_8374) false_6) with
        | boxU_17 m_8375 => m_8375
        end
      end
    end

#[program]
def proj2UUL_40 :=
  fun proj2_8376 {A_8377} -> {B_8378} -> (x_8379) ->
    match x_8379 with
    | apair_introUUL_40 x_8380 select_8381 =>
      match {NULL} with
      | reflU_15  =>
        match ((select_8381) false_6) with
        | boxU_17 m_8382 => m_8382
        end
      end
    end

#[program]
def proj2ULU_39 :=
  fun proj2_8383 {A_8384} -> {B_8385} -> (x_8386) ->
    match x_8386 with
    | apair_introULU_39 x_8387 select_8388 =>
      match {NULL} with
      | reflU_15  =>
        match ((select_8388) false_6) with
        | boxL_16 m_8389 => m_8389
        end
      end
    end

#[program]
def proj2ULL_38 :=
  fun proj2_8390 {A_8391} -> {B_8392} -> (x_8393) ->
    match x_8393 with
    | apair_introULL_38 x_8394 select_8395 =>
      match {NULL} with
      | reflU_15  =>
        match ((select_8395) false_6) with
        | boxL_16 m_8396 => m_8396
        end
      end
    end

#[program]
def proj2LUU_37 :=
  fun proj2_8397 {A_8398} -> {B_8399} -> (x_8400) ->
    match x_8400 with
    | apair_introLUU_37 x_8401 select_8402 =>
      match {NULL} with
      | reflL_14  =>
        match ((select_8402) false_6) with
        | boxU_17 m_8403 => m_8403
        end
      end
    end

#[program]
def proj2LUL_36 :=
  fun proj2_8404 {A_8405} -> {B_8406} -> (x_8407) ->
    match x_8407 with
    | apair_introLUL_36 x_8408 select_8409 =>
      match {NULL} with
      | reflL_14  =>
        match ((select_8409) false_6) with
        | boxU_17 m_8410 => m_8410
        end
      end
    end

#[program]
def proj2LLU_35 :=
  fun proj2_8411 {A_8412} -> {B_8413} -> (x_8414) ->
    match x_8414 with
    | apair_introLLU_35 x_8415 select_8416 =>
      match {NULL} with
      | reflL_14  =>
        match ((select_8416) false_6) with
        | boxL_16 m_8417 => m_8417
        end
      end
    end

#[program]
def proj2LLL_34 :=
  fun proj2_8418 {A_8419} -> {B_8420} -> (x_8421) ->
    match x_8421 with
    | apair_introLLL_34 x_8422 select_8423 =>
      match {NULL} with
      | reflL_14  =>
        match ((select_8423) false_6) with
        | boxL_16 m_8424 => m_8424
        end
      end
    end

#[program]
def my_apair0_9 :=
  (apair_introULU_39
    NULL
    fun _8425 (b_8426) ->
      match b_8426 with
      | true_5  => (justUL_20 zero_10)
      | false_6  => (boxL_16 ((nat_make_6) zero_10))
      end)

#[program]
def my_apair1_10 :=
  let nat_stream_8427 := ((nat_make_6) zero_10) in
  (apair_introULL_38
    NULL
    fun _8428 (b_8429) -o
      match b_8429 with
      | true_5  =>
        (justUL_20
          match ((uncons_streamU_25) NULL nat_stream_8427) with
          | pairULL_28 m_8430 n_8431 =>
            let __8432 := ((free_streamU_23) NULL n_8431) in m_8430
          end)
      | false_6  => (boxL_16 nat_stream_8427)
      end)

#[program]
def __11 := ((free_streamU_23) NULL ((proj2ULL_38) NULL NULL my_apair1_10))

-----------------------------------------

#[logical]
inductive eqU_12 where
| reflU_15 of layout[]

#[logical]
inductive eqL_11 where
| reflL_14 of layout[]

#[program]
inductive boxedU_14 where
| boxU_17 of layout[R]

#[program]
inductive boxedL_13 where
| boxL_16 of layout[R]

#[program]
inductive singUU_18 where
| justUU_21 of layout[R]

#[program]
inductive singUL_17 where
| justUL_20 of layout[R]

#[program]
inductive singLU_16 where


#[program]
inductive singLL_15 where
| justLL_18 of layout[R]

#[program]
inductive unitU_20 where
| ttU_23 of layout[]

#[program]
inductive unitL_19 where
| ttL_22 of layout[]

#[program]
inductive bool_5 where
| true_5 of layout[]
| false_6 of layout[]

#[program]
inductive choice_6 where
| next_7 of layout[]
| free_8 of layout[]

#[program]
inductive prodUUU_28 where
| pairUUU_31 of layout[R, R]

#[program]
inductive prodUUL_27 where
| pairUUL_30 of layout[R, R]

#[program]
inductive prodULU_26 where


#[program]
inductive prodULL_25 where
| pairULL_28 of layout[R, R]

#[program]
inductive prodLUU_24 where


#[program]
inductive prodLUL_23 where
| pairLUL_26 of layout[R, R]

#[program]
inductive prodLLU_22 where


#[program]
inductive prodLLL_21 where
| pairLLL_24 of layout[R, R]

#[program]
inductive nat_8 where
| zero_10 of layout[]
| succ_11 of layout[R]

#[program]
def sing_elimUU_15 :=
  fun sing_elim_8583 {A_8584} -> {x_8585} -> (__8586) ->
    match __8586 with
    | justUU_21 m_8587 => m_8587
    end

#[program]
def sing_elimUL_14 :=
  fun sing_elim_8588 {A_8589} -> {x_8590} -> (__8591) ->
    match __8591 with
    | justUL_20 m_8592 => m_8592
    end

#[program]
def sing_elimLU_13 :=
  fun sing_elim_8593 {A_8594} -> {x_8595} -> (__8596) -> !!

#[program]
def sing_elimLL_12 :=
  fun sing_elim_8597 {A_8598} -> {x_8599} -> (__8600) ->
    match __8600 with
    | justLL_18 m_8601 => m_8601
    end

#[logical]
def sing_uniqUU_19 := NULL

#[logical]
def sing_uniqUL_18 := NULL

#[logical]
def sing_uniqLU_17 := NULL

#[logical]
def sing_uniqLL_16 := NULL

#[program]
inductive stream_nodeU_30 where
| stream_consU_33 of layout[R, R]

#[program]
inductive stream_nodeL_29 where
| stream_consL_32 of layout[R, R]

#[logical]
def streamU_21 := NULL

#[logical]
def streamL_20 := NULL

#[program]
def free_streamU_23 :=
  fun free_stream_8602 {A_8603} -> (st_8604) ->
    match ((st_8604) free_8) with
    | ttL_22  => ttU_23
    end

#[program]
def free_streamL_22 :=
  fun free_stream_8605 {A_8606} -> (st_8607) ->
    match ((st_8607) free_8) with
    | ttL_22  => ttU_23
    end

#[program]
def uncons_streamU_25 :=
  fun uncons_stream_8608 {A_8609} -> (st_8610) ->
    match ((st_8610) next_7) with
    | stream_consU_33 hd_8611 tl_8612 => (pairULL_28 hd_8611 tl_8612)
    end

#[program]
def uncons_streamL_24 :=
  fun uncons_stream_8613 {A_8614} -> (st_8615) ->
    match ((st_8615) next_7) with
    | stream_consL_32 hd_8616 tl_8617 => (pairLLL_24 hd_8616 tl_8617)
    end

#[program]
def nat_make_6 :=
  fun nat_make_8618 (n_8619) -> (x_8620) -o
    match x_8620 with
    | next_7  => (stream_consU_33 n_8619 ((nat_make_8618) (succ_11 n_8619)))
    | free_8  => ttL_22
    end

#[program]
inductive apairUUU_38 where
| apair_introUUU_41 of layout[N, R]

#[program]
inductive apairUUL_37 where
| apair_introUUL_40 of layout[N, R]

#[program]
inductive apairULU_36 where
| apair_introULU_39 of layout[N, R]

#[program]
inductive apairULL_35 where
| apair_introULL_38 of layout[N, R]

#[program]
inductive apairLUU_34 where
| apair_introLUU_37 of layout[N, R]

#[program]
inductive apairLUL_33 where
| apair_introLUL_36 of layout[N, R]

#[program]
inductive apairLLU_32 where
| apair_introLLU_35 of layout[N, R]

#[program]
inductive apairLLL_31 where
| apair_introLLL_34 of layout[N, R]

#[program]
def proj1UUU_33 :=
  fun proj1_8621 {A_8622} -> {B_8623} -> (__8624) ->
    match __8624 with
    | apair_introUUU_41 x_8625 select_8626 =>
      ((sing_elimUL_14) NULL NULL ((select_8626) true_5))
    end

#[program]
def proj1UUL_32 :=
  fun proj1_8627 {A_8628} -> {B_8629} -> (__8630) ->
    match __8630 with
    | apair_introUUL_40 x_8631 select_8632 =>
      ((sing_elimUL_14) NULL NULL ((select_8632) true_5))
    end

#[program]
def proj1ULU_31 :=
  fun proj1_8633 {A_8634} -> {B_8635} -> (__8636) ->
    match __8636 with
    | apair_introULU_39 x_8637 select_8638 =>
      ((sing_elimUL_14) NULL NULL ((select_8638) true_5))
    end

#[program]
def proj1ULL_30 :=
  fun proj1_8639 {A_8640} -> {B_8641} -> (__8642) ->
    match __8642 with
    | apair_introULL_38 x_8643 select_8644 =>
      ((sing_elimUL_14) NULL NULL ((select_8644) true_5))
    end

#[program]
def proj1LUU_29 :=
  fun proj1_8645 {A_8646} -> {B_8647} -> (__8648) ->
    match __8648 with
    | apair_introLUU_37 x_8649 select_8650 =>
      ((sing_elimLL_12) NULL NULL ((select_8650) true_5))
    end

#[program]
def proj1LUL_28 :=
  fun proj1_8651 {A_8652} -> {B_8653} -> (__8654) ->
    match __8654 with
    | apair_introLUL_36 x_8655 select_8656 =>
      ((sing_elimLL_12) NULL NULL ((select_8656) true_5))
    end

#[program]
def proj1LLU_27 :=
  fun proj1_8657 {A_8658} -> {B_8659} -> (__8660) ->
    match __8660 with
    | apair_introLLU_35 x_8661 select_8662 =>
      ((sing_elimLL_12) NULL NULL ((select_8662) true_5))
    end

#[program]
def proj1LLL_26 :=
  fun proj1_8663 {A_8664} -> {B_8665} -> (__8666) ->
    match __8666 with
    | apair_introLLL_34 x_8667 select_8668 =>
      ((sing_elimLL_12) NULL NULL ((select_8668) true_5))
    end

#[program]
def proj2UUU_41 :=
  fun proj2_8669 {A_8670} -> {B_8671} -> (x_8672) ->
    match x_8672 with
    | apair_introUUU_41 x_8673 select_8674 =>
      match ((select_8674) false_6) with
      | boxU_17 m_8675 => m_8675
      end
    end

#[program]
def proj2UUL_40 :=
  fun proj2_8676 {A_8677} -> {B_8678} -> (x_8679) ->
    match x_8679 with
    | apair_introUUL_40 x_8680 select_8681 =>
      match ((select_8681) false_6) with
      | boxU_17 m_8682 => m_8682
      end
    end

#[program]
def proj2ULU_39 :=
  fun proj2_8683 {A_8684} -> {B_8685} -> (x_8686) ->
    match x_8686 with
    | apair_introULU_39 x_8687 select_8688 =>
      match ((select_8688) false_6) with
      | boxL_16 m_8689 => m_8689
      end
    end

#[program]
def proj2ULL_38 :=
  fun proj2_8690 {A_8691} -> {B_8692} -> (x_8693) ->
    match x_8693 with
    | apair_introULL_38 x_8694 select_8695 =>
      match ((select_8695) false_6) with
      | boxL_16 m_8696 => m_8696
      end
    end

#[program]
def proj2LUU_37 :=
  fun proj2_8697 {A_8698} -> {B_8699} -> (x_8700) ->
    match x_8700 with
    | apair_introLUU_37 x_8701 select_8702 =>
      match ((select_8702) false_6) with
      | boxU_17 m_8703 => m_8703
      end
    end

#[program]
def proj2LUL_36 :=
  fun proj2_8704 {A_8705} -> {B_8706} -> (x_8707) ->
    match x_8707 with
    | apair_introLUL_36 x_8708 select_8709 =>
      match ((select_8709) false_6) with
      | boxU_17 m_8710 => m_8710
      end
    end

#[program]
def proj2LLU_35 :=
  fun proj2_8711 {A_8712} -> {B_8713} -> (x_8714) ->
    match x_8714 with
    | apair_introLLU_35 x_8715 select_8716 =>
      match ((select_8716) false_6) with
      | boxL_16 m_8717 => m_8717
      end
    end

#[program]
def proj2LLL_34 :=
  fun proj2_8718 {A_8719} -> {B_8720} -> (x_8721) ->
    match x_8721 with
    | apair_introLLL_34 x_8722 select_8723 =>
      match ((select_8723) false_6) with
      | boxL_16 m_8724 => m_8724
      end
    end

#[program]
def my_apair0_9 :=
  (apair_introULU_39
    NULL
    fun _8725 (b_8726) ->
      match b_8726 with
      | true_5  => (justUL_20 zero_10)
      | false_6  => (boxL_16 ((nat_make_6) zero_10))
      end)

#[program]
def my_apair1_10 :=
  let nat_stream_8727 := ((nat_make_6) zero_10) in
  (apair_introULL_38
    NULL
    fun _8728 (b_8729) -o
      match b_8729 with
      | true_5  =>
        (justUL_20
          match ((uncons_streamU_25) NULL nat_stream_8727) with
          | pairULL_28 m_8730 n_8731 =>
            let __8732 := ((free_streamU_23) NULL n_8731) in m_8730
          end)
      | false_6  => (boxL_16 nat_stream_8727)
      end)

#[program]
def __11 := ((free_streamU_23) NULL ((proj2ULL_38) NULL NULL my_apair1_10))

-----------------------------------------

