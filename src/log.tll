[Inductive {name = "unit"; relv = R;
   body =
   (Binder ([],
      (PBase
         ((TBase (Type U)), [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
      ));
   view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase
                              (App
                                 [(Id ("eq", I)); (Id ("m", I));
                                   (Id ("m", I))])),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "exists"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("ex",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (N,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("pf",
                                       (TBase
                                          (App
                                             [(Id ("exists", I));
                                               (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "s"))))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m",
                           (TBase (App [(Id ("sing", I)); (Id ("m", I))]))))
                        )),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "list"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type U)),
                 [(DConstr ("nil",
                     (TBase (App [(Id ("list", I)); (Id ("A", I))])), 
                     []));
                   (DConstr ("cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (App [(Id ("list", I)); (Id ("A", I))]),
                               (Binder ("tl",
                                  (TBase
                                     (App [(Id ("list", I)); (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Inductive {name = "vec"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("nat", I)), (Binder ("_", (TBase (Type U))))
                    )),
                 [(DConstr ("vnil",
                     (TBase
                        (App
                           [(Id ("vec", I)); (Id ("A", I)); (Id ("zero", I))])),
                     []));
                   (DConstr ("vcons",
                      (TBind (N, (Id ("nat", I)),
                         (Binder ("n",
                            (TBind (R, (Id ("A", I)),
                               (Binder ("hd",
                                  (TBind (R,
                                     (App
                                        [(Inst ("vec", [(SId "s")], I));
                                          (Id ("A", I)); (Id ("n", I))]),
                                     (Binder ("tl",
                                        (TBase
                                           (App
                                              [(Id ("vec", I));
                                                (Id ("A", I));
                                                (App
                                                   [(Id ("succ", I));
                                                     (Id ("n", I))])
                                                ]))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         )),
                      [I; E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Definition {name = "uncons2"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("nat", I)),
                    (Binder ("n",
                       (Pi (R, U,
                          (App
                             [(Id ("vec", I)); (Id ("A", I)); (Id ("n", I))]),
                          (Binder ("_",
                             (Pi (R, U,
                                (App
                                   [(Id ("vec", I)); (Id ("A", I));
                                     (Id ("n", I))]),
                                (Binder ("_", (Id ("unit", I))))))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "uncons2"),
              [([(PId "A"); (PId "n"); (PId "vnil"); (PId "vnil")],
                (Some (Id ("tt", I))));
                ([(PId "A"); (PId "n");
                   (PConstr ("vcons", [(PId "_"); (PId "_"); (PId "_")]));
                   (PConstr ("vcons", [(PId "_"); (PId "_"); (PId "_")]))],
                 (Some (Id ("tt", I))))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("nat", I)),
                 (Binder ("n",
                    (Pi (R, U,
                       (App [(Id ("vec", I)); (Id ("A", I)); (Id ("n", I))]),
                       (Binder ("_",
                          (Pi (R, U,
                             (App
                                [(Id ("vec", I)); (Id ("A", I));
                                  (Id ("n", I))]),
                             (Binder ("_", (Id ("unit", I))))))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]}
  ]

-----------------------------------------

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_66 : nat_3) : nat_3

#[logical]
inductive eq_4‹s_67› (A_68 : Type‹s_67›) (m_69 : A_68): A_68 -> U
where
| refl_6 : (eq_4‹??_1› ?_1 m_69 m_69)

#[program]
inductive exists_5‹s_71,r_72,t_73› (A_74 : Type‹s_71›) (B_75 : 
A_74 -> Type‹r_72›): Type‹t_73› where
| ex_7
    (m_77 : A_74) {pf_78 : ((B_75) m_77)}
    : (exists_5‹??_2,??_3,??_4› ?_2 B_75)

#[program]
inductive sing_6‹s_79› (A_80 : Type‹s_79›): A_80 -> Type‹s_79›
where
| just_8 (m_82 : A_80) : (sing_6‹??_5› ?_3 m_82)

#[program]
inductive list_7‹s_83› (A_84 : Type‹s_83›): U where
| nil_9 : (list_7‹??_6› A_84)
| cons_10
    (hd_85 : A_84) (tl_86 : (list_7‹??_7› A_84))
    : (list_7‹??_8› A_84)

#[program]
inductive vec_8‹s_87› (A_88 : Type‹s_87›): nat_3 -> U where
| vnil_11 : (vec_8‹??_9› A_88 zero_4)
| vcons_12
    {n_90 : nat_3} (hd_91 : A_88) (tl_92 : (vec_8‹s_87› A_88 n_90))
    : (vec_8‹??_10› A_88 (succ_5‹› n_90))

#[program]
def uncons2_1‹s_93› :
  ∀ {A_94 : Type‹s_93›} ->
    ∀ {n_95 : nat_3} ->
      (vec_8‹??_13› A_94 n_95) -> (vec_8‹??_14› A_94 n_95) -> unit_1
:=
  function uncons2_98 :
    ∀ {A_99 : Type‹s_93›} ->
      ∀ {n_100 : nat_3} ->
        (vec_8‹??_11› A_99 n_100) ->
          (vec_8‹??_12› A_99 n_100) -> unit_1
  | A_103 n_104 vnil_11 vnil_11 => tt_1
  | A_105 n_106 (vcons_12 _107 _108 _109) (vcons_12 _110 _111 _112) => tt_1

-----------------------------------------

inductive-------------------------
infer_tm(unit_1)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(bool_2)
infer_tm(bool_2)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(nat_3)
infer_tm(nat_3)
infer_tm(nat_3)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(Type‹s_115›)
infer_tm(A_116)
infer_tm(A_116)
infer_tm(Type‹s_119›)
infer_tm(A_120)
assert_equal1( A_120, ?_1)
assert_equal1( m_121, m_121)
infer_tm((eq_4‹??_1› ?_1 m_121 m_121))
check_tm( ?_1, Type‹??_1›)
check_tm( m_121, ?_1)
infer_tm(m_121)
assert_equal1( ?_1, A_120)
check_tm( m_121, ?_1)
infer_tm(m_121)
assert_equal1( ?_1, A_120)
simpl_tm ~expand:false( ?_1, A_120)
simpl_tm ~expand:false( A_120, A_120)
simpl_tm ~expand:false( A_120, A_120)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_122
    
  |}
  imeta_meta {|
    ?_1 <= A_125
    
  |}
  eqns {|
    
  |}
end_dump
infer_tm(Type‹s_119›)
check_tm( A_120, Type‹s_119›)
infer_tm(A_120)
assert_equal1( Type‹s_119›, Type‹s_119›)
----------------------------------

inductive-------------------------
infer_tm(Type‹s_137›)
infer_tm(A_140 -> Type‹r_138›)
infer_tm(A_140)
infer_tm(Type‹r_138›)
infer_tm(Type‹s_144›)
infer_tm(A_147 -> Type‹r_145›)
infer_tm(A_147)
infer_tm(Type‹r_145›)
infer_tm(A_147)
infer_tm(((B_148) m_151))
infer_tm(B_148)
check_tm( m_151, A_147)
infer_tm(m_151)
assert_equal1( A_147, A_147)
assert_equal1( A_147, ?_2)
assert_equal1( B_148, B_148)
infer_tm((exists_5‹??_2,??_3,??_4› ?_2 B_148))
check_tm( ?_2, Type‹??_2›)
check_tm( B_148, ?_2 -> Type‹??_3›)
infer_tm(B_148)
assert_equal1( ?_2 -> Type‹??_3›, A_147 -> Type‹r_145›)
simpl_tm ~expand:false( ?_2 -> Type‹??_3›, A_147 -> Type‹r_145›)
simpl_tm ~expand:false( ?_2, A_147)
simpl_tm ~expand:false( Type‹??_3›, Type‹r_145›)
simpl_tm ~expand:false( A_147, A_147)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_162
    ??_2 <= s_165
    ??_3 <= r_167
    ??_4 <= t_169
    
  |}
  imeta_meta {|
    ?_1 <= A_174
    ?_2 <= A_181
    
  |}
  eqns {|
    
  |}
end_dump
infer_tm(Type‹s_144›)
check_tm( A_147, Type‹s_144›)
infer_tm(A_147)
assert_equal1( Type‹s_144›, Type‹s_144›)
----------------------------------

inductive-------------------------
infer_tm(Type‹s_214›)
infer_tm(A_215)
infer_tm(Type‹s_217›)
infer_tm(A_218)
assert_equal1( A_218, ?_3)
infer_tm((sing_6‹??_5› ?_3 m_219))
check_tm( ?_3, Type‹??_5›)
check_tm( m_219, ?_3)
infer_tm(m_219)
assert_equal1( ?_3, A_218)
simpl_tm ~expand:false( ?_3, A_218)
simpl_tm ~expand:false( A_218, A_218)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_220
    ??_2 <= s_223
    ??_3 <= r_225
    ??_4 <= t_227
    ??_5 <= s_230
    
  |}
  imeta_meta {|
    ?_1 <= A_233
    ?_2 <= A_240
    ?_3 <= A_243
    
  |}
  eqns {|
    
  |}
end_dump
infer_tm(Type‹s_217›)
check_tm( A_218, Type‹s_217›)
infer_tm(A_218)
assert_equal1( Type‹s_217›, Type‹s_217›)
----------------------------------

inductive-------------------------
infer_tm(Type‹s_256›)
infer_tm(Type‹s_258›)
assert_equal1( A_259, A_259)
infer_tm((list_7‹??_6› A_259))
check_tm( A_259, Type‹??_6›)
infer_tm(A_259)
assert_equal1( Type‹??_6›, Type‹s_258›)
simpl_tm ~expand:false( Type‹??_6›, Type‹s_258›)
infer_tm(Type‹s_260›)
infer_tm(A_261)
infer_tm((list_7‹??_7› A_261))
check_tm( A_261, Type‹??_7›)
infer_tm(A_261)
assert_equal1( Type‹??_7›, Type‹s_260›)
simpl_tm ~expand:false( Type‹??_7›, Type‹s_260›)
assert_equal1( A_261, A_261)
infer_tm((list_7‹??_8› A_261))
check_tm( A_261, Type‹??_8›)
infer_tm(A_261)
assert_equal1( Type‹??_8›, Type‹s_260›)
simpl_tm ~expand:false( Type‹??_8›, Type‹s_260›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_264
    ??_2 <= s_267
    ??_3 <= r_269
    ??_4 <= t_271
    ??_5 <= s_274
    ??_6 <= s_275
    ??_7 <= s_276
    ??_8 <= s_277
    
  |}
  imeta_meta {|
    ?_1 <= A_280
    ?_2 <= A_287
    ?_3 <= A_290
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(Type‹s_306›)
infer_tm(nat_3)
infer_tm(Type‹s_309›)
assert_equal1( A_310, A_310)
infer_tm((vec_8‹??_9› A_310 zero_4))
check_tm( A_310, Type‹??_9›)
infer_tm(A_310)
assert_equal1( Type‹??_9›, Type‹s_309›)
check_tm( zero_4, nat_3)
infer_tm(zero_4)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_9›, Type‹s_309›)
infer_tm(Type‹s_311›)
infer_tm(nat_3)
infer_tm(A_312)
infer_tm((vec_8‹s_311› A_312 n_313))
check_tm( A_312, Type‹s_311›)
infer_tm(A_312)
assert_equal1( Type‹s_311›, Type‹s_311›)
check_tm( n_313, nat_3)
infer_tm(n_313)
assert_equal1( nat_3, nat_3)
assert_equal1( A_312, A_312)
infer_tm((vec_8‹??_10› A_312 (succ_5‹› n_313)))
check_tm( A_312, Type‹??_10›)
infer_tm(A_312)
assert_equal1( Type‹??_10›, Type‹s_311›)
check_tm( (succ_5‹› n_313), nat_3)
infer_tm((succ_5‹› n_313))
check_tm( n_313, nat_3)
infer_tm(n_313)
assert_equal1( nat_3, nat_3)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_10›, Type‹s_311›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_316
    ??_2 <= s_319
    ??_3 <= r_321
    ??_4 <= t_323
    ??_5 <= s_326
    ??_6 <= s_327
    ??_7 <= s_328
    ??_8 <= s_329
    ??_9 <= s_330
    ??_10 <= s_331
    
  |}
  imeta_meta {|
    ?_1 <= A_334
    ?_2 <= A_341
    ?_3 <= A_344
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

definition-------------------------
infer_tm(∀ {A_367 : Type‹s_366›} ->
           ∀ {n_368 : nat_3} ->
             (vec_8‹??_13› A_367 n_368) ->
               (vec_8‹??_14› A_367 n_368) -> unit_1)
infer_tm(Type‹s_366›)
infer_tm(∀ {n_372 : nat_3} ->
           (vec_8‹??_13› A_371 n_372) ->
             (vec_8‹??_14› A_371 n_372) -> unit_1)
infer_tm(nat_3)
infer_tm((vec_8‹??_13› A_371 n_375) ->
           (vec_8‹??_14› A_371 n_375) -> unit_1)
infer_tm((vec_8‹??_13› A_371 n_375))
check_tm( A_371, Type‹??_13›)
infer_tm(A_371)
assert_equal1( Type‹??_13›, Type‹s_366›)
check_tm( n_375, nat_3)
infer_tm(n_375)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_13›, Type‹s_366›)
infer_tm((vec_8‹??_14› A_371 n_375) -> unit_1)
infer_tm((vec_8‹??_14› A_371 n_375))
check_tm( A_371, Type‹??_14›)
infer_tm(A_371)
assert_equal1( Type‹??_14›, Type‹s_366›)
check_tm( n_375, nat_3)
infer_tm(n_375)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_14›, Type‹s_366›)
infer_tm(unit_1)
check_tm(
  function uncons2_381 :
    ∀ {A_382 : Type‹s_366›} ->
      ∀ {n_383 : nat_3} ->
        (vec_8‹??_11› A_382 n_383) ->
          (vec_8‹??_12› A_382 n_383) -> unit_1
  | A_386 n_387 vnil_11 vnil_11 => tt_1
  | A_388 n_389 (vcons_12 _390 _391 _392) (vcons_12 _393 _394 _395) => tt_1,
  ∀ {A_396 : Type‹s_366›} ->
    ∀ {n_397 : nat_3} ->
      (vec_8‹??_13› A_396 n_397) ->
        (vec_8‹??_14› A_396 n_397) -> unit_1)
infer_tm(∀ {A_401 : Type‹s_366›} ->
           ∀ {n_402 : nat_3} ->
             (vec_8‹??_11› A_401 n_402) ->
               (vec_8‹??_12› A_401 n_402) -> unit_1)
infer_tm(Type‹s_366›)
infer_tm(∀ {n_406 : nat_3} ->
           (vec_8‹??_11› A_405 n_406) ->
             (vec_8‹??_12› A_405 n_406) -> unit_1)
infer_tm(nat_3)
infer_tm((vec_8‹??_11› A_405 n_409) ->
           (vec_8‹??_12› A_405 n_409) -> unit_1)
infer_tm((vec_8‹??_11› A_405 n_409))
check_tm( A_405, Type‹??_11›)
infer_tm(A_405)
assert_equal1( Type‹??_11›, Type‹s_366›)
check_tm( n_409, nat_3)
infer_tm(n_409)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_11›, Type‹s_366›)
infer_tm((vec_8‹??_12› A_405 n_409) -> unit_1)
infer_tm((vec_8‹??_12› A_405 n_409))
check_tm( A_405, Type‹??_12›)
infer_tm(A_405)
assert_equal1( Type‹??_12›, Type‹s_366›)
check_tm( n_409, nat_3)
infer_tm(n_409)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_12›, Type‹s_366›)
infer_tm(unit_1)
assert_equal1(
  ∀ {A_415 : Type‹s_366›} ->
    ∀ {n_416 : nat_3} ->
      (vec_8‹??_13› A_415 n_416) ->
        (vec_8‹??_14› A_415 n_416) -> unit_1,
  ∀ {A_419 : Type‹s_366›} ->
    ∀ {n_420 : nat_3} ->
      (vec_8‹??_11› A_419 n_420) ->
        (vec_8‹??_12› A_419 n_420) -> unit_1)
simpl_tm ~expand:false(
  ∀ {A_457 : Type‹s_366›} ->
    ∀ {n_458 : nat_3} ->
      (vec_8‹s_366› A_457 n_458) ->
        (vec_8‹s_366› A_457 n_458) -> unit_1,
  ∀ {A_461 : Type‹s_366›} ->
    ∀ {n_462 : nat_3} ->
      (vec_8‹s_366› A_461 n_462) ->
        (vec_8‹s_366› A_461 n_462) -> unit_1)
simpl_tm ~expand:false( Type‹s_366›, Type‹s_366›)
simpl_tm ~expand:false(
  ∀ {n_466 : nat_3} ->
    (vec_8‹s_366› A_465 n_466) ->
      (vec_8‹s_366› A_465 n_466) -> unit_1,
  ∀ {n_469 : nat_3} ->
    (vec_8‹s_366› A_465 n_469) ->
      (vec_8‹s_366› A_465 n_469) -> unit_1)
simpl_tm ~expand:false( nat_3, nat_3)
simpl_tm ~expand:false(
  (vec_8‹s_366› A_465 n_472) -> (vec_8‹s_366› A_465 n_472) -> unit_1,
  (vec_8‹s_366› A_465 n_472) -> (vec_8‹s_366› A_465 n_472) -> unit_1)
simpl_tm ~expand:false( (vec_8‹s_366› A_465 n_472),
  (vec_8‹s_366› A_465 n_472))
simpl_tm ~expand:false( A_465, A_465)
simpl_tm ~expand:false( n_472, n_472)
simpl_tm ~expand:false( (vec_8‹s_366› A_465 n_472) -> unit_1,
  (vec_8‹s_366› A_465 n_472) -> unit_1)
simpl_tm ~expand:false( (vec_8‹s_366› A_465 n_472),
  (vec_8‹s_366› A_465 n_472))
simpl_tm ~expand:false( A_465, A_465)
simpl_tm ~expand:false( n_472, n_472)
simpl_tm ~expand:false( unit_1, unit_1)
check_cls {|
  prblm {| ;
    {|  ::: [A_433, n_434, vnil_11, vnil_11] =>? tt_1 |}
    {|  ::: [A_435, n_436, (vcons_12 _437 _438 _439), (vcons_12 _440 _441 _442)] =>?
         tt_1
    |}
  |}
|}
case_intro
case_intro
case_intro
case_intro
case_splitting
splitting_on(vnil_11)
case_splitting
splitting_on(vnil_11)
case_coverage{|
  prblm {|
    eq_term?( (vec_8‹s_366› #A_488 #n_489),
      (vec_8‹s_366› #A_488 zero_4))
    eq_term?( (vec_8‹s_366› #A_488 #n_489),
      (vec_8‹s_366› #A_488 zero_4));
    {| eq_pat?( #A_488, A_433 : Type‹s_366›)
       eq_pat?( #n_489, n_434 : nat_3) ::: [] =>? tt_1
    |}
  |}
|}
unify_pprbm(
  eq_term?( (vec_8‹s_366› #A_488 #n_489),
    (vec_8‹s_366› #A_488 zero_4))
  eq_term?( (vec_8‹s_366› #A_488 #n_489),
    (vec_8‹s_366› #A_488 zero_4))
  eq_pat?( #A_488, A_433 : Type‹s_366›)
  eq_pat?( #n_489, n_434 : nat_3)
)
simpl_pprbm ~expand:false( (vec_8‹s_366› #A_488 #n_489),
  (vec_8‹s_366› #A_488 zero_4))
simpl_pprbm ~expand:false( #A_488, #A_488)
simpl_pprbm ~expand:false( #n_489, zero_4)
simpl_pprbm ~expand:false( (vec_8‹s_366› #A_488 #n_489),
  (vec_8‹s_366› #A_488 zero_4))
simpl_pprbm ~expand:false( #A_488, #A_488)
simpl_pprbm ~expand:false( #n_489, zero_4)
simpl_pprbm ~expand:false( #A_488, #A_433)
simpl_pprbm ~expand:false( #n_489, #n_434)
simpl_pprbm ~expand:false( zero_4, #n_489)
simpl_pprbm ~expand:false( zero_4, zero_4)
simpl_pprbm ~expand:false( #A_488, #A_433)
simpl_pprbm ~expand:false( zero_4, #n_434)
case_coverage_ok( tt_1, unit_1)
check_tm( tt_1, unit_1)
infer_tm(tt_1)
assert_equal1( unit_1, unit_1)
splitting_on(vcons_12)
case_empty
unify_pprbm(
  eq_term?( (vec_8‹s_366› #A_488 #n_489),
    (vec_8‹s_366› #A_488 (succ_5‹› #n_513)))
  eq_term?( (vec_8‹s_366› #A_488 #n_489),
    (vec_8‹s_366› #A_488 zero_4))
)
simpl_pprbm ~expand:false( (vec_8‹s_366› #A_488 #n_489),
  (vec_8‹s_366› #A_488 (succ_5‹› #n_513)))
simpl_pprbm ~expand:false( #A_488, #A_488)
simpl_pprbm ~expand:false( #n_489, (succ_5‹› #n_513))
simpl_pprbm ~expand:false( (vec_8‹s_366› #A_488 #n_489),
  (vec_8‹s_366› #A_488 zero_4))
simpl_pprbm ~expand:false( #A_488, #A_488)
simpl_pprbm ~expand:false( #n_489, zero_4)
simpl_pprbm ~expand:false( (succ_5‹› #n_513), #n_489)
simpl_pprbm ~expand:false( zero_4, (succ_5‹› #n_513))
simpl_pprbm ~expand:true( zero_4, (succ_5‹› #n_513))
splitting_on(vcons_12)
case_splitting
splitting_on(vnil_11)
case_empty
unify_pprbm(
  eq_term?( (vec_8‹s_366› #A_488 #n_489),
    (vec_8‹s_366› #A_488 zero_4))
  eq_term?( (vec_8‹s_366› #A_488 #n_489),
    (vec_8‹s_366› #A_488 (succ_5‹› #n_523)))
)
simpl_pprbm ~expand:false( (vec_8‹s_366› #A_488 #n_489),
  (vec_8‹s_366› #A_488 zero_4))
simpl_pprbm ~expand:false( #A_488, #A_488)
simpl_pprbm ~expand:false( #n_489, zero_4)
simpl_pprbm ~expand:false( (vec_8‹s_366› #A_488 #n_489),
  (vec_8‹s_366› #A_488 (succ_5‹› #n_523)))
simpl_pprbm ~expand:false( #A_488, #A_488)
simpl_pprbm ~expand:false( #n_489, (succ_5‹› #n_523))
simpl_pprbm ~expand:false( zero_4, #n_489)
simpl_pprbm ~expand:false( (succ_5‹› #n_523), zero_4)
simpl_pprbm ~expand:true( (succ_5‹› #n_523), zero_4)
splitting_on(vcons_12)
case_coverage{|
  prblm {|
    eq_term?( (vec_8‹s_366› #A_488 #n_489),
      (vec_8‹s_366› #A_488 (succ_5‹› #n_540)))
    eq_term?( (vec_8‹s_366› #A_488 #n_489),
      (vec_8‹s_366› #A_488 (succ_5‹› #n_523)));
    {| eq_pat?( #A_488, A_435 : Type‹s_366›)
       eq_pat?( #n_489, n_436 : nat_3)
       eq_pat?( #n_523, _437 : nat_3)
       eq_pat?( #hd_524, _438 : #A_488)
       eq_pat?( #tl_525, _439 : (vec_8‹s_366› #A_488 #n_523))
       eq_pat?( #n_540, _440 : nat_3)
       eq_pat?( #hd_541, _441 : #A_488)
       eq_pat?( #tl_542, _442 : (vec_8‹s_366› #A_488 #n_540)) ::: [] =>?
         tt_1
    |}
  |}
|}
unify_pprbm(
  eq_term?( (vec_8‹s_366› #A_488 #n_489),
    (vec_8‹s_366› #A_488 (succ_5‹› #n_540)))
  eq_term?( (vec_8‹s_366› #A_488 #n_489),
    (vec_8‹s_366› #A_488 (succ_5‹› #n_523)))
  eq_pat?( #A_488, A_435 : Type‹s_366›)
  eq_pat?( #n_489, n_436 : nat_3)
  eq_pat?( #n_523, _437 : nat_3)
  eq_pat?( #hd_524, _438 : #A_488)
  eq_pat?( #tl_525, _439 : (vec_8‹s_366› #A_488 #n_523))
  eq_pat?( #n_540, _440 : nat_3)
  eq_pat?( #hd_541, _441 : #A_488)
  eq_pat?( #tl_542, _442 : (vec_8‹s_366› #A_488 #n_540))
)
simpl_pprbm ~expand:false( (vec_8‹s_366› #A_488 #n_489),
  (vec_8‹s_366› #A_488 (succ_5‹› #n_540)))
simpl_pprbm ~expand:false( #A_488, #A_488)
simpl_pprbm ~expand:false( #n_489, (succ_5‹› #n_540))
simpl_pprbm ~expand:false( (vec_8‹s_366› #A_488 #n_489),
  (vec_8‹s_366› #A_488 (succ_5‹› #n_523)))
simpl_pprbm ~expand:false( #A_488, #A_488)
simpl_pprbm ~expand:false( #n_489, (succ_5‹› #n_523))
simpl_pprbm ~expand:false( #A_488, #A_435)
simpl_pprbm ~expand:false( #n_489, #n_436)
simpl_pprbm ~expand:false( #n_523, #_437)
simpl_pprbm ~expand:false( #hd_524, #_438)
simpl_pprbm ~expand:false( #tl_525, #_439)
simpl_pprbm ~expand:false( #n_540, #_440)
simpl_pprbm ~expand:false( #hd_541, #_441)
simpl_pprbm ~expand:false( #tl_542, #_442)
simpl_pprbm ~expand:false( (succ_5‹› #n_540), #n_489)
simpl_pprbm ~expand:false( (succ_5‹› #n_523), (succ_5‹› #n_540))
simpl_pprbm ~expand:false( #n_523, #n_540)
simpl_pprbm ~expand:false( #A_488, #A_435)
simpl_pprbm ~expand:false( (succ_5‹› #n_540), #n_436)
simpl_pprbm ~expand:false( #n_540, #_437)
simpl_pprbm ~expand:false( #hd_524, #_438)
simpl_pprbm ~expand:false( #tl_525, #_439)
simpl_pprbm ~expand:false( #n_540, #_440)
simpl_pprbm ~expand:false( #hd_541, #_441)
simpl_pprbm ~expand:false( #tl_542, #_442)
case_coverage_ok( tt_1, unit_1)
check_tm( tt_1, unit_1)
infer_tm(tt_1)
assert_equal1( unit_1, unit_1)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_557
    ??_2 <= s_560
    ??_3 <= r_562
    ??_4 <= t_564
    ??_5 <= s_567
    ??_6 <= s_568
    ??_7 <= s_569
    ??_8 <= s_570
    ??_9 <= s_571
    ??_10 <= s_572
    ??_11 <= s_573
    ??_12 <= s_574
    ??_13 <= s_575
    ??_14 <= s_576
    
  |}
  imeta_meta {|
    ?_1 <= A_579
    ?_2 <= A_586
    ?_3 <= A_589
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

smeta_meta {|
  ??_1 <= s_622
  ??_2 <= s_625
  ??_3 <= r_627
  ??_4 <= t_629
  ??_5 <= s_632
  ??_6 <= s_633
  ??_7 <= s_634
  ??_8 <= s_635
  ??_9 <= s_636
  ??_10 <= s_637
  ??_11 <= s_638
  ??_12 <= s_639
  ??_13 <= s_640
  ??_14 <= s_641
  
|}
imeta_meta {|
  ?_1 <= A_644
  ?_2 <= A_651
  ?_3 <= A_654
  
|}
#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_778 : nat_3) : nat_3

#[logical]
inductive eq_4‹s_779› (A_780 : Type‹s_779›) (m_781 : A_780):
  A_780 -> U
where
| refl_6 : (eq_4‹s_779› A_780 m_781 m_781)

#[program]
inductive exists_5‹s_783,r_784,t_785› (A_786 : Type‹s_783›) (B_787 : 
A_786 -> Type‹r_784›): Type‹t_785› where
| ex_7
    (m_789 : A_786) {pf_790 : ((B_787) m_789)}
    : (exists_5‹s_783,r_784,t_785› A_786 B_787)

#[program]
inductive sing_6‹s_791› (A_792 : Type‹s_791›):
  A_792 -> Type‹s_791›
where
| just_8 (m_794 : A_792) : (sing_6‹s_791› A_792 m_794)

#[program]
inductive list_7‹s_795› (A_796 : Type‹s_795›): U where
| nil_9 : (list_7‹s_795› A_796)
| cons_10
    (hd_797 : A_796) (tl_798 : (list_7‹s_795› A_796))
    : (list_7‹s_795› A_796)

#[program]
inductive vec_8‹s_799› (A_800 : Type‹s_799›): nat_3 -> U where
| vnil_11 : (vec_8‹s_799› A_800 zero_4)
| vcons_12
    {n_802 : nat_3} (hd_803 : A_800)
    (tl_804 : (vec_8‹s_799› A_800 n_802))
    : (vec_8‹s_799› A_800 (succ_5‹› n_802))

#[program]
def uncons2_1‹s_805› :
  ∀ {A_806 : Type‹s_805›} ->
    ∀ {n_807 : nat_3} ->
      (vec_8‹s_805› A_806 n_807) ->
        (vec_8‹s_805› A_806 n_807) -> unit_1
:=
  function uncons2_810 :
    ∀ {A_811 : Type‹s_805›} ->
      ∀ {n_812 : nat_3} ->
        (vec_8‹s_805› A_811 n_812) ->
          (vec_8‹s_805› A_811 n_812) -> unit_1
  | A_815 n_816 vnil_11 vnil_11 => tt_1
  | A_817 n_818 (vcons_12 _819 _820 _821) (vcons_12 _822 _823 _824) => tt_1

-----------------------------------------

