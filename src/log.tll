[Inductive {name = "unit"; relv = R;
   body =
   (Binder ([],
      (PBase ((TBase (Type U)), [(DMul ("tt", (TBase (Id "unit"))))]))))};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DMul ("zero", (TBase (Id "nat"))));
             (DMul ("succ",
                (TBind (R, (Id "nat"), (Binder ("n", (TBase (Id "nat"))))))))
             ]))
       ))};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id "A"),
                    (Binder ("_", (TBase (Type (SId "s"))))))),
                 [(DMul ("just",
                     (TBind (R, (Id "A"),
                        (Binder ("m",
                           (TBase (App [(Id "sing"); (Id "_"); (Id "m")]))))
                        ))
                     ))
                   ]))
             ))
          ))
       ))};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id "A"),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id "A"), (Binder ("_", (TBase (Type U))))
                          )),
                       [(DMul ("eq_refl",
                           (TBase
                              (App [(Id "eq"); (Id "_"); (Id "m"); (Id "m")]))
                           ))
                         ]))
                   ))
                ))
             ))
          ))
       ))};
  Definition {name = "test"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Id "sing"); (Id "nat"); (App [(Id "succ"); (Id "zero")])]),
              (Binder ("_", (Id "unit"))))),
           (Binder ((Some "test"),
              [([(PMul ("just", [(PId "x")]))],
                (Some (Let (R,
                         (Ann ((Id "eq_refl"),
                            (App
                               [(Id "eq"); (Id "_"); (Id "x");
                                 (App [(Id "succ"); (Id "zero")])])
                            )),
                         (Binder ("pf", (Id "tt")))))))
                ]
              ))
           )),
        (Pi (R, U,
           (App [(Id "sing"); (Id "nat"); (App [(Id "succ"); (Id "zero")])]),
           (Binder ("_", (Id "unit"))))))
       ))};
  Definition {name = "print"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (Id "A"), (Binder ("x", (IO (Id "unit"))))))))
              )),
           (Binder ((Some "print"),
              [([(PId "A"); (PId "x")], (Some (Magic (Id "_"))))]))
           )),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (R, U, (Id "A"), (Binder ("x", (IO (Id "unit"))))))))
           )))
       ))};
  Definition {name = "_"; relv = R;
    body =
    (Binder ([],
       ((App [(Id "print"); (Id "_"); (Id "tt")]), (IO (Id "unit")))))}
  ]

-----------------------------------------

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive nat_2‹› : U where
| zero_2 : nat_2
| succ_3 (n_27 : nat_2) : nat_2

#[program]
inductive sing_3‹s_28› (A_29 : Type‹s_28›): A_29 -> Type‹s_28›
where
| just_4 (m_31 : A_29) : (sing_3‹??_1› ?_1 m_31)

#[logical]
inductive eq_4‹s_32› (A_33 : Type‹s_32›) (m_34 : A_33): A_33 -> U
where
| eq_refl_5 : (eq_4‹??_2› ?_2 m_34 m_34)

#[program]
def test_1‹› : (sing_3‹??_6› nat_2 (succ_3‹› zero_2)) -> unit_1
:=
  function test_37 : (sing_3‹??_3› nat_2 (succ_3‹› zero_2)) -> unit_1
  | (just_4 x_39) =>
    let pf_40 :=
      (eq_refl_5‹??_4› : (eq_4‹??_5› ?_5 x_39 (succ_3‹› zero_2)))
    in tt_1

#[program]
def print_2‹s_41› : ∀ {A_42 : Type‹s_41›} -> A_42 -> IO unit_1 :=
  function print_44 : ∀ {A_45 : Type‹s_41›} -> A_45 -> IO unit_1
  | A_47 x_48 => #magic[?_6]

#[program]
def __3‹› : IO unit_1 := (print_2‹??_7›) ?_7 tt_1

-----------------------------------------

infer_tm(unit_1)
infer_tm(nat_2)
infer_tm(nat_2)
infer_tm(nat_2)
infer_tm(Type‹s_51›)
infer_tm(A_52)
infer_tm(Type‹s_54›)
infer_tm(A_55)
infer_tm((sing_3‹??_1› ?_1 m_56))
check_tm(?_1, Type‹??_1›)
check_tm(m_56, ?_1)
infer_tm(m_56)
loop_check(A_55 Type‹s_54›)
infer_tm(Type‹s_54›)
check_tm(A_55, Type‹s_54›)
infer_tm(A_55)
infer_tm(Type‹s_69›)
infer_tm(A_70)
infer_tm(A_70)
infer_tm(Type‹s_73›)
infer_tm(A_74)
infer_tm((eq_4‹??_2› ?_2 m_75 m_75))
check_tm(?_2, Type‹??_2›)
check_tm(m_75, ?_2)
infer_tm(m_75)
check_tm(m_75, ?_2)
infer_tm(m_75)
loop_check(A_74 Type‹s_73›)
infer_tm(Type‹s_73›)
check_tm(A_74, Type‹s_73›)
infer_tm(A_74)
infer_tm((sing_3‹??_6› nat_2 (succ_3‹› zero_2)) -> unit_1)
infer_tm((sing_3‹??_6› nat_2 (succ_3‹› zero_2)))
check_tm(nat_2, Type‹??_6›)
infer_tm(nat_2)
check_tm((succ_3‹› zero_2), nat_2)
infer_tm((succ_3‹› zero_2))
check_tm(zero_2, nat_2)
infer_tm(zero_2)
infer_tm(unit_1)
check_tm(function test_89 :
           (sing_3‹??_3› nat_2 (succ_3‹› zero_2)) -> unit_1
         | (just_4 x_91) =>
           let pf_92 :=
             (eq_refl_5‹??_4›
               : (eq_4‹??_5› ?_5 x_91 (succ_3‹› zero_2)))
           in tt_1, (sing_3‹??_6› nat_2 (succ_3‹› zero_2)) -> unit_1)
infer_tm(function test_94 :
           (sing_3‹??_3› nat_2 (succ_3‹› zero_2)) -> unit_1
         | (just_4 x_96) =>
           let pf_97 :=
             (eq_refl_5‹??_4›
               : (eq_4‹??_5› ?_5 x_96 (succ_3‹› zero_2)))
           in tt_1)
infer_tm((sing_3‹??_3› nat_2 (succ_3‹› zero_2)) -> unit_1)
infer_tm((sing_3‹??_3› nat_2 (succ_3‹› zero_2)))
check_tm(nat_2, Type‹??_3›)
infer_tm(nat_2)
check_tm((succ_3‹› zero_2), nat_2)
infer_tm((succ_3‹› zero_2))
check_tm(zero_2, nat_2)
infer_tm(zero_2)
infer_tm(unit_1)
case_coverage{|
  prblm {|
    eq_term?( (sing_3‹U› nat_2 (succ_3‹› zero_2)),
      (sing_3‹U› nat_2 #m_104));
    {| eq_pat?( #m_104, x_101 : nat_2) ::: [] =>?
         let pf_106 :=
           (eq_refl_5‹??_4›
             : (eq_4‹??_5› ?_5 #x_101 (succ_3‹› zero_2)))
         in tt_1
    |}
  |}
|}
solve_pprm(
  eq_term?( (sing_3‹U› nat_2 (succ_3‹› zero_2)),
    (sing_3‹U› nat_2 #m_104))
  eq_pat?( #m_104, x_101 : nat_2)
)
case_coverage_ok(let pf_109 :=
                   (eq_refl_5‹??_4›
                     : (eq_4‹??_5›
                         ?_5 (succ_3‹› zero_2) (succ_3‹› zero_2)))
                 in tt_1, unit_1)
check_tm(let pf_110 :=
           (eq_refl_5‹??_4›
             : (eq_4‹??_5›
                 ?_5 (succ_3‹› zero_2) (succ_3‹› zero_2)))
         in tt_1, unit_1)
infer_tm(let pf_111 :=
           (eq_refl_5‹??_4›
             : (eq_4‹??_5›
                 ?_5 (succ_3‹› zero_2) (succ_3‹› zero_2)))
         in tt_1)
infer_tm((eq_refl_5‹??_4›
           : (eq_4‹??_5› ?_5 (succ_3‹› zero_2) (succ_3‹› zero_2))))
infer_tm((eq_4‹??_5› ?_5 (succ_3‹› zero_2) (succ_3‹› zero_2)))
check_tm(?_5, Type‹??_5›)
check_tm((succ_3‹› zero_2), ?_5)
infer_tm((succ_3‹› zero_2))
check_tm(zero_2, nat_2)
infer_tm(zero_2)
check_tm((succ_3‹› zero_2), ?_5)
infer_tm((succ_3‹› zero_2))
check_tm(zero_2, nat_2)
infer_tm(zero_2)
check_tm(eq_refl_5‹??_4›, (eq_4‹??_5›
                                ?_5 (succ_3‹› zero_2)
                                (succ_3‹› zero_2)))
infer_tm(eq_refl_5‹??_4›)
check_tm(?_3, Type‹??_4›)
check_tm(?_4, ?_3)
infer_tm(tt_1)
loop_check(nat_2 Type‹??_4›)
infer_tm(Type‹??_4›)
check_tm(nat_2, Type‹??_4›)
infer_tm(nat_2)
loop_check((succ_3‹› zero_2) nat_2)
infer_tm(nat_2)
check_tm((succ_3‹› zero_2), nat_2)
infer_tm((succ_3‹› zero_2))
check_tm(zero_2, nat_2)
infer_tm(zero_2)
loop_check(nat_2 U)
infer_tm(U)
check_tm(nat_2, U)
infer_tm(nat_2)
infer_tm(∀ {A_130 : Type‹s_129›} -> A_130 -> IO unit_1)
infer_tm(Type‹s_129›)
infer_tm(A_132 -> IO unit_1)
infer_tm(A_132)
infer_tm(IO unit_1)
infer_tm(unit_1)
check_tm(function print_135 :
           ∀ {A_136 : Type‹s_129›} -> A_136 -> IO unit_1
         | A_138 x_139 => #magic[?_6], ∀ {A_140 : Type‹s_129›} ->
                                         A_140 -> IO unit_1)
infer_tm(function print_142 :
           ∀ {A_143 : Type‹s_129›} -> A_143 -> IO unit_1
         | A_145 x_146 => #magic[?_6])
infer_tm(∀ {A_148 : Type‹s_129›} -> A_148 -> IO unit_1)
infer_tm(Type‹s_129›)
infer_tm(A_150 -> IO unit_1)
infer_tm(A_150)
infer_tm(IO unit_1)
infer_tm(unit_1)
case_coverage{|
  prblm {| ;
    {| eq_pat?( #A_157, A_153 : Type‹s_129›)
       eq_pat?( #x_158, x_154 : #A_157) ::: [] =>? #magic[?_6]
    |}
  |}
|}
solve_pprm(
  eq_pat?( #A_157, A_153 : Type‹s_129›) eq_pat?( #x_158, x_154 : #A_157)
)
case_coverage_ok(#magic[?_6], IO unit_1)
check_tm(#magic[?_6], IO unit_1)
infer_tm(#magic[?_6])
infer_tm(IO unit_1)
infer_tm(unit_1)
check_tm((print_2‹??_7›) ?_7 tt_1, IO unit_1)
infer_tm((print_2‹??_7›) ?_7 tt_1)
infer_tm((print_2‹??_7›) ?_7)
infer_tm(print_2‹??_7›)
check_tm(?_7, Type‹??_7›)
check_tm(tt_1, ?_7)
infer_tm(tt_1)
loop_check(unit_1 Type‹??_7›)
infer_tm(Type‹??_7›)
check_tm(unit_1, Type‹??_7›)
infer_tm(unit_1)
smeta_meta {|
  ??_1 <= s_176
  ??_2 <= s_177
  ??_3 <= U
  ??_4 <= U
  ??_5 <= ??_4
  ??_6 <= U
  ??_7 <= U
  
|}
imeta_meta {|
  ?_1 <= A_180
  ?_2 <= A_183
  ?_3 <= nat_2
  ?_4 <= (succ_3‹› zero_2)
  ?_5 <= nat_2
  ?_6 <= IO unit_1
  ?_7 <= unit_1
  
|}

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive nat_2‹› : U where
| zero_2 : nat_2
| succ_3 (n_231 : nat_2) : nat_2

#[program]
inductive sing_3‹s_232› (A_233 : Type‹s_232›):
  A_233 -> Type‹s_232›
where
| just_4 (m_235 : A_233) : (sing_3‹s_232› A_233 m_235)

#[logical]
inductive eq_4‹s_236› (A_237 : Type‹s_236›) (m_238 : A_237):
  A_237 -> U
where
| eq_refl_5 : (eq_4‹s_236› A_237 m_238 m_238)

#[program]
def test_1‹› : (sing_3‹U› nat_2 (succ_3‹› zero_2)) -> unit_1 :=
  function test_241 : (sing_3‹U› nat_2 (succ_3‹› zero_2)) -> unit_1
  | (just_4 x_243) =>
    let pf_244 :=
      (eq_refl_5‹U› : (eq_4‹U› nat_2 x_243 (succ_3‹› zero_2)))
    in tt_1

#[program]
def print_2‹s_245› : ∀ {A_246 : Type‹s_245›} -> A_246 -> IO unit_1
:=
  function print_248 : ∀ {A_249 : Type‹s_245›} -> A_249 -> IO unit_1
  | A_251 x_252 => #magic[IO unit_1]

#[program]
def __3‹› : IO unit_1 := (print_2‹U›) unit_1 tt_1

-----------------------------------------

