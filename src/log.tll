[Notation {name = "|>"; body = (App [(Hole 2); (Hole 1)])};
  Notation {name = "@@"; body = (App [(Hole 1); (Hole 2)])};
  Notation {name = "="; body = (App [(Id ("eq", I)); (Hole 1); (Hole 2)])};
  Notation {name = "`"; body = (App [(Id ("sing", I)); (Hole 1)])};
  Notation {name = "&&"; body = (Id ("and", I))};
  Notation {name = "||"; body = (Id ("or", I))};
  Notation {name = "+"; body = (App [(Id ("add", I)); (Hole 1); (Hole 2)])};
  Notation {name = "-"; body = (App [(Id ("sub", I)); (Hole 1); (Hole 2)])};
  Notation {name = "*"; body = (App [(Id ("mul", I)); (Hole 1); (Hole 2)])};
  Notation {name = "/"; body = (App [(Id ("div", I)); (Hole 1); (Hole 2)])};
  Notation {name = "%"; body = (App [(Id ("rem", I)); (Hole 1); (Hole 2)])};
  Notation {name = "^"; body = (App [(Id ("pow", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<"; body = (App [(Id ("lt", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">"; body = (App [(Id ("gt", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<="; body = (App [(Id ("lte", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">="; body = (App [(Id ("gte", I)); (Hole 1); (Hole 2)])};
  Notation {name = "**"; body = (App [(Id ("prod1", I)); (Hole 1); (Hole 2)])};
  Notation {name = "::"; body = (App [(Id ("cons", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase (BOpr ("=", (Id ("m", I)), (Id ("m", I))))),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "unit"; relv = R;
    body =
    (Binder (["s"],
       (PBase
          ((TBase (Type (SId "s"))),
           [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
       ));
    view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type L)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type L)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder ([],
       (PBind ((Type L),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)), (Binder ("_", (TBase (Type L)))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m", (TBase (UOpr ("`", (Id ("m", I))))))))),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Definition {name = "sing_elim"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type L),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("x",
                       (Pi (R, U, (UOpr ("`", (Id ("x", I)))),
                          (Binder ("_", (Id ("A", I))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_elim"),
              [([(PId "A"); (PId "x"); (PConstr ("just", [(PId "x")]))],
                (Some (Id ("x", I))))]
              )),
           [I; I])),
        (Pi (N, U, (Type L),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("x",
                    (Pi (R, U, (UOpr ("`", (Id ("x", I)))),
                       (Binder ("_", (Id ("A", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "sing_uniq"; relv = N;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Type L),
              (Binder ("A",
                 (Pi (R, U, (Id ("A", I)),
                    (Binder ("x0",
                       (Pi (R, U, (UOpr ("`", (Id ("x0", I)))),
                          (Binder ("x",
                             (BOpr ("=", (Id ("x0", I)),
                                (App [(Id ("sing_elim", I)); (Id ("x", I))])
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_uniq"),
              [([(PId "A"); (PId "x0"); (PConstr ("just", [(PId "_")]))],
                (Some (Id ("refl", I))))]
              )),
           [I; I])),
        (Pi (R, U, (Type L),
           (Binder ("A",
              (Pi (R, U, (Id ("A", I)),
                 (Binder ("x0",
                    (Pi (R, U, (UOpr ("`", (Id ("x0", I)))),
                       (Binder ("x",
                          (BOpr ("=", (Id ("x0", I)),
                             (App [(Id ("sing_elim", I)); (Id ("x", I))])))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Inductive {name = "apair"; relv = R;
    body =
    (Binder ([],
       (PBind ((Type L),
          (Binder ("A",
             (PBind ((Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("apair_intro",
                           (TBind (N, (Id ("A", I)),
                              (Binder ("x",
                                 (TBind (R,
                                    (Pi (R, L, (Id ("bool", I)),
                                       (Binder ("b",
                                          (Match ([(R, (Id ("b", I)), None)],
                                             None,
                                             [([(PId "true")],
                                               (Some (UOpr ("`",
                                                        (Id ("x", I))))));
                                               ([(PId "false")],
                                                (Some (App
                                                         [(Id ("B", I));
                                                           (Id ("x", I))])))
                                               ]
                                             ))
                                          ))
                                       )),
                                    (Binder ("select",
                                       (TBase
                                          (App
                                             [(Id ("apair", I));
                                               (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [I; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Notation {name = "(,)";
    body =
    (App
       [(Id ("apair_intro", I));
         (Fun (IMeta,
            (Binder (None,
               [([(PId "true")], (Some (App [(Id ("just", I)); (Hole 1)])));
                 ([(PId "false")], (Some (Hole 2)))]
               )),
            []))
         ])};
  Definition {name = "proj1"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type L),
              (Binder ("A",
                 (Pi (N, U,
                    (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                    (Binder ("B",
                       (Pi (R, U,
                          (App
                             [(Id ("apair", E)); (Id ("A", I)); (Id ("B", I))
                               ]),
                          (Binder ("_", (Id ("A", I))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "proj1"),
              [([(PId "A"); (PId "B");
                  (PConstr ("apair_intro", [(PId "_"); (PId "select")]))],
                (Some (App
                         [(Id ("sing_elim", I));
                           (App [(Id ("select", I)); (Id ("true", I))])])))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type L),
           (Binder ("A",
              (Pi (N, U,
                 (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                 (Binder ("B",
                    (Pi (R, U,
                       (App [(Id ("apair", E)); (Id ("A", I)); (Id ("B", I))]),
                       (Binder ("_", (Id ("A", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "proj2"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type L),
              (Binder ("A",
                 (Pi (N, U,
                    (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                    (Binder ("B",
                       (Pi (R, U,
                          (App
                             [(Id ("apair", E)); (Id ("A", I)); (Id ("B", I))
                               ]),
                          (Binder ("x",
                             (App
                                [(Id ("B", I));
                                  (App [(Id ("proj1", I)); (Id ("x", I))])])
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "proj2"),
              [([(PId "A"); (PId "B");
                  (PConstr ("apair_intro", [(PId "x"); (PId "select")]))],
                (Some (Match (
                         [(N, (Id ("x", I)), (Some ("x0", IMeta)));
                           (N, (App [(Id ("select", I)); (Id ("true", I))]),
                            (Some ("a0", (UOpr ("`", (Id ("x", I)))))));
                           (N,
                            (App
                               [(Id ("sing_uniq", I));
                                 (App [(Id ("select", I)); (Id ("true", I))])
                                 ]),
                            (Some ("_",
                                   (BOpr ("=", (Id ("x0", I)),
                                      (App
                                         [(Id ("sing_elim", I));
                                           (Id ("a0", I))])
                                      )))));
                           (R, (App [(Id ("select", I)); (Id ("false", I))]),
                            (Some ("_", (App [(Id ("B", I)); (Id ("x0", I))]))))
                           ],
                         (Some (App
                                  [(Id ("B", I));
                                    (App
                                       [(Id ("sing_elim", I)); (Id ("a0", I))
                                         ])
                                    ])),
                         [([(PId "_"); (PId "_"); (PId "refl"); (PId "b")],
                           (Some (Id ("b", I))))]
                         ))))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type L),
           (Binder ("A",
              (Pi (N, U,
                 (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                 (Binder ("B",
                    (Pi (R, U,
                       (App [(Id ("apair", E)); (Id ("A", I)); (Id ("B", I))]),
                       (Binder ("x",
                          (App
                             [(Id ("B", I));
                               (App [(Id ("proj1", I)); (Id ("x", I))])])
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "bool2nat"; relv = R;
    body =
    (Binder ([],
       ((Fun ((Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("nat", I)))))),
           (Binder ((Some "bool2nat"),
              [([(PId "true")],
                (Some (App [(Id ("succ", I)); (Id ("zero", I))])));
                ([(PId "false")], (Some (Id ("zero", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("nat", I)))))))
       ));
    view = []};
  Definition {name = "free_bool"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_", (Inst ("unit", [U], I)))))),
           (Binder ((Some "free_bool"),
              [([(PId "true")], (Some (Id ("tt", I))));
                ([(PId "false")], (Some (Id ("tt", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Inst ("unit", [U], I))))
           )))
       ));
    view = []};
  Definition {name = "free_nat"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_", (Inst ("unit", [U], I)))))),
           (Binder ((Some "free_nat"),
              [([(PId "zero")], (Some (Id ("tt", I))));
                ([(PConstr ("succ", [(PId "n")]))],
                 (Some (App [(Id ("free_nat", I)); (Id ("n", I))])))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Inst ("unit", [U], I)))))))
       ));
    view = []};
  Definition {name = "my_apair"; relv = R;
    body =
    (Binder ([],
       ((Let (R, (Id ("false", I)),
           (Binder ((PId "my_val"),
              (BOpr ("(,)", (Id ("my_val", I)),
                 (App [(Id ("bool2nat", I)); (Id ("my_val", I))])))
              ))
           )),
        (App
           [(Id ("apair", I));
             (Fun ((Pi (R, U, (Id ("bool", I)), (Binder ("b", IMeta)))),
                (Binder (None,
                   [([(PId "b")],
                     (Some (Match ([(R, (Id ("b", I)), None)], None,
                              [([(PId "true")],
                                (Some (Inst ("unit", [L], I))));
                                ([(PId "false")], (Some (Id ("nat", I))))]
                              ))))
                     ]
                   )),
                []))
             ]))
       ));
    view = []};
  Definition {name = "_"; relv = R;
    body =
    (Binder ([],
       ((App
           [(Id ("free_bool", I));
             (App [(Id ("proj1", I)); (Id ("my_apair", I))])]),
        (Inst ("unit", [U], I)))
       ));
    view = []}
  ]

-----------------------------------------

#[logical]
inductive eq_1‹s_94› (A_95 : Type‹s_94›) (m_96 : A_95): A_95 -> U
where
| refl_1 : (eq_1‹??_1› ?_1[0;0] m_96 m_96)

#[program]
inductive unit_2‹s_98› : Type‹s_98› where
| tt_2 : unit_2‹??_2›

#[program]
inductive bool_3‹› : L where
| true_3 : bool_3
| false_4 : bool_3

#[program]
inductive nat_4‹› : L where
| zero_5 : nat_4
| succ_6 (pred_99 : nat_4) : nat_4

#[program]
inductive sing_5‹› (A_100 : L): A_100 -> L where
| just_7 (m_102 : A_100) : (sing_5 ?_2[0;0] m_102)

#[program]
def sing_elim_1‹› :
  ∀ {A_103 : L} -> ∀ {x_104 : A_103} -> (sing_5 ?_4[0;0] x_104) -> A_103
:=
  function sing_elim_106 :
    ∀ {A_107 : L} ->
      ∀ {x_108 : A_107} -> (sing_5 ?_3[0;0] x_108) -> A_107
  | A_110 x_111 (just_7 x_112) => x_112

#[logical]
def sing_uniq_2‹› :
  ∀ (A_113 : L) ->
    ∀ (x0_114 : A_113) ->
      ∀ (x_115 : (sing_5 ?_11[0;0] x0_114)) ->
        (eq_1‹??_5›
          ?_14[0;0] x0_114 ((sing_elim_1) ?_13[0;0] ?_12[0;0] x_115))
:=
  function sing_uniq_116 :
    ∀ (A_117 : L) ->
      ∀ (x0_118 : A_117) ->
        ∀ (x_119 : (sing_5 ?_5[0;0] x0_118)) ->
          (eq_1‹??_3›
            ?_8[0;0] x0_118 ((sing_elim_1) ?_7[0;0] ?_6[0;0] x_119))
  | A_120 x0_121 (just_7 _122) => (refl_1‹??_4› ?_9[0;0] ?_10[0;0])

#[program]
inductive apair_6‹› (A_123 : L) (B_124 : A_123 -> L): L where
| apair_intro_8
    {x_126 : A_123}
    (select_127 : ∀ (b_128 : bool_3) -o
                    match b_128 in ?_15[0;0] -o ?_16[0;0] with
                    | true_3 => (sing_5 ?_17[0;0] x_126)
                    | false_4 => ((B_124) x_126))
    : (apair_6 ?_18[0;0] B_124)

#[program]
def proj1_3‹› :
  ∀ {A_130 : L} ->
    ∀ {B_131 : A_130 -> L} -> (apair_6 A_130 B_131) -> A_130
:=
  function proj1_134 :
    ∀ {A_135 : L} ->
      ∀ {B_136 : A_135 -> L} -> (apair_6 A_135 B_136) -> A_135
  | A_139 B_140 (apair_intro_8 _141 select_142) =>
    ((sing_elim_1) ?_20[0;0] ?_19[0;0] ((select_142) true_3))

#[program]
def proj2_4‹› :
  ∀ {A_143 : L} ->
    ∀ {B_144 : A_143 -> L} ->
      ∀ (x_146 : (apair_6 A_143 B_144)) ->
        ((B_144) ((proj1_3) ?_33[0;0] ?_32[0;0] x_146))
:=
  function proj2_147 :
    ∀ {A_148 : L} ->
      ∀ {B_149 : A_148 -> L} ->
        ∀ (x_151 : (apair_6 A_148 B_149)) ->
          ((B_149) ((proj1_3) ?_22[0;0] ?_21[0;0] x_151))
  | A_152 B_153 (apair_intro_8 x_154 select_155) =>
    match x_154, ((select_155) true_3),
    ((sing_uniq_2) ?_24[0;0] ?_23[0;0] ((select_155) true_3)),
    ((select_155) false_4) in
      ∀ {x0_156 : ?_25[0;0]} -o
        ∀ {a0_157 : (sing_5 ?_26[0;0] x_154)} -o
          {(eq_1‹??_6›
             ?_29[0;0] x0_156 ((sing_elim_1) ?_28[0;0] ?_27[0;0] a0_157))} -o
            ((B_153) x0_156) -o
              ((B_153) ((sing_elim_1) ?_31[0;0] ?_30[0;0] a0_157))
    with
    | _160, _161, refl_1, b_162 => b_162

#[program]
def bool2nat_5‹› : bool_3 -> nat_4 :=
  function bool2nat_164 : bool_3 -> nat_4
  | true_3 => (succ_6‹› zero_5)
  | false_4 => zero_5

#[program]
def free_bool_6‹› : bool_3 -> unit_2‹U› :=
  function free_bool_167 : bool_3 -> unit_2‹U›
  | true_3 => tt_2‹??_7›
  | false_4 => tt_2‹??_8›

#[program]
def free_nat_7‹› : nat_4 -> unit_2‹U› :=
  function free_nat_170 : nat_4 -> unit_2‹U›
  | zero_5 => tt_2‹??_9›
  | (succ_6 n_172) => ((free_nat_170) n_172)

#[program]
def my_apair_8‹› :
  (apair_6
    ?_42[0;0]
    function _173 : bool_3 -> ?_39[0;0]
    | b_175 =>
      match b_175 in ?_40[0;0] -o ?_41[0;0] with
      | true_3 => unit_2‹L›
      | false_4 => nat_4)
:=
  let my_val_177 := false_4 in
  (apair_intro_8‹›
    ?_37[0;0] ?_38[0;0] ?_36[0;0]
    function _178 : ?_34[0;0]
    | true_3 => (just_7‹› ?_35[0;0] my_val_177)
    | false_4 => ((bool2nat_5) my_val_177))

#[program]
def __9‹› : unit_2‹U› :=
  ((free_bool_6) ((proj1_3) ?_44[0;0] ?_43[0;0] my_apair_8))

-----------------------------------------

#[logical]
inductive eq_1‹s_2077› (A_2078 : Type‹s_2077›) (m_2079 : A_2078):
  A_2078 -> U
where
| refl_1 : (eq_1‹s_2077› A_2078 m_2079 m_2079)

#[program]
inductive unit_2‹s_2081› : Type‹s_2081› where
| tt_2 : unit_2‹s_2081›

#[program]
inductive bool_3‹› : L where
| true_3 : bool_3
| false_4 : bool_3

#[program]
inductive nat_4‹› : L where
| zero_5 : nat_4
| succ_6 (pred_2082 : nat_4) : nat_4

#[program]
inductive sing_5‹› (A_2083 : L): A_2083 -> L where
| just_7 (m_2085 : A_2083) : (sing_5 A_2083 m_2085)

#[program]
def sing_elim_1‹› :
  ∀ {A_2086 : L} ->
    ∀ {x_2087 : A_2086} -> (sing_5 A_2086 x_2087) -> A_2086
:=
  function sing_elim_2089 :
    ∀ {A_2090 : L} ->
      ∀ {x_2091 : A_2090} -> (sing_5 A_2090 x_2091) -> A_2090
  | A_2093 x_2094 (just_7 m_2095) => m_2095

#[logical]
def sing_uniq_2‹› :
  ∀ (A_2096 : L) ->
    ∀ (x0_2097 : A_2096) ->
      ∀ (x_2098 : (sing_5 A_2096 x0_2097)) ->
        (eq_1‹L› A_2096 x0_2097 ((sing_elim_1) A_2096 x0_2097 x_2098))
:=
  function sing_uniq_2099 :
    ∀ (A_2100 : L) ->
      ∀ (x0_2101 : A_2100) ->
        ∀ (x_2102 : (sing_5 A_2100 x0_2101)) ->
          (eq_1‹L› A_2100 x0_2101 ((sing_elim_1) A_2100 x0_2101 x_2102))
  | A_2103 x0_2104 (just_7 m_2105) => (refl_1‹L› A_2103 m_2105)

#[program]
inductive apair_6‹› (A_2106 : L) (B_2107 : A_2106 -> L): L where
| apair_intro_8
    {x_2109 : A_2106}
    (select_2110 : ∀ (b_2111 : bool_3) -o
                     match b_2111 in bool_3 -o L with
                     | true_3 => (sing_5 A_2106 x_2109)
                     | false_4 => ((B_2107) x_2109))
    : (apair_6 A_2106 B_2107)

#[program]
def proj1_3‹› :
  ∀ {A_2113 : L} ->
    ∀ {B_2114 : A_2113 -> L} -> (apair_6 A_2113 B_2114) -> A_2113
:=
  function proj1_2117 :
    ∀ {A_2118 : L} ->
      ∀ {B_2119 : A_2118 -> L} -> (apair_6 A_2118 B_2119) -> A_2118
  | A_2122 B_2123 (apair_intro_8 x_2124 select_2125) =>
    ((sing_elim_1) A_2122 x_2124 ((select_2125) true_3))

#[program]
def proj2_4‹› :
  ∀ {A_2126 : L} ->
    ∀ {B_2127 : A_2126 -> L} ->
      ∀ (x_2129 : (apair_6 A_2126 B_2127)) ->
        ((B_2127) ((proj1_3) A_2126 B_2127 x_2129))
:=
  function proj2_2130 :
    ∀ {A_2131 : L} ->
      ∀ {B_2132 : A_2131 -> L} ->
        ∀ (x_2134 : (apair_6 A_2131 B_2132)) ->
          ((B_2132) ((proj1_3) A_2131 B_2132 x_2134))
  | A_2135 B_2136 (apair_intro_8 x_2137 select_2138) =>
    match x_2137, ((select_2138) true_3),
    ((sing_uniq_2) A_2135 x_2137 ((select_2138) true_3)),
    ((select_2138) false_4) in
      ∀ {x0_2139 : A_2135} -o
        ∀ {a0_2140 : (sing_5 A_2135 x_2137)} -o
          {(eq_1‹L› A_2135 x0_2139 ((sing_elim_1) A_2135 x_2137 a0_2140))} -o
            ((B_2136) x0_2139) -o
              ((B_2136) ((sing_elim_1) A_2135 x_2137 a0_2140))
    with
    | x0_2143, a0_2144, refl_1, __2145 => __2145

#[program]
def bool2nat_5‹› : bool_3 -> nat_4 :=
  function bool2nat_2147 : bool_3 -> nat_4
  | true_3 => (succ_6‹› zero_5)
  | false_4 => zero_5

#[program]
def free_bool_6‹› : bool_3 -> unit_2‹U› :=
  function free_bool_2150 : bool_3 -> unit_2‹U›
  | true_3 => tt_2‹U›
  | false_4 => tt_2‹U›

#[program]
def free_nat_7‹› : nat_4 -> unit_2‹U› :=
  function free_nat_2153 : nat_4 -> unit_2‹U›
  | zero_5 => tt_2‹U›
  | (succ_6 pred_2155) => ((free_nat_2153) pred_2155)

#[program]
def my_apair_8‹› :
  (apair_6
    bool_3
    function _2156 : bool_3 -> L
    | __2158 =>
      match __2158 in bool_3 -o L with
      | true_3 => unit_2‹L›
      | false_4 => nat_4)
:=
  let my_val_2160 := false_4 in
  (apair_intro_8‹›
    bool_3
    function _2161 : bool_3 -> L
    | __2163 =>
      match __2163 in bool_3 -o L with
      | true_3 => unit_2‹L›
      | false_4 => nat_4
    my_val_2160
    function _2165 :
      ∀ (b_2166 : bool_3) -o
        match b_2166 in bool_3 -o L with
        | true_3 => (sing_5 bool_3 my_val_2160)
        | false_4 =>
          ((function _2168 : bool_3 -> L
            | __2170 =>
              match __2170 in bool_3 -o L with
              | true_3 => unit_2‹L›
              | false_4 => nat_4)
            my_val_2160)
    | true_3 => (just_7‹› bool_3 my_val_2160)
    | false_4 => ((bool2nat_5) my_val_2160))

#[program]
def __9‹› : unit_2‹U› :=
  ((free_bool_6)
    ((proj1_3)
      bool_3
      function _2172 : bool_3 -> L
      | __2174 =>
        match __2174 in bool_3 -o L with
        | true_3 => unit_2‹L›
        | false_4 => nat_4
      my_apair_8))

-----------------------------------------

#[logical]
inductive eqU_8 where
| reflU_10 of layout[]

#[logical]
inductive eqL_7 where
| reflL_9 of layout[]

#[program]
inductive unitU_10 where
| ttU_12 of layout[]

#[program]
inductive unitL_9 where
| ttL_11 of layout[]

#[program]
inductive bool_3 where
| true_3 of layout[]
| false_4 of layout[]

#[program]
inductive nat_4 where
| zero_5 of layout[]
| succ_6 of layout[R]

#[program]
inductive sing_5 where
| just_7 of layout[R]

#[program]
def sing_elim_1 :=
  fun sing_elim_2711 {A_2712} -> {x_2713} -> (__2714) ->
    match __2714 with
    | just_7 m_2715 => m_2715
    end

#[logical]
def sing_uniq_2 := NULL

#[program]
inductive apair_6 where
| apair_intro_8 of layout[N, R]

#[program]
def proj1_3 :=
  fun proj1_2716 {A_2717} -> {B_2718} -> (__2719) ->
    match __2719 with
    | apair_intro_8 x_2720 select_2721 =>
      ((sing_elim_1) NULL NULL ((select_2721) true_3))
    end

#[program]
def proj2_4 :=
  fun proj2_2722 {A_2723} -> {B_2724} -> (x_2725) ->
    match x_2725 with
    | apair_intro_8 x_2726 select_2727 =>
      match {NULL} with
      | reflL_9  => ((select_2727) false_4)
      end
    end

#[program]
def bool2nat_5 :=
  fun bool2nat_2728 (__2729) ->
    match __2729 with
    | true_3  => (succ_6 zero_5) | false_4  => zero_5
    end

#[program]
def free_bool_6 :=
  fun free_bool_2730 (__2731) ->
    match __2731 with
    | true_3  => ttU_12 | false_4  => ttU_12
    end

#[program]
def free_nat_7 :=
  fun free_nat_2732 (__2733) ->
    match __2733 with
    | zero_5  => ttU_12 | succ_6 pred_2734 => ((free_nat_2732) pred_2734)
    end

#[program]
def my_apair_8 :=
  let my_val_2735 := false_4 in
  (apair_intro_8
    NULL
    fun _2736 (b_2737) -o
      match b_2737 with
      | true_3  => (just_7 my_val_2735)
      | false_4  => ((bool2nat_5) my_val_2735)
      end)

#[program]
def __9 := ((free_bool_6) ((proj1_3) NULL NULL my_apair_8))

-----------------------------------------

#[logical]
inductive eqU_8 where
| reflU_10 of layout[]

#[logical]
inductive eqL_7 where
| reflL_9 of layout[]

#[program]
inductive unitU_10 where
| ttU_12 of layout[]

#[program]
inductive unitL_9 where
| ttL_11 of layout[]

#[program]
inductive bool_3 where
| true_3 of layout[]
| false_4 of layout[]

#[program]
inductive nat_4 where
| zero_5 of layout[]
| succ_6 of layout[R]

#[program]
inductive sing_5 where
| just_7 of layout[R]

#[program]
def sing_elim_1 :=
  fun sing_elim_2765 {A_2766} -> {x_2767} -> (__2768) ->
    match __2768 with
    | just_7 m_2769 => m_2769
    end

#[logical]
def sing_uniq_2 := NULL

#[program]
inductive apair_6 where
| apair_intro_8 of layout[N, R]

#[program]
def proj1_3 :=
  fun proj1_2770 {A_2771} -> {B_2772} -> (__2773) ->
    match __2773 with
    | apair_intro_8 x_2774 select_2775 =>
      ((sing_elim_1) NULL NULL ((select_2775) true_3))
    end

#[program]
def proj2_4 :=
  fun proj2_2776 {A_2777} -> {B_2778} -> (x_2779) ->
    match x_2779 with
    | apair_intro_8 x_2780 select_2781 => ((select_2781) false_4)
    end

#[program]
def bool2nat_5 :=
  fun bool2nat_2782 (__2783) ->
    match __2783 with
    | true_3  => (succ_6 zero_5) | false_4  => zero_5
    end

#[program]
def free_bool_6 :=
  fun free_bool_2784 (__2785) ->
    match __2785 with
    | true_3  => ttU_12 | false_4  => ttU_12
    end

#[program]
def free_nat_7 :=
  fun free_nat_2786 (__2787) ->
    match __2787 with
    | zero_5  => ttU_12 | succ_6 pred_2788 => ((free_nat_2786) pred_2788)
    end

#[program]
def my_apair_8 :=
  let my_val_2789 := false_4 in
  (apair_intro_8
    NULL
    fun _2790 (b_2791) -o
      match b_2791 with
      | true_3  => (just_7 my_val_2789)
      | false_4  => ((bool2nat_5) my_val_2789)
      end)

#[program]
def __9 := ((free_bool_6) ((proj1_3) NULL NULL my_apair_8))

-----------------------------------------

