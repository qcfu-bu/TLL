[Inductive {name = "unit"; relv = R;
   body =
   (Binder (["s"],
      (PBase
         ((TBase (Type (SId "s"))),
          [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
      ));
   view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "choice"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type L)),
           [(DConstr ("next", (TBase (Id ("choice", I))), []));
             (DConstr ("free", (TBase (Id ("choice", I))), []))]))
       ));
    view = []};
  Inductive {name = "stream_node"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type L)),
                 [(DConstr ("stream_nil",
                     (TBase (App [(Id ("stream_node", I)); (Id ("A", I))])),
                     []));
                   (DConstr ("stream_cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (Pi (R, L, (Id ("choice", I)),
                                  (Binder ("x",
                                     (Match ([(R, (Id ("x", I)), None)],
                                        None,
                                        [([(PId "next")],
                                          (Some (App
                                                   [(Id ("stream_node", I));
                                                     (Id ("A", I))])));
                                          ([(PId "free")],
                                           (Some (Id ("unit", I))))
                                          ]
                                        ))
                                     ))
                                  )),
                               (Binder ("tl",
                                  (TBase
                                     (App
                                        [(Id ("stream_node", I));
                                          (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Definition {name = "stream"; relv = N;
    body =
    (Binder (["s"],
       ((Fun ((Pi (R, U, (Type (SId "s")), (Binder ("A", IMeta)))),
           (Binder ((Some "stream"),
              [([(PId "A")],
                (Some (Pi (R, L, (Id ("choice", I)),
                         (Binder ("x",
                            (Match ([(R, (Id ("x", I)), None)], None,
                               [([(PId "next")],
                                 (Some (App
                                          [(Id ("stream_node", I));
                                            (Id ("A", I))])));
                                 ([(PId "free")], (Some (Id ("unit", I))))]
                               ))
                            ))
                         ))))
                ]
              )),
           [E])),
        (Pi (R, U, (Type (SId "s")), (Binder ("A", IMeta)))))
       ));
    view = [E]};
  Definition {name = "free_stream"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (App [(Id ("stream", I)); (Id ("A", I))]),
                    (Binder ("st", (Inst ("unit", [U], I))))))
                 ))
              )),
           (Binder ((Some "free_stream"),
              [([(PId "A"); (PId "st")],
                (Some (Match (
                         [(R, (App [(Id ("st", I)); (Id ("free", I))]), None)
                           ],
                         None, [([(PId "tt")], (Some (Id ("tt", I))))]))))
                ]
              )),
           [I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (R, U, (App [(Id ("stream", I)); (Id ("A", I))]),
                 (Binder ("st", (Inst ("unit", [U], I))))))
              ))
           )))
       ));
    view = [I; E]};
  Definition {name = "stream_succ"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (App [(Id ("stream", I)); (Id ("nat", I))]),
              (Binder ("xs", (App [(Id ("stream", I)); (Id ("nat", I))]))))),
           (Binder ((Some "stream_succ"),
              [([(PId "xs"); (PId "next")],
                (Some (Match (
                         [(R, (App [(Id ("xs", I)); (Id ("next", I))]), None)
                           ],
                         None,
                         [([(PId "stream_nil")],
                           (Some (Id ("stream_nil", I))));
                           ([(PConstr ("stream_cons",
                                [(PId "hd"); (PId "tl")]))
                              ],
                            (Some (App
                                     [(Id ("stream_cons", I));
                                       (App
                                          [(Id ("succ", I)); (Id ("hd", I))]);
                                       (App
                                          [(Id ("stream_succ", I));
                                            (Id ("tl", I))])
                                       ])))
                           ]
                         ))));
                ([(PId "xs"); (PId "free")],
                 (Some (App [(Id ("xs", I)); (Id ("free", I))])))
                ]
              )),
           [E])),
        (Pi (R, U, (App [(Id ("stream", I)); (Id ("nat", I))]),
           (Binder ("xs", (App [(Id ("stream", I)); (Id ("nat", I))]))))))
       ));
    view = [E]};
  Definition {name = "nat_make"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("n", (App [(Id ("stream", I)); (Id ("nat", I))]))))),
           (Binder ((Some "nat_make"),
              [([(PId "n"); (PId "next")],
                (Some (App
                         [(Id ("stream_cons", I)); (Id ("n", I));
                           (App
                              [(Id ("nat_make", I));
                                (App [(Id ("succ", I)); (Id ("n", I))])])
                           ])));
                ([(PId "n"); (PId "free")], (Some (Id ("tt", I))))]
              )),
           [E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("n", (App [(Id ("stream", I)); (Id ("nat", I))]))))))
       ));
    view = [E]};
  Definition {name = "nat_stream"; relv = R;
    body =
    (Binder ([], ((App [(Id ("nat_make", I)); (Id ("zero", I))]), IMeta)));
    view = []};
  Definition {name = "snat_stream"; relv = R;
    body =
    (Binder ([],
       ((App [(Id ("stream_succ", I)); (Id ("nat_stream", I))]), IMeta)));
    view = []};
  Definition {name = "_"; relv = R;
    body =
    (Binder ([],
       ((App [(Id ("free_stream", I)); (Id ("snat_stream", I))]), IMeta)));
    view = []}
  ]

-----------------------------------------

#[program]
inductive unit_1‹s_42› : Type‹s_42› where
| tt_1 : unit_1‹??_1›

#[program]
inductive nat_2‹› : U where
| zero_2 : nat_2
| succ_3 (pred_43 : nat_2) : nat_2

#[program]
inductive choice_3‹› : L where
| next_4 : choice_3
| free_5 : choice_3

#[program]
inductive stream_node_4‹s_44› (A_45 : Type‹s_44›): L where
| stream_nil_6 : (stream_node_4‹??_2› A_45)
| stream_cons_7
    (hd_46 : A_45)
    (tl_47 : ∀ (x_48 : choice_3) -o
               match x_48 in ∀ (_49 : ?_1) -o ?_2 with
               | next_4 => (stream_node_4‹??_3› A_45)
               | free_5 => unit_1‹??_4›)
    : (stream_node_4‹??_5› A_45)

#[logical]
def stream_1‹s_50› : ∀ (A_51 : Type‹s_50›) -> ?_6 :=
  function stream_52 : ∀ (A_53 : Type‹s_50›) -> ?_3
  | A_54 =>
    ∀ (x_55 : choice_3) -o
      match x_55 in ∀ (_56 : ?_4) -o ?_5 with
      | next_4 => (stream_node_4‹??_6› A_54)
      | free_5 => unit_1‹??_7›

#[program]
def free_stream_2‹s_57› :
  ∀ {A_58 : Type‹s_57›} ->
    ((stream_1‹??_10›) A_58) -> unit_1‹U›
:=
  function free_stream_60 :
    ∀ {A_61 : Type‹s_57›} ->
      ((stream_1‹??_8›) A_61) -> unit_1‹U›
  | A_63 st_64 =>
    match ((st_64) free_5) in ∀ (_65 : ?_7) -o ?_8 with
    | tt_1 => tt_1‹??_9›

#[program]
def stream_succ_3‹› :
  ((stream_1‹??_15›) nat_2) -> ((stream_1‹??_16›) nat_2)
:=
  function stream_succ_67 :
    ((stream_1‹??_11›) nat_2) -> ((stream_1‹??_12›) nat_2)
  | xs_69 next_4 =>
    match ((xs_69) next_4) in ∀ (_70 : ?_9) -o ?_10 with
    | stream_nil_6 => stream_nil_6‹??_13›
    | (stream_cons_7 hd_71 tl_72) =>
      (stream_cons_7‹??_14›
        (succ_3‹› hd_71) ((stream_succ_67) tl_72))
  | xs_73 free_5 => ((xs_73) free_5)

#[program]
def nat_make_4‹› : nat_2 -> ((stream_1‹??_20›) nat_2) :=
  function nat_make_75 : nat_2 -> ((stream_1‹??_17›) nat_2)
  | n_77 next_4 =>
    (stream_cons_7‹??_18› n_77 ((nat_make_75) (succ_3‹› n_77)))
  | n_78 free_5 => tt_1‹??_19›

#[program]
def nat_stream_5‹› : ?_14 := ((nat_make_4) zero_2)

#[program]
def snat_stream_6‹› : ?_15 := ((stream_succ_3) nat_stream_5)

#[program]
def __7‹› : ?_17 := ((free_stream_2‹??_21›) ?_16 snat_stream_6)

-----------------------------------------

#[program]
inductive unit_1‹s_404› : Type‹s_404› where
| tt_1 : unit_1‹s_404›

#[program]
inductive nat_2‹› : U where
| zero_2 : nat_2
| succ_3 (pred_405 : nat_2) : nat_2

#[program]
inductive choice_3‹› : L where
| next_4 : choice_3
| free_5 : choice_3

#[program]
inductive stream_node_4‹s_406› (A_407 : Type‹s_406›): L where
| stream_nil_6 : (stream_node_4‹s_406› A_407)
| stream_cons_7
    (hd_408 : A_407)
    (tl_409 : ∀ (x_410 : choice_3) -o
                match x_410 in choice_3 -o L with
                | next_4 => (stream_node_4‹s_406› A_407)
                | free_5 => unit_1‹L›)
    : (stream_node_4‹s_406› A_407)

#[logical]
def stream_1‹s_412› : Type‹s_412› -> L :=
  function stream_414 : Type‹s_412› -> L
  | A_416 =>
    ∀ (x_417 : choice_3) -o
      match x_417 in choice_3 -o L with
      | next_4 => (stream_node_4‹s_412› A_416)
      | free_5 => unit_1‹L›

#[program]
def free_stream_2‹s_419› :
  ∀ {A_420 : Type‹s_419›} ->
    ((stream_1‹s_419›) A_420) -> unit_1‹U›
:=
  function free_stream_422 :
    ∀ {A_423 : Type‹s_419›} ->
      ((stream_1‹s_419›) A_423) -> unit_1‹U›
  | A_425 st_426 =>
    match ((st_426) free_5) in unit_1‹L› -o unit_1‹U› with
    | tt_1 => tt_1‹U›

#[program]
def stream_succ_3‹› :
  ((stream_1‹U›) nat_2) -> ((stream_1‹U›) nat_2)
:=
  function stream_succ_429 :
    ((stream_1‹U›) nat_2) -> ((stream_1‹U›) nat_2)
  | xs_431 next_4 =>
    match ((xs_431) next_4) in
      (stream_node_4‹U› nat_2) -o (stream_node_4‹U› nat_2)
    with
    | stream_nil_6 => stream_nil_6‹U›
    | (stream_cons_7 hd_433 tl_434) =>
      (stream_cons_7‹U› (succ_3‹› hd_433) ((stream_succ_429) tl_434))
  | xs_435 free_5 => ((xs_435) free_5)

#[program]
def nat_make_4‹› : nat_2 -> ((stream_1‹U›) nat_2) :=
  function nat_make_437 : nat_2 -> ((stream_1‹U›) nat_2)
  | n_439 next_4 =>
    (stream_cons_7‹U› n_439 ((nat_make_437) (succ_3‹› n_439)))
  | n_440 free_5 => tt_1‹L›

#[program]
def nat_stream_5‹› : ((stream_1‹U›) nat_2) := ((nat_make_4) zero_2)

#[program]
def snat_stream_6‹› : ((stream_1‹U›) nat_2) :=
  ((stream_succ_3) nat_stream_5)

#[program]
def __7‹› : unit_1‹U› := ((free_stream_2‹U›) nat_2 snat_stream_6)

-----------------------------------------

#[program]
inductive unitU_6 where
| ttU_9 of layout[]

#[program]
inductive unitL_5 where
| ttL_8 of layout[]

#[program]
inductive nat_2 where
| zero_2 of layout[]
| succ_3 of layout[R]

#[program]
inductive choice_3 where
| next_4 of layout[]
| free_5 of layout[]

#[program]
inductive stream_nodeU_8 where
| stream_nilU_12 of layout[]
| stream_consU_13 of layout[R, R]

#[program]
inductive stream_nodeL_7 where
| stream_nilL_10 of layout[]
| stream_consL_11 of layout[R, R]

#[logical]
def streamU_9 := NULL

#[logical]
def streamL_8 := NULL

#[program]
def free_streamU_11 :=
  fun free_stream_620 (A_621, st_622) =>
    match ((st_622) free_5) with
    | ttL_8  => ttU_9
    end

#[program]
def free_streamL_10 :=
  fun free_stream_623 (A_624, st_625) =>
    match ((st_625) free_5) with
    | ttL_8  => ttU_9
    end

#[program]
def stream_succ_3 :=
  fun stream_succ_626 (xs_627, x_628) =>
    match x_628 with
    | next_4  =>
      match ((xs_627) next_4) with
      | stream_nilU_12  => stream_nilU_12
      | stream_consU_13 hd_629 tl_630 =>
        (stream_consU_13 (succ_3 hd_629) ((stream_succ_626) tl_630))
      end
    | free_5  => ((xs_627) free_5)
    end

#[program]
def nat_make_4 :=
  fun nat_make_631 (n_632, x_633) =>
    match x_633 with
    | next_4  => (stream_consU_13 n_632 ((nat_make_631) (succ_3 n_632)))
    | free_5  => ttL_8
    end

#[program]
def nat_stream_5 := ((nat_make_4) zero_2)

#[program]
def snat_stream_6 := ((stream_succ_3) nat_stream_5)

#[program]
def __7 := ((free_streamU_11) NULL snat_stream_6)

-----------------------------------------

#[program]
inductive unitU_6 where
| ttU_9 of layout[]

#[program]
inductive unitL_5 where
| ttL_8 of layout[]

#[program]
inductive nat_2 where
| zero_2 of layout[]
| succ_3 of layout[R]

#[program]
inductive choice_3 where
| next_4 of layout[]
| free_5 of layout[]

#[program]
inductive stream_nodeU_8 where
| stream_nilU_12 of layout[]
| stream_consU_13 of layout[R, R]

#[program]
inductive stream_nodeL_7 where
| stream_nilL_10 of layout[]
| stream_consL_11 of layout[R, R]

#[logical]
def streamU_9 := NULL

#[logical]
def streamL_8 := NULL

#[program]
def free_streamU_11 :=
  fun free_stream_648 (A_649, st_650) =>
    match ((st_650) free_5) with
    | ttL_8  => ttU_9
    end

#[program]
def free_streamL_10 :=
  fun free_stream_651 (A_652, st_653) =>
    match ((st_653) free_5) with
    | ttL_8  => ttU_9
    end

#[program]
def stream_succ_3 :=
  fun stream_succ_654 (xs_655, x_656) =>
    match x_656 with
    | next_4  =>
      match ((xs_655) next_4) with
      | stream_nilU_12  => stream_nilU_12
      | stream_consU_13 hd_657 tl_658 =>
        (stream_consU_13 (succ_3 hd_657) ((stream_succ_654) tl_658))
      end
    | free_5  => ((xs_655) free_5)
    end

#[program]
def nat_make_4 :=
  fun nat_make_659 (n_660, x_661) =>
    match x_661 with
    | next_4  => (stream_consU_13 n_660 ((nat_make_659) (succ_3 n_660)))
    | free_5  => ttL_8
    end

#[program]
def nat_stream_5 := ((nat_make_4) zero_2)

#[program]
def snat_stream_6 := ((stream_succ_3) nat_stream_5)

#[program]
def __7 := ((free_streamU_11) NULL snat_stream_6)

-----------------------------------------

