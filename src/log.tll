[Inductive {name = "unit"; relv = R;
   body =
   (Binder ([],
      (PBase
         ((TBase (Type U)), [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
      ));
   view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "list"; relv = R;
    body =
    (Binder ([],
       (PBind ((Type U),
          (Binder ("A",
             (PBase
                ((TBase (Type U)),
                 [(DConstr ("nil",
                     (TBase (App [(Id ("list", I)); (Id ("A", I))])), 
                     []));
                   (DConstr ("cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (App [(Id ("list", I)); (Id ("A", I))]),
                               (Binder ("tl",
                                  (TBase
                                     (App [(Id ("list", I)); (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Notation {name = "::"; body = (App [(Id ("cons", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase
                              (App
                                 [(Id ("eq", I)); (Id ("m", I));
                                   (Id ("m", I))])),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Notation {name = "="; body = (App [(Id ("eq", I)); (Hole 1); (Hole 2)])};
  Notation {name = "::"; body = (App [(Id ("cons", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "exists"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("ex",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (N,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("pf",
                                       (TBase
                                          (App
                                             [(Id ("exists", I));
                                               (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "s"))))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m",
                           (TBase (App [(Id ("sing", I)); (Id ("m", I))]))))
                        )),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Notation {name = "`"; body = (App [(Id ("sing", I)); (Hole 1)])};
  Inductive {name = "prod"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Type (SId "r")),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("pair",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R, (Id ("B", I)),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("prod", I));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [E; E]};
  Notation {name = "**";
    body =
    (App [(Inst ("prod", [(SId "_"); (SId "_"); L], I)); (Hole 1); (Hole 2)])};
  Definition {name = "exists_sing"; relv = R;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U,
                          (App
                             [(Inst ("exists",
                                 [(SId "_"); (SId "_"); (SId "t")], I));
                               (Fun (
                                  (Pi (R, U, (Id ("A", I)),
                                     (Binder ("a", IMeta)))),
                                  (Binder (None,
                                     [([(PId "a")],
                                       (Some (BOpr ("=", (Id ("a", I)),
                                                (Id ("m", I))))))
                                       ]
                                     )),
                                  []))
                               ]),
                          (Binder ("_", (UOpr ("`", (Id ("m", I))))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "exists_sing"),
              [([(PId "A"); (PId "m");
                  (PConstr ("ex", [(PId "x"); (PId "refl")]))],
                (Some (App [(Id ("just", I)); (Id ("x", I))])))]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U,
                       (App
                          [(Inst ("exists",
                              [(SId "_"); (SId "_"); (SId "t")], I));
                            (Fun (
                               (Pi (R, U, (Id ("A", I)),
                                  (Binder ("a", IMeta)))),
                               (Binder (None,
                                  [([(PId "a")],
                                    (Some (BOpr ("=", (Id ("a", I)),
                                             (Id ("m", I))))))
                                    ]
                                  )),
                               []))
                            ]),
                       (Binder ("_", (UOpr ("`", (Id ("m", I))))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "sing_exists"; relv = R;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                          (Binder ("_",
                             (App
                                [(Inst ("exists",
                                    [(SId "_"); (SId "_"); (SId "t")], I));
                                  (Fun (
                                     (Pi (R, U, (Id ("A", I)),
                                        (Binder ("a", IMeta)))),
                                     (Binder (None,
                                        [([(PId "a")],
                                          (Some (BOpr ("=", (Id ("a", I)),
                                                   (Id ("m", I))))))
                                          ]
                                        )),
                                     []))
                                  ])
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_exists"),
              [([(PId "A"); (PId "m"); (PConstr ("just", [(PId "x")]))],
                (Some (App [(Id ("ex", I)); (Id ("x", I)); (Id ("refl", I))])))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                       (Binder ("_",
                          (App
                             [(Inst ("exists",
                                 [(SId "_"); (SId "_"); (SId "t")], I));
                               (Fun (
                                  (Pi (R, U, (Id ("A", I)),
                                     (Binder ("a", IMeta)))),
                                  (Binder (None,
                                     [([(PId "a")],
                                       (Some (BOpr ("=", (Id ("a", I)),
                                                (Id ("m", I))))))
                                       ]
                                     )),
                                  []))
                               ])
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "sing_exists_equiv1"; relv = N;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                          (Binder ("x",
                             (BOpr ("=",
                                (App
                                   [(Id ("exists_sing", I));
                                     (App
                                        [(Inst ("sing_exists",
                                            [(SId "_"); (SId "t")], I));
                                          (Id ("x", I))])
                                     ]),
                                (Id ("x", I))))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_exists_equiv1"),
              [([(PId "A"); (PId "m"); (PConstr ("just", [(PId "x")]))],
                (Some (Id ("refl", I))))]
              )),
           [E; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                       (Binder ("x",
                          (BOpr ("=",
                             (App
                                [(Id ("exists_sing", I));
                                  (App
                                     [(Inst ("sing_exists",
                                         [(SId "_"); (SId "t")], I));
                                       (Id ("x", I))])
                                  ]),
                             (Id ("x", I))))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "sing_exists_equiv2"; relv = N;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U,
                          (App
                             [(Inst ("exists",
                                 [(SId "_"); (SId "_"); (SId "t")], I));
                               (Fun (
                                  (Pi (R, U, (Id ("A", I)),
                                     (Binder ("a", IMeta)))),
                                  (Binder (None,
                                     [([(PId "a")],
                                       (Some (BOpr ("=", (Id ("a", I)),
                                                (Id ("m", I))))))
                                       ]
                                     )),
                                  []))
                               ]),
                          (Binder ("x",
                             (BOpr ("=",
                                (App
                                   [(Id ("sing_exists", I));
                                     (App
                                        [(Id ("exists_sing", I));
                                          (Id ("x", I))])
                                     ]),
                                (Id ("x", I))))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_exists_equiv2"),
              [([(PId "A"); (PId "m");
                  (PConstr ("ex", [(PId "x"); (PId "refl")]))],
                (Some (Id ("refl", I))))]
              )),
           [E; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U,
                       (App
                          [(Inst ("exists",
                              [(SId "_"); (SId "_"); (SId "t")], I));
                            (Fun (
                               (Pi (R, U, (Id ("A", I)),
                                  (Binder ("a", IMeta)))),
                               (Binder (None,
                                  [([(PId "a")],
                                    (Some (BOpr ("=", (Id ("a", I)),
                                             (Id ("m", I))))))
                                    ]
                                  )),
                               []))
                            ]),
                       (Binder ("x",
                          (BOpr ("=",
                             (App
                                [(Id ("sing_exists", I));
                                  (App
                                     [(Id ("exists_sing", I)); (Id ("x", I))])
                                  ]),
                             (Id ("x", I))))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "sing_double"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                          (Binder ("_",
                             (Pi (R, L, (UOpr ("`", (Id ("m", I)))),
                                (Binder ("_",
                                   (BOpr ("**", (Id ("A", I)), (Id ("A", I))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_double"),
              [([(PId "A"); (PId "m"); (PConstr ("just", [(PId "x")]));
                  (PConstr ("just", [(PId "y")]))],
                (Some (Let (N,
                         (Ann ((Id ("refl", I)),
                            (BOpr ("=", (Id ("x", I)), (Id ("y", I)))))),
                         (Binder ("pf",
                            (App
                               [(Id ("pair", I)); (Id ("x", I));
                                 (Id ("y", I))])
                            ))
                         ))))
                ]
              )),
           [E; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                       (Binder ("_",
                          (Pi (R, L, (UOpr ("`", (Id ("m", I)))),
                             (Binder ("_",
                                (BOpr ("**", (Id ("A", I)), (Id ("A", I))))))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "axiom_K"; relv = N;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type U),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (BOpr ("=", (Id ("m", I)), (Id ("m", I)))),
                          (Binder ("x",
                             (BOpr ("=", (Id ("x", I)), (Id ("refl", I))))))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "axiom_K"),
              [([(PId "A"); (PId "m"); (PId "refl")], (Some (Id ("refl", I))))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type U),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (BOpr ("=", (Id ("m", I)), (Id ("m", I)))),
                       (Binder ("x",
                          (BOpr ("=", (Id ("x", I)), (Id ("refl", I))))))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]}
  ]

-----------------------------------------

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_135 : nat_3) : nat_3

#[program]
inductive list_4‹› (A_136 : U): U where
| nil_6 : (list_4 A_136)
| cons_7 (hd_137 : A_136) (tl_138 : (list_4 A_136)) : (list_4 A_136)

#[logical]
inductive eq_5‹s_139› (A_140 : Type‹s_139›) (m_141 : A_140):
  A_140 -> U
where
| refl_8 : (eq_5‹??_1› ?_1[0;0] m_141 m_141)

#[program]
inductive exists_6‹s_143,r_144,t_145› (A_146 : Type‹s_143›) (B_147 : 
A_146 -> Type‹r_144›): Type‹t_145› where
| ex_9
    (m_149 : A_146) {pf_150 : ((B_147) m_149)}
    : (exists_6‹??_2,??_3,??_4› ?_2[0;0] B_147)

#[program]
inductive sing_7‹s_151› (A_152 : Type‹s_151›):
  A_152 -> Type‹s_151›
where
| just_10 (m_154 : A_152) : (sing_7‹??_5› ?_3[0;0] m_154)

#[program]
inductive prod_8‹s_155,r_156,t_157› (A_158 : Type‹s_155›) (B_159 : Type‹r_156›):
  Type‹t_157›
where
| pair_11
    (m_160 : A_158) (n_161 : B_159)
    : (prod_8‹??_6,??_7,??_8› A_158 B_159)

#[program]
def exists_sing_1‹s_162,t_163› :
  ∀ {A_164 : Type‹s_162›} ->
    ∀ {m_165 : A_164} ->
      (exists_6‹??_14,??_15,t_163›
        ?_11[0;0]
        function _167 : A_164 -> ?_9[0;0]
        | a_169 => (eq_5‹??_16› ?_10[0;0] a_169 m_165)) ->
        (sing_7‹??_17› ?_12[0;0] m_165)
:=
  function exists_sing_170 :
    ∀ {A_171 : Type‹s_162›} ->
      ∀ {m_172 : A_171} ->
        (exists_6‹??_9,??_10,t_163›
          ?_6[0;0]
          function _174 : A_171 -> ?_4[0;0]
          | a_176 => (eq_5‹??_11› ?_5[0;0] a_176 m_172)) ->
          (sing_7‹??_12› ?_7[0;0] m_172)
  | A_177 m_178 (ex_9 x_179 refl_8) => (just_10‹??_13› ?_8[0;0] x_179)

#[program]
def sing_exists_2‹s_180,t_181› :
  ∀ {A_182 : Type‹s_180›} ->
    ∀ {m_183 : A_182} ->
      (sing_7‹??_26› ?_21[0;0] m_183) ->
        (exists_6‹??_27,??_28,t_181›
          ?_24[0;0]
          function _185 : A_182 -> ?_22[0;0]
          | a_187 => (eq_5‹??_29› ?_23[0;0] a_187 m_183))
:=
  function sing_exists_188 :
    ∀ {A_189 : Type‹s_180›} ->
      ∀ {m_190 : A_189} ->
        (sing_7‹??_18› ?_13[0;0] m_190) ->
          (exists_6‹??_19,??_20,t_181›
            ?_16[0;0]
            function _192 : A_189 -> ?_14[0;0]
            | a_194 => (eq_5‹??_21› ?_15[0;0] a_194 m_190))
  | A_195 m_196 (just_10 x_197) =>
    (ex_9‹??_23,??_24,??_25›
      ?_19[0;0] ?_20[0;0] x_197 (refl_8‹??_22› ?_17[0;0] ?_18[0;0]))

#[logical]
def sing_exists_equiv1_3‹s_198,t_199› :
  ∀ {A_200 : Type‹s_198›} ->
    ∀ {m_201 : A_200} ->
      ∀ (x_202 : (sing_7‹??_36› ?_33[0;0] m_201)) ->
        (eq_5‹??_40›
          ?_38[0;0]
          ((exists_sing_1‹??_38,??_39›)
            ?_37[0;0] ?_36[0;0]
            ((sing_exists_2‹??_37,t_199›) ?_35[0;0] ?_34[0;0] x_202))
          x_202)
:=
  function sing_exists_equiv1_203 :
    ∀ {A_204 : Type‹s_198›} ->
      ∀ {m_205 : A_204} ->
        ∀ (x_206 : (sing_7‹??_30› ?_25[0;0] m_205)) ->
          (eq_5‹??_34›
            ?_30[0;0]
            ((exists_sing_1‹??_32,??_33›)
              ?_29[0;0] ?_28[0;0]
              ((sing_exists_2‹??_31,t_199›) ?_27[0;0] ?_26[0;0] x_206))
            x_206)
  | A_207 m_208 (just_10 x_209) => (refl_8‹??_35› ?_31[0;0] ?_32[0;0])

#[logical]
def sing_exists_equiv2_4‹s_210,t_211› :
  ∀ {A_212 : Type‹s_210›} ->
    ∀ {m_213 : A_212} ->
      ∀ (x_214 :
        (exists_6‹??_50,??_51,t_211›
          ?_51[0;0]
          function _215 : A_212 -> ?_49[0;0]
          | a_217 => (eq_5‹??_52› ?_50[0;0] a_217 m_213))) ->
        (eq_5‹??_57›
          ?_56[0;0]
          ((sing_exists_2‹??_55,??_56›)
            ?_55[0;0] ?_54[0;0]
            ((exists_sing_1‹??_53,??_54›) ?_53[0;0] ?_52[0;0] x_214))
          x_214)
:=
  function sing_exists_equiv2_218 :
    ∀ {A_219 : Type‹s_210›} ->
      ∀ {m_220 : A_219} ->
        ∀ (x_221 :
          (exists_6‹??_41,??_42,t_211›
            ?_41[0;0]
            function _222 : A_219 -> ?_39[0;0]
            | a_224 => (eq_5‹??_43› ?_40[0;0] a_224 m_220))) ->
          (eq_5‹??_48›
            ?_46[0;0]
            ((sing_exists_2‹??_46,??_47›)
              ?_45[0;0] ?_44[0;0]
              ((exists_sing_1‹??_44,??_45›) ?_43[0;0] ?_42[0;0] x_221))
            x_221)
  | A_225 m_226 (ex_9 x_227 refl_8) =>
    (refl_8‹??_49› ?_47[0;0] ?_48[0;0])

#[program]
def sing_double_5‹s_228› :
  ∀ {A_229 : Type‹s_228›} ->
    ∀ {m_230 : A_229} ->
      (sing_7‹??_67› ?_64[0;0] m_230) ->
        (sing_7‹??_68› ?_65[0;0] m_230) -o
          (prod_8‹??_69,??_70,L› A_229 A_229)
:=
  function sing_double_233 :
    ∀ {A_234 : Type‹s_228›} ->
      ∀ {m_235 : A_234} ->
        (sing_7‹??_58› ?_57[0;0] m_235) ->
          (sing_7‹??_59› ?_58[0;0] m_235) -o
            (prod_8‹??_60,??_61,L› A_234 A_234)
  | A_238 m_239 (just_10 x_240) (just_10 y_241) =>
    let {pf_242} :=
      ((refl_8‹??_62› ?_59[0;0] ?_60[0;0])
        : (eq_5‹??_63› ?_61[0;0] x_240 y_241))
    in (pair_11‹??_64,??_65,??_66› ?_62[0;0] ?_63[0;0] x_240 y_241)

#[logical]
def axiom_K_6‹› :
  ∀ {A_243 : U} ->
    ∀ {m_244 : A_243} ->
      ∀ (x_245 : (eq_5‹??_75› ?_72[0;0] m_244 m_244)) ->
        (eq_5‹??_77›
          ?_75[0;0] x_245 (refl_8‹??_76› ?_73[0;0] ?_74[0;0]))
:=
  function axiom_K_246 :
    ∀ {A_247 : U} ->
      ∀ {m_248 : A_247} ->
        ∀ (x_249 : (eq_5‹??_71› ?_66[0;0] m_248 m_248)) ->
          (eq_5‹??_73›
            ?_69[0;0] x_249 (refl_8‹??_72› ?_67[0;0] ?_68[0;0]))
  | A_250 m_251 refl_8 => (refl_8‹??_74› ?_70[0;0] ?_71[0;0])

-----------------------------------------

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_4137 : nat_3) : nat_3

#[program]
inductive list_4‹› (A_4138 : U): U where
| nil_6 : (list_4 A_4138)
| cons_7 (hd_4139 : A_4138) (tl_4140 : (list_4 A_4138)) : (list_4 A_4138)

#[logical]
inductive eq_5‹s_4141› (A_4142 : Type‹s_4141›) (m_4143 : A_4142):
  A_4142 -> U
where
| refl_8 : (eq_5‹s_4141› A_4142 m_4143 m_4143)

#[program]
inductive exists_6‹s_4145,r_4146,t_4147› (A_4148 : Type‹s_4145›) (B_4149 : 
A_4148 -> Type‹r_4146›): Type‹t_4147› where
| ex_9
    (m_4151 : A_4148) {pf_4152 : ((B_4149) m_4151)}
    : (exists_6‹s_4145,r_4146,t_4147› A_4148 B_4149)

#[program]
inductive sing_7‹s_4153› (A_4154 : Type‹s_4153›):
  A_4154 -> Type‹s_4153›
where
| just_10 (m_4156 : A_4154) : (sing_7‹s_4153› A_4154 m_4156)

#[program]
inductive prod_8‹s_4157,r_4158,t_4159› (A_4160 : Type‹s_4157›) (B_4161 : Type‹r_4158›):
  Type‹t_4159›
where
| pair_11
    (m_4162 : A_4160) (n_4163 : B_4161)
    : (prod_8‹s_4157,r_4158,t_4159› A_4160 B_4161)

#[program]
def exists_sing_1‹s_4164,t_4165› :
  ∀ {A_4166 : Type‹s_4164›} ->
    ∀ {m_4167 : A_4166} ->
      (exists_6‹s_4164,U,t_4165›
        A_4166
        function _4169 : A_4166 -> U
        | __4171 => (eq_5‹s_4164› A_4166 __4171 m_4167)) ->
        (sing_7‹s_4164› A_4166 m_4167)
:=
  function exists_sing_4172 :
    ∀ {A_4173 : Type‹s_4164›} ->
      ∀ {m_4174 : A_4173} ->
        (exists_6‹s_4164,U,t_4165›
          A_4173
          function _4176 : A_4173 -> U
          | __4178 => (eq_5‹s_4164› A_4173 __4178 m_4174)) ->
          (sing_7‹s_4164› A_4173 m_4174)
  | A_4179 m_4180 (ex_9 m_4181 refl_8) => (just_10‹s_4164› A_4179 m_4181)

#[program]
def sing_exists_2‹s_4182,t_4183› :
  ∀ {A_4184 : Type‹s_4182›} ->
    ∀ {m_4185 : A_4184} ->
      (sing_7‹s_4182› A_4184 m_4185) ->
        (exists_6‹s_4182,U,t_4183›
          A_4184
          function _4187 : A_4184 -> U
          | __4189 => (eq_5‹s_4182› A_4184 __4189 m_4185))
:=
  function sing_exists_4190 :
    ∀ {A_4191 : Type‹s_4182›} ->
      ∀ {m_4192 : A_4191} ->
        (sing_7‹s_4182› A_4191 m_4192) ->
          (exists_6‹s_4182,U,t_4183›
            A_4191
            function _4194 : A_4191 -> U
            | __4196 => (eq_5‹s_4182› A_4191 __4196 m_4192))
  | A_4197 m_4198 (just_10 m_4199) =>
    (ex_9‹s_4182,U,t_4183›
      A_4197
      function _4200 : A_4197 -> U
      | __4202 => (eq_5‹s_4182› A_4197 __4202 m_4199) m_4199
      (refl_8‹s_4182› A_4197 m_4199))

#[logical]
def sing_exists_equiv1_3‹s_4203,t_4204› :
  ∀ {A_4205 : Type‹s_4203›} ->
    ∀ {m_4206 : A_4205} ->
      ∀ (x_4207 : (sing_7‹s_4203› A_4205 m_4206)) ->
        (eq_5‹s_4203›
          (sing_7‹s_4203› A_4205 m_4206)
          ((exists_sing_1‹s_4203,t_4204›)
            A_4205 m_4206
            ((sing_exists_2‹s_4203,t_4204›) A_4205 m_4206 x_4207))
          x_4207)
:=
  function sing_exists_equiv1_4208 :
    ∀ {A_4209 : Type‹s_4203›} ->
      ∀ {m_4210 : A_4209} ->
        ∀ (x_4211 : (sing_7‹s_4203› A_4209 m_4210)) ->
          (eq_5‹s_4203›
            (sing_7‹s_4203› A_4209 m_4210)
            ((exists_sing_1‹s_4203,t_4204›)
              A_4209 m_4210
              ((sing_exists_2‹s_4203,t_4204›) A_4209 m_4210 x_4211))
            x_4211)
  | A_4212 m_4213 (just_10 m_4214) =>
    (refl_8‹s_4203›
      (sing_7‹s_4203› A_4212 m_4214)
      ((exists_sing_1‹s_4203,t_4204›)
        A_4212 m_4214
        ((sing_exists_2‹s_4203,t_4204›)
          A_4212 m_4214 (just_10‹s_4203› A_4212 m_4214))))

#[logical]
def sing_exists_equiv2_4‹s_4215,t_4216› :
  ∀ {A_4217 : Type‹s_4215›} ->
    ∀ {m_4218 : A_4217} ->
      ∀ (x_4219 :
        (exists_6‹s_4215,U,t_4216›
          A_4217
          function _4220 : A_4217 -> U
          | __4222 => (eq_5‹s_4215› A_4217 __4222 m_4218))) ->
        (eq_5‹t_4216›
          (exists_6‹s_4215,U,t_4216›
            A_4217
            function _4223 : A_4217 -> U
            | __4225 => (eq_5‹s_4215› A_4217 __4225 m_4218))
          ((sing_exists_2‹s_4215,t_4216›)
            A_4217 m_4218
            ((exists_sing_1‹s_4215,t_4216›) A_4217 m_4218 x_4219))
          x_4219)
:=
  function sing_exists_equiv2_4226 :
    ∀ {A_4227 : Type‹s_4215›} ->
      ∀ {m_4228 : A_4227} ->
        ∀ (x_4229 :
          (exists_6‹s_4215,U,t_4216›
            A_4227
            function _4230 : A_4227 -> U
            | __4232 => (eq_5‹s_4215› A_4227 __4232 m_4228))) ->
          (eq_5‹t_4216›
            (exists_6‹s_4215,U,t_4216›
              A_4227
              function _4233 : A_4227 -> U
              | __4235 => (eq_5‹s_4215› A_4227 __4235 m_4228))
            ((sing_exists_2‹s_4215,t_4216›)
              A_4227 m_4228
              ((exists_sing_1‹s_4215,t_4216›) A_4227 m_4228 x_4229))
            x_4229)
  | A_4236 m_4237 (ex_9 m_4238 refl_8) =>
    (refl_8‹t_4216›
      (exists_6‹s_4215,U,t_4216›
        A_4236
        function _4239 : A_4236 -> U
        | __4241 => (eq_5‹s_4215› A_4236 __4241 m_4238))
      ((sing_exists_2‹s_4215,t_4216›)
        A_4236 m_4238
        ((exists_sing_1‹s_4215,t_4216›)
          A_4236 m_4238
          (ex_9‹s_4215,U,t_4216›
            A_4236
            function _4242 : A_4236 -> U
            | __4244 => (eq_5‹s_4215› A_4236 __4244 m_4238) m_4238
            (refl_8‹s_4215› A_4236 m_4238)))))

#[program]
def sing_double_5‹s_4245› :
  ∀ {A_4246 : Type‹s_4245›} ->
    ∀ {m_4247 : A_4246} ->
      (sing_7‹s_4245› A_4246 m_4247) ->
        (sing_7‹s_4245› A_4246 m_4247) -o
          (prod_8‹s_4245,s_4245,L› A_4246 A_4246)
:=
  function sing_double_4250 :
    ∀ {A_4251 : Type‹s_4245›} ->
      ∀ {m_4252 : A_4251} ->
        (sing_7‹s_4245› A_4251 m_4252) ->
          (sing_7‹s_4245› A_4251 m_4252) -o
            (prod_8‹s_4245,s_4245,L› A_4251 A_4251)
  | A_4255 m_4256 (just_10 m_4257) (just_10 m_4258) =>
    let {pf_4259} :=
      ((refl_8‹s_4245› A_4255 m_4257)
        : (eq_5‹s_4245› A_4255 m_4257 m_4258))
    in (pair_11‹s_4245,s_4245,L› A_4255 A_4255 m_4257 m_4258)

#[logical]
def axiom_K_6‹› :
  ∀ {A_4260 : U} ->
    ∀ {m_4261 : A_4260} ->
      ∀ (x_4262 : (eq_5‹U› A_4260 m_4261 m_4261)) ->
        (eq_5‹U›
          (eq_5‹U› A_4260 m_4261 m_4261) x_4262
          (refl_8‹U› A_4260 m_4261))
:=
  function axiom_K_4263 :
    ∀ {A_4264 : U} ->
      ∀ {m_4265 : A_4264} ->
        ∀ (x_4266 : (eq_5‹U› A_4264 m_4265 m_4265)) ->
          (eq_5‹U›
            (eq_5‹U› A_4264 m_4265 m_4265) x_4266
            (refl_8‹U› A_4264 m_4265))
  | A_4267 m_4268 refl_8 =>
    (refl_8‹U›
      (eq_5‹U› A_4267 m_4268 m_4268) (refl_8‹U› A_4267 m_4268))

-----------------------------------------

#[program]
inductive unit_1 where
| tt_1 of layout[]

#[program]
inductive bool_2 where
| true_2 of layout[]
| false_3 of layout[]

#[program]
inductive nat_3 where
| zero_4 of layout[]
| succ_5 of layout[R]

#[program]
inductive list_4 where
| nil_6 of layout[]
| cons_7 of layout[R, R]

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
inductive existsUUU_18 where
| exUUU_21 of layout[R, N]

#[program]
inductive existsUUL_17 where
| exUUL_20 of layout[R, N]

#[program]
inductive existsULU_16 where
| exULU_19 of layout[R, N]

#[program]
inductive existsULL_15 where
| exULL_18 of layout[R, N]

#[program]
inductive existsLUU_14 where


#[program]
inductive existsLUL_13 where
| exLUL_16 of layout[R, N]

#[program]
inductive existsLLU_12 where


#[program]
inductive existsLLL_11 where
| exLLL_14 of layout[R, N]

#[program]
inductive singU_20 where
| justU_23 of layout[R]

#[program]
inductive singL_19 where
| justL_22 of layout[R]

#[program]
inductive prodUUU_28 where
| pairUUU_31 of layout[R, R]

#[program]
inductive prodUUL_27 where
| pairUUL_30 of layout[R, R]

#[program]
inductive prodULU_26 where


#[program]
inductive prodULL_25 where
| pairULL_28 of layout[R, R]

#[program]
inductive prodLUU_24 where


#[program]
inductive prodLUL_23 where
| pairLUL_26 of layout[R, R]

#[program]
inductive prodLLU_22 where


#[program]
inductive prodLLL_21 where
| pairLLL_24 of layout[R, R]

#[program]
def exists_singUU_10 :=
  fun exists_sing_7127 {A_7128} -> {m_7129} -> (__7130) ->
    match __7130 with
    | exUUU_21 m_7131 pf_7132 =>
      match {NULL} with
      | reflU_13  => (justU_23 m_7131)
      end
    end

#[program]
def exists_singUL_9 :=
  fun exists_sing_7133 {A_7134} -> {m_7135} -> (__7136) ->
    match __7136 with
    | exUUL_20 m_7137 pf_7138 =>
      match {NULL} with
      | reflU_13  => (justU_23 m_7137)
      end
    end

#[program]
def exists_singLU_8 :=
  fun exists_sing_7139 {A_7140} -> {m_7141} -> (__7142) ->
    match __7142 with
    
    end

#[program]
def exists_singLL_7 :=
  fun exists_sing_7143 {A_7144} -> {m_7145} -> (__7146) ->
    match __7146 with
    | exLUL_16 m_7147 pf_7148 =>
      match {NULL} with
      | reflL_12  => (justL_22 m_7147)
      end
    end

#[program]
def sing_existsUU_14 :=
  fun sing_exists_7149 {A_7150} -> {m_7151} -> (__7152) ->
    match __7152 with
    | justU_23 m_7153 => (exUUU_21 m_7153 NULL)
    end

#[program]
def sing_existsUL_13 :=
  fun sing_exists_7154 {A_7155} -> {m_7156} -> (__7157) ->
    match __7157 with
    | justU_23 m_7158 => (exUUL_20 m_7158 NULL)
    end

#[program]
def sing_existsLL_11 :=
  fun sing_exists_7159 {A_7160} -> {m_7161} -> (__7162) ->
    match __7162 with
    | justL_22 m_7163 => (exLUL_16 m_7163 NULL)
    end

#[logical]
def sing_exists_equiv1UU_18 := NULL

#[logical]
def sing_exists_equiv1UL_17 := NULL

#[logical]
def sing_exists_equiv1LL_15 := NULL

#[logical]
def sing_exists_equiv2UU_22 := NULL

#[logical]
def sing_exists_equiv2UL_21 := NULL

#[logical]
def sing_exists_equiv2LL_19 := NULL

#[program]
def sing_doubleU_24 :=
  fun sing_double_7164 {A_7165} -> {m_7166} -> (__7167) -> (__7168) -o
    match __7167 with
    | justU_23 m_7169 =>
      match __7168 with
      | justU_23 m_7170 => (pairUUL_30 m_7169 m_7170)
      end
    end

#[program]
def sing_doubleL_23 :=
  fun sing_double_7171 {A_7172} -> {m_7173} -> (__7174) -> (__7175) -o
    match __7174 with
    | justL_22 m_7176 =>
      match __7175 with
      | justL_22 m_7177 => (pairLLL_24 m_7176 m_7177)
      end
    end

#[logical]
def axiom_K_6 := NULL

-----------------------------------------

#[program]
inductive unit_1 where
| tt_1 of layout[]

#[program]
inductive bool_2 where
| true_2 of layout[]
| false_3 of layout[]

#[program]
inductive nat_3 where
| zero_4 of layout[]
| succ_5 of layout[R]

#[program]
inductive list_4 where
| nil_6 of layout[]
| cons_7 of layout[R, R]

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
inductive existsUUU_18 where
| exUUU_21 of layout[R, N]

#[program]
inductive existsUUL_17 where
| exUUL_20 of layout[R, N]

#[program]
inductive existsULU_16 where
| exULU_19 of layout[R, N]

#[program]
inductive existsULL_15 where
| exULL_18 of layout[R, N]

#[program]
inductive existsLUU_14 where


#[program]
inductive existsLUL_13 where
| exLUL_16 of layout[R, N]

#[program]
inductive existsLLU_12 where


#[program]
inductive existsLLL_11 where
| exLLL_14 of layout[R, N]

#[program]
inductive singU_20 where
| justU_23 of layout[R]

#[program]
inductive singL_19 where
| justL_22 of layout[R]

#[program]
inductive prodUUU_28 where
| pairUUU_31 of layout[R, R]

#[program]
inductive prodUUL_27 where
| pairUUL_30 of layout[R, R]

#[program]
inductive prodULU_26 where


#[program]
inductive prodULL_25 where
| pairULL_28 of layout[R, R]

#[program]
inductive prodLUU_24 where


#[program]
inductive prodLUL_23 where
| pairLUL_26 of layout[R, R]

#[program]
inductive prodLLU_22 where


#[program]
inductive prodLLL_21 where
| pairLLL_24 of layout[R, R]

#[program]
def exists_singUU_10 :=
  fun exists_sing_7229 {A_7230} -> {m_7231} -> (__7232) ->
    match __7232 with
    | exUUU_21 m_7233 pf_7234 => (justU_23 m_7233)
    end

#[program]
def exists_singUL_9 :=
  fun exists_sing_7235 {A_7236} -> {m_7237} -> (__7238) ->
    match __7238 with
    | exUUL_20 m_7239 pf_7240 => (justU_23 m_7239)
    end

#[program]
def exists_singLU_8 :=
  fun exists_sing_7241 {A_7242} -> {m_7243} -> (__7244) -> !!

#[program]
def exists_singLL_7 :=
  fun exists_sing_7245 {A_7246} -> {m_7247} -> (__7248) ->
    match __7248 with
    | exLUL_16 m_7249 pf_7250 => (justL_22 m_7249)
    end

#[program]
def sing_existsUU_14 :=
  fun sing_exists_7251 {A_7252} -> {m_7253} -> (__7254) ->
    match __7254 with
    | justU_23 m_7255 => (exUUU_21 m_7255 NULL)
    end

#[program]
def sing_existsUL_13 :=
  fun sing_exists_7256 {A_7257} -> {m_7258} -> (__7259) ->
    match __7259 with
    | justU_23 m_7260 => (exUUL_20 m_7260 NULL)
    end

#[program]
def sing_existsLL_11 :=
  fun sing_exists_7261 {A_7262} -> {m_7263} -> (__7264) ->
    match __7264 with
    | justL_22 m_7265 => (exLUL_16 m_7265 NULL)
    end

#[logical]
def sing_exists_equiv1UU_18 := NULL

#[logical]
def sing_exists_equiv1UL_17 := NULL

#[logical]
def sing_exists_equiv1LL_15 := NULL

#[logical]
def sing_exists_equiv2UU_22 := NULL

#[logical]
def sing_exists_equiv2UL_21 := NULL

#[logical]
def sing_exists_equiv2LL_19 := NULL

#[program]
def sing_doubleU_24 :=
  fun sing_double_7266 {A_7267} -> {m_7268} -> (__7269) -> (__7270) -o
    match __7269 with
    | justU_23 m_7271 =>
      match __7270 with
      | justU_23 m_7272 => (pairUUL_30 m_7271 m_7272)
      end
    end

#[program]
def sing_doubleL_23 :=
  fun sing_double_7273 {A_7274} -> {m_7275} -> (__7276) -> (__7277) -o
    match __7276 with
    | justL_22 m_7278 =>
      match __7277 with
      | justL_22 m_7279 => (pairLLL_24 m_7278 m_7279)
      end
    end

#[logical]
def axiom_K_6 := NULL

-----------------------------------------

