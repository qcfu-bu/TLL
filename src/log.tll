[Inductive {name = "unit"; relv = R;
   body =
   (Binder ([],
      (PBase
         ((TBase (Type U)), [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
      ));
   view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase
                              (App
                                 [(Id ("eq", I)); (Id ("m", I));
                                   (Id ("m", I))])),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "exists"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("ex",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (N,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("pf",
                                       (TBase
                                          (App
                                             [(Id ("exists", I));
                                               (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "s"))))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m",
                           (TBase (App [(Id ("sing", I)); (Id ("m", I))]))))
                        )),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "list"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type (SId "s"))),
                 [(DConstr ("nil",
                     (TBase (App [(Id ("list", I)); (Id ("A", I))])), 
                     []));
                   (DConstr ("cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (App [(Id ("list", I)); (Id ("A", I))]),
                               (Binder ("tl",
                                  (TBase
                                     (App [(Id ("list", I)); (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Definition {name = "lte"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("bool", I))))
                    ))
                 ))
              )),
           (Binder ((Some "lte"),
              [([(PId "zero"); (PId "_")], (Some (Id ("true", I))));
                ([(PId "_"); (PId "zero")], (Some (Id ("false", I))));
                ([(PConstr ("succ", [(PId "x")]));
                   (PConstr ("succ", [(PId "y")]))],
                 (Some (App [(Id ("lte", I)); (Id ("x", I)); (Id ("y", I))])))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "lt"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", (Id ("bool", I))))
                    ))
                 ))
              )),
           (Binder ((Some "lt"),
              [([(PId "x"); (PId "y")],
                (Some (App
                         [(Id ("lte", I));
                           (App [(Id ("succ", I)); (Id ("x", I))]);
                           (Id ("y", I))])))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x",
              (Pi (R, U, (Id ("nat", I)), (Binder ("y", (Id ("bool", I))))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "length"; relv = N;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (R, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (App [(Id ("list", I)); (Id ("A", I))]),
                    (Binder ("_", (Id ("nat", I))))))
                 ))
              )),
           (Binder ((Some "length"),
              [([(PId "A"); (PId "nil")], (Some (Id ("zero", I))));
                ([(PId "A"); (PConstr ("cons", [(PId "_"); (PId "tl")]))],
                 (Some (App
                          [(Id ("succ", I));
                            (App [(Id ("length", I)); (Id ("tl", I))])])))
                ]
              )),
           [I])),
        (Pi (R, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (R, U, (App [(Id ("list", I)); (Id ("A", I))]),
                 (Binder ("_", (Id ("nat", I))))))
              ))
           )))
       ));
    view = [I]};
  Inductive {name = "at"; relv = N;
    body =
    (Binder ([],
       (PBind ((Type U),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("x",
                   (PBase
                      ((TBind (R, (Id ("nat", I)),
                          (Binder ("_",
                             (TBind (R,
                                (App [(Id ("list", I)); (Id ("A", I))]),
                                (Binder ("_", (TBase (Type U))))))
                             ))
                          )),
                       [(DConstr ("at_zero",
                           (TBind (R,
                              (App [(Id ("list", I)); (Id ("A", I))]),
                              (Binder ("xs0",
                                 (TBase
                                    (App
                                       [(Id ("at", I)); (Id ("x", I));
                                         (Id ("zero", I));
                                         (App
                                            [(Id ("cons", I)); (Id ("x", I));
                                              (Id ("xs0", I))])
                                         ]))
                                 ))
                              )),
                           [E]));
                         (DConstr ("at_succ",
                            (TBind (R, (Id ("nat", I)),
                               (Binder ("n",
                                  (TBind (R, (Id ("A", I)),
                                     (Binder ("x0",
                                        (TBind (R,
                                           (App
                                              [(Id ("list", I));
                                                (Id ("A", I))]),
                                           (Binder ("xs0",
                                              (TBind (R,
                                                 (App
                                                    [(Id ("at", I));
                                                      (Id ("x", I));
                                                      (Id ("n", I));
                                                      (Id ("xs0", I))]),
                                                 (Binder ("h",
                                                    (TBase
                                                       (App
                                                          [(Id ("at", I));
                                                            (Id ("x", I));
                                                            (App
                                                               [(Id ("succ",
                                                                   I));
                                                                 (Id ("n", I
                                                                    ))
                                                                 ]);
                                                            (App
                                                               [(Id ("cons",
                                                                   I));
                                                                 (Id ("x0", I
                                                                    ));
                                                                 (Id ("xs0",
                                                                    I))
                                                                 ])
                                                            ]))
                                                    ))
                                                 ))
                                              ))
                                           ))
                                        ))
                                     ))
                                  ))
                               )),
                            [I; E; I; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "get_at"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type U),
              (Binder ("A",
                 (Pi (R, U, (Id ("nat", I)),
                    (Binder ("n",
                       (Pi (R, U, (App [(Id ("list", I)); (Id ("A", I))]),
                          (Binder ("xs",
                             (Pi (N, U,
                                (App
                                   [(Id ("eq", I));
                                     (App
                                        [(Id ("lt", I)); (Id ("n", I));
                                          (App
                                             [(Id ("length", I));
                                               (Id ("xs", I))])
                                          ]);
                                     (Id ("true", I))]),
                                (Binder ("_",
                                   (App
                                      [(Inst ("exists",
                                          [(SId "_"); (SId "_"); L], I));
                                        (Fun (
                                           (Pi (R, U, IMeta,
                                              (Binder ("x", IMeta)))),
                                           (Binder (None,
                                              [([(PId "x")],
                                                (Some (App
                                                         [(Id ("at", I));
                                                           (Id ("x", I));
                                                           (Id ("n", I));
                                                           (Id ("xs", I))])))
                                                ]
                                              )),
                                           []))
                                        ])
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "get_at"),
              [([(PId "A"); (PId "_"); (PId "nil"); PAbsurd], None);
                ([(PId "A"); (PId "zero");
                   (PConstr ("cons", [(PId "x"); (PId "xs")])); (PId "_")],
                 (Some (App
                          [(Id ("ex", I)); (Id ("x", I));
                            (App [(Id ("at_zero", I)); (Id ("xs", I))])])));
                ([(PId "A"); (PConstr ("succ", [(PId "n")]));
                   (PConstr ("cons", [(PId "x"); (PId "xs")])); (PId "e")],
                 (Some (Match (
                          [(R,
                            (App
                               [(Id ("get_at", I)); (Id ("n", I));
                                 (Id ("xs", I)); (Id ("e", I))]),
                            None)],
                          None,
                          [([(PConstr ("ex", [(PId "x0"); (PId "pf")]))],
                            (Some (App
                                     [(Id ("ex", I)); (Id ("x0", I));
                                       (App
                                          [(Id ("at_succ", I)); IMeta;
                                            (Id ("pf", I))])
                                       ])))
                            ]
                          ))))
                ]
              )),
           [I])),
        (Pi (N, U, (Type U),
           (Binder ("A",
              (Pi (R, U, (Id ("nat", I)),
                 (Binder ("n",
                    (Pi (R, U, (App [(Id ("list", I)); (Id ("A", I))]),
                       (Binder ("xs",
                          (Pi (N, U,
                             (App
                                [(Id ("eq", I));
                                  (App
                                     [(Id ("lt", I)); (Id ("n", I));
                                       (App
                                          [(Id ("length", I)); (Id ("xs", I))
                                            ])
                                       ]);
                                  (Id ("true", I))]),
                             (Binder ("_",
                                (App
                                   [(Inst ("exists",
                                       [(SId "_"); (SId "_"); L], I));
                                     (Fun (
                                        (Pi (R, U, IMeta,
                                           (Binder ("x", IMeta)))),
                                        (Binder (None,
                                           [([(PId "x")],
                                             (Some (App
                                                      [(Id ("at", I));
                                                        (Id ("x", I));
                                                        (Id ("n", I));
                                                        (Id ("xs", I))])))
                                             ]
                                           )),
                                        []))
                                     ])
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I]}
  ]

-----------------------------------------

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_104 : nat_3) : nat_3

#[logical]
inductive eq_4‹s_105› (A_106 : Type‹s_105›) (m_107 : A_106):
  A_106 -> U
where
| refl_6 : (eq_4‹??_1› ?_1 m_107 m_107)

#[program]
inductive exists_5‹s_109,r_110,t_111› (A_112 : Type‹s_109›) (B_113 : 
A_112 -> Type‹r_110›): Type‹t_111› where
| ex_7
    (m_115 : A_112) {pf_116 : ((B_113) m_115)}
    : (exists_5‹??_2,??_3,??_4› ?_2 B_113)

#[program]
inductive sing_6‹s_117› (A_118 : Type‹s_117›):
  A_118 -> Type‹s_117›
where
| just_8 (m_120 : A_118) : (sing_6‹??_5› ?_3 m_120)

#[program]
inductive list_7‹s_121› (A_122 : Type‹s_121›): Type‹s_121› where
| nil_9 : (list_7‹??_6› A_122)
| cons_10
    (hd_123 : A_122) (tl_124 : (list_7‹??_7› A_122))
    : (list_7‹??_8› A_122)

#[program]
def lte_1‹› : nat_3 -> nat_3 -> bool_2 :=
  function lte_127 : nat_3 -> nat_3 -> bool_2
  | zero_4 _130 => true_2
  | _131 zero_4 => false_3
  | (succ_5 x_132) (succ_5 y_133) => ((lte_127) x_132 y_133)

#[program]
def lt_2‹› : nat_3 -> nat_3 -> bool_2 :=
  function lt_136 : nat_3 -> nat_3 -> bool_2
  | x_139 y_140 => ((lte_1) (succ_5‹› x_139) y_140)

#[logical]
def length_3‹s_141› :
  ∀ (A_142 : Type‹s_141›) -> (list_7‹??_10› A_142) -> nat_3
:=
  function length_144 :
    ∀ (A_145 : Type‹s_141›) -> (list_7‹??_9› A_145) -> nat_3
  | A_147 nil_9 => zero_4
  | A_148 (cons_10 _149 tl_150) => (succ_5‹› ((length_144) ?_4 tl_150))

#[logical]
inductive at_8‹› (A_151 : U) (x_152 : A_151):
  nat_3 -> (list_7‹??_11› A_151) -> U
where
| at_zero_11
    (xs0_155 : (list_7‹??_12› A_151))
    : (at_8 ?_6 x_152 zero_4 (cons_10‹??_13› x_152 xs0_155))
| at_succ_12
    (n_156 : nat_3) (x0_157 : A_151) (xs0_158 : (list_7‹??_14› A_151))
    (h_159 : (at_8 ?_7 x_152 n_156 xs0_158))
    : (at_8
        ?_9 x_152 (succ_5‹› n_156) (cons_10‹??_15› x0_157 xs0_158))

#[program]
def get_at_4‹› :
  ∀ {A_160 : U} ->
    ∀ (n_161 : nat_3) ->
      ∀ (xs_162 : (list_7‹??_27› A_160)) ->
        ∀ {__163 :
          (eq_4‹??_29›
            ?_31 ((lt_2) n_161 ((length_3‹??_28›) ?_30 xs_162)) true_2)} ->
          (exists_5‹??_30,??_31,L›
            ?_35
            function _164 : ∀ (x_165 : ?_32) -> ?_33
            | x_166 => (at_8 ?_34 x_166 n_161 xs_162))
:=
  function get_at_167 :
    ∀ {A_168 : U} ->
      ∀ (n_169 : nat_3) ->
        ∀ (xs_170 : (list_7‹??_16› A_168)) ->
          ∀ {__171 :
            (eq_4‹??_18›
              ?_11 ((lt_2) n_169 ((length_3‹??_17›) ?_10 xs_170)) true_2)} ->
            (exists_5‹??_19,??_20,L›
              ?_15
              function _172 : ∀ (x_173 : ?_12) -> ?_13
              | x_174 => (at_8 ?_14 x_174 n_169 xs_170))
  | A_175 _176 nil_9 !! =>
  | A_177 zero_4 (cons_10 x_178 xs_179) _180 =>
    (ex_7‹??_21,??_22,??_23› x_178 (at_zero_11‹› xs_179))
  | A_181 (succ_5 n_182) (cons_10 x_183 xs_184) e_185 =>
    match ((get_at_167) ?_20 n_182 xs_184 e_185) in ∀ (_186 : ?_21) -o ?_22
    with
    | (ex_7 x0_187 pf_188) =>
      (ex_7‹??_24,??_25,??_26›
        x0_187 (at_succ_12‹› ?_25 ?_23 ?_24 pf_188))

-----------------------------------------

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_1752 : nat_3) : nat_3

#[logical]
inductive eq_4‹s_1753› (A_1754 : Type‹s_1753›) (m_1755 : A_1754):
  A_1754 -> U
where
| refl_6 : (eq_4‹s_1753› A_1754 m_1755 m_1755)

#[program]
inductive exists_5‹s_1757,r_1758,t_1759› (A_1760 : Type‹s_1757›) (B_1761 : 
A_1760 -> Type‹r_1758›): Type‹t_1759› where
| ex_7
    (m_1763 : A_1760) {pf_1764 : ((B_1761) m_1763)}
    : (exists_5‹s_1757,r_1758,t_1759› A_1760 B_1761)

#[program]
inductive sing_6‹s_1765› (A_1766 : Type‹s_1765›):
  A_1766 -> Type‹s_1765›
where
| just_8 (m_1768 : A_1766) : (sing_6‹s_1765› A_1766 m_1768)

#[program]
inductive list_7‹s_1769› (A_1770 : Type‹s_1769›): Type‹s_1769›
where
| nil_9 : (list_7‹s_1769› A_1770)
| cons_10
    (hd_1771 : A_1770) (tl_1772 : (list_7‹s_1769› A_1770))
    : (list_7‹s_1769› A_1770)

#[program]
def lte_1‹› : nat_3 -> nat_3 -> bool_2 :=
  function lte_1775 : nat_3 -> nat_3 -> bool_2
  | zero_4 _1778 => true_2
  | _1779 zero_4 => false_3
  | (succ_5 x_1780) (succ_5 y_1781) => ((lte_1775) x_1780 y_1781)

#[program]
def lt_2‹› : nat_3 -> nat_3 -> bool_2 :=
  function lt_1784 : nat_3 -> nat_3 -> bool_2
  | x_1787 y_1788 => ((lte_1) (succ_5‹› x_1787) y_1788)

#[logical]
def length_3‹s_1789› :
  ∀ (A_1790 : Type‹s_1789›) -> (list_7‹s_1789› A_1790) -> nat_3
:=
  function length_1792 :
    ∀ (A_1793 : Type‹s_1789›) -> (list_7‹s_1789› A_1793) -> nat_3
  | A_1795 nil_9 => zero_4
  | A_1796 (cons_10 _1797 tl_1798) =>
    (succ_5‹› ((length_1792) A_1796 tl_1798))

#[logical]
inductive at_8‹› (A_1799 : U) (x_1800 : A_1799):
  nat_3 -> (list_7‹U› A_1799) -> U
where
| at_zero_11
    (xs0_1803 : (list_7‹U› A_1799))
    : (at_8 A_1799 x_1800 zero_4 (cons_10‹U› x_1800 xs0_1803))
| at_succ_12
    (n_1804 : nat_3) (x0_1805 : A_1799) (xs0_1806 : (list_7‹U› A_1799))
    (h_1807 : (at_8 A_1799 x_1800 n_1804 xs0_1806))
    : (at_8
        A_1799 x_1800 (succ_5‹› n_1804) (cons_10‹U› x0_1805 xs0_1806))

#[program]
def get_at_4‹› :
  ∀ {A_1808 : U} ->
    ∀ (n_1809 : nat_3) ->
      ∀ (xs_1810 : (list_7‹U› A_1808)) ->
        {(eq_4‹U›
           bool_2 ((lt_2) n_1809 ((length_3‹U›) A_1808 xs_1810)) true_2)} ->
          (exists_5‹U,U,L›
            A_1808
            function _1812 : A_1808 -> U
            | x_1814 => (at_8 A_1808 x_1814 n_1809 xs_1810))
:=
  function get_at_1815 :
    ∀ {A_1816 : U} ->
      ∀ (n_1817 : nat_3) ->
        ∀ (xs_1818 : (list_7‹U› A_1816)) ->
          {(eq_4‹U›
             bool_2 ((lt_2) n_1817 ((length_3‹U›) A_1816 xs_1818)) true_2)} ->
            (exists_5‹U,U,L›
              A_1816
              function _1820 : A_1816 -> U
              | x_1822 => (at_8 A_1816 x_1822 n_1817 xs_1818))
  | A_1823 _1824 nil_9 !! =>
  | A_1825 zero_4 (cons_10 x_1826 xs_1827) _1828 =>
    (ex_7‹U,U,L› x_1826 (at_zero_11‹› xs_1827))
  | A_1829 (succ_5 n_1830) (cons_10 x_1831 xs_1832) e_1833 =>
    match ((get_at_1815) A_1829 n_1830 xs_1832 e_1833) in
      (exists_5‹U,U,L›
        A_1829
        function _1835 : A_1829 -> U
        | x_1837 => (at_8 A_1829 x_1837 n_1830 xs_1832)) -o
        (exists_5‹U,U,L›
          A_1829
          function _1838 : A_1829 -> U
          | x_1840 =>
            (at_8
              A_1829 x_1840 (succ_5‹› n_1830)
              (cons_10‹U› x_1831 xs_1832)))
    with
    | (ex_7 x0_1841 pf_1842) =>
      (ex_7‹U,U,L›
        x0_1841 (at_succ_12‹› n_1830 x_1831 xs_1832 pf_1842))

-----------------------------------------

  warning - pruned constructor exLLU_16 trans12.check_dconstrs
  warning - pruned constructor exLUU_18 trans12.check_dconstrs
#[program]
inductive unit_1 where
| tt_1 of layout[]

#[program]
inductive bool_2 where
| true_2 of layout[]
| false_3 of layout[]

#[program]
inductive nat_3 where
| zero_4 of layout[]
| succ_5 of layout[R]

#[logical]
inductive eqU_10 where
| reflU_14 of layout[]

#[logical]
inductive eqL_9 where
| reflL_13 of layout[]

#[program]
inductive existsUUU_18 where
| exUUU_22 of layout[R, N]

#[program]
inductive existsUUL_17 where
| exUUL_21 of layout[R, N]

#[program]
inductive existsULU_16 where
| exULU_20 of layout[R, N]

#[program]
inductive existsULL_15 where
| exULL_19 of layout[R, N]

#[program]
inductive existsLUU_14 where


#[program]
inductive existsLUL_13 where
| exLUL_17 of layout[R, N]

#[program]
inductive existsLLU_12 where


#[program]
inductive existsLLL_11 where
| exLLL_15 of layout[R, N]

#[program]
inductive singU_20 where
| justU_24 of layout[R]

#[program]
inductive singL_19 where
| justL_23 of layout[R]

#[program]
inductive listU_22 where
| nilU_27 of layout[]
| consU_28 of layout[R, R]

#[program]
inductive listL_21 where
| nilL_25 of layout[]
| consL_26 of layout[R, R]

#[program]
def lte_1 :=
  fun lte_2947 (__2948, __2949) =>
    match __2948 with
    | zero_4  => true_2
    | succ_5 pred_2950 =>
      match __2949 with
      | zero_4  => false_3
      | succ_5 pred_2951 => ((lte_2947) pred_2950 pred_2951)
      end
    end

#[program]
def lt_2 := fun lt_2952 (x_2953, y_2954) => ((lte_1) (succ_5 x_2953) y_2954)

#[logical]
def lengthU_6 := NULL

#[logical]
def lengthL_5 := NULL

#[logical]
inductive at_8 where
| at_zero_11 of layout[R]
| at_succ_12 of layout[R, R, R, R]

#[program]
def get_at_4 :=
  fun get_at_2955 (A_2956, n_2957, xs_2958, __2959) =>
    match xs_2958 with
    | nilU_27  => !!
    | consU_28 hd_2960 tl_2961 =>
      match n_2957 with
      | zero_4  => (exUUL_21 hd_2960 NULL)
      | succ_5 pred_2962 =>
        match ((get_at_2955) NULL pred_2962 tl_2961 NULL) with
        | exUUL_21 m_2963 pf_2964 => (exUUL_21 m_2963 NULL)
        end
      end
    end

-----------------------------------------

#[program]
inductive unit_1 where
| tt_1 of layout[]

#[program]
inductive bool_2 where
| true_2 of layout[]
| false_3 of layout[]

#[program]
inductive nat_3 where
| zero_4 of layout[]
| succ_5 of layout[R]

#[logical]
inductive eqU_10 where
| reflU_14 of layout[]

#[logical]
inductive eqL_9 where
| reflL_13 of layout[]

#[program]
inductive existsUUU_18 where
| exUUU_22 of layout[R, N]

#[program]
inductive existsUUL_17 where
| exUUL_21 of layout[R, N]

#[program]
inductive existsULU_16 where
| exULU_20 of layout[R, N]

#[program]
inductive existsULL_15 where
| exULL_19 of layout[R, N]

#[program]
inductive existsLUU_14 where


#[program]
inductive existsLUL_13 where
| exLUL_17 of layout[R, N]

#[program]
inductive existsLLU_12 where


#[program]
inductive existsLLL_11 where
| exLLL_15 of layout[R, N]

#[program]
inductive singU_20 where
| justU_24 of layout[R]

#[program]
inductive singL_19 where
| justL_23 of layout[R]

#[program]
inductive listU_22 where
| nilU_27 of layout[]
| consU_28 of layout[R, R]

#[program]
inductive listL_21 where
| nilL_25 of layout[]
| consL_26 of layout[R, R]

#[program]
def lte_1 :=
  fun lte_2983 (__2984, __2985) =>
    match __2984 with
    | zero_4  => true_2
    | succ_5 pred_2986 =>
      match __2985 with
      | zero_4  => false_3
      | succ_5 pred_2987 => ((lte_2983) pred_2986 pred_2987)
      end
    end

#[program]
def lt_2 := fun lt_2988 (x_2989, y_2990) => ((lte_1) (succ_5 x_2989) y_2990)

#[logical]
def lengthU_6 := NULL

#[logical]
def lengthL_5 := NULL

#[logical]
inductive at_8 where
| at_zero_11 of layout[R]
| at_succ_12 of layout[R, R, R, R]

#[program]
def get_at_4 :=
  fun get_at_2991 (A_2992, n_2993, xs_2994, __2995) =>
    match xs_2994 with
    | consU_28 hd_2996 tl_2997 =>
      match n_2993 with
      | zero_4  => (exUUL_21 hd_2996 NULL)
      | succ_5 pred_2998 =>
        match ((get_at_2991) NULL pred_2998 tl_2997 NULL) with
        | exUUL_21 m_2999 pf_3000 => (exUUL_21 m_2999 NULL)
        end
      end
    end

-----------------------------------------

