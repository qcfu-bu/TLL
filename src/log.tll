[Notation {name = "|>"; body = (App [(Hole 2); (Hole 1)])};
  Notation {name = "@@"; body = (App [(Hole 1); (Hole 2)])};
  Notation {name = "="; body = (App [(Id ("eq", I)); (Hole 1); (Hole 2)])};
  Notation {name = "`"; body = (App [(Id ("sing", I)); (Hole 1)])};
  Notation {name = "&&"; body = (Id ("and", I))};
  Notation {name = "||"; body = (Id ("or", I))};
  Notation {name = "+"; body = (App [(Id ("add", I)); (Hole 1); (Hole 2)])};
  Notation {name = "-"; body = (App [(Id ("sub", I)); (Hole 1); (Hole 2)])};
  Notation {name = "*"; body = (App [(Id ("mul", I)); (Hole 1); (Hole 2)])};
  Notation {name = "/"; body = (App [(Id ("div", I)); (Hole 1); (Hole 2)])};
  Notation {name = "%"; body = (App [(Id ("rem", I)); (Hole 1); (Hole 2)])};
  Notation {name = "^"; body = (App [(Id ("pow", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<"; body = (App [(Id ("lt", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">"; body = (App [(Id ("gt", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<="; body = (App [(Id ("lte", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">="; body = (App [(Id ("gte", I)); (Hole 1); (Hole 2)])};
  Notation {name = "**"; body = (App [(Id ("prod1", I)); (Hole 1); (Hole 2)])};
  Notation {name = "::"; body = (App [(Id ("cons", I)); (Hole 1); (Hole 2)])};
  Notation {name = "\226\159\168,\226\159\169";
    body = (App [(Id ("pair", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase (BOpr ("=", (Id ("m", I)), (Id ("m", I))))),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "boxed"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type L)),
                 [(DConstr ("box",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m",
                           (TBase (App [(Id ("boxed", I)); (Id ("A", I))]))))
                        )),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "t"))))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m", (TBase (UOpr ("`", (Id ("m", I))))))))),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "unit"; relv = R;
    body =
    (Binder (["s"],
       (PBase
          ((TBase (Type (SId "s"))),
           [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
       ));
    view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "choice"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type L)),
           [(DConstr ("next", (TBase (Id ("choice", I))), []));
             (DConstr ("free", (TBase (Id ("choice", I))), []))]))
       ));
    view = []};
  Inductive {name = "prod"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Type (SId "r")),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("pair",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R, (Id ("B", I)),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("prod", I));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [E; E]};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("_", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Definition {name = "sing_elim"; relv = R;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("x",
                       (Pi (R, U,
                          (App
                             [(Inst ("sing", [(SId "s"); (SId "t")], I));
                               (Id ("x", I))]),
                          (Binder ("_", (Id ("A", I))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_elim"),
              [([(PId "A"); (PId "x"); (PConstr ("just", [(PId "x")]))],
                (Some (Id ("x", I))))]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("x",
                    (Pi (R, U,
                       (App
                          [(Inst ("sing", [(SId "s"); (SId "t")], I));
                            (Id ("x", I))]),
                       (Binder ("_", (Id ("A", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "sing_uniq"; relv = N;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (R, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (Id ("A", I)),
                    (Binder ("x0",
                       (Pi (R, U,
                          (App
                             [(Inst ("sing", [(SId "s"); (SId "t")], I));
                               (Id ("x0", I))]),
                          (Binder ("x",
                             (BOpr ("=", (Id ("x0", I)),
                                (App [(Id ("sing_elim", I)); (Id ("x", I))])
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_uniq"),
              [([(PId "A"); (PId "x0"); (PConstr ("just", [(PId "_")]))],
                (Some (Id ("refl", I))))]
              )),
           [I; I])),
        (Pi (R, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (R, U, (Id ("A", I)),
                 (Binder ("x0",
                    (Pi (R, U,
                       (App
                          [(Inst ("sing", [(SId "s"); (SId "t")], I));
                            (Id ("x0", I))]),
                       (Binder ("x",
                          (BOpr ("=", (Id ("x0", I)),
                             (App [(Id ("sing_elim", I)); (Id ("x", I))])))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Inductive {name = "stream_node"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type L)),
                 [(DConstr ("stream_cons",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("hd",
                           (TBind (R,
                              (Pi (R, L, (Id ("choice", I)),
                                 (Binder ("x",
                                    (Match ([(R, (Id ("x", I)), None)], None,
                                       [([(PId "next")],
                                         (Some (App
                                                  [(Id ("stream_node", I));
                                                    (Id ("A", I))])));
                                         ([(PId "free")],
                                          (Some (Id ("unit", I))))
                                         ]
                                       ))
                                    ))
                                 )),
                              (Binder ("tl",
                                 (TBase
                                    (App
                                       [(Id ("stream_node", I));
                                         (Id ("A", I))]))
                                 ))
                              ))
                           ))
                        )),
                     [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Definition {name = "stream"; relv = N;
    body =
    (Binder (["s"],
       ((Fun ((Pi (R, U, (Type (SId "s")), (Binder ("A", IMeta)))),
           (Binder ((Some "stream"),
              [([(PId "A")],
                (Some (Pi (R, L, (Id ("choice", I)),
                         (Binder ("x",
                            (Match ([(R, (Id ("x", I)), None)], None,
                               [([(PId "next")],
                                 (Some (App
                                          [(Id ("stream_node", I));
                                            (Id ("A", I))])));
                                 ([(PId "free")], (Some (Id ("unit", I))))]
                               ))
                            ))
                         ))))
                ]
              )),
           [E])),
        (Pi (R, U, (Type (SId "s")), (Binder ("A", IMeta)))))
       ));
    view = [E]};
  Definition {name = "free_stream"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (App [(Id ("stream", I)); (Id ("A", I))]),
                    (Binder ("st", (Inst ("unit", [U], I))))))
                 ))
              )),
           (Binder ((Some "free_stream"),
              [([(PId "A"); (PId "st")],
                (Some (Match (
                         [(R, (App [(Id ("st", I)); (Id ("free", I))]), None)
                           ],
                         None, [([(PId "tt")], (Some (Id ("tt", I))))]))))
                ]
              )),
           [I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (R, U, (App [(Id ("stream", I)); (Id ("A", I))]),
                 (Binder ("st", (Inst ("unit", [U], I))))))
              ))
           )))
       ));
    view = [I; E]};
  Definition {name = "uncons_stream"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (App [(Id ("stream", I)); (Id ("A", I))]),
                    (Binder ("st",
                       (App
                          [(Inst ("prod", [(SId "_"); (SId "_"); L], I));
                            (Id ("A", I));
                            (App [(Id ("stream", I)); (Id ("A", I))])])
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "uncons_stream"),
              [([(PId "A"); (PId "st")],
                (Some (Let (R, (App [(Id ("st", I)); (Id ("next", I))]),
                         (Binder (
                            (PConstr ("stream_cons", [(PId "hd"); (PId "tl")]
                               )),
                            (BOpr ("\226\159\168,\226\159\169",
                               (Id ("hd", I)), (Id ("tl", I))))
                            ))
                         ))))
                ]
              )),
           [I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (R, U, (App [(Id ("stream", I)); (Id ("A", I))]),
                 (Binder ("st",
                    (App
                       [(Inst ("prod", [(SId "_"); (SId "_"); L], I));
                         (Id ("A", I));
                         (App [(Id ("stream", I)); (Id ("A", I))])])
                    ))
                 ))
              ))
           )))
       ));
    view = [I; E]};
  Definition {name = "nat_make"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("n", (App [(Id ("stream", I)); (Id ("nat", I))]))))),
           (Binder ((Some "nat_make"),
              [([(PId "n"); (PId "next")],
                (Some (App
                         [(Id ("stream_cons", I)); (Id ("n", I));
                           (App
                              [(Id ("nat_make", I));
                                (App [(Id ("succ", I)); (Id ("n", I))])])
                           ])));
                ([(PId "n"); (PId "free")], (Some (Id ("tt", I))))]
              )),
           [E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("n", (App [(Id ("stream", I)); (Id ("nat", I))]))))))
       ));
    view = [E]};
  Inductive {name = "apair"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("apair_intro",
                           (TBind (N, (Id ("A", I)),
                              (Binder ("x",
                                 (TBind (R,
                                    (Pi (R, (SId "t"), (Id ("bool", I)),
                                       (Binder ("b",
                                          (Match ([(R, (Id ("b", I)), None)],
                                             None,
                                             [([(PId "true")],
                                               (Some (App
                                                        [(Inst ("sing",
                                                            [(SId "_"); L], I
                                                            ));
                                                          (Id ("x", I))])));
                                               ([(PId "false")],
                                                (Some (App
                                                         [(Id ("boxed", I));
                                                           (App
                                                              [(Id ("B", I));
                                                                (Id ("x", I))
                                                                ])
                                                           ])))
                                               ]
                                             ))
                                          ))
                                       )),
                                    (Binder ("select",
                                       (TBase
                                          (App
                                             [(Id ("apair", I));
                                               (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [I; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Notation {name = "(,)";
    body =
    (App
       [(Id ("apair_intro", I));
         (Fun (IMeta,
            (Binder (None,
               [([(PId "true")], (Some (App [(Id ("just", I)); (Hole 1)])));
                 ([(PId "false")], (Some (App [(Id ("box", I)); (Hole 2)])))]
               )),
            []))
         ])};
  Definition {name = "proj1"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U,
                    (Pi (R, U, (Id ("A", I)),
                       (Binder ("_", (Type (SId "r")))))),
                    (Binder ("B",
                       (Pi (R, U,
                          (App
                             [(Inst ("apair",
                                 [(SId "s"); (SId "r"); (SId "t")], E));
                               (Id ("A", I)); (Id ("B", I))]),
                          (Binder ("_", (Id ("A", I))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "proj1"),
              [([(PId "A"); (PId "B");
                  (PConstr ("apair_intro", [(PId "_"); (PId "select")]))],
                (Some (App
                         [(Id ("sing_elim", I));
                           (App [(Id ("select", I)); (Id ("true", I))])])))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U,
                 (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                 (Binder ("B",
                    (Pi (R, U,
                       (App
                          [(Inst ("apair", [(SId "s"); (SId "r"); (SId "t")],
                              E));
                            (Id ("A", I)); (Id ("B", I))]),
                       (Binder ("_", (Id ("A", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "proj2"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U,
                    (Pi (R, U, (Id ("A", I)),
                       (Binder ("_", (Type (SId "r")))))),
                    (Binder ("B",
                       (Pi (R, U,
                          (App
                             [(Inst ("apair",
                                 [(SId "s"); (SId "r"); (SId "t")], E));
                               (Id ("A", I)); (Id ("B", I))]),
                          (Binder ("x",
                             (App
                                [(Id ("B", I));
                                  (App [(Id ("proj1", I)); (Id ("x", I))])])
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "proj2"),
              [([(PId "A"); (PId "B");
                  (PConstr ("apair_intro", [(PId "x"); (PId "select")]))],
                (Some (Match (
                         [(N, (Id ("x", I)), (Some ("x0", IMeta)));
                           (N, (App [(Id ("select", I)); (Id ("true", I))]),
                            (Some ("a0", (UOpr ("`", (Id ("x", I)))))));
                           (N,
                            (App
                               [(Id ("sing_uniq", I));
                                 (App [(Id ("select", I)); (Id ("true", I))])
                                 ]),
                            (Some ("_",
                                   (BOpr ("=", (Id ("x0", I)),
                                      (App
                                         [(Id ("sing_elim", I));
                                           (Id ("a0", I))])
                                      )))));
                           (R, (App [(Id ("select", I)); (Id ("false", I))]),
                            (Some ("_",
                                   (App
                                      [(Id ("boxed", I));
                                        (App [(Id ("B", I)); (Id ("x0", I))])
                                        ]))))
                           ],
                         (Some (App
                                  [(Id ("B", I));
                                    (App
                                       [(Id ("sing_elim", I)); (Id ("a0", I))
                                         ])
                                    ])),
                         [([(PId "_"); (PId "_"); (PId "refl");
                             (PConstr ("box", [(PId "b")]))],
                           (Some (Id ("b", I))))]
                         ))))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U,
                 (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                 (Binder ("B",
                    (Pi (R, U,
                       (App
                          [(Inst ("apair", [(SId "s"); (SId "r"); (SId "t")],
                              E));
                            (Id ("A", I)); (Id ("B", I))]),
                       (Binder ("x",
                          (App
                             [(Id ("B", I));
                               (App [(Id ("proj1", I)); (Id ("x", I))])])
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "my_apair0"; relv = R;
    body =
    (Binder ([],
       ((BOpr ("(,)", (Id ("zero", I)),
           (Let (R, (App [(Id ("nat_make", I)); (Id ("zero", I))]),
              (Binder ((PId "nat_stream"), (Id ("nat_stream", I))))))
           )),
        (App
           [(Inst ("apair", [(SId "_"); (SId "_"); U], I));
             (Fun ((Pi (R, U, (Id ("nat", I)), (Binder ("n", IMeta)))),
                (Binder (None,
                   [([(PId "n")],
                     (Some (Match ([(R, (Id ("n", I)), None)], None,
                              [([(PId "zero")],
                                (Some (App
                                         [(Id ("stream", I)); (Id ("nat", I))
                                           ])));
                                ([(PConstr ("succ", [(PId "_")]))],
                                 (Some (Inst ("unit", [L], I))))
                                ]
                              ))))
                     ]
                   )),
                []))
             ]))
       ));
    view = []};
  Definition {name = "my_apair1"; relv = R;
    body =
    (Binder ([],
       ((Let (R, (App [(Id ("nat_make", I)); (Id ("zero", I))]),
           (Binder ((PId "nat_stream"),
              (BOpr ("(,)",
                 (Let (R,
                    (App [(Id ("uncons_stream", I)); (Id ("nat_stream", I))]),
                    (Binder (
                       (PBOpr ("\226\159\168,\226\159\169", (PId "hd"),
                          (PId "tl"))),
                       (Let (R,
                          (App [(Id ("free_stream", I)); (Id ("tl", I))]),
                          (Binder ((PId "_"), (Id ("hd", I))))))
                       ))
                    )),
                 (Id ("nat_stream", I))))
              ))
           )),
        (App
           [(Inst ("apair", [(SId "_"); (SId "_"); L], I));
             (Fun ((Pi (R, U, (Id ("nat", I)), (Binder ("n", IMeta)))),
                (Binder (None,
                   [([(PId "n")],
                     (Some (Match ([(R, (Id ("n", I)), None)], None,
                              [([(PId "zero")],
                                (Some (App
                                         [(Id ("stream", I)); (Id ("nat", I))
                                           ])));
                                ([(PConstr ("succ", [(PId "_")]))],
                                 (Some (Inst ("unit", [L], I))))
                                ]
                              ))))
                     ]
                   )),
                []))
             ]))
       ));
    view = []};
  Definition {name = "_"; relv = R;
    body =
    (Binder ([],
       ((App
           [(Id ("free_stream", I));
             (App [(Id ("proj2", I)); (Id ("my_apair1", I))])]),
        (Id ("unit", I)))
       ));
    view = []}
  ]

-----------------------------------------

#[logical]
inductive eq_1‹s_179› (A_180 : Type‹s_179›) (m_181 : A_180):
  A_180 -> U
where
| refl_1 : (eq_1‹??_1› ?_1[0;0] m_181 m_181)

#[program]
inductive boxed_2‹s_183› (A_184 : Type‹s_183›): L where
| box_2 (m_185 : A_184) : (boxed_2‹??_2› A_184)

#[program]
inductive sing_3‹s_186,t_187› (A_188 : Type‹s_186›):
  A_188 -> Type‹t_187›
where
| just_3 (m_190 : A_188) : (sing_3‹??_3,??_4› ?_2[0;0] m_190)

#[program]
inductive unit_4‹s_191› : Type‹s_191› where
| tt_4 : unit_4‹??_5›

#[program]
inductive bool_5‹› : U where
| true_5 : bool_5
| false_6 : bool_5

#[program]
inductive choice_6‹› : L where
| next_7 : choice_6
| free_8 : choice_6

#[program]
inductive prod_7‹s_192,r_193,t_194› (A_195 : Type‹s_192›) (B_196 : Type‹r_193›):
  Type‹t_194›
where
| pair_9
    (m_197 : A_195) (n_198 : B_196)
    : (prod_7‹??_6,??_7,??_8› A_195 B_196)

#[program]
inductive nat_8‹› : U where
| zero_10 : nat_8
| succ_11 (__199 : nat_8) : nat_8

#[program]
def sing_elim_1‹s_200,t_201› :
  ∀ {A_202 : Type‹s_200›} ->
    ∀ {x_203 : A_202} -> (sing_3‹s_200,t_201› ?_4[0;0] x_203) -> A_202
:=
  function sing_elim_205 :
    ∀ {A_206 : Type‹s_200›} ->
      ∀ {x_207 : A_206} ->
        (sing_3‹s_200,t_201› ?_3[0;0] x_207) -> A_206
  | A_209 x_210 (just_3 x_211) => x_211

#[logical]
def sing_uniq_2‹s_212,t_213› :
  ∀ (A_214 : Type‹s_212›) ->
    ∀ (x0_215 : A_214) ->
      ∀ (x_216 : (sing_3‹s_212,t_213› ?_11[0;0] x0_215)) ->
        (eq_1‹??_15›
          ?_14[0;0] x0_215
          ((sing_elim_1‹??_13,??_14›) ?_13[0;0] ?_12[0;0] x_216))
:=
  function sing_uniq_217 :
    ∀ (A_218 : Type‹s_212›) ->
      ∀ (x0_219 : A_218) ->
        ∀ (x_220 : (sing_3‹s_212,t_213› ?_5[0;0] x0_219)) ->
          (eq_1‹??_11›
            ?_8[0;0] x0_219
            ((sing_elim_1‹??_9,??_10›) ?_7[0;0] ?_6[0;0] x_220))
  | A_221 x0_222 (just_3 _223) => (refl_1‹??_12› ?_9[0;0] ?_10[0;0])

#[program]
inductive stream_node_9‹s_224› (A_225 : Type‹s_224›): L where
| stream_cons_12
    (hd_226 : A_225)
    (tl_227 : ∀ (x_228 : choice_6) -o
                match x_228 in ?_15[0;0] -o ?_16[0;0] with
                | next_7 => (stream_node_9‹??_16› A_225)
                | free_8 => unit_4‹??_17›)
    : (stream_node_9‹??_18› A_225)

#[logical]
def stream_3‹s_230› : Type‹s_230› -> ?_20[0;0] :=
  function stream_232 : Type‹s_230› -> ?_17[0;0]
  | A_234 =>
    ∀ (x_235 : choice_6) -o
      match x_235 in ?_18[0;0] -o ?_19[0;0] with
      | next_7 => (stream_node_9‹??_19› A_234)
      | free_8 => unit_4‹??_20›

#[program]
def free_stream_4‹s_237› :
  ∀ {A_238 : Type‹s_237›} ->
    ((stream_3‹??_23›) A_238) -> unit_4‹U›
:=
  function free_stream_240 :
    ∀ {A_241 : Type‹s_237›} ->
      ((stream_3‹??_21›) A_241) -> unit_4‹U›
  | A_243 st_244 =>
    match ((st_244) free_8) in ?_21[0;0] -o ?_22[0;0] with
    | tt_4 => tt_4‹??_22›

#[program]
def uncons_stream_5‹s_246› :
  ∀ {A_247 : Type‹s_246›} ->
    ((stream_3‹??_31›) A_247) ->
      (prod_7‹??_32,??_33,L› A_247 ((stream_3‹??_34›) A_247))
:=
  function uncons_stream_249 :
    ∀ {A_250 : Type‹s_246›} ->
      ((stream_3‹??_24›) A_250) ->
        (prod_7‹??_25,??_26,L› A_250 ((stream_3‹??_27›) A_250))
  | A_252 st_253 =>
    match ((st_253) next_7) in ?_26[0;0] -o ?_25[0;0] with
    | (stream_cons_12 hd_255 tl_256) =>
      (pair_9‹??_28,??_29,??_30› ?_23[0;0] ?_24[0;0] hd_255 tl_256)

#[program]
def nat_make_6‹› : nat_8 -> ((stream_3‹??_38›) nat_8) :=
  function nat_make_258 : nat_8 -> ((stream_3‹??_35›) nat_8)
  | n_260 next_7 =>
    (stream_cons_12‹??_36›
      ?_27[0;0] n_260 ((nat_make_258) (succ_11‹› n_260)))
  | n_261 free_8 => tt_4‹??_37›

#[program]
inductive apair_10‹s_262,r_263,t_264› (A_265 : Type‹s_262›) (B_266 : 
A_265 -> Type‹r_263›): Type‹t_264› where
| apair_intro_13
    {x_268 : A_265}
    (select_269 : forall‹t_264›(b_270 : bool_5),
                    match b_270 in ?_28[0;0] -o ?_29[0;0] with
                    | true_5 => (sing_3‹??_39,L› ?_30[0;0] x_268)
                    | false_6 => (boxed_2‹??_40› ((B_266) x_268)))
    : (apair_10‹??_41,??_42,??_43› ?_31[0;0] B_266)

#[program]
def proj1_7‹s_272,r_273,t_274› :
  ∀ {A_275 : Type‹s_272›} ->
    ∀ {B_276 : A_275 -> Type‹r_273›} ->
      (apair_10‹s_272,r_273,t_274› A_275 B_276) -> A_275
:=
  function proj1_279 :
    ∀ {A_280 : Type‹s_272›} ->
      ∀ {B_281 : A_280 -> Type‹r_273›} ->
        (apair_10‹s_272,r_273,t_274› A_280 B_281) -> A_280
  | A_284 B_285 (apair_intro_13 _286 select_287) =>
    ((sing_elim_1‹??_44,??_45›)
      ?_33[0;0] ?_32[0;0] ((select_287) true_5))

#[program]
def proj2_8‹s_288,r_289,t_290› :
  ∀ {A_291 : Type‹s_288›} ->
    ∀ {B_292 : A_291 -> Type‹r_289›} ->
      ∀ (x_294 : (apair_10‹s_288,r_289,t_290› A_291 B_292)) ->
        ((B_292)
          ((proj1_7‹??_59,??_60,??_61›) ?_46[0;0] ?_45[0;0] x_294))
:=
  function proj2_295 :
    ∀ {A_296 : Type‹s_288›} ->
      ∀ {B_297 : A_296 -> Type‹r_289›} ->
        ∀ (x_299 : (apair_10‹s_288,r_289,t_290› A_296 B_297)) ->
          ((B_297)
            ((proj1_7‹??_46,??_47,??_48›) ?_35[0;0] ?_34[0;0] x_299))
  | A_300 B_301 (apair_intro_13 x_302 select_303) =>
    match x_302, ((select_303) true_5),
    ((sing_uniq_2‹??_49,??_50›)
      ?_37[0;0] ?_36[0;0] ((select_303) true_5)),
    ((select_303) false_6) in
      ∀ {x0_304 : ?_38[0;0]} -o
        ∀ {a0_305 : (sing_3‹??_51,??_52› ?_39[0;0] x_302)} -o
          {(eq_1‹??_55›
             ?_42[0;0] x0_304
             ((sing_elim_1‹??_53,??_54›) ?_41[0;0] ?_40[0;0] a0_305))} -o
            (boxed_2‹??_56› ((B_301) x0_304)) -o
              ((B_301)
                ((sing_elim_1‹??_57,??_58›) ?_44[0;0] ?_43[0;0] a0_305))
    with
    | _308, _309, refl_1, (box_2 b_310) => b_310

#[program]
def my_apair0_9‹› :
  (apair_10‹??_68,??_69,U›
    ?_56[0;0]
    function _311 : nat_8 -> ?_53[0;0]
    | n_313 =>
      match n_313 in ?_54[0;0] -o ?_55[0;0] with
      | zero_10 => ((stream_3‹??_70›) nat_8)
      | (succ_11 _315) => unit_4‹L›)
:=
  (apair_intro_13‹??_65,??_66,??_67›
    ?_51[0;0] ?_52[0;0] ?_50[0;0]
    function _316 : ?_47[0;0]
    | true_5 => (just_3‹??_62,??_63› ?_48[0;0] zero_10)
    | false_6 =>
      (box_2‹??_64›
        ?_49[0;0]
        let nat_stream_317 := ((nat_make_6) zero_10) in nat_stream_317))

#[program]
def my_apair1_10‹› :
  (apair_10‹??_79,??_80,L›
    ?_70[0;0]
    function _318 : nat_8 -> ?_67[0;0]
    | n_320 =>
      match n_320 in ?_68[0;0] -o ?_69[0;0] with
      | zero_10 => ((stream_3‹??_81›) nat_8)
      | (succ_11 _322) => unit_4‹L›)
:=
  let nat_stream_323 := ((nat_make_6) zero_10) in
  (apair_intro_13‹??_76,??_77,??_78›
    ?_65[0;0] ?_66[0;0] ?_64[0;0]
    function _324 : ?_57[0;0]
    | true_5 =>
      (just_3‹??_73,??_74›
        ?_62[0;0]
        match ((uncons_stream_5‹??_71›) ?_58[0;0] nat_stream_323) in
          ?_61[0;0] -o ?_60[0;0]
        with
        | (pair_9 hd_326 tl_327) =>
          let __328 := ((free_stream_4‹??_72›) ?_59[0;0] tl_327) in
          hd_326)
    | false_6 => (box_2‹??_75› ?_63[0;0] nat_stream_323))

#[program]
def __11‹› : unit_4‹??_86› :=
  ((free_stream_4‹??_85›)
    ?_73[0;0]
    ((proj2_8‹??_82,??_83,??_84›) ?_72[0;0] ?_71[0;0] my_apair1_10))

-----------------------------------------

#[logical]
inductive eq_1‹s_4393› (A_4394 : Type‹s_4393›) (m_4395 : A_4394):
  A_4394 -> U
where
| refl_1 : (eq_1‹s_4393› A_4394 m_4395 m_4395)

#[program]
inductive boxed_2‹s_4397› (A_4398 : Type‹s_4397›): L where
| box_2 (m_4399 : A_4398) : (boxed_2‹s_4397› A_4398)

#[program]
inductive sing_3‹s_4400,t_4401› (A_4402 : Type‹s_4400›):
  A_4402 -> Type‹t_4401›
where
| just_3 (m_4404 : A_4402) : (sing_3‹s_4400,t_4401› A_4402 m_4404)

#[program]
inductive unit_4‹s_4405› : Type‹s_4405› where
| tt_4 : unit_4‹s_4405›

#[program]
inductive bool_5‹› : U where
| true_5 : bool_5
| false_6 : bool_5

#[program]
inductive choice_6‹› : L where
| next_7 : choice_6
| free_8 : choice_6

#[program]
inductive prod_7‹s_4406,r_4407,t_4408› (A_4409 : Type‹s_4406›) (B_4410 : Type‹r_4407›):
  Type‹t_4408›
where
| pair_9
    (m_4411 : A_4409) (n_4412 : B_4410)
    : (prod_7‹s_4406,r_4407,t_4408› A_4409 B_4410)

#[program]
inductive nat_8‹› : U where
| zero_10 : nat_8
| succ_11 (__4413 : nat_8) : nat_8

#[program]
def sing_elim_1‹s_4414,t_4415› :
  ∀ {A_4416 : Type‹s_4414›} ->
    ∀ {x_4417 : A_4416} ->
      (sing_3‹s_4414,t_4415› A_4416 x_4417) -> A_4416
:=
  function sing_elim_4419 :
    ∀ {A_4420 : Type‹s_4414›} ->
      ∀ {x_4421 : A_4420} ->
        (sing_3‹s_4414,t_4415› A_4420 x_4421) -> A_4420
  | A_4423 x_4424 (just_3 m_4425) => m_4425

#[logical]
def sing_uniq_2‹s_4426,t_4427› :
  ∀ (A_4428 : Type‹s_4426›) ->
    ∀ (x0_4429 : A_4428) ->
      ∀ (x_4430 : (sing_3‹s_4426,t_4427› A_4428 x0_4429)) ->
        (eq_1‹s_4426›
          A_4428 x0_4429
          ((sing_elim_1‹s_4426,t_4427›) A_4428 x0_4429 x_4430))
:=
  function sing_uniq_4431 :
    ∀ (A_4432 : Type‹s_4426›) ->
      ∀ (x0_4433 : A_4432) ->
        ∀ (x_4434 : (sing_3‹s_4426,t_4427› A_4432 x0_4433)) ->
          (eq_1‹s_4426›
            A_4432 x0_4433
            ((sing_elim_1‹s_4426,t_4427›) A_4432 x0_4433 x_4434))
  | A_4435 x0_4436 (just_3 m_4437) => (refl_1‹s_4426› A_4435 m_4437)

#[program]
inductive stream_node_9‹s_4438› (A_4439 : Type‹s_4438›): L where
| stream_cons_12
    (hd_4440 : A_4439)
    (tl_4441 : ∀ (x_4442 : choice_6) -o
                 match x_4442 in choice_6 -o L with
                 | next_7 => (stream_node_9‹s_4438› A_4439)
                 | free_8 => unit_4‹L›)
    : (stream_node_9‹s_4438› A_4439)

#[logical]
def stream_3‹s_4444› : Type‹s_4444› -> L :=
  function stream_4446 : Type‹s_4444› -> L
  | A_4448 =>
    ∀ (x_4449 : choice_6) -o
      match x_4449 in choice_6 -o L with
      | next_7 => (stream_node_9‹s_4444› A_4448)
      | free_8 => unit_4‹L›

#[program]
def free_stream_4‹s_4451› :
  ∀ {A_4452 : Type‹s_4451›} ->
    ((stream_3‹s_4451›) A_4452) -> unit_4‹U›
:=
  function free_stream_4454 :
    ∀ {A_4455 : Type‹s_4451›} ->
      ((stream_3‹s_4451›) A_4455) -> unit_4‹U›
  | A_4457 st_4458 =>
    match ((st_4458) free_8) in unit_4‹L› -o unit_4‹U› with
    | tt_4 => tt_4‹U›

#[program]
def uncons_stream_5‹s_4460› :
  ∀ {A_4461 : Type‹s_4460›} ->
    ((stream_3‹s_4460›) A_4461) ->
      (prod_7‹s_4460,L,L› A_4461 ((stream_3‹s_4460›) A_4461))
:=
  function uncons_stream_4463 :
    ∀ {A_4464 : Type‹s_4460›} ->
      ((stream_3‹s_4460›) A_4464) ->
        (prod_7‹s_4460,L,L› A_4464 ((stream_3‹s_4460›) A_4464))
  | A_4466 st_4467 =>
    match ((st_4467) next_7) in
      (stream_node_9‹s_4460› A_4466) -o
        (prod_7‹s_4460,L,L› A_4466 ((stream_3‹s_4460›) A_4466))
    with
    | (stream_cons_12 hd_4469 tl_4470) =>
      (pair_9‹s_4460,L,L›
        A_4466 ((stream_3‹s_4460›) A_4466) hd_4469 tl_4470)

#[program]
def nat_make_6‹› : nat_8 -> ((stream_3‹U›) nat_8) :=
  function nat_make_4472 : nat_8 -> ((stream_3‹U›) nat_8)
  | n_4474 next_7 =>
    (stream_cons_12‹U›
      nat_8 n_4474 ((nat_make_4472) (succ_11‹› n_4474)))
  | n_4475 free_8 => tt_4‹L›

#[program]
inductive apair_10‹s_4476,r_4477,t_4478› (A_4479 : Type‹s_4476›) (B_4480 : 
A_4479 -> Type‹r_4477›): Type‹t_4478› where
| apair_intro_13
    {x_4482 : A_4479}
    (select_4483 : forall‹t_4478›(b_4484 : bool_5),
                     match b_4484 in bool_5 -o L with
                     | true_5 => (sing_3‹s_4476,L› A_4479 x_4482)
                     | false_6 => (boxed_2‹r_4477› ((B_4480) x_4482)))
    : (apair_10‹s_4476,r_4477,t_4478› A_4479 B_4480)

#[program]
def proj1_7‹s_4486,r_4487,t_4488› :
  ∀ {A_4489 : Type‹s_4486›} ->
    ∀ {B_4490 : A_4489 -> Type‹r_4487›} ->
      (apair_10‹s_4486,r_4487,t_4488› A_4489 B_4490) -> A_4489
:=
  function proj1_4493 :
    ∀ {A_4494 : Type‹s_4486›} ->
      ∀ {B_4495 : A_4494 -> Type‹r_4487›} ->
        (apair_10‹s_4486,r_4487,t_4488› A_4494 B_4495) -> A_4494
  | A_4498 B_4499 (apair_intro_13 x_4500 select_4501) =>
    ((sing_elim_1‹s_4486,L›) A_4498 x_4500 ((select_4501) true_5))

#[program]
def proj2_8‹s_4502,r_4503,t_4504› :
  ∀ {A_4505 : Type‹s_4502›} ->
    ∀ {B_4506 : A_4505 -> Type‹r_4503›} ->
      ∀ (x_4508 : (apair_10‹s_4502,r_4503,t_4504› A_4505 B_4506)) ->
        ((B_4506) ((proj1_7‹s_4502,r_4503,t_4504›) A_4505 B_4506 x_4508))
:=
  function proj2_4509 :
    ∀ {A_4510 : Type‹s_4502›} ->
      ∀ {B_4511 : A_4510 -> Type‹r_4503›} ->
        ∀ (x_4513 : (apair_10‹s_4502,r_4503,t_4504› A_4510 B_4511)) ->
          ((B_4511)
            ((proj1_7‹s_4502,r_4503,t_4504›) A_4510 B_4511 x_4513))
  | A_4514 B_4515 (apair_intro_13 x_4516 select_4517) =>
    match x_4516, ((select_4517) true_5),
    ((sing_uniq_2‹s_4502,L›) A_4514 x_4516 ((select_4517) true_5)),
    ((select_4517) false_6) in
      ∀ {x0_4518 : A_4514} -o
        ∀ {a0_4519 : (sing_3‹s_4502,L› A_4514 x_4516)} -o
          {(eq_1‹s_4502›
             A_4514 x0_4518
             ((sing_elim_1‹s_4502,L›) A_4514 x_4516 a0_4519))} -o
            (boxed_2‹r_4503› ((B_4515) x0_4518)) -o
              ((B_4515) ((sing_elim_1‹s_4502,L›) A_4514 x_4516 a0_4519))
    with
    | x0_4522, a0_4523, refl_1, (box_2 m_4524) => m_4524

#[program]
def my_apair0_9‹› :
  (apair_10‹U,L,U›
    nat_8
    function _4525 : nat_8 -> L
    | __4527 =>
      match __4527 in nat_8 -o L with
      | zero_10 => ((stream_3‹U›) nat_8)
      | (succ_11 __4529) => unit_4‹L›)
:=
  (apair_intro_13‹U,L,U›
    nat_8
    function _4530 : nat_8 -> L
    | __4532 =>
      match __4532 in nat_8 -o L with
      | zero_10 => ((stream_3‹U›) nat_8)
      | (succ_11 __4534) => unit_4‹L›
    zero_10
    function _4535 :
      ∀ (b_4536 : bool_5) ->
        match b_4536 in bool_5 -o L with
        | true_5 => (sing_3‹U,L› nat_8 zero_10)
        | false_6 =>
          (boxed_2‹L›
            ((function _4538 : nat_8 -> L
              | __4540 =>
                match __4540 in nat_8 -o L with
                | zero_10 => ((stream_3‹U›) nat_8)
                | (succ_11 __4542) => unit_4‹L›)
              zero_10))
    | true_5 => (just_3‹U,L› nat_8 zero_10)
    | false_6 =>
      (box_2‹L›
        ((stream_3‹U›) nat_8)
        let nat_stream_4543 := ((nat_make_6) zero_10) in nat_stream_4543))

#[program]
def my_apair1_10‹› :
  (apair_10‹U,L,L›
    nat_8
    function _4544 : nat_8 -> L
    | __4546 =>
      match __4546 in nat_8 -o L with
      | zero_10 => ((stream_3‹U›) nat_8)
      | (succ_11 __4548) => unit_4‹L›)
:=
  let nat_stream_4549 := ((nat_make_6) zero_10) in
  (apair_intro_13‹U,L,L›
    nat_8
    function _4550 : nat_8 -> L
    | __4552 =>
      match __4552 in nat_8 -o L with
      | zero_10 => ((stream_3‹U›) nat_8)
      | (succ_11 __4554) => unit_4‹L›
    match ((uncons_stream_5‹U›) nat_8 nat_stream_4549) in
      (prod_7‹U,L,L› nat_8 ((stream_3‹U›) nat_8)) -o nat_8
    with
    | (pair_9 m_4556 n_4557) =>
      let __4558 := ((free_stream_4‹U›) nat_8 n_4557) in m_4556
    function _4559 :
      ∀ (b_4560 : bool_5) -o
        match b_4560 in bool_5 -o L with
        | true_5 =>
          (sing_3‹U,L›
            nat_8
            match ((uncons_stream_5‹U›) nat_8 nat_stream_4549) in
              (prod_7‹U,L,L› nat_8 ((stream_3‹U›) nat_8)) -o nat_8
            with
            | (pair_9 m_4563 n_4564) =>
              let __4565 := ((free_stream_4‹U›) nat_8 n_4564) in m_4563)
        | false_6 =>
          (boxed_2‹L›
            ((function _4566 : nat_8 -> L
              | __4568 =>
                match __4568 in nat_8 -o L with
                | zero_10 => ((stream_3‹U›) nat_8)
                | (succ_11 __4570) => unit_4‹L›)
              match ((uncons_stream_5‹U›) nat_8 nat_stream_4549) in
                (prod_7‹U,L,L› nat_8 ((stream_3‹U›) nat_8)) -o nat_8
              with
              | (pair_9 m_4572 n_4573) =>
                let __4574 := ((free_stream_4‹U›) nat_8 n_4573) in m_4572))
    | true_5 =>
      (just_3‹U,L›
        nat_8
        match ((uncons_stream_5‹U›) nat_8 nat_stream_4549) in
          (prod_7‹U,L,L› nat_8 ((stream_3‹U›) nat_8)) -o nat_8
        with
        | (pair_9 m_4576 n_4577) =>
          let __4578 := ((free_stream_4‹U›) nat_8 n_4577) in m_4576)
    | false_6 =>
      (box_2‹L›
        match match ((uncons_stream_5‹U›) nat_8 nat_stream_4549) in
                (prod_7‹U,L,L› nat_8 ((stream_3‹U›) nat_8)) -o nat_8
              with
              | (pair_9 m_4580 n_4581) =>
                let __4582 := ((free_stream_4‹U›) nat_8 n_4581) in m_4580 in
          nat_8 -o L
        with
        | zero_10 => ((stream_3‹U›) nat_8)
        | (succ_11 __4584) => unit_4‹L› nat_stream_4549))

#[program]
def __11‹› : unit_4‹U› :=
  ((free_stream_4‹U›)
    nat_8
    ((proj2_8‹U,L,L›)
      nat_8
      function _4585 : nat_8 -> L
      | __4587 =>
        match __4587 in nat_8 -o L with
        | zero_10 => ((stream_3‹U›) nat_8)
        | (succ_11 __4589) => unit_4‹L›
      my_apair1_10))

-----------------------------------------

#[logical]
inductive eqU_12 where
| reflU_15 of layout[]

#[logical]
inductive eqL_11 where
| reflL_14 of layout[]

#[program]
inductive boxedU_14 where
| boxU_17 of layout[R]

#[program]
inductive boxedL_13 where
| boxL_16 of layout[R]

#[program]
inductive singUU_18 where
| justUU_21 of layout[R]

#[program]
inductive singUL_17 where
| justUL_20 of layout[R]

#[program]
inductive singLU_16 where


#[program]
inductive singLL_15 where
| justLL_18 of layout[R]

#[program]
inductive unitU_20 where
| ttU_23 of layout[]

#[program]
inductive unitL_19 where
| ttL_22 of layout[]

#[program]
inductive bool_5 where
| true_5 of layout[]
| false_6 of layout[]

#[program]
inductive choice_6 where
| next_7 of layout[]
| free_8 of layout[]

#[program]
inductive prodUUU_28 where
| pairUUU_31 of layout[R, R]

#[program]
inductive prodUUL_27 where
| pairUUL_30 of layout[R, R]

#[program]
inductive prodULU_26 where


#[program]
inductive prodULL_25 where
| pairULL_28 of layout[R, R]

#[program]
inductive prodLUU_24 where


#[program]
inductive prodLUL_23 where
| pairLUL_26 of layout[R, R]

#[program]
inductive prodLLU_22 where


#[program]
inductive prodLLL_21 where
| pairLLL_24 of layout[R, R]

#[program]
inductive nat_8 where
| zero_10 of layout[]
| succ_11 of layout[R]

#[program]
def sing_elimUU_15 :=
  fun sing_elim_8292 {A_8293} -> {x_8294} -> (__8295) ->
    match __8295 with
    | justUU_21 m_8296 => m_8296
    end

#[program]
def sing_elimUL_14 :=
  fun sing_elim_8297 {A_8298} -> {x_8299} -> (__8300) ->
    match __8300 with
    | justUL_20 m_8301 => m_8301
    end

#[program]
def sing_elimLU_13 :=
  fun sing_elim_8302 {A_8303} -> {x_8304} -> (__8305) ->
    match __8305 with
    
    end

#[program]
def sing_elimLL_12 :=
  fun sing_elim_8306 {A_8307} -> {x_8308} -> (__8309) ->
    match __8309 with
    | justLL_18 m_8310 => m_8310
    end

#[logical]
def sing_uniqUU_19 := NULL

#[logical]
def sing_uniqUL_18 := NULL

#[logical]
def sing_uniqLU_17 := NULL

#[logical]
def sing_uniqLL_16 := NULL

#[program]
inductive stream_nodeU_30 where
| stream_consU_33 of layout[R, R]

#[program]
inductive stream_nodeL_29 where
| stream_consL_32 of layout[R, R]

#[logical]
def streamU_21 := NULL

#[logical]
def streamL_20 := NULL

#[program]
def free_streamU_23 :=
  fun free_stream_8311 {A_8312} -> (st_8313) ->
    match ((st_8313) free_8) with
    | ttL_22  => ttU_23
    end

#[program]
def free_streamL_22 :=
  fun free_stream_8314 {A_8315} -> (st_8316) ->
    match ((st_8316) free_8) with
    | ttL_22  => ttU_23
    end

#[program]
def uncons_streamU_25 :=
  fun uncons_stream_8317 {A_8318} -> (st_8319) ->
    match ((st_8319) next_7) with
    | stream_consU_33 hd_8320 tl_8321 => (pairULL_28 hd_8320 tl_8321)
    end

#[program]
def uncons_streamL_24 :=
  fun uncons_stream_8322 {A_8323} -> (st_8324) ->
    match ((st_8324) next_7) with
    | stream_consL_32 hd_8325 tl_8326 => (pairLLL_24 hd_8325 tl_8326)
    end

#[program]
def nat_make_6 :=
  fun nat_make_8327 (n_8328) -> (x_8329) -o
    match x_8329 with
    | next_7  => (stream_consU_33 n_8328 ((nat_make_8327) (succ_11 n_8328)))
    | free_8  => ttL_22
    end

#[program]
inductive apairUUU_38 where
| apair_introUUU_41 of layout[N, R]

#[program]
inductive apairUUL_37 where
| apair_introUUL_40 of layout[N, R]

#[program]
inductive apairULU_36 where
| apair_introULU_39 of layout[N, R]

#[program]
inductive apairULL_35 where
| apair_introULL_38 of layout[N, R]

#[program]
inductive apairLUU_34 where
| apair_introLUU_37 of layout[N, R]

#[program]
inductive apairLUL_33 where
| apair_introLUL_36 of layout[N, R]

#[program]
inductive apairLLU_32 where
| apair_introLLU_35 of layout[N, R]

#[program]
inductive apairLLL_31 where
| apair_introLLL_34 of layout[N, R]

#[program]
def proj1UUU_33 :=
  fun proj1_8330 {A_8331} -> {B_8332} -> (__8333) ->
    match __8333 with
    | apair_introUUU_41 x_8334 select_8335 =>
      ((sing_elimUL_14) NULL NULL ((select_8335) true_5))
    end

#[program]
def proj1UUL_32 :=
  fun proj1_8336 {A_8337} -> {B_8338} -> (__8339) ->
    match __8339 with
    | apair_introUUL_40 x_8340 select_8341 =>
      ((sing_elimUL_14) NULL NULL ((select_8341) true_5))
    end

#[program]
def proj1ULU_31 :=
  fun proj1_8342 {A_8343} -> {B_8344} -> (__8345) ->
    match __8345 with
    | apair_introULU_39 x_8346 select_8347 =>
      ((sing_elimUL_14) NULL NULL ((select_8347) true_5))
    end

#[program]
def proj1ULL_30 :=
  fun proj1_8348 {A_8349} -> {B_8350} -> (__8351) ->
    match __8351 with
    | apair_introULL_38 x_8352 select_8353 =>
      ((sing_elimUL_14) NULL NULL ((select_8353) true_5))
    end

#[program]
def proj1LUU_29 :=
  fun proj1_8354 {A_8355} -> {B_8356} -> (__8357) ->
    match __8357 with
    | apair_introLUU_37 x_8358 select_8359 =>
      ((sing_elimLL_12) NULL NULL ((select_8359) true_5))
    end

#[program]
def proj1LUL_28 :=
  fun proj1_8360 {A_8361} -> {B_8362} -> (__8363) ->
    match __8363 with
    | apair_introLUL_36 x_8364 select_8365 =>
      ((sing_elimLL_12) NULL NULL ((select_8365) true_5))
    end

#[program]
def proj1LLU_27 :=
  fun proj1_8366 {A_8367} -> {B_8368} -> (__8369) ->
    match __8369 with
    | apair_introLLU_35 x_8370 select_8371 =>
      ((sing_elimLL_12) NULL NULL ((select_8371) true_5))
    end

#[program]
def proj1LLL_26 :=
  fun proj1_8372 {A_8373} -> {B_8374} -> (__8375) ->
    match __8375 with
    | apair_introLLL_34 x_8376 select_8377 =>
      ((sing_elimLL_12) NULL NULL ((select_8377) true_5))
    end

#[program]
def proj2UUU_41 :=
  fun proj2_8378 {A_8379} -> {B_8380} -> (x_8381) ->
    match x_8381 with
    | apair_introUUU_41 x_8382 select_8383 =>
      match {NULL} with
      | reflU_15  =>
        match ((select_8383) false_6) with
        | boxU_17 m_8384 => m_8384
        end
      end
    end

#[program]
def proj2UUL_40 :=
  fun proj2_8385 {A_8386} -> {B_8387} -> (x_8388) ->
    match x_8388 with
    | apair_introUUL_40 x_8389 select_8390 =>
      match {NULL} with
      | reflU_15  =>
        match ((select_8390) false_6) with
        | boxU_17 m_8391 => m_8391
        end
      end
    end

#[program]
def proj2ULU_39 :=
  fun proj2_8392 {A_8393} -> {B_8394} -> (x_8395) ->
    match x_8395 with
    | apair_introULU_39 x_8396 select_8397 =>
      match {NULL} with
      | reflU_15  =>
        match ((select_8397) false_6) with
        | boxL_16 m_8398 => m_8398
        end
      end
    end

#[program]
def proj2ULL_38 :=
  fun proj2_8399 {A_8400} -> {B_8401} -> (x_8402) ->
    match x_8402 with
    | apair_introULL_38 x_8403 select_8404 =>
      match {NULL} with
      | reflU_15  =>
        match ((select_8404) false_6) with
        | boxL_16 m_8405 => m_8405
        end
      end
    end

#[program]
def proj2LUU_37 :=
  fun proj2_8406 {A_8407} -> {B_8408} -> (x_8409) ->
    match x_8409 with
    | apair_introLUU_37 x_8410 select_8411 =>
      match {NULL} with
      | reflL_14  =>
        match ((select_8411) false_6) with
        | boxU_17 m_8412 => m_8412
        end
      end
    end

#[program]
def proj2LUL_36 :=
  fun proj2_8413 {A_8414} -> {B_8415} -> (x_8416) ->
    match x_8416 with
    | apair_introLUL_36 x_8417 select_8418 =>
      match {NULL} with
      | reflL_14  =>
        match ((select_8418) false_6) with
        | boxU_17 m_8419 => m_8419
        end
      end
    end

#[program]
def proj2LLU_35 :=
  fun proj2_8420 {A_8421} -> {B_8422} -> (x_8423) ->
    match x_8423 with
    | apair_introLLU_35 x_8424 select_8425 =>
      match {NULL} with
      | reflL_14  =>
        match ((select_8425) false_6) with
        | boxL_16 m_8426 => m_8426
        end
      end
    end

#[program]
def proj2LLL_34 :=
  fun proj2_8427 {A_8428} -> {B_8429} -> (x_8430) ->
    match x_8430 with
    | apair_introLLL_34 x_8431 select_8432 =>
      match {NULL} with
      | reflL_14  =>
        match ((select_8432) false_6) with
        | boxL_16 m_8433 => m_8433
        end
      end
    end

#[program]
def my_apair0_9 :=
  (apair_introULU_39
    NULL
    fun _8434 (b_8435) ->
      match b_8435 with
      | true_5  => (justUL_20 zero_10)
      | false_6  =>
        (boxL_16
          let nat_stream_8436 := ((nat_make_6) zero_10) in nat_stream_8436)
      end)

#[program]
def my_apair1_10 :=
  let nat_stream_8437 := ((nat_make_6) zero_10) in
  (apair_introULL_38
    NULL
    fun _8438 (b_8439) -o
      match b_8439 with
      | true_5  =>
        (justUL_20
          match ((uncons_streamU_25) NULL nat_stream_8437) with
          | pairULL_28 m_8440 n_8441 =>
            let __8442 := ((free_streamU_23) NULL n_8441) in m_8440
          end)
      | false_6  => (boxL_16 nat_stream_8437)
      end)

#[program]
def __11 := ((free_streamU_23) NULL ((proj2ULL_38) NULL NULL my_apair1_10))

-----------------------------------------

#[logical]
inductive eqU_12 where
| reflU_15 of layout[]

#[logical]
inductive eqL_11 where
| reflL_14 of layout[]

#[program]
inductive boxedU_14 where
| boxU_17 of layout[R]

#[program]
inductive boxedL_13 where
| boxL_16 of layout[R]

#[program]
inductive singUU_18 where
| justUU_21 of layout[R]

#[program]
inductive singUL_17 where
| justUL_20 of layout[R]

#[program]
inductive singLU_16 where


#[program]
inductive singLL_15 where
| justLL_18 of layout[R]

#[program]
inductive unitU_20 where
| ttU_23 of layout[]

#[program]
inductive unitL_19 where
| ttL_22 of layout[]

#[program]
inductive bool_5 where
| true_5 of layout[]
| false_6 of layout[]

#[program]
inductive choice_6 where
| next_7 of layout[]
| free_8 of layout[]

#[program]
inductive prodUUU_28 where
| pairUUU_31 of layout[R, R]

#[program]
inductive prodUUL_27 where
| pairUUL_30 of layout[R, R]

#[program]
inductive prodULU_26 where


#[program]
inductive prodULL_25 where
| pairULL_28 of layout[R, R]

#[program]
inductive prodLUU_24 where


#[program]
inductive prodLUL_23 where
| pairLUL_26 of layout[R, R]

#[program]
inductive prodLLU_22 where


#[program]
inductive prodLLL_21 where
| pairLLL_24 of layout[R, R]

#[program]
inductive nat_8 where
| zero_10 of layout[]
| succ_11 of layout[R]

#[program]
def sing_elimUU_15 :=
  fun sing_elim_8594 {A_8595} -> {x_8596} -> (__8597) ->
    match __8597 with
    | justUU_21 m_8598 => m_8598
    end

#[program]
def sing_elimUL_14 :=
  fun sing_elim_8599 {A_8600} -> {x_8601} -> (__8602) ->
    match __8602 with
    | justUL_20 m_8603 => m_8603
    end

#[program]
def sing_elimLU_13 :=
  fun sing_elim_8604 {A_8605} -> {x_8606} -> (__8607) -> !!

#[program]
def sing_elimLL_12 :=
  fun sing_elim_8608 {A_8609} -> {x_8610} -> (__8611) ->
    match __8611 with
    | justLL_18 m_8612 => m_8612
    end

#[logical]
def sing_uniqUU_19 := NULL

#[logical]
def sing_uniqUL_18 := NULL

#[logical]
def sing_uniqLU_17 := NULL

#[logical]
def sing_uniqLL_16 := NULL

#[program]
inductive stream_nodeU_30 where
| stream_consU_33 of layout[R, R]

#[program]
inductive stream_nodeL_29 where
| stream_consL_32 of layout[R, R]

#[logical]
def streamU_21 := NULL

#[logical]
def streamL_20 := NULL

#[program]
def free_streamU_23 :=
  fun free_stream_8613 {A_8614} -> (st_8615) ->
    match ((st_8615) free_8) with
    | ttL_22  => ttU_23
    end

#[program]
def free_streamL_22 :=
  fun free_stream_8616 {A_8617} -> (st_8618) ->
    match ((st_8618) free_8) with
    | ttL_22  => ttU_23
    end

#[program]
def uncons_streamU_25 :=
  fun uncons_stream_8619 {A_8620} -> (st_8621) ->
    match ((st_8621) next_7) with
    | stream_consU_33 hd_8622 tl_8623 => (pairULL_28 hd_8622 tl_8623)
    end

#[program]
def uncons_streamL_24 :=
  fun uncons_stream_8624 {A_8625} -> (st_8626) ->
    match ((st_8626) next_7) with
    | stream_consL_32 hd_8627 tl_8628 => (pairLLL_24 hd_8627 tl_8628)
    end

#[program]
def nat_make_6 :=
  fun nat_make_8629 (n_8630) -> (x_8631) -o
    match x_8631 with
    | next_7  => (stream_consU_33 n_8630 ((nat_make_8629) (succ_11 n_8630)))
    | free_8  => ttL_22
    end

#[program]
inductive apairUUU_38 where
| apair_introUUU_41 of layout[N, R]

#[program]
inductive apairUUL_37 where
| apair_introUUL_40 of layout[N, R]

#[program]
inductive apairULU_36 where
| apair_introULU_39 of layout[N, R]

#[program]
inductive apairULL_35 where
| apair_introULL_38 of layout[N, R]

#[program]
inductive apairLUU_34 where
| apair_introLUU_37 of layout[N, R]

#[program]
inductive apairLUL_33 where
| apair_introLUL_36 of layout[N, R]

#[program]
inductive apairLLU_32 where
| apair_introLLU_35 of layout[N, R]

#[program]
inductive apairLLL_31 where
| apair_introLLL_34 of layout[N, R]

#[program]
def proj1UUU_33 :=
  fun proj1_8632 {A_8633} -> {B_8634} -> (__8635) ->
    match __8635 with
    | apair_introUUU_41 x_8636 select_8637 =>
      ((sing_elimUL_14) NULL NULL ((select_8637) true_5))
    end

#[program]
def proj1UUL_32 :=
  fun proj1_8638 {A_8639} -> {B_8640} -> (__8641) ->
    match __8641 with
    | apair_introUUL_40 x_8642 select_8643 =>
      ((sing_elimUL_14) NULL NULL ((select_8643) true_5))
    end

#[program]
def proj1ULU_31 :=
  fun proj1_8644 {A_8645} -> {B_8646} -> (__8647) ->
    match __8647 with
    | apair_introULU_39 x_8648 select_8649 =>
      ((sing_elimUL_14) NULL NULL ((select_8649) true_5))
    end

#[program]
def proj1ULL_30 :=
  fun proj1_8650 {A_8651} -> {B_8652} -> (__8653) ->
    match __8653 with
    | apair_introULL_38 x_8654 select_8655 =>
      ((sing_elimUL_14) NULL NULL ((select_8655) true_5))
    end

#[program]
def proj1LUU_29 :=
  fun proj1_8656 {A_8657} -> {B_8658} -> (__8659) ->
    match __8659 with
    | apair_introLUU_37 x_8660 select_8661 =>
      ((sing_elimLL_12) NULL NULL ((select_8661) true_5))
    end

#[program]
def proj1LUL_28 :=
  fun proj1_8662 {A_8663} -> {B_8664} -> (__8665) ->
    match __8665 with
    | apair_introLUL_36 x_8666 select_8667 =>
      ((sing_elimLL_12) NULL NULL ((select_8667) true_5))
    end

#[program]
def proj1LLU_27 :=
  fun proj1_8668 {A_8669} -> {B_8670} -> (__8671) ->
    match __8671 with
    | apair_introLLU_35 x_8672 select_8673 =>
      ((sing_elimLL_12) NULL NULL ((select_8673) true_5))
    end

#[program]
def proj1LLL_26 :=
  fun proj1_8674 {A_8675} -> {B_8676} -> (__8677) ->
    match __8677 with
    | apair_introLLL_34 x_8678 select_8679 =>
      ((sing_elimLL_12) NULL NULL ((select_8679) true_5))
    end

#[program]
def proj2UUU_41 :=
  fun proj2_8680 {A_8681} -> {B_8682} -> (x_8683) ->
    match x_8683 with
    | apair_introUUU_41 x_8684 select_8685 =>
      match ((select_8685) false_6) with
      | boxU_17 m_8686 => m_8686
      end
    end

#[program]
def proj2UUL_40 :=
  fun proj2_8687 {A_8688} -> {B_8689} -> (x_8690) ->
    match x_8690 with
    | apair_introUUL_40 x_8691 select_8692 =>
      match ((select_8692) false_6) with
      | boxU_17 m_8693 => m_8693
      end
    end

#[program]
def proj2ULU_39 :=
  fun proj2_8694 {A_8695} -> {B_8696} -> (x_8697) ->
    match x_8697 with
    | apair_introULU_39 x_8698 select_8699 =>
      match ((select_8699) false_6) with
      | boxL_16 m_8700 => m_8700
      end
    end

#[program]
def proj2ULL_38 :=
  fun proj2_8701 {A_8702} -> {B_8703} -> (x_8704) ->
    match x_8704 with
    | apair_introULL_38 x_8705 select_8706 =>
      match ((select_8706) false_6) with
      | boxL_16 m_8707 => m_8707
      end
    end

#[program]
def proj2LUU_37 :=
  fun proj2_8708 {A_8709} -> {B_8710} -> (x_8711) ->
    match x_8711 with
    | apair_introLUU_37 x_8712 select_8713 =>
      match ((select_8713) false_6) with
      | boxU_17 m_8714 => m_8714
      end
    end

#[program]
def proj2LUL_36 :=
  fun proj2_8715 {A_8716} -> {B_8717} -> (x_8718) ->
    match x_8718 with
    | apair_introLUL_36 x_8719 select_8720 =>
      match ((select_8720) false_6) with
      | boxU_17 m_8721 => m_8721
      end
    end

#[program]
def proj2LLU_35 :=
  fun proj2_8722 {A_8723} -> {B_8724} -> (x_8725) ->
    match x_8725 with
    | apair_introLLU_35 x_8726 select_8727 =>
      match ((select_8727) false_6) with
      | boxL_16 m_8728 => m_8728
      end
    end

#[program]
def proj2LLL_34 :=
  fun proj2_8729 {A_8730} -> {B_8731} -> (x_8732) ->
    match x_8732 with
    | apair_introLLL_34 x_8733 select_8734 =>
      match ((select_8734) false_6) with
      | boxL_16 m_8735 => m_8735
      end
    end

#[program]
def my_apair0_9 :=
  (apair_introULU_39
    NULL
    fun _8736 (b_8737) ->
      match b_8737 with
      | true_5  => (justUL_20 zero_10)
      | false_6  =>
        (boxL_16
          let nat_stream_8738 := ((nat_make_6) zero_10) in nat_stream_8738)
      end)

#[program]
def my_apair1_10 :=
  let nat_stream_8739 := ((nat_make_6) zero_10) in
  (apair_introULL_38
    NULL
    fun _8740 (b_8741) -o
      match b_8741 with
      | true_5  =>
        (justUL_20
          match ((uncons_streamU_25) NULL nat_stream_8739) with
          | pairULL_28 m_8742 n_8743 =>
            let __8744 := ((free_streamU_23) NULL n_8743) in m_8742
          end)
      | false_6  => (boxL_16 nat_stream_8739)
      end)

#[program]
def __11 := ((free_streamU_23) NULL ((proj2ULL_38) NULL NULL my_apair1_10))

-----------------------------------------

