[Inductive {name = "eq"; relv = N;
   body =
   (Binder (["s"],
      (PBind ((Type (SId "s")),
         (Binder ("A",
            (PBind ((Id ("A", I)),
               (Binder ("m",
                  (PBase
                     ((TBind (R, (Id ("A", I)),
                         (Binder ("_", (TBase (Type U)))))),
                      [(DConstr ("refl",
                          (TBase
                             (App
                                [(Id ("eq", I)); (Id ("m", I)); (Id ("m", I))
                                  ])),
                          []))
                        ]))
                  ))
               ))
            ))
         ))
      ));
   view = [I; E]};
  Inductive {name = "unit"; relv = R;
    body =
    (Binder (["s"],
       (PBase
          ((TBase (Type (SId "s"))),
           [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
       ));
    view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type L)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type L)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder ([],
       (PBind ((Type L),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)), (Binder ("_", (TBase (Type L)))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m",
                           (TBase (App [(Id ("sing", I)); (Id ("m", I))]))))
                        )),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "apair"; relv = R;
    body =
    (Binder ([],
       (PBind ((Type L),
          (Binder ("A",
             (PBind ((Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("apair_intro",
                           (TBind (N, (Id ("A", I)),
                              (Binder ("x",
                                 (TBind (R,
                                    (Pi (R, L, (Id ("bool", I)),
                                       (Binder ("b",
                                          (Match ([(R, (Id ("b", I)), None)],
                                             None,
                                             [([(PId "true")],
                                               (Some (App
                                                        [(Id ("sing", I));
                                                          (Id ("x", I))])));
                                               ([(PId "false")],
                                                (Some (App
                                                         [(Id ("B", I));
                                                           (Id ("x", I))])))
                                               ]
                                             ))
                                          ))
                                       )),
                                    (Binder ("select",
                                       (TBase
                                          (App
                                             [(Id ("apair", I));
                                               (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [I; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "sing_elim"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type L),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("x",
                       (Pi (R, U, (App [(Id ("sing", I)); (Id ("x", I))]),
                          (Binder ("_", (Id ("A", I))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_elim"),
              [([(PId "A"); (PId "x"); (PConstr ("just", [(PId "x")]))],
                (Some (Id ("x", I))))]
              )),
           [I; I])),
        (Pi (N, U, (Type L),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("x",
                    (Pi (R, U, (App [(Id ("sing", I)); (Id ("x", I))]),
                       (Binder ("_", (Id ("A", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "sing_uniq"; relv = N;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Type L),
              (Binder ("A",
                 (Pi (R, U, (Id ("A", I)),
                    (Binder ("x0",
                       (Pi (R, U, (App [(Id ("sing", I)); (Id ("x0", I))]),
                          (Binder ("x",
                             (App
                                [(Id ("eq", I)); (Id ("x0", I));
                                  (App [(Id ("sing_elim", I)); (Id ("x", I))])
                                  ])
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_uniq"),
              [([(PId "A"); (PId "x0"); (PConstr ("just", [(PId "_")]))],
                (Some (Id ("refl", I))))]
              )),
           [I; I])),
        (Pi (R, U, (Type L),
           (Binder ("A",
              (Pi (R, U, (Id ("A", I)),
                 (Binder ("x0",
                    (Pi (R, U, (App [(Id ("sing", I)); (Id ("x0", I))]),
                       (Binder ("x",
                          (App
                             [(Id ("eq", I)); (Id ("x0", I));
                               (App [(Id ("sing_elim", I)); (Id ("x", I))])])
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "proj1"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type L),
              (Binder ("A",
                 (Pi (N, U,
                    (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                    (Binder ("B",
                       (Pi (R, U,
                          (App
                             [(Id ("apair", E)); (Id ("A", I)); (Id ("B", I))
                               ]),
                          (Binder ("_", (Id ("A", I))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "proj1"),
              [([(PId "A"); (PId "B");
                  (PConstr ("apair_intro", [(PId "_"); (PId "select")]))],
                (Some (App
                         [(Id ("sing_elim", I));
                           (App [(Id ("select", I)); (Id ("true", I))])])))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type L),
           (Binder ("A",
              (Pi (N, U,
                 (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                 (Binder ("B",
                    (Pi (R, U,
                       (App [(Id ("apair", E)); (Id ("A", I)); (Id ("B", I))]),
                       (Binder ("_", (Id ("A", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "proj2"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type L),
              (Binder ("A",
                 (Pi (N, U,
                    (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                    (Binder ("B",
                       (Pi (R, U,
                          (App
                             [(Id ("apair", E)); (Id ("A", I)); (Id ("B", I))
                               ]),
                          (Binder ("x",
                             (App
                                [(Id ("B", I));
                                  (App [(Id ("proj1", I)); (Id ("x", I))])])
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "proj2"),
              [([(PId "A"); (PId "B");
                  (PConstr ("apair_intro", [(PId "x"); (PId "select")]))],
                (Some (Match (
                         [(N, (Id ("x", I)), (Some ("x0", IMeta)));
                           (N, (App [(Id ("select", I)); (Id ("true", I))]),
                            (Some ("a0",
                                   (App [(Id ("sing", I)); (Id ("x", I))]))));
                           (N,
                            (App
                               [(Id ("sing_uniq", I));
                                 (App [(Id ("select", I)); (Id ("true", I))])
                                 ]),
                            (Some ("_",
                                   (App
                                      [(Id ("eq", I)); (Id ("x0", I));
                                        (App
                                           [(Id ("sing_elim", I));
                                             (Id ("a0", I))])
                                        ]))));
                           (R, (App [(Id ("select", I)); (Id ("false", I))]),
                            (Some ("_", (App [(Id ("B", I)); (Id ("x0", I))]))))
                           ],
                         (Some (App
                                  [(Id ("B", I));
                                    (App
                                       [(Id ("sing_elim", I)); (Id ("a0", I))
                                         ])
                                    ])),
                         [([(PId "_"); (PId "_"); (PId "refl"); (PId "b")],
                           (Some (Id ("b", I))))]
                         ))))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type L),
           (Binder ("A",
              (Pi (N, U,
                 (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                 (Binder ("B",
                    (Pi (R, U,
                       (App [(Id ("apair", E)); (Id ("A", I)); (Id ("B", I))]),
                       (Binder ("x",
                          (App
                             [(Id ("B", I));
                               (App [(Id ("proj1", I)); (Id ("x", I))])])
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "bool2nat"; relv = R;
    body =
    (Binder ([],
       ((Fun ((Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("nat", I)))))),
           (Binder ((Some "bool2nat"),
              [([(PId "true")],
                (Some (App [(Id ("succ", I)); (Id ("zero", I))])));
                ([(PId "false")], (Some (Id ("zero", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("nat", I)))))))
       ));
    view = []};
  Definition {name = "free_bool"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_", (Inst ("unit", [U], I)))))),
           (Binder ((Some "free_bool"),
              [([(PId "true")], (Some (Id ("tt", I))));
                ([(PId "false")], (Some (Id ("tt", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Inst ("unit", [U], I))))
           )))
       ));
    view = []};
  Definition {name = "free_nat"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_", (Inst ("unit", [U], I)))))),
           (Binder ((Some "free_nat"),
              [([(PId "zero")], (Some (Id ("tt", I))));
                ([(PConstr ("succ", [(PId "n")]))],
                 (Some (App [(Id ("free_nat", I)); (Id ("n", I))])))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Inst ("unit", [U], I)))))))
       ));
    view = []};
  Definition {name = "my_apair"; relv = R;
    body =
    (Binder ([],
       ((Let (R, (Id ("false", I)),
           (Binder ("my_val",
              (App
                 [(Id ("apair_intro", I));
                   (Fun (IMeta,
                      (Binder (None,
                         [([(PId "true")],
                           (Some (App [(Id ("just", I)); (Id ("my_val", I))])));
                           ([(PId "false")],
                            (Some (App
                                     [(Id ("bool2nat", I));
                                       (Id ("my_val", I))])))
                           ]
                         )),
                      []))
                   ])
              ))
           )),
        (App
           [(Id ("apair", I));
             (Fun ((Pi (R, U, (Id ("bool", I)), (Binder ("b", IMeta)))),
                (Binder (None,
                   [([(PId "b")],
                     (Some (Match ([(R, (Id ("b", I)), None)], None,
                              [([(PId "true")],
                                (Some (Inst ("unit", [L], I))));
                                ([(PId "false")], (Some (Id ("nat", I))))]
                              ))))
                     ]
                   )),
                []))
             ]))
       ));
    view = []};
  Definition {name = "_"; relv = R;
    body =
    (Binder ([],
       ((App
           [(Id ("free_bool", I));
             (App [(Id ("proj1", I)); (Id ("my_apair", I))])]),
        (Inst ("unit", [U], I)))
       ));
    view = []}
  ]

-----------------------------------------

#[logical]
inductive eq_1‹s_93› (A_94 : Type‹s_93›) (m_95 : A_94): A_94 -> U
where
| refl_1 : (eq_1‹??_1› ?_1 m_95 m_95)

#[program]
inductive unit_2‹s_97› : Type‹s_97› where
| tt_2 : unit_2‹??_2›

#[program]
inductive bool_3‹› : L where
| true_3 : bool_3
| false_4 : bool_3

#[program]
inductive nat_4‹› : L where
| zero_5 : nat_4
| succ_6 (pred_98 : nat_4) : nat_4

#[program]
inductive sing_5‹› (A_99 : L): A_99 -> L where
| just_7 (m_101 : A_99) : (sing_5 ?_2 m_101)

#[program]
inductive apair_6‹› (A_102 : L) (B_103 : A_102 -> L): L where
| apair_intro_8
    {x_105 : A_102}
    (select_106 : ∀ (b_107 : bool_3) -o
                    match b_107 in ∀ (_108 : ?_3) -o ?_4 with
                    | true_3 => (sing_5 ?_5 x_105)
                    | false_4 => ((B_103) x_105))
    : (apair_6 ?_6 B_103)

#[program]
def sing_elim_1‹› :
  ∀ {A_109 : L} -> ∀ {x_110 : A_109} -> (sing_5 ?_8 x_110) -> A_109
:=
  function sing_elim_112 :
    ∀ {A_113 : L} -> ∀ {x_114 : A_113} -> (sing_5 ?_7 x_114) -> A_113
  | A_116 x_117 (just_7 x_118) => x_118

#[logical]
def sing_uniq_2‹› :
  ∀ (A_119 : L) ->
    ∀ (x0_120 : A_119) ->
      ∀ (x_121 : (sing_5 ?_15 x0_120)) ->
        (eq_1‹??_5› ?_18 x0_120 ((sing_elim_1) ?_17 ?_16 x_121))
:=
  function sing_uniq_122 :
    ∀ (A_123 : L) ->
      ∀ (x0_124 : A_123) ->
        ∀ (x_125 : (sing_5 ?_9 x0_124)) ->
          (eq_1‹??_3› ?_12 x0_124 ((sing_elim_1) ?_11 ?_10 x_125))
  | A_126 x0_127 (just_7 _128) => refl_1‹??_4›

#[program]
def proj1_3‹› :
  ∀ {A_129 : L} ->
    ∀ {B_130 : A_129 -> L} -> (apair_6 A_129 B_130) -> A_129
:=
  function proj1_133 :
    ∀ {A_134 : L} ->
      ∀ {B_135 : A_134 -> L} -> (apair_6 A_134 B_135) -> A_134
  | A_138 B_139 (apair_intro_8 _140 select_141) =>
    ((sing_elim_1) ?_20 ?_19 ((select_141) true_3))

#[program]
def proj2_4‹› :
  ∀ {A_142 : L} ->
    ∀ {B_143 : A_142 -> L} ->
      ∀ (x_145 : (apair_6 A_142 B_143)) ->
        ((B_143) ((proj1_3) ?_33 ?_32 x_145))
:=
  function proj2_146 :
    ∀ {A_147 : L} ->
      ∀ {B_148 : A_147 -> L} ->
        ∀ (x_150 : (apair_6 A_147 B_148)) ->
          ((B_148) ((proj1_3) ?_22 ?_21 x_150))
  | A_151 B_152 (apair_intro_8 x_153 select_154) =>
    match x_153, ((select_154) true_3),
    ((sing_uniq_2) ?_24 ?_23 ((select_154) true_3)),
    ((select_154) false_4) in
      ∀ {x0_155 : ?_25} -o
        ∀ {a0_156 : (sing_5 ?_26 x_153)} -o
          ∀ {__157 :
            (eq_1‹??_6› ?_29 x0_155 ((sing_elim_1) ?_28 ?_27 a0_156))} -o
            ∀ (__158 : ((B_152) x0_155)) -o
              ((B_152) ((sing_elim_1) ?_31 ?_30 a0_156))
    with
    | _159, _160, refl_1, b_161 => b_161

#[program]
def bool2nat_5‹› : bool_3 -> nat_4 :=
  function bool2nat_163 : bool_3 -> nat_4
  | true_3 => (succ_6‹› zero_5)
  | false_4 => zero_5

#[program]
def free_bool_6‹› : bool_3 -> unit_2‹U› :=
  function free_bool_166 : bool_3 -> unit_2‹U›
  | true_3 => tt_2‹??_7›
  | false_4 => tt_2‹??_8›

#[program]
def free_nat_7‹› : nat_4 -> unit_2‹U› :=
  function free_nat_169 : nat_4 -> unit_2‹U›
  | zero_5 => tt_2‹??_9›
  | (succ_6 n_171) => ((free_nat_169) n_171)

#[program]
def my_apair_8‹› :
  (apair_6
    ?_42
    function _172 : ∀ (b_173 : bool_3) -> ?_39
    | b_174 =>
      match b_174 in ∀ (_175 : ?_40) -o ?_41 with
      | true_3 => unit_2‹L›
      | false_4 => nat_4)
:=
  let my_val_176 := false_4 in
  (apair_intro_8‹›
    ?_36
    function _177 : ?_34
    | true_3 => (just_7‹› my_val_176)
    | false_4 => ((bool2nat_5) my_val_176))

#[program]
def __9‹› : unit_2‹U› :=
  ((free_bool_6) ((proj1_3) ?_44 ?_43 my_apair_8))

-----------------------------------------

#[logical]
inductive eq_1‹s_1304› (A_1305 : Type‹s_1304›) (m_1306 : A_1305):
  A_1305 -> U
where
| refl_1 : (eq_1‹s_1304› A_1305 m_1306 m_1306)

#[program]
inductive unit_2‹s_1308› : Type‹s_1308› where
| tt_2 : unit_2‹s_1308›

#[program]
inductive bool_3‹› : L where
| true_3 : bool_3
| false_4 : bool_3

#[program]
inductive nat_4‹› : L where
| zero_5 : nat_4
| succ_6 (pred_1309 : nat_4) : nat_4

#[program]
inductive sing_5‹› (A_1310 : L): A_1310 -> L where
| just_7 (m_1312 : A_1310) : (sing_5 A_1310 m_1312)

#[program]
inductive apair_6‹› (A_1313 : L) (B_1314 : A_1313 -> L): L where
| apair_intro_8
    {x_1316 : A_1313}
    (select_1317 : ∀ (b_1318 : bool_3) -o
                     match b_1318 in bool_3 -o L with
                     | true_3 => (sing_5 A_1313 x_1316)
                     | false_4 => ((B_1314) x_1316))
    : (apair_6 A_1313 B_1314)

#[program]
def sing_elim_1‹› :
  ∀ {A_1320 : L} ->
    ∀ {x_1321 : A_1320} -> (sing_5 A_1320 x_1321) -> A_1320
:=
  function sing_elim_1323 :
    ∀ {A_1324 : L} ->
      ∀ {x_1325 : A_1324} -> (sing_5 A_1324 x_1325) -> A_1324
  | A_1327 x_1328 (just_7 x_1329) => x_1329

#[logical]
def sing_uniq_2‹› :
  ∀ (A_1330 : L) ->
    ∀ (x0_1331 : A_1330) ->
      ∀ (x_1332 : (sing_5 A_1330 x0_1331)) ->
        (eq_1‹L› A_1330 x0_1331 ((sing_elim_1) A_1330 x0_1331 x_1332))
:=
  function sing_uniq_1333 :
    ∀ (A_1334 : L) ->
      ∀ (x0_1335 : A_1334) ->
        ∀ (x_1336 : (sing_5 A_1334 x0_1335)) ->
          (eq_1‹L› A_1334 x0_1335 ((sing_elim_1) A_1334 x0_1335 x_1336))
  | A_1337 x0_1338 (just_7 _1339) => refl_1‹L›

#[program]
def proj1_3‹› :
  ∀ {A_1340 : L} ->
    ∀ {B_1341 : A_1340 -> L} -> (apair_6 A_1340 B_1341) -> A_1340
:=
  function proj1_1344 :
    ∀ {A_1345 : L} ->
      ∀ {B_1346 : A_1345 -> L} -> (apair_6 A_1345 B_1346) -> A_1345
  | A_1349 B_1350 (apair_intro_8 _1351 select_1352) =>
    ((sing_elim_1) A_1349 _1351 ((select_1352) true_3))

#[program]
def proj2_4‹› :
  ∀ {A_1353 : L} ->
    ∀ {B_1354 : A_1353 -> L} ->
      ∀ (x_1356 : (apair_6 A_1353 B_1354)) ->
        ((B_1354) ((proj1_3) A_1353 B_1354 x_1356))
:=
  function proj2_1357 :
    ∀ {A_1358 : L} ->
      ∀ {B_1359 : A_1358 -> L} ->
        ∀ (x_1361 : (apair_6 A_1358 B_1359)) ->
          ((B_1359) ((proj1_3) A_1358 B_1359 x_1361))
  | A_1362 B_1363 (apair_intro_8 x_1364 select_1365) =>
    match x_1364, ((select_1365) true_3),
    ((sing_uniq_2) A_1362 x_1364 ((select_1365) true_3)),
    ((select_1365) false_4) in
      ∀ {x0_1366 : A_1362} -o
        ∀ {a0_1367 : (sing_5 A_1362 x_1364)} -o
          {(eq_1‹L› A_1362 x0_1366 ((sing_elim_1) A_1362 x_1364 a0_1367))} -o
            ((B_1363) x0_1366) -o
              ((B_1363) ((sing_elim_1) A_1362 x_1364 a0_1367))
    with
    | _1370, _1371, refl_1, b_1372 => b_1372

#[program]
def bool2nat_5‹› : bool_3 -> nat_4 :=
  function bool2nat_1374 : bool_3 -> nat_4
  | true_3 => (succ_6‹› zero_5)
  | false_4 => zero_5

#[program]
def free_bool_6‹› : bool_3 -> unit_2‹U› :=
  function free_bool_1377 : bool_3 -> unit_2‹U›
  | true_3 => tt_2‹U›
  | false_4 => tt_2‹U›

#[program]
def free_nat_7‹› : nat_4 -> unit_2‹U› :=
  function free_nat_1380 : nat_4 -> unit_2‹U›
  | zero_5 => tt_2‹U›
  | (succ_6 n_1382) => ((free_nat_1380) n_1382)

#[program]
def my_apair_8‹› :
  (apair_6
    bool_3
    function _1383 : bool_3 -> L
    | b_1385 =>
      match b_1385 in bool_3 -o L with
      | true_3 => unit_2‹L›
      | false_4 => nat_4)
:=
  let my_val_1387 := false_4 in
  (apair_intro_8‹›
    my_val_1387
    function _1388 :
      ∀ (b_1389 : bool_3) -o
        match b_1389 in bool_3 -o L with
        | true_3 => (sing_5 bool_3 my_val_1387)
        | false_4 =>
          ((function _1391 : bool_3 -> L
            | b_1393 =>
              match b_1393 in bool_3 -o L with
              | true_3 => unit_2‹L›
              | false_4 => nat_4)
            my_val_1387)
    | true_3 => (just_7‹› my_val_1387)
    | false_4 => ((bool2nat_5) my_val_1387))

#[program]
def __9‹› : unit_2‹U› :=
  ((free_bool_6)
    ((proj1_3)
      bool_3
      function _1395 : bool_3 -> L
      | b_1397 =>
        match b_1397 in bool_3 -o L with
        | true_3 => unit_2‹L›
        | false_4 => nat_4
      my_apair_8))

-----------------------------------------

#[logical]
inductive eqU_8 where
| reflU_10 of layout[]

#[logical]
inductive eqL_7 where
| reflL_9 of layout[]

#[program]
inductive unitU_10 where
| ttU_12 of layout[]

#[program]
inductive unitL_9 where
| ttL_11 of layout[]

#[program]
inductive bool_3 where
| true_3 of layout[]
| false_4 of layout[]

#[program]
inductive nat_4 where
| zero_5 of layout[]
| succ_6 of layout[R]

#[program]
inductive sing_5 where
| just_7 of layout[R]

#[program]
inductive apair_6 where
| apair_intro_8 of layout[N, R]

#[program]
def sing_elim_1 :=
  fun sing_elim_2078 (A_2079, x_2080, __2081) =>
    match __2081 with
    | just_7 m_2082 => m_2082
    end

#[logical]
def sing_uniq_2 := NULL

#[program]
def proj1_3 :=
  fun proj1_2083 (A_2084, B_2085, __2086) =>
    match __2086 with
    | apair_intro_8 x_2087 select_2088 =>
      ((sing_elim_1) NULL NULL ((select_2088) true_3))
    end

#[program]
def proj2_4 :=
  fun proj2_2089 (A_2090, B_2091, x_2092) =>
    match x_2092 with
    | apair_intro_8 x_2093 select_2094 =>
      match {NULL} with
      | reflL_9  => ((select_2094) false_4)
      end
    end

#[program]
def bool2nat_5 :=
  fun bool2nat_2095 (__2096) =>
    match __2096 with
    | true_3  => (succ_6 zero_5) | false_4  => zero_5
    end

#[program]
def free_bool_6 :=
  fun free_bool_2097 (__2098) =>
    match __2098 with
    | true_3  => ttU_12 | false_4  => ttU_12
    end

#[program]
def free_nat_7 :=
  fun free_nat_2099 (__2100) =>
    match __2100 with
    | zero_5  => ttU_12 | succ_6 pred_2101 => ((free_nat_2099) pred_2101)
    end

#[program]
def my_apair_8 :=
  let my_val_2102 := false_4 in
  (apair_intro_8
    NULL
    fun _2103 (b_2104) =>
      match b_2104 with
      | true_3  => (just_7 my_val_2102)
      | false_4  => ((bool2nat_5) my_val_2102)
      end)

#[program]
def __9 := ((free_bool_6) ((proj1_3) NULL NULL my_apair_8))

-----------------------------------------

#[logical]
inductive eqU_8 where
| reflU_10 of layout[]

#[logical]
inductive eqL_7 where
| reflL_9 of layout[]

#[program]
inductive unitU_10 where
| ttU_12 of layout[]

#[program]
inductive unitL_9 where
| ttL_11 of layout[]

#[program]
inductive bool_3 where
| true_3 of layout[]
| false_4 of layout[]

#[program]
inductive nat_4 where
| zero_5 of layout[]
| succ_6 of layout[R]

#[program]
inductive sing_5 where
| just_7 of layout[R]

#[program]
inductive apair_6 where
| apair_intro_8 of layout[N, R]

#[program]
def sing_elim_1 :=
  fun sing_elim_2132 (A_2133, x_2134, __2135) =>
    match __2135 with
    | just_7 m_2136 => m_2136
    end

#[logical]
def sing_uniq_2 := NULL

#[program]
def proj1_3 :=
  fun proj1_2137 (A_2138, B_2139, __2140) =>
    match __2140 with
    | apair_intro_8 x_2141 select_2142 =>
      ((sing_elim_1) NULL NULL ((select_2142) true_3))
    end

#[program]
def proj2_4 :=
  fun proj2_2143 (A_2144, B_2145, x_2146) =>
    match x_2146 with
    | apair_intro_8 x_2147 select_2148 => ((select_2148) false_4)
    end

#[program]
def bool2nat_5 :=
  fun bool2nat_2149 (__2150) =>
    match __2150 with
    | true_3  => (succ_6 zero_5) | false_4  => zero_5
    end

#[program]
def free_bool_6 :=
  fun free_bool_2151 (__2152) =>
    match __2152 with
    | true_3  => ttU_12 | false_4  => ttU_12
    end

#[program]
def free_nat_7 :=
  fun free_nat_2153 (__2154) =>
    match __2154 with
    | zero_5  => ttU_12 | succ_6 pred_2155 => ((free_nat_2153) pred_2155)
    end

#[program]
def my_apair_8 :=
  let my_val_2156 := false_4 in
  (apair_intro_8
    NULL
    fun _2157 (b_2158) =>
      match b_2158 with
      | true_3  => (just_7 my_val_2156)
      | false_4  => ((bool2nat_5) my_val_2156)
      end)

#[program]
def __9 := ((free_bool_6) ((proj1_3) NULL NULL my_apair_8))

-----------------------------------------

