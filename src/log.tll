[Notation {name = "|>"; body = (App [(Hole 2); (Hole 1)])};
  Notation {name = "@@"; body = (App [(Hole 1); (Hole 2)])};
  Notation {name = "="; body = (App [(Id ("eq", I)); (Hole 1); (Hole 2)])};
  Notation {name = "`"; body = (App [(Id ("sing", I)); (Hole 1)])};
  Notation {name = "&&"; body = (App [(Id ("and", I)); (Hole 1); (Hole 2)])};
  Notation {name = "||"; body = (App [(Id ("or", I)); (Hole 1); (Hole 2)])};
  Notation {name = "+"; body = (App [(Id ("add", I)); (Hole 1); (Hole 2)])};
  Notation {name = "-"; body = (App [(Id ("sub", I)); (Hole 1); (Hole 2)])};
  Notation {name = "*"; body = (App [(Id ("mul", I)); (Hole 1); (Hole 2)])};
  Notation {name = "/"; body = (App [(Id ("div", I)); (Hole 1); (Hole 2)])};
  Notation {name = "%"; body = (App [(Id ("rem", I)); (Hole 1); (Hole 2)])};
  Notation {name = "^"; body = (App [(Id ("pow", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<"; body = (App [(Id ("lt", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">"; body = (App [(Id ("gt", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<="; body = (App [(Id ("lte", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">="; body = (App [(Id ("gte", I)); (Hole 1); (Hole 2)])};
  Notation {name = "\195\151";
    body = (App [(Id ("prod1", I)); (Hole 1); (Hole 2)])};
  Notation {name = "::"; body = (App [(Id ("cons", I)); (Hole 1); (Hole 2)])};
  Notation {name = ";";
    body = (MLet ((Hole 1), (Binder ((PId "_"), (Hole 2)))))};
  Notation {name = "\226\159\168{},\226\159\169";
    body = (App [(Id ("ex0", I)); (Hole 1); (Hole 2)])};
  Notation {name = "\226\159\168,\226\159\169";
    body = (App [(Id ("ex1", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase (BOpr ("=", (Id ("m", I)), (Id ("m", I))))),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "rwl"; relv = R;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (N, U, (Id ("A", I)),
                          (Binder ("n",
                             (Pi (N, U,
                                (Pi (R, U, (Id ("A", I)),
                                   (Binder ("_", (Type (SId "r")))))),
                                (Binder ("B",
                                   (Pi (N, U,
                                      (BOpr ("=", (Id ("m", I)),
                                         (Id ("n", I)))),
                                      (Binder ("_",
                                         (Pi (R, U,
                                            (App
                                               [(Id ("B", I)); (Id ("m", I))]),
                                            (Binder ("_",
                                               (App
                                                  [(Id ("B", I));
                                                    (Id ("n", I))])
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "rwl"),
              [([(PId "A"); (PId "m"); (PId "n"); (PId "B"); (PId "refl");
                  (PId "x")],
                (Some (Id ("x", I))))]
              )),
           [I; I; I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (N, U, (Id ("A", I)),
                       (Binder ("n",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Type (SId "r")))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=", (Id ("m", I)), (Id ("n", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App [(Id ("B", I)); (Id ("m", I))]),
                                         (Binder ("_",
                                            (App
                                               [(Id ("B", I)); (Id ("n", I))])
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; E]};
  Definition {name = "rwr"; relv = R;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (N, U, (Id ("A", I)),
                          (Binder ("n",
                             (Pi (N, U,
                                (Pi (R, U, (Id ("A", I)),
                                   (Binder ("_", (Type (SId "r")))))),
                                (Binder ("B",
                                   (Pi (N, U,
                                      (BOpr ("=", (Id ("m", I)),
                                         (Id ("n", I)))),
                                      (Binder ("_",
                                         (Pi (R, U,
                                            (App
                                               [(Id ("B", I)); (Id ("n", I))]),
                                            (Binder ("_",
                                               (App
                                                  [(Id ("B", I));
                                                    (Id ("m", I))])
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "rwr"),
              [([(PId "A"); (PId "m"); (PId "n"); (PId "B"); (PId "refl");
                  (PId "x")],
                (Some (Id ("x", I))))]
              )),
           [I; I; I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (N, U, (Id ("A", I)),
                       (Binder ("n",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Type (SId "r")))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=", (Id ("m", I)), (Id ("n", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App [(Id ("B", I)); (Id ("n", I))]),
                                         (Binder ("_",
                                            (App
                                               [(Id ("B", I)); (Id ("m", I))])
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "s"))))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m", (TBase (UOpr ("`", (Id ("m", I))))))))),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "unit"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)), [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
       ));
    view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("n", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "list"; relv = R;
    body =
    (Binder (["s"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type (SId "t"))),
                 [(DConstr ("nil",
                     (TBase (App [(Id ("list", I)); (Id ("A", I))])), 
                     []));
                   (DConstr ("cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (App
                                  [(Inst ("list", [(SId "_"); (SId "t")], I));
                                    (Id ("A", I))]),
                               (Binder ("tl",
                                  (TBase
                                     (App [(Id ("list", I)); (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Inductive {name = "exists0"; relv = R;
    body =
    (Binder (["s"; "r"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("ex0",
                           (TBind (N, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("exists0", E));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "exists1"; relv = R;
    body =
    (Binder (["s"; "r"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("ex1",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("exists1", E));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "prod0"; relv = N;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (R, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))))
              )),
           (Binder ((Some "prod0"),
              [([(PId "A"); (PId "B")],
                (Some (App
                         [(Id ("exists0", E)); (Id ("A", I));
                           (Fun ((Pi (R, U, IMeta, (Binder ("_", IMeta)))),
                              (Binder (None,
                                 [([(PId "_")], (Some (Id ("B", I))))])),
                              []))
                           ])))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Type (SId "s")),
           (Binder ("A", (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "prod1"; relv = N;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (R, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))))
              )),
           (Binder ((Some "prod1"),
              [([(PId "A"); (PId "B")],
                (Some (App
                         [(Id ("exists1", E)); (Id ("A", I));
                           (Fun ((Pi (R, U, IMeta, (Binder ("_", IMeta)))),
                              (Binder (None,
                                 [([(PId "_")], (Some (Id ("B", I))))])),
                              []))
                           ])))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Type (SId "s")),
           (Binder ("A", (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "not"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I)))))),
           (Binder ((Some "not"),
              [([(PId "true")], (Some (Id ("false", I))));
                ([(PId "false")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I)))))))
       ));
    view = []};
  Definition {name = "and"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "and"),
              [([(PId "true"); (PId "true")], (Some (Id ("true", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("false", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "or"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "or"),
              [([(PId "false"); (PId "false")], (Some (Id ("false", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "xor"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, L, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "xor"),
              [([(PId "true"); (PId "true")], (Some (Id ("false", I))));
                ([(PId "false"); (PId "false")], (Some (Id ("false", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, L, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "lte"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("bool", I))))
                    ))
                 ))
              )),
           (Binder ((Some "lte"),
              [([(PId "zero"); (PId "_")], (Some (Id ("true", I))));
                ([(PId "_"); (PId "zero")], (Some (Id ("false", I))));
                ([(PConstr ("succ", [(PId "x")]));
                   (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("<=", (Id ("x", I)), (Id ("y", I))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "lt"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", (Id ("bool", I))))
                    ))
                 ))
              )),
           (Binder ((Some "lt"),
              [([(PId "x"); (PId "y")],
                (Some (BOpr ("<=", (App [(Id ("succ", I)); (Id ("x", I))]),
                         (Id ("y", I))))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x",
              (Pi (R, U, (Id ("nat", I)), (Binder ("y", (Id ("bool", I))))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "pred"; relv = R;
    body =
    (Binder ([],
       ((Fun ((Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I)))))),
           (Binder ((Some "pred"),
              [([(PId "zero")], (Some (Id ("zero", I))));
                ([(PConstr ("succ", [(PId "x")]))], (Some (Id ("x", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I)))))))
       ));
    view = []};
  Definition {name = "add"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "add"),
              [([(PId "zero"); (PId "y")], (Some (Id ("y", I))));
                ([(PConstr ("succ", [(PId "x")])); (PId "y")],
                 (Some (App
                          [(Id ("succ", I));
                            (BOpr ("+", (Id ("x", I)), (Id ("y", I))))])))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "sub"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "sub"),
              [([(PId "x"); (PId "zero")], (Some (Id ("x", I))));
                ([(PId "x"); (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("-", (App [(Id ("pred", I)); (Id ("x", I))]),
                          (Id ("y", I))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "mul"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "mul"),
              [([(PId "zero"); (PId "_")], (Some (Id ("zero", I))));
                ([(PConstr ("succ", [(PId "x")])); (PId "y")],
                 (Some (BOpr ("+", (Id ("y", I)),
                          (BOpr ("*", (Id ("x", I)), (Id ("y", I))))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "div"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))))
              )),
           (Binder ((Some "div"),
              [([(PId "x"); (PId "y")],
                (Some (Match (
                         [(R,
                           (App
                              [(Id ("lt", I)); (Id ("x", I)); (Id ("y", I))]),
                           None)],
                         None,
                         [([(PId "true")], (Some (Id ("zero", I))));
                           ([(PId "false")],
                            (Some (Let (R,
                                     (Fun (
                                        (Pi (R, U, (Id ("nat", I)),
                                           (Binder ("x",
                                              (Pi (R, U, (Id ("nat", I)),
                                                 (Binder ("y", IMeta))))
                                              ))
                                           )),
                                        (Binder ((Some "loop"),
                                           [([(PId "x"); (PId "y")],
                                             (Some (Match (
                                                      [(R,
                                                        (BOpr ("-",
                                                           (Id ("x", I)),
                                                           (App
                                                              [(Id ("pred", I
                                                                  ));
                                                                (Id ("y", I))
                                                                ])
                                                           )),
                                                        None)],
                                                      None,
                                                      [([(PId "zero")],
                                                        (Some (Id ("zero", I
                                                                 ))));
                                                        ([(PConstr ("succ",
                                                             [(PId "x")]))
                                                           ],
                                                         (Some (App
                                                                  [(Id (
                                                                    "succ", I
                                                                    ));
                                                                    (
                                                                    App
                                                                    [(Id (
                                                                    "loop", I
                                                                    ));
                                                                    (Id ("x",
                                                                    I));
                                                                    (Id ("y",
                                                                    I))])])))
                                                        ]
                                                      ))))
                                             ]
                                           )),
                                        [])),
                                     (Binder ((PId "loop"),
                                        (App
                                           [(Id ("loop", I)); (Id ("x", I));
                                             (Id ("y", I))])
                                        ))
                                     ))))
                           ]
                         ))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x", (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "rem"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))))
              )),
           (Binder ((Some "rem"),
              [([(PId "x"); (PId "y")],
                (Some (BOpr ("-", (Id ("x", I)),
                         (BOpr ("*",
                            (BOpr ("/", (Id ("x", I)), (Id ("y", I)))),
                            (Id ("y", I))))
                         ))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x", (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "pow"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "pow"),
              [([(PId "_"); (PId "zero")],
                (Some (App [(Id ("succ", I)); (Id ("zero", I))])));
                ([(PId "x"); (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("*", (Id ("x", I)),
                          (BOpr ("^", (Id ("x", I)), (Id ("y", I))))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Extern {name = "proto"; relv = N; body = (Binder ([], (None, (Type U))));
    view = []};
  Extern {name = "act0"; relv = N;
    body =
    (Binder (["s"],
       (None,
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("b",
              (Pi (R, U, (Type (SId "s")),
                 (Binder ("A",
                    (Pi (R, U,
                       (Pi (R, U, (Id ("A", I)),
                          (Binder ("_", (Id ("proto", I)))))),
                       (Binder ("B", (Id ("proto", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; I; E]};
  Extern {name = "act1"; relv = N;
    body =
    (Binder (["s"],
       (None,
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("b",
              (Pi (R, U, (Type (SId "s")),
                 (Binder ("A",
                    (Pi (R, U,
                       (Pi (R, U, (Id ("A", I)),
                          (Binder ("_", (Id ("proto", I)))))),
                       (Binder ("B", (Id ("proto", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; I; E]};
  Extern {name = "endp"; relv = N;
    body = (Binder ([], (None, (Id ("proto", I))))); view = []};
  Extern {name = "ch"; relv = N;
    body =
    (Binder ([],
       (None,
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("proto", I)), (Binder ("_", (Type L)))))))
           )))
       ));
    view = []};
  Extern {name = "close"; relv = R;
    body =
    (Binder ([],
       (None,
        (Pi (N, U, (Id ("bool", I)),
           (Binder ("b",
              (Pi (R, U,
                 (App [(Id ("ch", I)); (Id ("b", I)); (Id ("endp", I))]),
                 (Binder ("_", (IO (Id ("unit", I)))))))
              ))
           )))
       ));
    view = [I]};
  Extern {name = "send0"; relv = R;
    body =
    (Binder (["s"],
       (None,
        (Pi (N, U, (Id ("bool", I)),
           (Binder ("b1",
              (Pi (N, U, (Id ("bool", I)),
                 (Binder ("b2",
                    (Pi (N, U, (Type (SId "s")),
                       (Binder ("A",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Id ("proto", I)))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=",
                                      (App
                                         [(Id ("xor", I)); (Id ("b1", I));
                                           (Id ("b2", I))]),
                                      (Id ("false", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App
                                            [(Id ("ch", I)); (Id ("b1", I));
                                              (App
                                                 [(Id ("act0", I));
                                                   (Id ("b2", I));
                                                   (Id ("B", I))])
                                              ]),
                                         (Binder ("_",
                                            (Pi (N, L, (Id ("A", I)),
                                               (Binder ("x",
                                                  (IO
                                                     (App
                                                        [(Id ("ch", I));
                                                          (Id ("b1", I));
                                                          (App
                                                             [(Id ("B", I));
                                                               (Id ("x", I))])
                                                          ]))
                                                  ))
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; I]};
  Extern {name = "send1"; relv = R;
    body =
    (Binder (["s"],
       (None,
        (Pi (N, U, (Id ("bool", I)),
           (Binder ("b1",
              (Pi (N, U, (Id ("bool", I)),
                 (Binder ("b2",
                    (Pi (N, U, (Type (SId "s")),
                       (Binder ("A",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Id ("proto", I)))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=",
                                      (App
                                         [(Id ("xor", I)); (Id ("b1", I));
                                           (Id ("b2", I))]),
                                      (Id ("false", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App
                                            [(Id ("ch", I)); (Id ("b1", I));
                                              (App
                                                 [(Id ("act1", I));
                                                   (Id ("b2", I));
                                                   (Id ("B", I))])
                                              ]),
                                         (Binder ("_",
                                            (Pi (R, L, (Id ("A", I)),
                                               (Binder ("x",
                                                  (IO
                                                     (App
                                                        [(Id ("ch", I));
                                                          (Id ("b1", I));
                                                          (App
                                                             [(Id ("B", I));
                                                               (Id ("x", I))])
                                                          ]))
                                                  ))
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; I]};
  Extern {name = "recv0"; relv = R;
    body =
    (Binder (["s"],
       (None,
        (Pi (N, U, (Id ("bool", I)),
           (Binder ("b1",
              (Pi (N, U, (Id ("bool", I)),
                 (Binder ("b2",
                    (Pi (N, U, (Type (SId "s")),
                       (Binder ("A",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Id ("proto", I)))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=",
                                      (App
                                         [(Id ("xor", I)); (Id ("b1", I));
                                           (Id ("b2", I))]),
                                      (Id ("true", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App
                                            [(Id ("ch", I)); (Id ("b1", I));
                                              (App
                                                 [(Id ("act0", I));
                                                   (Id ("b2", I));
                                                   (Id ("B", I))])
                                              ]),
                                         (Binder ("_",
                                            (IO
                                               (App
                                                  [(Id ("exists0", I));
                                                    (Fun (
                                                       (Pi (R, U,
                                                          (Id ("A", I)),
                                                          (Binder ("x", IMeta
                                                             ))
                                                          )),
                                                       (Binder (None,
                                                          [([(PId "x")],
                                                            (Some (App
                                                                    [(Id (
                                                                    "ch", I));
                                                                    (Id (
                                                                    "b1", I));
                                                                    (App
                                                                    [(Id (
                                                                    "B", I));
                                                                    (Id ("x",
                                                                    I))])])))
                                                            ]
                                                          )),
                                                       []))
                                                    ]))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; I]};
  Extern {name = "recv1"; relv = R;
    body =
    (Binder (["s"],
       (None,
        (Pi (N, U, (Id ("bool", I)),
           (Binder ("b1",
              (Pi (N, U, (Id ("bool", I)),
                 (Binder ("b2",
                    (Pi (N, U, (Type (SId "s")),
                       (Binder ("A",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Id ("proto", I)))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=",
                                      (App
                                         [(Id ("xor", I)); (Id ("b1", I));
                                           (Id ("b2", I))]),
                                      (Id ("true", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App
                                            [(Id ("ch", I)); (Id ("b1", I));
                                              (App
                                                 [(Id ("act1", I));
                                                   (Id ("b2", I));
                                                   (Id ("B", I))])
                                              ]),
                                         (Binder ("_",
                                            (IO
                                               (App
                                                  [(Id ("exists1", I));
                                                    (Fun (
                                                       (Pi (R, U,
                                                          (Id ("A", I)),
                                                          (Binder ("x", IMeta
                                                             ))
                                                          )),
                                                       (Binder (None,
                                                          [([(PId "x")],
                                                            (Some (App
                                                                    [(Id (
                                                                    "ch", I));
                                                                    (Id (
                                                                    "b1", I));
                                                                    (App
                                                                    [(Id (
                                                                    "B", I));
                                                                    (Id ("x",
                                                                    I))])])))
                                                            ]
                                                          )),
                                                       []))
                                                    ]))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; I]};
  Extern {name = "fork"; relv = R;
    body =
    (Binder ([],
       (None,
        (Pi (N, U, (Id ("bool", I)),
           (Binder ("b",
              (Pi (N, U, (Id ("proto", I)),
                 (Binder ("P",
                    (Pi (R, U,
                       (Pi (R, L,
                          (App [(Id ("ch", I)); (Id ("b", I)); (Id ("P", I))]),
                          (Binder ("_", (IO (Id ("unit", I))))))),
                       (Binder ("_",
                          (IO
                             (App
                                [(Id ("ch", I));
                                  (App [(Id ("not", I)); (Id ("b", I))]);
                                  (Id ("P", I))]))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "split"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("_",
                 (BOpr ("\195\151",
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))]),
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))])
                    ))
                 ))
              )),
           (Binder ((Some "split"),
              [([(PId "nil")],
                (Some (BOpr ("\226\159\168,\226\159\169", (Id ("nil", I)),
                         (Id ("nil", I))))));
                ([(PBOpr ("::", (PId "x"), (PId "nil")))],
                 (Some (BOpr ("\226\159\168,\226\159\169",
                          (BOpr ("::", (Id ("x", I)), (Id ("nil", I)))),
                          (Id ("nil", I))))));
                ([(PBOpr ("::", (PId "x"),
                     (PBOpr ("::", (PId "y"), (PId "zs")))))
                   ],
                 (Some (Let (R, (App [(Id ("split", I)); (Id ("zs", I))]),
                          (Binder (
                             (PBOpr ("\226\159\168,\226\159\169", (PId "xs"),
                                (PId "ys"))),
                             (BOpr ("\226\159\168,\226\159\169",
                                (BOpr ("::", (Id ("x", I)), (Id ("xs", I)))),
                                (BOpr ("::", (Id ("y", I)), (Id ("ys", I))))
                                ))
                             ))
                          ))))
                ]
              )),
           [])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("_",
              (BOpr ("\195\151",
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))]),
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))])
                 ))
              ))
           )))
       ));
    view = []};
  Definition {name = "merge"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("_",
                 (Pi (R, L,
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))]),
                    (Binder ("_",
                       (App
                          [(Inst ("list", [(SId "_"); (SId "t")], I));
                            (Id ("nat", I))])
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "merge"),
              [([(PId "nil"); (PId "ys")], (Some (Id ("ys", I))));
                ([(PId "xs"); (PId "nil")], (Some (Id ("xs", I))));
                ([(PBOpr ("::", (PId "x"), (PId "xs")));
                   (PBOpr ("::", (PId "y"), (PId "ys")))],
                 (Some (Match (
                          [(R, (BOpr ("<=", (Id ("x", I)), (Id ("y", I)))),
                            None)],
                          None,
                          [([(PId "true")],
                            (Some (BOpr ("::", (Id ("x", I)),
                                     (App
                                        [(Id ("merge", I)); (Id ("xs", I));
                                          (BOpr ("::", (Id ("y", I)),
                                             (Id ("ys", I))))
                                          ])
                                     ))));
                            ([(PId "false")],
                             (Some (BOpr ("::", (Id ("y", I)),
                                      (App
                                         [(Id ("merge", I));
                                           (BOpr ("::", (Id ("x", I)),
                                              (Id ("xs", I))));
                                           (Id ("ys", I))])
                                      ))))
                            ]
                          ))))
                ]
              )),
           [])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("_",
              (Pi (R, L,
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))]),
                 (Binder ("_",
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))])
                    ))
                 ))
              ))
           )))
       ));
    view = []};
  Definition {name = "msort"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("_",
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))])
                 ))
              )),
           (Binder ((Some "msort"),
              [([(PId "nil")], (Some (Id ("nil", I))));
                ([(PBOpr ("::", (PId "z"), (PId "nil")))],
                 (Some (BOpr ("::", (Id ("z", I)), (Id ("nil", I))))));
                ([(PId "zs")],
                 (Some (Let (R, (App [(Id ("split", I)); (Id ("zs", I))]),
                          (Binder (
                             (PBOpr ("\226\159\168,\226\159\169", (PId "xs"),
                                (PId "ys"))),
                             (App
                                [(Id ("merge", I));
                                  (App [(Id ("msort", I)); (Id ("xs", I))]);
                                  (App [(Id ("msort", I)); (Id ("ys", I))])])
                             ))
                          ))))
                ]
              )),
           [])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("_",
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ])
              ))
           )))
       ));
    view = []};
  Definition {name = "cmsort_ch"; relv = N;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("xs", (Type L))))),
           (Binder ((Some "cmsort_ch"),
              [([(PId "xs")],
                (Some (App
                         [(Id ("ch", I)); (Id ("true", I));
                           (App
                              [(Id ("act1", I)); (Id ("true", I));
                                (Fun (
                                   (Pi (R, U,
                                      (UOpr ("`",
                                         (App
                                            [(Id ("msort", I));
                                              (Id ("xs", I))])
                                         )),
                                      (Binder ("_", IMeta)))),
                                   (Binder (None,
                                      [([(PId "_")], (Some (Id ("endp", I))))
                                        ]
                                      )),
                                   []))
                                ])
                           ])))
                ]
              )),
           [E])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("xs", (Type L))))))
       ));
    view = [E]};
  Definition {name = "cmsort_worker"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U,
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))]),
                    (Binder ("zs",
                       (Pi (R, L,
                          (App
                             [(Inst ("cmsort_ch", [(SId "t")], I));
                               (Id ("zs", I))]),
                          (Binder ("_", (IO (Id ("unit", I)))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "cmsort_worker"),
              [([(PId "zero"); (PId "zs"); (PId "c")],
                (Some (MLet (
                         (App
                            [(Id ("send1", I)); (Id ("refl", I));
                              (Id ("c", I));
                              (App
                                 [(Id ("just", I));
                                   (App [(Id ("msort", I)); (Id ("zs", I))])])
                              ]),
                         (Binder ((PId "c"),
                            (App [(Id ("close", I)); (Id ("c", I))])))
                         ))));
                ([(PConstr ("succ", [(PId "n")])); (PId "nil"); (PId "c")],
                 (Some (MLet (
                          (App
                             [(Id ("send1", I)); (Id ("refl", I));
                               (Id ("c", I));
                               (App [(Id ("just", I)); (Id ("nil", I))])]),
                          (Binder ((PId "c"),
                             (App [(Id ("close", I)); (Id ("c", I))])))
                          ))));
                ([(PConstr ("succ", [(PId "n")]));
                   (PBOpr ("::", (PId "z"), (PId "nil"))); (PId "c")],
                 (Some (MLet (
                          (App
                             [(Id ("send1", I)); (Id ("refl", I));
                               (Id ("c", I));
                               (App
                                  [(Id ("just", I));
                                    (BOpr ("::", (Id ("z", I)),
                                       (Id ("nil", I))))
                                    ])
                               ]),
                          (Binder ((PId "c"),
                             (App [(Id ("close", I)); (Id ("c", I))])))
                          ))));
                ([(PConstr ("succ", [(PId "n")])); (PId "zs"); (PId "c")],
                 (Some (Match (
                          [(R, (App [(Id ("split", I)); (Id ("zs", I))]),
                            (Some ("h1", IMeta)));
                            (N, (Id ("refl", I)),
                             (Some ("_",
                                    (BOpr ("=",
                                       (Let (R, (Id ("h1", I)),
                                          (Binder (
                                             (PBOpr (
                                                "\226\159\168,\226\159\169",
                                                (PId "xs"), (PId "ys"))),
                                             (App
                                                [(Id ("merge", I));
                                                  (App
                                                     [(Id ("msort", I));
                                                       (Id ("xs", I))]);
                                                  (App
                                                     [(Id ("msort", I));
                                                       (Id ("ys", I))])
                                                  ])
                                             ))
                                          )),
                                       (Let (R,
                                          (App
                                             [(Id ("split", I));
                                               (Id ("zs", I))]),
                                          (Binder (
                                             (PBOpr (
                                                "\226\159\168,\226\159\169",
                                                (PId "xs"), (PId "ys"))),
                                             (App
                                                [(Id ("merge", I));
                                                  (App
                                                     [(Id ("msort", I));
                                                       (Id ("xs", I))]);
                                                  (App
                                                     [(Id ("msort", I));
                                                       (Id ("ys", I))])
                                                  ])
                                             ))
                                          ))
                                       )))))
                            ],
                          None,
                          [([(PBOpr ("\226\159\168,\226\159\169",
                                (PId "xs0"), (PId "ys0")));
                              (PId "pf")],
                            (Some (MLet (
                                     (App
                                        [(Id ("fork", I));
                                          (Fun (
                                             (Pi (R, L, IMeta,
                                                (Binder ("c1", IMeta)))),
                                             (Binder (None,
                                                [([(PId "c1")],
                                                  (Some (App
                                                           [(Id (
                                                               "cmsort_worker",
                                                               I));
                                                             (Id ("n", I));
                                                             (Id ("xs0", I));
                                                             (Id ("c1", I))])))
                                                  ]
                                                )),
                                             []))
                                          ]),
                                     (Binder ((PId "r1"),
                                        (MLet (
                                           (App
                                              [(Id ("fork", I));
                                                (Fun (
                                                   (Pi (R, L, IMeta,
                                                      (Binder ("c2", IMeta))
                                                      )),
                                                   (Binder (None,
                                                      [([(PId "c2")],
                                                        (Some (App
                                                                 [(Id (
                                                                    "cmsort_worker",
                                                                    I));
                                                                   (Id ("n",
                                                                    I));
                                                                   (Id (
                                                                    "ys0", I
                                                                    ));
                                                                   (Id ("c2",
                                                                    I))
                                                                   ])))
                                                        ]
                                                      )),
                                                   []))
                                                ]),
                                           (Binder ((PId "r2"),
                                              (MLet (
                                                 (App
                                                    [(Id ("recv1", I));
                                                      (Id ("refl", I));
                                                      (Id ("r1", I))]),
                                                 (Binder (
                                                    (PBOpr (
                                                       "\226\159\168,\226\159\169",
                                                       (PId "xs1"),
                                                       (PId "c1"))),
                                                    (BOpr (";",
                                                       (App
                                                          [(Id ("close", I));
                                                            (Id ("c1", I))]),
                                                       (MLet (
                                                          (App
                                                             [(Id ("recv1", I
                                                                 ));
                                                               (Id ("refl", I
                                                                  ));
                                                               (Id ("r2", I))
                                                               ]),
                                                          (Binder (
                                                             (PBOpr (
                                                                "\226\159\168,\226\159\169",
                                                                (PId "ys1"),
                                                                (PId "c2"))),
                                                             (BOpr (";",
                                                                (App
                                                                   [(Id (
                                                                    "close",
                                                                    I));
                                                                    (Id (
                                                                    "c2", I))
                                                                    ]),
                                                                (Match (
                                                                   [(R,
                                                                    (Id (
                                                                    "xs1", I
                                                                    )), None);
                                                                    (R,
                                                                    (Id (
                                                                    "ys1", I
                                                                    )), None)
                                                                    ],
                                                                   None,
                                                                   [([(PConstr (
                                                                    "just",
                                                                    [(PId
                                                                    "xs1")]));
                                                                    (PConstr (
                                                                    "just",
                                                                    [(PId
                                                                    "ys1")]))
                                                                    ],
                                                                    (Some (
                                                                    Let (R,
                                                                    (Ann (
                                                                    (App
                                                                    [(Id (
                                                                    "just", I
                                                                    ));
                                                                    (App
                                                                    [(Id (
                                                                    "merge",
                                                                    I));
                                                                    (Id (
                                                                    "xs1", I
                                                                    ));
                                                                    (Id (
                                                                    "ys1", I
                                                                    ))])]),
                                                                    (UOpr (
                                                                    "`",
                                                                    (App
                                                                    [(Id (
                                                                    "merge",
                                                                    I));
                                                                    (App
                                                                    [(Id (
                                                                    "msort",
                                                                    I));
                                                                    (Id (
                                                                    "xs0", I
                                                                    ))]);
                                                                    (App
                                                                    [(Id (
                                                                    "msort",
                                                                    I));
                                                                    (Id (
                                                                    "ys0", I
                                                                    ))])])))
                                                                    )),
                                                                    (Binder (
                                                                    (PId
                                                                    "zs1"),
                                                                    (Let (R,
                                                                    (Ann (
                                                                    (App
                                                                    [(Id (
                                                                    "rwl", I
                                                                    ));
                                                                    (Fun (
                                                                    (Pi (R,
                                                                    U, IMeta,
                                                                    (Binder (
                                                                    "x",
                                                                    IMeta)))),
                                                                    (Binder (
                                                                    None,
                                                                    [([(PId
                                                                    "x")],
                                                                    (Some (
                                                                    UOpr (
                                                                    "`",
                                                                    (Id ("x",
                                                                    I))))))]
                                                                    )), 
                                                                    []));
                                                                    (Id (
                                                                    "pf", I));
                                                                    (Id (
                                                                    "zs1", I
                                                                    ))]),
                                                                    (UOpr (
                                                                    "`",
                                                                    (App
                                                                    [(Id (
                                                                    "msort",
                                                                    I));
                                                                    (Id (
                                                                    "zs", I))
                                                                    ]))))),
                                                                    (Binder (
                                                                    (PId
                                                                    "zs1"),
                                                                    (MLet (
                                                                    (App
                                                                    [(Id (
                                                                    "send1",
                                                                    I));
                                                                    (Id (
                                                                    "refl", I
                                                                    ));
                                                                    (Id ("c",
                                                                    I));
                                                                    (Id (
                                                                    "zs1", I
                                                                    ))]),
                                                                    (Binder (
                                                                    (PId "c"),
                                                                    (BOpr (
                                                                    ";",
                                                                    (App
                                                                    [(Id (
                                                                    "close",
                                                                    I));
                                                                    (Id ("c",
                                                                    I))]),
                                                                    (Return
                                                                    (Id (
                                                                    "tt", I)))
                                                                    ))))))))
                                                                    ))))))))]
                                                                   ))
                                                                ))
                                                             ))
                                                          ))
                                                       ))
                                                    ))
                                                 ))
                                              ))
                                           ))
                                        ))
                                     ))))
                            ]
                          ))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U,
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))]),
                 (Binder ("zs",
                    (Pi (R, L,
                       (App
                          [(Inst ("cmsort_ch", [(SId "t")], I));
                            (Id ("zs", I))]),
                       (Binder ("_", (IO (Id ("unit", I)))))))
                    ))
                 ))
              ))
           )))
       ));
    view = []}
  ]

-----------------------------------------

#[logical]
inductive eq_1s_398 (A_399 : Types_398) (m_400 : A_399):
  A_399 -> U
where
| refl_1 : (eq_1??_1 ?_1[0;0] m_400 m_400)

#[program]
def rwl_1s_402,r_403 :
   {A_404 : Types_402} ->
     {m_405 : A_404} ->
       {n_406 : A_404} ->
         {B_407 : A_404 -> Typer_403} ->
          {(eq_1??_3 ?_3[0;0] m_405 n_406)} ->
            ((B_407) m_405) -> ((B_407) n_406)
:=
  function rwl_411 :
     {A_412 : Types_402} ->
       {m_413 : A_412} ->
         {n_414 : A_412} ->
           {B_415 : A_412 -> Typer_403} ->
            {(eq_1??_2 ?_2[0;0] m_413 n_414)} ->
              ((B_415) m_413) -> ((B_415) n_414)
  | A_419 m_420 n_421 B_422 refl_1 x_423 => x_423

#[program]
def rwr_2s_424,r_425 :
   {A_426 : Types_424} ->
     {m_427 : A_426} ->
       {n_428 : A_426} ->
         {B_429 : A_426 -> Typer_425} ->
          {(eq_1??_5 ?_5[0;0] m_427 n_428)} ->
            ((B_429) n_428) -> ((B_429) m_427)
:=
  function rwr_433 :
     {A_434 : Types_424} ->
       {m_435 : A_434} ->
         {n_436 : A_434} ->
           {B_437 : A_434 -> Typer_425} ->
            {(eq_1??_4 ?_4[0;0] m_435 n_436)} ->
              ((B_437) n_436) -> ((B_437) m_435)
  | A_441 m_442 n_443 B_444 refl_1 x_445 => x_445

#[program]
inductive sing_2s_446 (A_447 : Types_446):
  A_447 -> Types_446
where
| just_2 (m_449 : A_447) : (sing_2??_6 ?_6[0;0] m_449)

#[program]
inductive unit_3 : U where
| tt_3 : unit_3

#[program]
inductive bool_4 : U where
| true_4 : bool_4
| false_5 : bool_4

#[program]
inductive nat_5 : U where
| zero_6 : nat_5
| succ_7 (n_450 : nat_5) : nat_5

#[program]
inductive list_6s_451,t_452 (A_453 : Types_451): Typet_452
where
| nil_8 : (list_6??_7,??_8 A_453)
| cons_9
    (hd_454 : A_453) (tl_455 : (list_6??_9,t_452 A_453))
    : (list_6??_10,??_11 A_453)

#[program]
inductive exists0_7s_456,r_457 (A_458 : Types_456) (B_459 : 
A_458 -> Typer_457): L where
| ex0_10
    {m_461 : A_458} (n_462 : ((B_459) m_461))
    : (exists0_7??_12,??_13 A_458 B_459)

#[program]
inductive exists1_8s_463,r_464 (A_465 : Types_463) (B_466 : 
A_465 -> Typer_464): L where
| ex1_11
    (m_468 : A_465) (n_469 : ((B_466) m_468))
    : (exists1_8??_14,??_15 A_465 B_466)

#[logical]
def prod0_3s_470,r_471 :
  Types_470 -> Typer_471 -> ?_10[0;0]
:=
  function prod0_474 : Types_470 -> Typer_471 -> ?_7[0;0]
  | A_477 B_478 =>
    (exists0_7??_16,??_17
      A_477 function _479 : ?_8[0;0] -> ?_9[0;0]
            | _481 => B_478)

#[logical]
def prod1_4s_482,r_483 :
  Types_482 -> Typer_483 -> ?_14[0;0]
:=
  function prod1_486 : Types_482 -> Typer_483 -> ?_11[0;0]
  | A_489 B_490 =>
    (exists1_8??_18,??_19
      A_489 function _491 : ?_12[0;0] -> ?_13[0;0]
            | _493 => B_490)

#[program]
def not_5 : bool_4 -> bool_4 :=
  function not_495 : bool_4 -> bool_4
  | true_4 => false_5
  | false_5 => true_4

#[program]
def and_6 : bool_4 -> bool_4 -> bool_4 :=
  function and_499 : bool_4 -> bool_4 -> bool_4
  | true_4 true_4 => true_4
  | _502 _503 => false_5

#[program]
def or_7 : bool_4 -> bool_4 -> bool_4 :=
  function or_506 : bool_4 -> bool_4 -> bool_4
  | false_5 false_5 => false_5
  | _509 _510 => true_4

#[program]
def xor_8 : bool_4 -> bool_4 -o bool_4 :=
  function xor_513 : bool_4 -> bool_4 -o bool_4
  | true_4 true_4 => false_5
  | false_5 false_5 => false_5
  | _516 _517 => true_4

#[program]
def lte_9 : nat_5 -> nat_5 -> bool_4 :=
  function lte_520 : nat_5 -> nat_5 -> bool_4
  | zero_6 _523 => true_4
  | _524 zero_6 => false_5
  | (succ_7 x_525) (succ_7 y_526) => ((lte_520) x_525 y_526)

#[program]
def lt_10 : nat_5 -> nat_5 -> bool_4 :=
  function lt_529 : nat_5 -> nat_5 -> bool_4
  | x_532 y_533 => ((lte_9) (succ_7 x_532) y_533)

#[program]
def pred_11 : nat_5 -> nat_5 :=
  function pred_535 : nat_5 -> nat_5
  | zero_6 => zero_6
  | (succ_7 x_537) => x_537

#[program]
def add_12 : nat_5 -> nat_5 -> nat_5 :=
  function add_540 : nat_5 -> nat_5 -> nat_5
  | zero_6 y_543 => y_543
  | (succ_7 x_544) y_545 => (succ_7 ((add_540) x_544 y_545))

#[program]
def sub_13 : nat_5 -> nat_5 -> nat_5 :=
  function sub_548 : nat_5 -> nat_5 -> nat_5
  | x_551 zero_6 => x_551
  | x_552 (succ_7 y_553) => ((sub_548) ((pred_11) x_552) y_553)

#[program]
def mul_14 : nat_5 -> nat_5 -> nat_5 :=
  function mul_556 : nat_5 -> nat_5 -> nat_5
  | zero_6 _559 => zero_6
  | (succ_7 x_560) y_561 => ((add_12) y_561 ((mul_556) x_560 y_561))

#[program]
def div_15 : nat_5 -> nat_5 -> ?_21[0;0] :=
  function div_564 : nat_5 -> nat_5 -> ?_15[0;0]
  | x_567 y_568 =>
    match ((lt_10) x_567 y_568) in ?_16[0;0] -o ?_17[0;0] with
    | true_4 => zero_6
    | false_5 =>
      let loop_570 :=
        function loop_571 : nat_5 -> nat_5 -> ?_18[0;0]
        | x_574 y_575 =>
          match ((sub_13) x_574 ((pred_11) y_575)) in ?_19[0;0] -o ?_20[0;0]
          with
          | zero_6 => zero_6
          | (succ_7 x_577) => (succ_7 ((loop_571) x_577 y_575))
      in ((loop_570) x_567 y_568)

#[program]
def rem_16 : nat_5 -> nat_5 -> ?_23[0;0] :=
  function rem_580 : nat_5 -> nat_5 -> ?_22[0;0]
  | x_583 y_584 => ((sub_13) x_583 ((mul_14) ((div_15) x_583 y_584) y_584))

#[program]
def pow_17 : nat_5 -> nat_5 -> nat_5 :=
  function pow_587 : nat_5 -> nat_5 -> nat_5
  | _590 zero_6 => (succ_7 zero_6)
  | x_591 (succ_7 y_592) => ((mul_14) x_591 ((pow_587) x_591 y_592))

#[logical]
extern proto_18 : U

#[logical]
extern act0_19s_593 :
  bool_4 ->  (A_595 : Types_593) -> A_595 -> proto_18 -> proto_18

#[logical]
extern act1_20s_598 :
  bool_4 ->  (A_600 : Types_598) -> A_600 -> proto_18 -> proto_18

#[logical]
extern endp_21 : proto_18

#[logical]
extern ch_22 : bool_4 -> proto_18 -> L

#[program]
extern close_23 :
   {b_605 : bool_4} -> ((ch_22) b_605 endp_21) -> IO unit_3

#[program]
extern send0_24s_607 :
   {b1_608 : bool_4} ->
     {b2_609 : bool_4} ->
       {A_610 : Types_607} ->
         {B_611 : A_610 -> proto_18} ->
          {(eq_1??_20 ?_24[0;0] ((xor_8) b1_608 b2_609) false_5)} ->
            ((ch_22) b1_608 ((act0_19??_21) b2_609 ?_25[0;0] B_611)) ->
               {x_615 : A_610} -o IO ((ch_22) b1_608 ((B_611) x_615))

#[program]
extern send1_25s_616 :
   {b1_617 : bool_4} ->
     {b2_618 : bool_4} ->
       {A_619 : Types_616} ->
         {B_620 : A_619 -> proto_18} ->
          {(eq_1??_22 ?_26[0;0] ((xor_8) b1_617 b2_618) false_5)} ->
            ((ch_22) b1_617 ((act1_20??_23) b2_618 ?_27[0;0] B_620)) ->
               (x_624 : A_619) -o IO ((ch_22) b1_617 ((B_620) x_624))

#[program]
extern recv0_26s_625 :
   {b1_626 : bool_4} ->
     {b2_627 : bool_4} ->
       {A_628 : Types_625} ->
         {B_629 : A_628 -> proto_18} ->
          {(eq_1??_24 ?_28[0;0] ((xor_8) b1_626 b2_627) true_4)} ->
            ((ch_22) b1_626 ((act0_19??_25) b2_627 ?_29[0;0] B_629)) ->
              IO (exists0_7??_26,??_27
                   ?_31[0;0]
                   function _633 : A_628 -> ?_30[0;0]
                   | x_635 => ((ch_22) b1_626 ((B_629) x_635)))

#[program]
extern recv1_27s_636 :
   {b1_637 : bool_4} ->
     {b2_638 : bool_4} ->
       {A_639 : Types_636} ->
         {B_640 : A_639 -> proto_18} ->
          {(eq_1??_28 ?_32[0;0] ((xor_8) b1_637 b2_638) true_4)} ->
            ((ch_22) b1_637 ((act1_20??_29) b2_638 ?_33[0;0] B_640)) ->
              IO (exists1_8??_30,??_31
                   ?_35[0;0]
                   function _644 : A_639 -> ?_34[0;0]
                   | x_646 => ((ch_22) b1_637 ((B_640) x_646)))

#[program]
extern fork_28 :
   {b_647 : bool_4} ->
     {P_648 : proto_18} ->
      ((ch_22) b_647 P_648) -o IO unit_3 ->
        IO ((ch_22) ((not_5) b_647) P_648)

#[program]
def split_29t_651 :
  (list_6??_57,t_651 nat_5) ->
    ((prod1_4??_60,??_61)
      (list_6??_58,t_651 nat_5) (list_6??_59,t_651 nat_5))
:=
  function split_653 :
    (list_6??_32,t_651 nat_5) ->
      ((prod1_4??_35,??_36)
        (list_6??_33,t_651 nat_5) (list_6??_34,t_651 nat_5))
  | nil_8 =>
    (ex1_11??_41,??_42
      ?_38[0;0] ?_39[0;0] (nil_8??_37,??_38 ?_36[0;0])
      (nil_8??_39,??_40 ?_37[0;0]))
  | (cons_9 x_655 nil_8) =>
    (ex1_11??_49,??_50
      ?_43[0;0] ?_44[0;0]
      (cons_9??_45,??_46
        ?_41[0;0] x_655 (nil_8??_43,??_44 ?_40[0;0]))
      (nil_8??_47,??_48 ?_42[0;0]))
  | (cons_9 x_656 (cons_9 y_657 zs_658)) =>
    match ((split_653) zs_658) in ?_50[0;0] -o ?_49[0;0] with
    | (ex1_11 xs_660 ys_661) =>
      (ex1_11??_55,??_56
        ?_47[0;0] ?_48[0;0] (cons_9??_51,??_52 ?_45[0;0] x_656 xs_660)
        (cons_9??_53,??_54 ?_46[0;0] y_657 ys_661))

#[program]
def merge_30t_662 :
  (list_6??_73,t_662 nat_5) ->
    (list_6??_74,t_662 nat_5) -o (list_6??_75,t_662 nat_5)
:=
  function merge_665 :
    (list_6??_62,t_662 nat_5) ->
      (list_6??_63,t_662 nat_5) -o (list_6??_64,t_662 nat_5)
  | nil_8 ys_668 => ys_668
  | xs_669 nil_8 => xs_669
  | (cons_9 x_670 xs_671) (cons_9 y_672 ys_673) =>
    match ((lte_9) x_670 y_672) in ?_51[0;0] -o ?_52[0;0] with
    | true_4 =>
      (cons_9??_67,??_68
        ?_54[0;0] x_670
        ((merge_665) xs_671 (cons_9??_65,??_66 ?_53[0;0] y_672 ys_673)))
    | false_5 =>
      (cons_9??_71,??_72
        ?_56[0;0] y_672
        ((merge_665) (cons_9??_69,??_70 ?_55[0;0] x_670 xs_671) ys_673))

#[program]
def msort_31t_675 :
  (list_6??_86,t_675 nat_5) -> (list_6??_87,t_675 nat_5)
:=
  function msort_677 :
    (list_6??_76,t_675 nat_5) -> (list_6??_77,t_675 nat_5)
  | nil_8 => (nil_8??_78,??_79 ?_57[0;0])
  | (cons_9 z_679 nil_8) =>
    (cons_9??_82,??_83
      ?_59[0;0] z_679 (nil_8??_80,??_81 ?_58[0;0]))
  | zs_680 =>
    match ((split_29??_84) zs_680) in ?_61[0;0] -o ?_60[0;0] with
    | (ex1_11 xs_682 ys_683) =>
      ((merge_30??_85) ((msort_677) xs_682) ((msort_677) ys_683))

#[logical]
def cmsort_ch_32t_684 : (list_6??_92,t_684 nat_5) -> L :=
  function cmsort_ch_686 : (list_6??_88,t_684 nat_5) -> L
  | xs_688 =>
    ((ch_22)
      true_4
      ((act1_20??_91)
        true_4 ?_64[0;0]
        function _689 :
          (sing_2??_90 ?_62[0;0] ((msort_31??_89) xs_688)) ->
            ?_63[0;0]
        | _691 => endp_21))

#[program]
def cmsort_worker_33t_692 :
  nat_5 ->
     (zs_694 : (list_6??_137,t_692 nat_5)) ->
      ((cmsort_ch_32t_692) zs_694) -o IO unit_3
:=
  function cmsort_worker_696 :
    nat_5 ->
       (zs_698 : (list_6??_93,t_692 nat_5)) ->
        ((cmsort_ch_32t_692) zs_698) -o IO unit_3
  | zero_6 zs_700 c_701 =>
    let* c_702 :=
      ((send1_25??_97)
        ?_71[0;0] ?_70[0;0] ?_69[0;0] ?_68[0;0]
        (refl_1??_94 ?_65[0;0] ?_66[0;0]) c_701
        (just_2??_96 ?_67[0;0] ((msort_31??_95) zs_700)))
    in ((close_23) ?_72[0;0] c_702)
  | (succ_7 n_703) nil_8 c_704 =>
    let* c_705 :=
      ((send1_25??_102)
        ?_80[0;0] ?_79[0;0] ?_78[0;0] ?_77[0;0]
        (refl_1??_98 ?_73[0;0] ?_74[0;0]) c_704
        (just_2??_101 ?_76[0;0] (nil_8??_99,??_100 ?_75[0;0])))
    in ((close_23) ?_81[0;0] c_705)
  | (succ_7 n_706) (cons_9 z_707 nil_8) c_708 =>
    let* c_709 :=
      ((send1_25??_109)
        ?_90[0;0] ?_89[0;0] ?_88[0;0] ?_87[0;0]
        (refl_1??_103 ?_82[0;0] ?_83[0;0]) c_708
        (just_2??_108
          ?_86[0;0]
          (cons_9??_106,??_107
            ?_85[0;0] z_707 (nil_8??_104,??_105 ?_84[0;0]))))
    in ((close_23) ?_91[0;0] c_709)
  | (succ_7 n_710) zs_711 c_712 =>
    match ((split_29??_110) zs_711),
    (refl_1??_111 ?_92[0;0] ?_93[0;0]) in
       (h1_713 : ?_94[0;0]) -o
        {(eq_1??_119
           ?_99[0;0]
           match h1_713 in ?_96[0;0] -o ?_95[0;0] with
           | (ex1_11 xs_716 ys_717) =>
             ((merge_30??_114)
               ((msort_31??_112) xs_716)
               ((msort_31??_113) ys_717))
           match ((split_29??_115) zs_711) in ?_98[0;0] -o ?_97[0;0]
           with
           | (ex1_11 xs_719 ys_720) =>
             ((merge_30??_118)
               ((msort_31??_116) xs_719)
               ((msort_31??_117) ys_720)))} -o
          ?_100[0;0]
    with
    | (ex1_11 xs0_721 ys0_722), pf_723 =>
      let* r1_724 :=
        ((fork_28)
          ?_104[0;0] ?_103[0;0]
          function _725 : ?_101[0;0] -o ?_102[0;0]
          | c1_727 => ((cmsort_worker_696) n_710 xs0_721 c1_727))
      in
      let* r2_728 :=
        ((fork_28)
          ?_108[0;0] ?_107[0;0]
          function _729 : ?_105[0;0] -o ?_106[0;0]
          | c2_731 => ((cmsort_worker_696) n_710 ys0_722 c2_731))
      in
      let* _732 :=
        ((recv1_27??_121)
          ?_114[0;0] ?_113[0;0] ?_112[0;0] ?_111[0;0]
          (refl_1??_120 ?_109[0;0] ?_110[0;0]) r1_724)
      in
      match _732 in ?_145[0;0] -o ?_144[0;0] with
      | (ex1_11 xs1_734 c1_735) =>
        let* __736 := ((close_23) ?_115[0;0] c1_735) in
        let* _737 :=
          ((recv1_27??_123)
            ?_121[0;0] ?_120[0;0] ?_119[0;0] ?_118[0;0]
            (refl_1??_122 ?_116[0;0] ?_117[0;0]) r2_728)
        in
        match _737 in ?_143[0;0] -o ?_142[0;0] with
        | (ex1_11 ys1_739 c2_740) =>
          let* __741 := ((close_23) ?_122[0;0] c2_740) in
          match xs1_734, ys1_739 in ?_123[0;0] -o ?_124[0;0] -o ?_125[0;0]
          with
          | (just_2 xs1_744), (just_2 ys1_745) =>
            let zs1_746 :=
              ((just_2??_125
                 ?_126[0;0] ((merge_30??_124) xs1_744 ys1_745))
                : (sing_2??_129
                    ?_127[0;0]
                    ((merge_30??_128)
                      ((msort_31??_126) xs0_721)
                      ((msort_31??_127) ys0_722))))
            in
            let zs1_747 :=
              (((rwl_1??_131,??_132)
                 ?_133[0;0] ?_132[0;0] ?_131[0;0]
                 function _748 : ?_128[0;0] -> ?_129[0;0]
                 | x_750 => (sing_2??_130 ?_130[0;0] x_750) pf_723
                 zs1_746)
                : (sing_2??_134
                    ?_134[0;0] ((msort_31??_133) zs_711)))
            in
            let* c_751 :=
              ((send1_25??_136)
                ?_140[0;0] ?_139[0;0] ?_138[0;0] ?_137[0;0]
                (refl_1??_135 ?_135[0;0] ?_136[0;0]) c_712 zs1_747)
            in let* __752 := ((close_23) ?_141[0;0] c_751) in return tt_3

-----------------------------------------

#[logical]
inductive eq_1s_19036 (A_19037 : Types_19036) (m_19038 : A_19037):
  A_19037 -> U
where
| refl_1 : (eq_1s_19036 A_19037 m_19038 m_19038)

#[program]
def rwl_1s_19040,r_19041 :
   {A_19042 : Types_19040} ->
     {m_19043 : A_19042} ->
       {n_19044 : A_19042} ->
         {B_19045 : A_19042 -> Typer_19041} ->
          {(eq_1s_19040 A_19042 m_19043 n_19044)} ->
            ((B_19045) m_19043) -> ((B_19045) n_19044)
:=
  function rwl_19049 :
     {A_19050 : Types_19040} ->
       {m_19051 : A_19050} ->
         {n_19052 : A_19050} ->
           {B_19053 : A_19050 -> Typer_19041} ->
            {(eq_1s_19040 A_19050 m_19051 n_19052)} ->
              ((B_19053) m_19051) -> ((B_19053) n_19052)
  | A_19057 m_19058 n_19059 B_19060 refl_1 __19061 => __19061

#[program]
def rwr_2s_19062,r_19063 :
   {A_19064 : Types_19062} ->
     {m_19065 : A_19064} ->
       {n_19066 : A_19064} ->
         {B_19067 : A_19064 -> Typer_19063} ->
          {(eq_1s_19062 A_19064 m_19065 n_19066)} ->
            ((B_19067) n_19066) -> ((B_19067) m_19065)
:=
  function rwr_19071 :
     {A_19072 : Types_19062} ->
       {m_19073 : A_19072} ->
         {n_19074 : A_19072} ->
           {B_19075 : A_19072 -> Typer_19063} ->
            {(eq_1s_19062 A_19072 m_19073 n_19074)} ->
              ((B_19075) n_19074) -> ((B_19075) m_19073)
  | A_19079 m_19080 n_19081 B_19082 refl_1 __19083 => __19083

#[program]
inductive sing_2s_19084 (A_19085 : Types_19084):
  A_19085 -> Types_19084
where
| just_2 (m_19087 : A_19085) : (sing_2s_19084 A_19085 m_19087)

#[program]
inductive unit_3 : U where
| tt_3 : unit_3

#[program]
inductive bool_4 : U where
| true_4 : bool_4
| false_5 : bool_4

#[program]
inductive nat_5 : U where
| zero_6 : nat_5
| succ_7 (n_19088 : nat_5) : nat_5

#[program]
inductive list_6s_19089,t_19090 (A_19091 : Types_19089):
  Typet_19090
where
| nil_8 : (list_6s_19089,t_19090 A_19091)
| cons_9
    (hd_19092 : A_19091) (tl_19093 : (list_6s_19089,t_19090 A_19091))
    : (list_6s_19089,t_19090 A_19091)

#[program]
inductive exists0_7s_19094,r_19095 (A_19096 : Types_19094) (B_19097 : 
A_19096 -> Typer_19095): L where
| ex0_10
    {m_19099 : A_19096} (n_19100 : ((B_19097) m_19099))
    : (exists0_7s_19094,r_19095 A_19096 B_19097)

#[program]
inductive exists1_8s_19101,r_19102 (A_19103 : Types_19101) (B_19104 : 
A_19103 -> Typer_19102): L where
| ex1_11
    (m_19106 : A_19103) (n_19107 : ((B_19104) m_19106))
    : (exists1_8s_19101,r_19102 A_19103 B_19104)

#[logical]
def prod0_3s_19108,r_19109 :
  Types_19108 -> Typer_19109 -> L
:=
  function prod0_19112 : Types_19108 -> Typer_19109 -> L
  | A_19115 B_19116 =>
    (exists0_7s_19108,r_19109
      A_19115
      function _19117 : A_19115 -> Typer_19109
      | __19119 => B_19116)

#[logical]
def prod1_4s_19120,r_19121 :
  Types_19120 -> Typer_19121 -> L
:=
  function prod1_19124 : Types_19120 -> Typer_19121 -> L
  | A_19127 B_19128 =>
    (exists1_8s_19120,r_19121
      A_19127
      function _19129 : A_19127 -> Typer_19121
      | __19131 => B_19128)

#[program]
def not_5 : bool_4 -> bool_4 :=
  function not_19133 : bool_4 -> bool_4
  | true_4 => false_5
  | false_5 => true_4

#[program]
def and_6 : bool_4 -> bool_4 -> bool_4 :=
  function and_19137 : bool_4 -> bool_4 -> bool_4
  | true_4 true_4 => true_4
  | true_4 false_5 => false_5
  | false_5 __19140 => false_5

#[program]
def or_7 : bool_4 -> bool_4 -> bool_4 :=
  function or_19143 : bool_4 -> bool_4 -> bool_4
  | true_4 __19146 => true_4
  | false_5 true_4 => true_4
  | false_5 false_5 => false_5

#[program]
def xor_8 : bool_4 -> bool_4 -o bool_4 :=
  function xor_19149 : bool_4 -> bool_4 -o bool_4
  | true_4 true_4 => false_5
  | true_4 false_5 => true_4
  | false_5 true_4 => true_4
  | false_5 false_5 => false_5

#[program]
def lte_9 : nat_5 -> nat_5 -> bool_4 :=
  function lte_19154 : nat_5 -> nat_5 -> bool_4
  | zero_6 __19157 => true_4
  | (succ_7 n_19158) zero_6 => false_5
  | (succ_7 n_19159) (succ_7 n_19160) => ((lte_19154) n_19159 n_19160)

#[program]
def lt_10 : nat_5 -> nat_5 -> bool_4 :=
  function lt_19163 : nat_5 -> nat_5 -> bool_4
  | x_19166 y_19167 => ((lte_9) (succ_7 x_19166) y_19167)

#[program]
def pred_11 : nat_5 -> nat_5 :=
  function pred_19169 : nat_5 -> nat_5
  | zero_6 => zero_6
  | (succ_7 n_19171) => n_19171

#[program]
def add_12 : nat_5 -> nat_5 -> nat_5 :=
  function add_19174 : nat_5 -> nat_5 -> nat_5
  | zero_6 __19177 => __19177
  | (succ_7 n_19178) __19179 => (succ_7 ((add_19174) n_19178 __19179))

#[program]
def sub_13 : nat_5 -> nat_5 -> nat_5 :=
  function sub_19182 : nat_5 -> nat_5 -> nat_5
  | __19185 zero_6 => __19185
  | __19186 (succ_7 n_19187) => ((sub_19182) ((pred_11) __19186) n_19187)

#[program]
def mul_14 : nat_5 -> nat_5 -> nat_5 :=
  function mul_19190 : nat_5 -> nat_5 -> nat_5
  | zero_6 __19193 => zero_6
  | (succ_7 n_19194) __19195 =>
    ((add_12) __19195 ((mul_19190) n_19194 __19195))

#[program]
def div_15 : nat_5 -> nat_5 -> nat_5 :=
  function div_19198 : nat_5 -> nat_5 -> nat_5
  | x_19201 y_19202 =>
    match ((lt_10) x_19201 y_19202) in bool_4 -o nat_5 with
    | true_4 => zero_6
    | false_5 =>
      let loop_19204 :=
        function loop_19205 : nat_5 -> nat_5 -> nat_5
        | x_19208 y_19209 =>
          match ((sub_13) x_19208 ((pred_11) y_19209)) in nat_5 -o nat_5 with
          | zero_6 => zero_6
          | (succ_7 n_19211) => (succ_7 ((loop_19205) n_19211 y_19209))
      in ((loop_19204) x_19201 y_19202)

#[program]
def rem_16 : nat_5 -> nat_5 -> nat_5 :=
  function rem_19214 : nat_5 -> nat_5 -> nat_5
  | x_19217 y_19218 =>
    ((sub_13) x_19217 ((mul_14) ((div_15) x_19217 y_19218) y_19218))

#[program]
def pow_17 : nat_5 -> nat_5 -> nat_5 :=
  function pow_19221 : nat_5 -> nat_5 -> nat_5
  | __19224 zero_6 => (succ_7 zero_6)
  | __19225 (succ_7 n_19226) =>
    ((mul_14) __19225 ((pow_19221) __19225 n_19226))

#[logical]
extern proto_18 : U

#[logical]
extern act0_19s_19227 :
  bool_4 ->
     (A_19229 : Types_19227) -> A_19229 -> proto_18 -> proto_18

#[logical]
extern act1_20s_19232 :
  bool_4 ->
     (A_19234 : Types_19232) -> A_19234 -> proto_18 -> proto_18

#[logical]
extern endp_21 : proto_18

#[logical]
extern ch_22 : bool_4 -> proto_18 -> L

#[program]
extern close_23 :
   {b_19239 : bool_4} -> ((ch_22) b_19239 endp_21) -> IO unit_3

#[program]
extern send0_24s_19241 :
   {b1_19242 : bool_4} ->
     {b2_19243 : bool_4} ->
       {A_19244 : Types_19241} ->
         {B_19245 : A_19244 -> proto_18} ->
          {(eq_1U bool_4 ((xor_8) b1_19242 b2_19243) false_5)} ->
            ((ch_22)
              b1_19242 ((act0_19s_19241) b2_19243 A_19244 B_19245)) ->
               {x_19249 : A_19244} -o
                IO ((ch_22) b1_19242 ((B_19245) x_19249))

#[program]
extern send1_25s_19250 :
   {b1_19251 : bool_4} ->
     {b2_19252 : bool_4} ->
       {A_19253 : Types_19250} ->
         {B_19254 : A_19253 -> proto_18} ->
          {(eq_1U bool_4 ((xor_8) b1_19251 b2_19252) false_5)} ->
            ((ch_22)
              b1_19251 ((act1_20s_19250) b2_19252 A_19253 B_19254)) ->
               (x_19258 : A_19253) -o
                IO ((ch_22) b1_19251 ((B_19254) x_19258))

#[program]
extern recv0_26s_19259 :
   {b1_19260 : bool_4} ->
     {b2_19261 : bool_4} ->
       {A_19262 : Types_19259} ->
         {B_19263 : A_19262 -> proto_18} ->
          {(eq_1U bool_4 ((xor_8) b1_19260 b2_19261) true_4)} ->
            ((ch_22)
              b1_19260 ((act0_19s_19259) b2_19261 A_19262 B_19263)) ->
              IO (exists0_7s_19259,L
                   A_19262
                   function _19267 : A_19262 -> L
                   | __19269 => ((ch_22) b1_19260 ((B_19263) __19269)))

#[program]
extern recv1_27s_19270 :
   {b1_19271 : bool_4} ->
     {b2_19272 : bool_4} ->
       {A_19273 : Types_19270} ->
         {B_19274 : A_19273 -> proto_18} ->
          {(eq_1U bool_4 ((xor_8) b1_19271 b2_19272) true_4)} ->
            ((ch_22)
              b1_19271 ((act1_20s_19270) b2_19272 A_19273 B_19274)) ->
              IO (exists1_8s_19270,L
                   A_19273
                   function _19278 : A_19273 -> L
                   | __19280 => ((ch_22) b1_19271 ((B_19274) __19280)))

#[program]
extern fork_28 :
   {b_19281 : bool_4} ->
     {P_19282 : proto_18} ->
      ((ch_22) b_19281 P_19282) -o IO unit_3 ->
        IO ((ch_22) ((not_5) b_19281) P_19282)

#[program]
def split_29t_19285 :
  (list_6U,t_19285 nat_5) ->
    ((prod1_4t_19285,t_19285)
      (list_6U,t_19285 nat_5) (list_6U,t_19285 nat_5))
:=
  function split_19287 :
    (list_6U,t_19285 nat_5) ->
      ((prod1_4t_19285,t_19285)
        (list_6U,t_19285 nat_5) (list_6U,t_19285 nat_5))
  | nil_8 =>
    (ex1_11t_19285,t_19285
      (list_6U,t_19285 nat_5)
      function _19289 : (list_6U,t_19285 nat_5) -> Typet_19285
      | __19291 => (list_6U,t_19285 nat_5) (nil_8U,t_19285 nat_5)
      (nil_8U,t_19285 nat_5))
  | (cons_9 hd_19292 nil_8) =>
    (ex1_11t_19285,t_19285
      (list_6U,t_19285 nat_5)
      function _19293 : (list_6U,t_19285 nat_5) -> Typet_19285
      | __19295 => (list_6U,t_19285 nat_5)
      (cons_9U,t_19285 nat_5 hd_19292 (nil_8U,t_19285 nat_5))
      (nil_8U,t_19285 nat_5))
  | (cons_9 hd_19296 (cons_9 hd_19297 tl_19298)) =>
    match ((split_19287) tl_19298) in
      ((prod1_4t_19285,t_19285)
        (list_6U,t_19285 nat_5) (list_6U,t_19285 nat_5)) -o
        ((prod1_4t_19285,t_19285)
          (list_6U,t_19285 nat_5) (list_6U,t_19285 nat_5))
    with
    | (ex1_11 m_19300 n_19301) =>
      (ex1_11t_19285,t_19285
        (list_6U,t_19285 nat_5)
        function _19302 : (list_6U,t_19285 nat_5) -> Typet_19285
        | __19304 => (list_6U,t_19285 nat_5)
        (cons_9U,t_19285 nat_5 hd_19296 m_19300)
        (cons_9U,t_19285 nat_5 hd_19297 n_19301))

#[program]
def merge_30t_19305 :
  (list_6U,t_19305 nat_5) ->
    (list_6U,t_19305 nat_5) -o (list_6U,t_19305 nat_5)
:=
  function merge_19308 :
    (list_6U,t_19305 nat_5) ->
      (list_6U,t_19305 nat_5) -o (list_6U,t_19305 nat_5)
  | nil_8 __19311 => __19311
  | (cons_9 hd_19312 tl_19313) nil_8 =>
    (cons_9U,t_19305 nat_5 hd_19312 tl_19313)
  | (cons_9 hd_19314 tl_19315) (cons_9 hd_19316 tl_19317) =>
    match ((lte_9) hd_19314 hd_19316) in
      bool_4 -o (list_6U,t_19305 nat_5)
    with
    | true_4 =>
      (cons_9U,t_19305
        nat_5 hd_19314
        ((merge_19308)
          tl_19315 (cons_9U,t_19305 nat_5 hd_19316 tl_19317)))
    | false_5 =>
      (cons_9U,t_19305
        nat_5 hd_19316
        ((merge_19308)
          (cons_9U,t_19305 nat_5 hd_19314 tl_19315) tl_19317))

#[program]
def msort_31t_19319 :
  (list_6U,t_19319 nat_5) -> (list_6U,t_19319 nat_5)
:=
  function msort_19321 :
    (list_6U,t_19319 nat_5) -> (list_6U,t_19319 nat_5)
  | nil_8 => (nil_8U,t_19319 nat_5)
  | (cons_9 hd_19323 nil_8) =>
    (cons_9U,t_19319 nat_5 hd_19323 (nil_8U,t_19319 nat_5))
  | (cons_9 hd_19324 (cons_9 hd_19325 tl_19326)) =>
    match ((split_29t_19319)
            (cons_9U,t_19319
              nat_5 hd_19324 (cons_9U,t_19319 nat_5 hd_19325 tl_19326))) in
      ((prod1_4t_19319,t_19319)
        (list_6U,t_19319 nat_5) (list_6U,t_19319 nat_5)) -o
        (list_6U,t_19319 nat_5)
    with
    | (ex1_11 m_19328 n_19329) =>
      ((merge_30t_19319)
        ((msort_19321) m_19328) ((msort_19321) n_19329))

#[logical]
def cmsort_ch_32t_19330 : (list_6U,t_19330 nat_5) -> L :=
  function cmsort_ch_19332 : (list_6U,t_19330 nat_5) -> L
  | xs_19334 =>
    ((ch_22)
      true_4
      ((act1_20t_19330)
        true_4
        (sing_2t_19330
          (list_6U,t_19330 nat_5) ((msort_31t_19330) xs_19334))
        function _19335 :
          (sing_2t_19330
            (list_6U,t_19330 nat_5) ((msort_31t_19330) xs_19334)) ->
            proto_18
        | __19337 => endp_21))

#[program]
def cmsort_worker_33t_19338 :
  nat_5 ->
     (zs_19340 : (list_6U,t_19338 nat_5)) ->
      ((cmsort_ch_32t_19338) zs_19340) -o IO unit_3
:=
  function cmsort_worker_19342 :
    nat_5 ->
       (zs_19344 : (list_6U,t_19338 nat_5)) ->
        ((cmsort_ch_32t_19338) zs_19344) -o IO unit_3
  | zero_6 zs_19346 __19347 =>
    let* c_19348 :=
      ((send1_25t_19338)
        true_4 true_4
        (sing_2t_19338
          (list_6U,t_19338 nat_5) ((msort_31t_19338) zs_19346))
        function _19349 :
          (sing_2t_19338
            (list_6U,t_19338 nat_5) ((msort_31t_19338) zs_19346)) ->
            proto_18
        | __19351 => endp_21 (refl_1U bool_4 ((xor_8) true_4 true_4))
        __19347
        (just_2t_19338
          (list_6U,t_19338 nat_5) ((msort_31t_19338) zs_19346)))
    in ((close_23) true_4 c_19348)
  | (succ_7 n_19352) nil_8 __19353 =>
    let* c_19354 :=
      ((send1_25t_19338)
        true_4 true_4
        (sing_2t_19338
          (list_6U,t_19338 nat_5)
          ((msort_31t_19338) (nil_8U,t_19338 nat_5)))
        function _19355 :
          (sing_2t_19338
            (list_6U,t_19338 nat_5)
            ((msort_31t_19338) (nil_8U,t_19338 nat_5))) ->
            proto_18
        | __19357 => endp_21 (refl_1U bool_4 ((xor_8) true_4 true_4))
        __19353
        (just_2t_19338
          (list_6U,t_19338 nat_5) (nil_8U,t_19338 nat_5)))
    in ((close_23) true_4 c_19354)
  | (succ_7 n_19358) (cons_9 hd_19359 nil_8) __19360 =>
    let* c_19361 :=
      ((send1_25t_19338)
        true_4 true_4
        (sing_2t_19338
          (list_6U,t_19338 nat_5)
          ((msort_31t_19338)
            (cons_9U,t_19338
              nat_5 hd_19359 (nil_8U,t_19338 nat_5))))
        function _19362 :
          (sing_2t_19338
            (list_6U,t_19338 nat_5)
            ((msort_31t_19338)
              (cons_9U,t_19338
                nat_5 hd_19359 (nil_8U,t_19338 nat_5)))) ->
            proto_18
        | __19364 => endp_21 (refl_1U bool_4 ((xor_8) true_4 true_4))
        __19360
        (just_2t_19338
          (list_6U,t_19338 nat_5)
          (cons_9U,t_19338 nat_5 hd_19359 (nil_8U,t_19338 nat_5))))
    in ((close_23) true_4 c_19361)
  | (succ_7 n_19365) (cons_9 hd_19366 (cons_9 hd_19367 tl_19368)) __19369 =>
    match ((split_29t_19338)
            (cons_9U,t_19338
              nat_5 hd_19366 (cons_9U,t_19338 nat_5 hd_19367 tl_19368))),
    (refl_1t_19338
      (list_6U,t_19338 nat_5)
      match ((split_29t_19338)
              (cons_9U,t_19338
                nat_5 hd_19366
                (cons_9U,t_19338 nat_5 hd_19367 tl_19368))) in
        ((prod1_4t_19338,t_19338)
          (list_6U,t_19338 nat_5) (list_6U,t_19338 nat_5)) -o
          (list_6U,t_19338 nat_5)
      with
      | (ex1_11 m_19371 n_19372) =>
        ((merge_30t_19338)
          ((msort_31t_19338) m_19371) ((msort_31t_19338) n_19372))) in
       (h1_19373 :
        ((prod1_4t_19338,t_19338)
          (list_6U,t_19338 nat_5) (list_6U,t_19338 nat_5))) -o
        {(eq_1t_19338
           (list_6U,t_19338 nat_5)
           match h1_19373 in
             ((prod1_4t_19338,t_19338)
               (list_6U,t_19338 nat_5) (list_6U,t_19338 nat_5)) -o
               (list_6U,t_19338 nat_5)
           with
           | (ex1_11 m_19376 n_19377) =>
             ((merge_30t_19338)
               ((msort_31t_19338) m_19376)
               ((msort_31t_19338) n_19377))
           match ((split_29t_19338)
                   (cons_9U,t_19338
                     nat_5 hd_19366
                     (cons_9U,t_19338 nat_5 hd_19367 tl_19368))) in
             ((prod1_4t_19338,t_19338)
               (list_6U,t_19338 nat_5) (list_6U,t_19338 nat_5)) -o
               (list_6U,t_19338 nat_5)
           with
           | (ex1_11 m_19379 n_19380) =>
             ((merge_30t_19338)
               ((msort_31t_19338) m_19379)
               ((msort_31t_19338) n_19380)))} -o
          IO unit_3
    with
    | (ex1_11 m_19381 n_19382), __19383 =>
      let* r1_19384 :=
        ((fork_28)
          true_4
          ((act1_20t_19338)
            true_4
            (sing_2t_19338
              (list_6U,t_19338 nat_5) ((msort_31t_19338) m_19381))
            function _19385 :
              (sing_2t_19338
                (list_6U,t_19338 nat_5)
                ((msort_31t_19338) m_19381)) -> proto_18
            | __19387 => endp_21)
          function _19388 :
            ((ch_22)
              true_4
              ((act1_20t_19338)
                true_4
                (sing_2t_19338
                  (list_6U,t_19338 nat_5)
                  ((msort_31t_19338) m_19381))
                function _19390 :
                  (sing_2t_19338
                    (list_6U,t_19338 nat_5)
                    ((msort_31t_19338) m_19381)) -> proto_18
                | __19392 => endp_21)) -o
              IO unit_3
          | __19393 => ((cmsort_worker_19342) n_19365 m_19381 __19393))
      in
      let* r2_19394 :=
        ((fork_28)
          true_4
          ((act1_20t_19338)
            true_4
            (sing_2t_19338
              (list_6U,t_19338 nat_5) ((msort_31t_19338) n_19382))
            function _19395 :
              (sing_2t_19338
                (list_6U,t_19338 nat_5)
                ((msort_31t_19338) n_19382)) -> proto_18
            | __19397 => endp_21)
          function _19398 :
            ((ch_22)
              true_4
              ((act1_20t_19338)
                true_4
                (sing_2t_19338
                  (list_6U,t_19338 nat_5)
                  ((msort_31t_19338) n_19382))
                function _19400 :
                  (sing_2t_19338
                    (list_6U,t_19338 nat_5)
                    ((msort_31t_19338) n_19382)) -> proto_18
                | __19402 => endp_21)) -o
              IO unit_3
          | __19403 => ((cmsort_worker_19342) n_19365 n_19382 __19403))
      in
      let* _19404 :=
        ((recv1_27t_19338)
          ((not_5) true_4) true_4
          (sing_2t_19338
            (list_6U,t_19338 nat_5) ((msort_31t_19338) m_19381))
          function _19405 :
            (sing_2t_19338
              (list_6U,t_19338 nat_5) ((msort_31t_19338) m_19381)) ->
              proto_18
          | __19407 => endp_21
          (refl_1U bool_4 ((xor_8) ((not_5) true_4) true_4)) r1_19384)
      in
      match _19404 in
        (exists1_8t_19338,L
          (sing_2t_19338
            (list_6U,t_19338 nat_5) ((msort_31t_19338) m_19381))
          function _19409 :
            (sing_2t_19338
              (list_6U,t_19338 nat_5) ((msort_31t_19338) m_19381)) ->
              L
          | __19411 =>
            ((ch_22)
              ((not_5) true_4)
              ((function _19412 :
                  (sing_2t_19338
                    (list_6U,t_19338 nat_5)
                    ((msort_31t_19338) m_19381)) -> proto_18
                | __19414 => endp_21) __19411))) -o
          IO unit_3
      with
      | (ex1_11 m_19415 n_19416) =>
        let* __19417 := ((close_23) ((not_5) true_4) n_19416) in
        let* _19418 :=
          ((recv1_27t_19338)
            ((not_5) true_4) true_4
            (sing_2t_19338
              (list_6U,t_19338 nat_5) ((msort_31t_19338) n_19382))
            function _19419 :
              (sing_2t_19338
                (list_6U,t_19338 nat_5)
                ((msort_31t_19338) n_19382)) -> proto_18
            | __19421 => endp_21
            (refl_1U bool_4 ((xor_8) ((not_5) true_4) true_4)) r2_19394)
        in
        match _19418 in
          (exists1_8t_19338,L
            (sing_2t_19338
              (list_6U,t_19338 nat_5) ((msort_31t_19338) n_19382))
            function _19423 :
              (sing_2t_19338
                (list_6U,t_19338 nat_5)
                ((msort_31t_19338) n_19382)) -> L
            | __19425 =>
              ((ch_22)
                ((not_5) true_4)
                ((function _19426 :
                    (sing_2t_19338
                      (list_6U,t_19338 nat_5)
                      ((msort_31t_19338) n_19382)) -> proto_18
                  | __19428 => endp_21) __19425))) -o
            IO unit_3
        with
        | (ex1_11 m_19429 n_19430) =>
          let* __19431 := ((close_23) ((not_5) true_4) n_19430) in
          match m_19415, m_19429 in
            (sing_2t_19338
              (list_6U,t_19338 nat_5) ((msort_31t_19338) m_19381)) -o
              (sing_2t_19338
                (list_6U,t_19338 nat_5)
                ((msort_31t_19338) n_19382)) -o IO unit_3
          with
          | (just_2 m_19434), (just_2 m_19435) =>
            let zs1_19436 :=
              ((just_2t_19338
                 (list_6U,t_19338 nat_5)
                 ((merge_30t_19338) m_19434 m_19435))
                : (sing_2t_19338
                    (list_6U,t_19338 nat_5)
                    ((merge_30t_19338)
                      ((msort_31t_19338) m_19381)
                      ((msort_31t_19338) n_19382))))
            in
            let zs1_19437 :=
              (((rwl_1t_19338,t_19338)
                 (list_6U,t_19338 nat_5)
                 ((merge_30t_19338)
                   ((msort_31t_19338) m_19381)
                   ((msort_31t_19338) n_19382))
                 match ((split_29t_19338)
                         (cons_9U,t_19338
                           nat_5 hd_19366
                           (cons_9U,t_19338 nat_5 hd_19367 tl_19368))) in
                   ((prod1_4t_19338,t_19338)
                     (list_6U,t_19338 nat_5)
                     (list_6U,t_19338 nat_5)) -o
                     (list_6U,t_19338 nat_5)
                 with
                 | (ex1_11 m_19439 n_19440) =>
                   ((merge_30t_19338)
                     ((msort_31t_19338) m_19439)
                     ((msort_31t_19338) n_19440))
                 function _19441 :
                   (list_6U,t_19338 nat_5) -> Typet_19338
                 | __19443 =>
                   (sing_2t_19338
                     (list_6U,t_19338 nat_5) __19443)
                 __19383 zs1_19436)
                : (sing_2t_19338
                    (list_6U,t_19338 nat_5)
                    ((msort_31t_19338)
                      (cons_9U,t_19338
                        nat_5 hd_19366
                        (cons_9U,t_19338 nat_5 hd_19367 tl_19368)))))
            in
            let* c_19444 :=
              ((send1_25t_19338)
                true_4 true_4
                (sing_2t_19338
                  (list_6U,t_19338 nat_5)
                  ((msort_31t_19338)
                    (cons_9U,t_19338
                      nat_5 hd_19366
                      (cons_9U,t_19338 nat_5 hd_19367 tl_19368))))
                function _19445 :
                  (sing_2t_19338
                    (list_6U,t_19338 nat_5)
                    ((msort_31t_19338)
                      (cons_9U,t_19338
                        nat_5 hd_19366
                        (cons_9U,t_19338 nat_5 hd_19367 tl_19368)))) ->
                    proto_18
                | __19447 => endp_21
                (refl_1U bool_4 ((xor_8) true_4 true_4)) __19369
                zs1_19437)
            in let* __19448 := ((close_23) true_4 c_19444) in return tt_3

-----------------------------------------

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
def rwlUU_37 :=
  fun rwl_31139 {A_31140} -> {m_31141} -> {n_31142} -> {B_31143} ->
  {__31144} -> (__31145) ->
    match {NULL} with
    | reflU_13  => __31145
    end

#[program]
def rwlUL_36 :=
  fun rwl_31146 {A_31147} -> {m_31148} -> {n_31149} -> {B_31150} ->
  {__31151} -> (__31152) ->
    match {NULL} with
    | reflU_13  => __31152
    end

#[program]
def rwlLU_35 :=
  fun rwl_31153 {A_31154} -> {m_31155} -> {n_31156} -> {B_31157} ->
  {__31158} -> (__31159) ->
    match {NULL} with
    | reflL_12  => __31159
    end

#[program]
def rwlLL_34 :=
  fun rwl_31160 {A_31161} -> {m_31162} -> {n_31163} -> {B_31164} ->
  {__31165} -> (__31166) ->
    match {NULL} with
    | reflL_12  => __31166
    end

#[program]
def rwrUU_41 :=
  fun rwr_31167 {A_31168} -> {m_31169} -> {n_31170} -> {B_31171} ->
  {__31172} -> (__31173) ->
    match {NULL} with
    | reflU_13  => __31173
    end

#[program]
def rwrUL_40 :=
  fun rwr_31174 {A_31175} -> {m_31176} -> {n_31177} -> {B_31178} ->
  {__31179} -> (__31180) ->
    match {NULL} with
    | reflU_13  => __31180
    end

#[program]
def rwrLU_39 :=
  fun rwr_31181 {A_31182} -> {m_31183} -> {n_31184} -> {B_31185} ->
  {__31186} -> (__31187) ->
    match {NULL} with
    | reflL_12  => __31187
    end

#[program]
def rwrLL_38 :=
  fun rwr_31188 {A_31189} -> {m_31190} -> {n_31191} -> {B_31192} ->
  {__31193} -> (__31194) ->
    match {NULL} with
    | reflL_12  => __31194
    end

#[program]
inductive singU_12 where
| justU_15 of layout[R]

#[program]
inductive singL_11 where
| justL_14 of layout[R]

#[program]
inductive unit_3 where
| tt_3 of layout[]

#[program]
inductive bool_4 where
| true_4 of layout[]
| false_5 of layout[]

#[program]
inductive nat_5 where
| zero_6 of layout[]
| succ_7 of layout[R]

#[program]
inductive listUU_16 where
| nilUU_22 of layout[]
| consUU_23 of layout[R, R]

#[program]
inductive listUL_15 where
| nilUL_20 of layout[]
| consUL_21 of layout[R, R]

#[program]
inductive listLU_14 where
| nilLU_18 of layout[]

#[program]
inductive listLL_13 where
| nilLL_16 of layout[]
| consLL_17 of layout[R, R]

#[program]
inductive exists0UU_20 where
| ex0UU_27 of layout[N, R]

#[program]
inductive exists0UL_19 where
| ex0UL_26 of layout[N, R]

#[program]
inductive exists0LU_18 where
| ex0LU_25 of layout[N, R]

#[program]
inductive exists0LL_17 where
| ex0LL_24 of layout[N, R]

#[program]
inductive exists1UU_24 where
| ex1UU_31 of layout[R, R]

#[program]
inductive exists1UL_23 where
| ex1UL_30 of layout[R, R]

#[program]
inductive exists1LU_22 where
| ex1LU_29 of layout[R, R]

#[program]
inductive exists1LL_21 where
| ex1LL_28 of layout[R, R]

#[logical]
def prod0UU_45 := NULL

#[logical]
def prod0UL_44 := NULL

#[logical]
def prod0LU_43 := NULL

#[logical]
def prod0LL_42 := NULL

#[logical]
def prod1UU_49 := NULL

#[logical]
def prod1UL_48 := NULL

#[logical]
def prod1LU_47 := NULL

#[logical]
def prod1LL_46 := NULL

#[program]
def not_5 :=
  fun not_31195 (__31196) ->
    match __31196 with
    | true_4  => false_5 | false_5  => true_4
    end

#[program]
def and_6 :=
  fun and_31197 (__31198) -> (__31199) ->
    match __31198 with
    | true_4  =>
      match __31199 with
      | true_4  => true_4 | false_5  => false_5
      end
    | false_5  => false_5
    end

#[program]
def or_7 :=
  fun or_31200 (__31201) -> (__31202) ->
    match __31201 with
    | true_4  => true_4
    | false_5  =>
      match __31202 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def xor_8 :=
  fun xor_31203 (__31204) -> (__31205) -o
    match __31204 with
    | true_4  =>
      match __31205 with
      | true_4  => false_5 | false_5  => true_4
      end
    | false_5  =>
      match __31205 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def lte_9 :=
  fun lte_31206 (__31207) -> (__31208) ->
    match __31207 with
    | zero_6  => true_4
    | succ_7 n_31209 =>
      match __31208 with
      | zero_6  => false_5 | succ_7 n_31210 => ((lte_31206) n_31209 n_31210)
      end
    end

#[program]
def lt_10 :=
  fun lt_31211 (x_31212) -> (y_31213) ->
    ((lte_9) (succ_7 x_31212) y_31213)

#[program]
def pred_11 :=
  fun pred_31214 (__31215) ->
    match __31215 with
    | zero_6  => zero_6 | succ_7 n_31216 => n_31216
    end

#[program]
def add_12 :=
  fun add_31217 (__31218) -> (__31219) ->
    match __31218 with
    | zero_6  => __31219
    | succ_7 n_31220 => (succ_7 ((add_31217) n_31220 __31219))
    end

#[program]
def sub_13 :=
  fun sub_31221 (__31222) -> (__31223) ->
    match __31223 with
    | zero_6  => __31222
    | succ_7 n_31224 => ((sub_31221) ((pred_11) __31222) n_31224)
    end

#[program]
def mul_14 :=
  fun mul_31225 (__31226) -> (__31227) ->
    match __31226 with
    | zero_6  => zero_6
    | succ_7 n_31228 => ((add_12) __31227 ((mul_31225) n_31228 __31227))
    end

#[program]
def div_15 :=
  fun div_31229 (x_31230) -> (y_31231) ->
    match ((lt_10) x_31230 y_31231) with
    | true_4  => zero_6
    | false_5  =>
      let loop_31232 :=
        fun loop_31233 (x_31234) -> (y_31235) ->
          match ((sub_13) x_31234 ((pred_11) y_31235)) with
          | zero_6  => zero_6
          | succ_7 n_31236 => (succ_7 ((loop_31233) n_31236 y_31235))
          end
      in ((loop_31232) x_31230 y_31231)
    end

#[program]
def rem_16 :=
  fun rem_31237 (x_31238) -> (y_31239) ->
    ((sub_13) x_31238 ((mul_14) ((div_15) x_31238 y_31239) y_31239))

#[program]
def pow_17 :=
  fun pow_31240 (__31241) -> (__31242) ->
    match __31242 with
    | zero_6  => (succ_7 zero_6)
    | succ_7 n_31243 => ((mul_14) __31241 ((pow_31240) __31241 n_31243))
    end

#[logical]
extern proto_18

#[logical]
extern act0U_51

#[logical]
extern act0L_50

#[logical]
extern act1U_53

#[logical]
extern act1L_52

#[logical]
extern endp_21

#[logical]
extern ch_22

#[program]
extern close_23

#[program]
extern send0U_55

#[program]
extern send0L_54

#[program]
extern send1U_57

#[program]
extern send1L_56

#[program]
extern recv0U_59

#[program]
extern recv0L_58

#[program]
extern recv1U_61

#[program]
extern recv1L_60

#[program]
extern fork_28

#[program]
def splitU_63 :=
  fun split_31244 (__31245) ->
    match __31245 with
    | nilUU_22  => (ex1UU_31 nilUU_22 nilUU_22)
    | consUU_23 hd_31246 tl_31247 =>
      match tl_31247 with
      | nilUU_22  => (ex1UU_31 (consUU_23 hd_31246 nilUU_22) nilUU_22)
      | consUU_23 hd_31248 tl_31249 =>
        match ((split_31244) tl_31249) with
        | ex1UU_31 m_31250 n_31251 =>
          (ex1UU_31
            (consUU_23 hd_31246 m_31250) (consUU_23 hd_31248 n_31251))
        end
      end
    end

#[program]
def splitL_62 :=
  fun split_31252 (__31253) ->
    match __31253 with
    | nilUL_20  => (ex1LL_28 nilUL_20 nilUL_20)
    | consUL_21 hd_31254 tl_31255 =>
      match tl_31255 with
      | nilUL_20  => (ex1LL_28 (consUL_21 hd_31254 nilUL_20) nilUL_20)
      | consUL_21 hd_31256 tl_31257 =>
        match ((split_31252) tl_31257) with
        | ex1LL_28 m_31258 n_31259 =>
          (ex1LL_28
            (consUL_21 hd_31254 m_31258) (consUL_21 hd_31256 n_31259))
        end
      end
    end

#[program]
def mergeU_65 :=
  fun merge_31260 (__31261) -> (__31262) -o
    match __31261 with
    | nilUU_22  => __31262
    | consUU_23 hd_31263 tl_31264 =>
      match __31262 with
      | nilUU_22  => (consUU_23 hd_31263 tl_31264)
      | consUU_23 hd_31265 tl_31266 =>
        match ((lte_9) hd_31263 hd_31265) with
        | true_4  =>
          (consUU_23
            hd_31263 ((merge_31260) tl_31264 (consUU_23 hd_31265 tl_31266)))
        | false_5  =>
          (consUU_23
            hd_31265 ((merge_31260) (consUU_23 hd_31263 tl_31264) tl_31266))
        end
      end
    end

#[program]
def mergeL_64 :=
  fun merge_31267 (__31268) -> (__31269) -o
    match __31268 with
    | nilUL_20  => __31269
    | consUL_21 hd_31270 tl_31271 =>
      match __31269 with
      | nilUL_20  => (consUL_21 hd_31270 tl_31271)
      | consUL_21 hd_31272 tl_31273 =>
        match ((lte_9) hd_31270 hd_31272) with
        | true_4  =>
          (consUL_21
            hd_31270 ((merge_31267) tl_31271 (consUL_21 hd_31272 tl_31273)))
        | false_5  =>
          (consUL_21
            hd_31272 ((merge_31267) (consUL_21 hd_31270 tl_31271) tl_31273))
        end
      end
    end

#[program]
def msortU_67 :=
  fun msort_31274 (__31275) ->
    match __31275 with
    | nilUU_22  => nilUU_22
    | consUU_23 hd_31276 tl_31277 =>
      match tl_31277 with
      | nilUU_22  => (consUU_23 hd_31276 nilUU_22)
      | consUU_23 hd_31278 tl_31279 =>
        match ((splitU_63)
                (consUU_23 hd_31276 (consUU_23 hd_31278 tl_31279))) with
        | ex1UU_31 m_31280 n_31281 =>
          ((mergeU_65) ((msort_31274) m_31280) ((msort_31274) n_31281))
        end
      end
    end

#[program]
def msortL_66 :=
  fun msort_31282 (__31283) ->
    match __31283 with
    | nilUL_20  => nilUL_20
    | consUL_21 hd_31284 tl_31285 =>
      match tl_31285 with
      | nilUL_20  => (consUL_21 hd_31284 nilUL_20)
      | consUL_21 hd_31286 tl_31287 =>
        match ((splitL_62)
                (consUL_21 hd_31284 (consUL_21 hd_31286 tl_31287))) with
        | ex1LL_28 m_31288 n_31289 =>
          ((mergeL_64) ((msort_31282) m_31288) ((msort_31282) n_31289))
        end
      end
    end

#[logical]
def cmsort_chU_69 := NULL

#[logical]
def cmsort_chL_68 := NULL

#[program]
def cmsort_workerU_71 :=
  fun cmsort_worker_31290 (__31291) -> (zs_31292) -> (__31293) -o
    match __31291 with
    | zero_6  =>
      let* c_31294 :=
        ((send1U_57)
          NULL NULL NULL NULL NULL __31293 (justU_15 ((msortU_67) zs_31292)))
      in ((close_23) NULL c_31294)
    | succ_7 n_31295 =>
      match zs_31292 with
      | nilUU_22  =>
        let* c_31296 :=
          ((send1U_57) NULL NULL NULL NULL NULL __31293 (justU_15 nilUU_22))
        in ((close_23) NULL c_31296)
      | consUU_23 hd_31297 tl_31298 =>
        match tl_31298 with
        | nilUU_22  =>
          let* c_31299 :=
            ((send1U_57)
              NULL NULL NULL NULL NULL __31293
              (justU_15 (consUU_23 hd_31297 nilUU_22)))
          in ((close_23) NULL c_31299)
        | consUU_23 hd_31300 tl_31301 =>
          match ((splitU_63)
                  (consUU_23 hd_31297 (consUU_23 hd_31300 tl_31301))) with
          | ex1UU_31 m_31302 n_31303 =>
            let* r1_31304 :=
              ((fork_28)
                NULL NULL
                fun _31305 (c1_31306) -o
                  ((cmsort_worker_31290) n_31295 m_31302 c1_31306))
            in
            let* r2_31307 :=
              ((fork_28)
                NULL NULL
                fun _31308 (c2_31309) -o
                  ((cmsort_worker_31290) n_31295 n_31303 c2_31309))
            in
            let* _31310 := ((recv1U_61) NULL NULL NULL NULL NULL r1_31304) in
            match _31310 with
            | ex1UL_30 m_31311 n_31312 =>
              let* __31313 := ((close_23) NULL n_31312) in
              let* _31314 := ((recv1U_61) NULL NULL NULL NULL NULL r2_31307)
              in
              match _31314 with
              | ex1UL_30 m_31315 n_31316 =>
                let* __31317 := ((close_23) NULL n_31316) in
                match m_31311 with
                | justU_15 m_31318 =>
                  match m_31315 with
                  | justU_15 m_31319 =>
                    let zs1_31320 := (justU_15 ((mergeU_65) m_31318 m_31319))
                    in
                    let zs1_31321 :=
                      ((rwlUU_37) NULL NULL NULL NULL NULL zs1_31320)
                    in
                    let* c_31322 :=
                      ((send1U_57)
                        NULL NULL NULL NULL NULL __31293 zs1_31321)
                    in
                    let* __31323 := ((close_23) NULL c_31322) in return tt_3
                  end
                end
              end
            end
          end
        end
      end
    end

#[program]
def cmsort_workerL_70 :=
  fun cmsort_worker_31324 (__31325) -> (zs_31326) -> (__31327) -o
    match __31325 with
    | zero_6  =>
      let* c_31328 :=
        ((send1L_56)
          NULL NULL NULL NULL NULL __31327 (justL_14 ((msortL_66) zs_31326)))
      in ((close_23) NULL c_31328)
    | succ_7 n_31329 =>
      match zs_31326 with
      | nilUL_20  =>
        let* c_31330 :=
          ((send1L_56) NULL NULL NULL NULL NULL __31327 (justL_14 nilUL_20))
        in ((close_23) NULL c_31330)
      | consUL_21 hd_31331 tl_31332 =>
        match tl_31332 with
        | nilUL_20  =>
          let* c_31333 :=
            ((send1L_56)
              NULL NULL NULL NULL NULL __31327
              (justL_14 (consUL_21 hd_31331 nilUL_20)))
          in ((close_23) NULL c_31333)
        | consUL_21 hd_31334 tl_31335 =>
          match ((splitL_62)
                  (consUL_21 hd_31331 (consUL_21 hd_31334 tl_31335))) with
          | ex1LL_28 m_31336 n_31337 =>
            let* r1_31338 :=
              ((fork_28)
                NULL NULL
                fun _31339 (c1_31340) -o
                  ((cmsort_worker_31324) n_31329 m_31336 c1_31340))
            in
            let* r2_31341 :=
              ((fork_28)
                NULL NULL
                fun _31342 (c2_31343) -o
                  ((cmsort_worker_31324) n_31329 n_31337 c2_31343))
            in
            let* _31344 := ((recv1L_60) NULL NULL NULL NULL NULL r1_31338) in
            match _31344 with
            | ex1LL_28 m_31345 n_31346 =>
              let* __31347 := ((close_23) NULL n_31346) in
              let* _31348 := ((recv1L_60) NULL NULL NULL NULL NULL r2_31341)
              in
              match _31348 with
              | ex1LL_28 m_31349 n_31350 =>
                let* __31351 := ((close_23) NULL n_31350) in
                match m_31345 with
                | justL_14 m_31352 =>
                  match m_31349 with
                  | justL_14 m_31353 =>
                    let zs1_31354 := (justL_14 ((mergeL_64) m_31352 m_31353))
                    in
                    let zs1_31355 :=
                      ((rwlLL_34) NULL NULL NULL NULL NULL zs1_31354)
                    in
                    let* c_31356 :=
                      ((send1L_56)
                        NULL NULL NULL NULL NULL __31327 zs1_31355)
                    in
                    let* __31357 := ((close_23) NULL c_31356) in return tt_3
                  end
                end
              end
            end
          end
        end
      end
    end

-----------------------------------------

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
def rwlUU_37 :=
  fun rwl_31577 {A_31578} -> {m_31579} -> {n_31580} -> {B_31581} ->
  {__31582} -> (__31583) ->
    __31583

#[program]
def rwlUL_36 :=
  fun rwl_31584 {A_31585} -> {m_31586} -> {n_31587} -> {B_31588} ->
  {__31589} -> (__31590) ->
    __31590

#[program]
def rwlLU_35 :=
  fun rwl_31591 {A_31592} -> {m_31593} -> {n_31594} -> {B_31595} ->
  {__31596} -> (__31597) ->
    __31597

#[program]
def rwlLL_34 :=
  fun rwl_31598 {A_31599} -> {m_31600} -> {n_31601} -> {B_31602} ->
  {__31603} -> (__31604) ->
    __31604

#[program]
def rwrUU_41 :=
  fun rwr_31605 {A_31606} -> {m_31607} -> {n_31608} -> {B_31609} ->
  {__31610} -> (__31611) ->
    __31611

#[program]
def rwrUL_40 :=
  fun rwr_31612 {A_31613} -> {m_31614} -> {n_31615} -> {B_31616} ->
  {__31617} -> (__31618) ->
    __31618

#[program]
def rwrLU_39 :=
  fun rwr_31619 {A_31620} -> {m_31621} -> {n_31622} -> {B_31623} ->
  {__31624} -> (__31625) ->
    __31625

#[program]
def rwrLL_38 :=
  fun rwr_31626 {A_31627} -> {m_31628} -> {n_31629} -> {B_31630} ->
  {__31631} -> (__31632) ->
    __31632

#[program]
inductive singU_12 where
| justU_15 of layout[R]

#[program]
inductive singL_11 where
| justL_14 of layout[R]

#[program]
inductive unit_3 where
| tt_3 of layout[]

#[program]
inductive bool_4 where
| true_4 of layout[]
| false_5 of layout[]

#[program]
inductive nat_5 where
| zero_6 of layout[]
| succ_7 of layout[R]

#[program]
inductive listUU_16 where
| nilUU_22 of layout[]
| consUU_23 of layout[R, R]

#[program]
inductive listUL_15 where
| nilUL_20 of layout[]
| consUL_21 of layout[R, R]

#[program]
inductive listLU_14 where
| nilLU_18 of layout[]

#[program]
inductive listLL_13 where
| nilLL_16 of layout[]
| consLL_17 of layout[R, R]

#[program]
inductive exists0UU_20 where
| ex0UU_27 of layout[N, R]

#[program]
inductive exists0UL_19 where
| ex0UL_26 of layout[N, R]

#[program]
inductive exists0LU_18 where
| ex0LU_25 of layout[N, R]

#[program]
inductive exists0LL_17 where
| ex0LL_24 of layout[N, R]

#[program]
inductive exists1UU_24 where
| ex1UU_31 of layout[R, R]

#[program]
inductive exists1UL_23 where
| ex1UL_30 of layout[R, R]

#[program]
inductive exists1LU_22 where
| ex1LU_29 of layout[R, R]

#[program]
inductive exists1LL_21 where
| ex1LL_28 of layout[R, R]

#[logical]
def prod0UU_45 := NULL

#[logical]
def prod0UL_44 := NULL

#[logical]
def prod0LU_43 := NULL

#[logical]
def prod0LL_42 := NULL

#[logical]
def prod1UU_49 := NULL

#[logical]
def prod1UL_48 := NULL

#[logical]
def prod1LU_47 := NULL

#[logical]
def prod1LL_46 := NULL

#[program]
def not_5 :=
  fun not_31633 (__31634) ->
    match __31634 with
    | true_4  => false_5 | false_5  => true_4
    end

#[program]
def and_6 :=
  fun and_31635 (__31636) -> (__31637) ->
    match __31636 with
    | true_4  =>
      match __31637 with
      | true_4  => true_4 | false_5  => false_5
      end
    | false_5  => false_5
    end

#[program]
def or_7 :=
  fun or_31638 (__31639) -> (__31640) ->
    match __31639 with
    | true_4  => true_4
    | false_5  =>
      match __31640 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def xor_8 :=
  fun xor_31641 (__31642) -> (__31643) -o
    match __31642 with
    | true_4  =>
      match __31643 with
      | true_4  => false_5 | false_5  => true_4
      end
    | false_5  =>
      match __31643 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def lte_9 :=
  fun lte_31644 (__31645) -> (__31646) ->
    match __31645 with
    | zero_6  => true_4
    | succ_7 n_31647 =>
      match __31646 with
      | zero_6  => false_5 | succ_7 n_31648 => ((lte_31644) n_31647 n_31648)
      end
    end

#[program]
def lt_10 :=
  fun lt_31649 (x_31650) -> (y_31651) ->
    ((lte_9) (succ_7 x_31650) y_31651)

#[program]
def pred_11 :=
  fun pred_31652 (__31653) ->
    match __31653 with
    | zero_6  => zero_6 | succ_7 n_31654 => n_31654
    end

#[program]
def add_12 :=
  fun add_31655 (__31656) -> (__31657) ->
    match __31656 with
    | zero_6  => __31657
    | succ_7 n_31658 => (succ_7 ((add_31655) n_31658 __31657))
    end

#[program]
def sub_13 :=
  fun sub_31659 (__31660) -> (__31661) ->
    match __31661 with
    | zero_6  => __31660
    | succ_7 n_31662 => ((sub_31659) ((pred_11) __31660) n_31662)
    end

#[program]
def mul_14 :=
  fun mul_31663 (__31664) -> (__31665) ->
    match __31664 with
    | zero_6  => zero_6
    | succ_7 n_31666 => ((add_12) __31665 ((mul_31663) n_31666 __31665))
    end

#[program]
def div_15 :=
  fun div_31667 (x_31668) -> (y_31669) ->
    match ((lt_10) x_31668 y_31669) with
    | true_4  => zero_6
    | false_5  =>
      let loop_31670 :=
        fun loop_31671 (x_31672) -> (y_31673) ->
          match ((sub_13) x_31672 ((pred_11) y_31673)) with
          | zero_6  => zero_6
          | succ_7 n_31674 => (succ_7 ((loop_31671) n_31674 y_31673))
          end
      in ((loop_31670) x_31668 y_31669)
    end

#[program]
def rem_16 :=
  fun rem_31675 (x_31676) -> (y_31677) ->
    ((sub_13) x_31676 ((mul_14) ((div_15) x_31676 y_31677) y_31677))

#[program]
def pow_17 :=
  fun pow_31678 (__31679) -> (__31680) ->
    match __31680 with
    | zero_6  => (succ_7 zero_6)
    | succ_7 n_31681 => ((mul_14) __31679 ((pow_31678) __31679 n_31681))
    end

#[logical]
extern proto_18

#[logical]
extern act0U_51

#[logical]
extern act0L_50

#[logical]
extern act1U_53

#[logical]
extern act1L_52

#[logical]
extern endp_21

#[logical]
extern ch_22

#[program]
extern close_23

#[program]
extern send0U_55

#[program]
extern send0L_54

#[program]
extern send1U_57

#[program]
extern send1L_56

#[program]
extern recv0U_59

#[program]
extern recv0L_58

#[program]
extern recv1U_61

#[program]
extern recv1L_60

#[program]
extern fork_28

#[program]
def splitU_63 :=
  fun split_31682 (__31683) ->
    match __31683 with
    | nilUU_22  => (ex1UU_31 nilUU_22 nilUU_22)
    | consUU_23 hd_31684 tl_31685 =>
      match tl_31685 with
      | nilUU_22  => (ex1UU_31 (consUU_23 hd_31684 nilUU_22) nilUU_22)
      | consUU_23 hd_31686 tl_31687 =>
        match ((split_31682) tl_31687) with
        | ex1UU_31 m_31688 n_31689 =>
          (ex1UU_31
            (consUU_23 hd_31684 m_31688) (consUU_23 hd_31686 n_31689))
        end
      end
    end

#[program]
def splitL_62 :=
  fun split_31690 (__31691) ->
    match __31691 with
    | nilUL_20  => (ex1LL_28 nilUL_20 nilUL_20)
    | consUL_21 hd_31692 tl_31693 =>
      match tl_31693 with
      | nilUL_20  => (ex1LL_28 (consUL_21 hd_31692 nilUL_20) nilUL_20)
      | consUL_21 hd_31694 tl_31695 =>
        match ((split_31690) tl_31695) with
        | ex1LL_28 m_31696 n_31697 =>
          (ex1LL_28
            (consUL_21 hd_31692 m_31696) (consUL_21 hd_31694 n_31697))
        end
      end
    end

#[program]
def mergeU_65 :=
  fun merge_31698 (__31699) -> (__31700) -o
    match __31699 with
    | nilUU_22  => __31700
    | consUU_23 hd_31701 tl_31702 =>
      match __31700 with
      | nilUU_22  => (consUU_23 hd_31701 tl_31702)
      | consUU_23 hd_31703 tl_31704 =>
        match ((lte_9) hd_31701 hd_31703) with
        | true_4  =>
          (consUU_23
            hd_31701 ((merge_31698) tl_31702 (consUU_23 hd_31703 tl_31704)))
        | false_5  =>
          (consUU_23
            hd_31703 ((merge_31698) (consUU_23 hd_31701 tl_31702) tl_31704))
        end
      end
    end

#[program]
def mergeL_64 :=
  fun merge_31705 (__31706) -> (__31707) -o
    match __31706 with
    | nilUL_20  => __31707
    | consUL_21 hd_31708 tl_31709 =>
      match __31707 with
      | nilUL_20  => (consUL_21 hd_31708 tl_31709)
      | consUL_21 hd_31710 tl_31711 =>
        match ((lte_9) hd_31708 hd_31710) with
        | true_4  =>
          (consUL_21
            hd_31708 ((merge_31705) tl_31709 (consUL_21 hd_31710 tl_31711)))
        | false_5  =>
          (consUL_21
            hd_31710 ((merge_31705) (consUL_21 hd_31708 tl_31709) tl_31711))
        end
      end
    end

#[program]
def msortU_67 :=
  fun msort_31712 (__31713) ->
    match __31713 with
    | nilUU_22  => nilUU_22
    | consUU_23 hd_31714 tl_31715 =>
      match tl_31715 with
      | nilUU_22  => (consUU_23 hd_31714 nilUU_22)
      | consUU_23 hd_31716 tl_31717 =>
        match ((splitU_63)
                (consUU_23 hd_31714 (consUU_23 hd_31716 tl_31717))) with
        | ex1UU_31 m_31718 n_31719 =>
          ((mergeU_65) ((msort_31712) m_31718) ((msort_31712) n_31719))
        end
      end
    end

#[program]
def msortL_66 :=
  fun msort_31720 (__31721) ->
    match __31721 with
    | nilUL_20  => nilUL_20
    | consUL_21 hd_31722 tl_31723 =>
      match tl_31723 with
      | nilUL_20  => (consUL_21 hd_31722 nilUL_20)
      | consUL_21 hd_31724 tl_31725 =>
        match ((splitL_62)
                (consUL_21 hd_31722 (consUL_21 hd_31724 tl_31725))) with
        | ex1LL_28 m_31726 n_31727 =>
          ((mergeL_64) ((msort_31720) m_31726) ((msort_31720) n_31727))
        end
      end
    end

#[logical]
def cmsort_chU_69 := NULL

#[logical]
def cmsort_chL_68 := NULL

#[program]
def cmsort_workerU_71 :=
  fun cmsort_worker_31728 (__31729) -> (zs_31730) -> (__31731) -o
    match __31729 with
    | zero_6  =>
      let* c_31732 :=
        ((send1U_57)
          NULL NULL NULL NULL NULL __31731 (justU_15 ((msortU_67) zs_31730)))
      in ((close_23) NULL c_31732)
    | succ_7 n_31733 =>
      match zs_31730 with
      | nilUU_22  =>
        let* c_31734 :=
          ((send1U_57) NULL NULL NULL NULL NULL __31731 (justU_15 nilUU_22))
        in ((close_23) NULL c_31734)
      | consUU_23 hd_31735 tl_31736 =>
        match tl_31736 with
        | nilUU_22  =>
          let* c_31737 :=
            ((send1U_57)
              NULL NULL NULL NULL NULL __31731
              (justU_15 (consUU_23 hd_31735 nilUU_22)))
          in ((close_23) NULL c_31737)
        | consUU_23 hd_31738 tl_31739 =>
          match ((splitU_63)
                  (consUU_23 hd_31735 (consUU_23 hd_31738 tl_31739))) with
          | ex1UU_31 m_31740 n_31741 =>
            let* r1_31742 :=
              ((fork_28)
                NULL NULL
                fun _31743 (c1_31744) -o
                  ((cmsort_worker_31728) n_31733 m_31740 c1_31744))
            in
            let* r2_31745 :=
              ((fork_28)
                NULL NULL
                fun _31746 (c2_31747) -o
                  ((cmsort_worker_31728) n_31733 n_31741 c2_31747))
            in
            let* _31748 := ((recv1U_61) NULL NULL NULL NULL NULL r1_31742) in
            match _31748 with
            | ex1UL_30 m_31749 n_31750 =>
              let* __31751 := ((close_23) NULL n_31750) in
              let* _31752 := ((recv1U_61) NULL NULL NULL NULL NULL r2_31745)
              in
              match _31752 with
              | ex1UL_30 m_31753 n_31754 =>
                let* __31755 := ((close_23) NULL n_31754) in
                match m_31749 with
                | justU_15 m_31756 =>
                  match m_31753 with
                  | justU_15 m_31757 =>
                    let zs1_31758 := (justU_15 ((mergeU_65) m_31756 m_31757))
                    in
                    let zs1_31759 :=
                      ((rwlUU_37) NULL NULL NULL NULL NULL zs1_31758)
                    in
                    let* c_31760 :=
                      ((send1U_57)
                        NULL NULL NULL NULL NULL __31731 zs1_31759)
                    in
                    let* __31761 := ((close_23) NULL c_31760) in return tt_3
                  end
                end
              end
            end
          end
        end
      end
    end

#[program]
def cmsort_workerL_70 :=
  fun cmsort_worker_31762 (__31763) -> (zs_31764) -> (__31765) -o
    match __31763 with
    | zero_6  =>
      let* c_31766 :=
        ((send1L_56)
          NULL NULL NULL NULL NULL __31765 (justL_14 ((msortL_66) zs_31764)))
      in ((close_23) NULL c_31766)
    | succ_7 n_31767 =>
      match zs_31764 with
      | nilUL_20  =>
        let* c_31768 :=
          ((send1L_56) NULL NULL NULL NULL NULL __31765 (justL_14 nilUL_20))
        in ((close_23) NULL c_31768)
      | consUL_21 hd_31769 tl_31770 =>
        match tl_31770 with
        | nilUL_20  =>
          let* c_31771 :=
            ((send1L_56)
              NULL NULL NULL NULL NULL __31765
              (justL_14 (consUL_21 hd_31769 nilUL_20)))
          in ((close_23) NULL c_31771)
        | consUL_21 hd_31772 tl_31773 =>
          match ((splitL_62)
                  (consUL_21 hd_31769 (consUL_21 hd_31772 tl_31773))) with
          | ex1LL_28 m_31774 n_31775 =>
            let* r1_31776 :=
              ((fork_28)
                NULL NULL
                fun _31777 (c1_31778) -o
                  ((cmsort_worker_31762) n_31767 m_31774 c1_31778))
            in
            let* r2_31779 :=
              ((fork_28)
                NULL NULL
                fun _31780 (c2_31781) -o
                  ((cmsort_worker_31762) n_31767 n_31775 c2_31781))
            in
            let* _31782 := ((recv1L_60) NULL NULL NULL NULL NULL r1_31776) in
            match _31782 with
            | ex1LL_28 m_31783 n_31784 =>
              let* __31785 := ((close_23) NULL n_31784) in
              let* _31786 := ((recv1L_60) NULL NULL NULL NULL NULL r2_31779)
              in
              match _31786 with
              | ex1LL_28 m_31787 n_31788 =>
                let* __31789 := ((close_23) NULL n_31788) in
                match m_31783 with
                | justL_14 m_31790 =>
                  match m_31787 with
                  | justL_14 m_31791 =>
                    let zs1_31792 := (justL_14 ((mergeL_64) m_31790 m_31791))
                    in
                    let zs1_31793 :=
                      ((rwlLL_34) NULL NULL NULL NULL NULL zs1_31792)
                    in
                    let* c_31794 :=
                      ((send1L_56)
                        NULL NULL NULL NULL NULL __31765 zs1_31793)
                    in
                    let* __31795 := ((close_23) NULL c_31794) in return tt_3
                  end
                end
              end
            end
          end
        end
      end
    end

-----------------------------------------

def rwlUU_37 :=
  fun rwl_32023 () -> () -> () -> () -> () -> (__32024) -> __32024

def rwlUL_36 :=
  fun rwl_32025 () -> () -> () -> () -> () -> (__32026) -> __32026

def rwlLU_35 :=
  fun rwl_32027 () -> () -> () -> () -> () -> (__32028) -> __32028

def rwlLL_34 :=
  fun rwl_32029 () -> () -> () -> () -> () -> (__32030) -> __32030

def rwrUU_41 :=
  fun rwr_32031 () -> () -> () -> () -> () -> (__32032) -> __32032

def rwrUL_40 :=
  fun rwr_32033 () -> () -> () -> () -> () -> (__32034) -> __32034

def rwrLU_39 :=
  fun rwr_32035 () -> () -> () -> () -> () -> (__32036) -> __32036

def rwrLL_38 :=
  fun rwr_32037 () -> () -> () -> () -> () -> (__32038) -> __32038

def not_5 :=
  fun not_32039 (__32040) ->
    match __32040 with
    | true_4 => false_5 | false_5 => true_4
    end

def and_6 :=
  fun and_32041 (__32042) -> (__32043) ->
    match __32042 with
    | true_4 =>
      match __32043 with
      | true_4 => true_4 | false_5 => false_5
      end
    | false_5 => false_5
    end

def or_7 :=
  fun or_32044 (__32045) -> (__32046) ->
    match __32045 with
    | true_4 => true_4
    | false_5 =>
      match __32046 with
      | true_4 => true_4 | false_5 => false_5
      end
    end

def xor_8 :=
  fun xor_32047 (__32048) -> (__32049) -o
    match __32048 with
    | true_4 =>
      match __32049 with
      | true_4 => false_5 | false_5 => true_4
      end
    | false_5 =>
      match __32049 with
      | true_4 => true_4 | false_5 => false_5
      end
    end

def lte_9 :=
  fun lte_32050 (__32051) -> (__32052) ->
    match __32051 with
    | zero_6  => true_4
    | succ_7 n_32053 =>
      match __32052 with
      | zero_6  => false_5 | succ_7 n_32054 => ((lte_32050) n_32053 n_32054)
      end
    end

def lt_10 :=
  fun lt_32055 (x_32056) -> (y_32057) -> ((lte_9) (succ_7 x_32056) y_32057)

def pred_11 :=
  fun pred_32058 (__32059) ->
    match __32059 with
    | zero_6  => (zero_6 ) | succ_7 n_32060 => n_32060
    end

def add_12 :=
  fun add_32061 (__32062) -> (__32063) ->
    match __32062 with
    | zero_6  => __32063
    | succ_7 n_32064 => (succ_7 ((add_32061) n_32064 __32063))
    end

def sub_13 :=
  fun sub_32065 (__32066) -> (__32067) ->
    match __32067 with
    | zero_6  => __32066
    | succ_7 n_32068 => ((sub_32065) ((pred_11) __32066) n_32068)
    end

def mul_14 :=
  fun mul_32069 (__32070) -> (__32071) ->
    match __32070 with
    | zero_6  => (zero_6 )
    | succ_7 n_32072 => ((add_12) __32071 ((mul_32069) n_32072 __32071))
    end

def div_15 :=
  fun div_32073 (x_32074) -> (y_32075) ->
    match ((lt_10) x_32074 y_32075) with
    | true_4 => (zero_6 )
    | false_5 =>
      let loop_32076 :=
        fun loop_32077 (x_32078) -> (y_32079) ->
          match ((sub_13) x_32078 ((pred_11) y_32079)) with
          | zero_6  => (zero_6 )
          | succ_7 n_32080 => (succ_7 ((loop_32077) n_32080 y_32079))
          end
        in
      ((loop_32076) x_32074 y_32075)
    end

def rem_16 :=
  fun rem_32081 (x_32082) -> (y_32083) ->
    ((sub_13) x_32082 ((mul_14) ((div_15) x_32082 y_32083) y_32083))

def pow_17 :=
  fun pow_32084 (__32085) -> (__32086) ->
    match __32086 with
    | zero_6  => (succ_7 (zero_6 ))
    | succ_7 n_32087 => ((mul_14) __32085 ((pow_32084) __32085 n_32087))
    end

def splitU_63 :=
  fun split_32088 (__32089) ->
    match __32089 with
    | nilUU_22  => (ex1UU_31 (nilUU_22 ) (nilUU_22 ))
    | consUU_23 hd_32090 tl_32091 =>
      match tl_32091 with
      | nilUU_22  => (ex1UU_31 (consUU_23 hd_32090 (nilUU_22 )) (nilUU_22 ))
      | consUU_23 hd_32092 tl_32093 =>
        match ((split_32088) tl_32093) with
        | ex1UU_31 m_32094 n_32095 =>
          (ex1UU_31
            (consUU_23 hd_32090 m_32094) (consUU_23 hd_32092 n_32095))
        end
      end
    end

def splitL_62 :=
  fun split_32096 (__32097) ->
    match __32097 with
    | nilUL_20  => (ex1LL_28 (nilUL_20 ) (nilUL_20 ))
    | consUL_21 hd_32098 tl_32099 =>
      match tl_32099 with
      | nilUL_20  => (ex1LL_28 (consUL_21 hd_32098 (nilUL_20 )) (nilUL_20 ))
      | consUL_21 hd_32100 tl_32101 =>
        match ((split_32096) tl_32101) with
        | ex1LL_28 m_32102 n_32103 =>
          (ex1LL_28
            (consUL_21 hd_32098 m_32102) (consUL_21 hd_32100 n_32103))
        end
      end
    end

def mergeU_65 :=
  fun merge_32104 (__32105) -> (__32106) -o
    match __32105 with
    | nilUU_22  => __32106
    | consUU_23 hd_32107 tl_32108 =>
      match __32106 with
      | nilUU_22  => (consUU_23 hd_32107 tl_32108)
      | consUU_23 hd_32109 tl_32110 =>
        match ((lte_9) hd_32107 hd_32109) with
        | true_4 =>
          (consUU_23
            hd_32107 ((merge_32104) tl_32108 (consUU_23 hd_32109 tl_32110)))
        | false_5 =>
          (consUU_23
            hd_32109 ((merge_32104) (consUU_23 hd_32107 tl_32108) tl_32110))
        end
      end
    end

def mergeL_64 :=
  fun merge_32111 (__32112) -> (__32113) -o
    match __32112 with
    | nilUL_20  => __32113
    | consUL_21 hd_32114 tl_32115 =>
      match __32113 with
      | nilUL_20  => (consUL_21 hd_32114 tl_32115)
      | consUL_21 hd_32116 tl_32117 =>
        match ((lte_9) hd_32114 hd_32116) with
        | true_4 =>
          (consUL_21
            hd_32114 ((merge_32111) tl_32115 (consUL_21 hd_32116 tl_32117)))
        | false_5 =>
          (consUL_21
            hd_32116 ((merge_32111) (consUL_21 hd_32114 tl_32115) tl_32117))
        end
      end
    end

def msortU_67 :=
  fun msort_32118 (__32119) ->
    match __32119 with
    | nilUU_22  => (nilUU_22 )
    | consUU_23 hd_32120 tl_32121 =>
      match tl_32121 with
      | nilUU_22  => (consUU_23 hd_32120 (nilUU_22 ))
      | consUU_23 hd_32122 tl_32123 =>
        match ((splitU_63)
                (consUU_23 hd_32120 (consUU_23 hd_32122 tl_32123))) with
        | ex1UU_31 m_32124 n_32125 =>
          ((mergeU_65) ((msort_32118) m_32124) ((msort_32118) n_32125))
        end
      end
    end

def msortL_66 :=
  fun msort_32126 (__32127) ->
    match __32127 with
    | nilUL_20  => (nilUL_20 )
    | consUL_21 hd_32128 tl_32129 =>
      match tl_32129 with
      | nilUL_20  => (consUL_21 hd_32128 (nilUL_20 ))
      | consUL_21 hd_32130 tl_32131 =>
        match ((splitL_62)
                (consUL_21 hd_32128 (consUL_21 hd_32130 tl_32131))) with
        | ex1LL_28 m_32132 n_32133 =>
          ((mergeL_64) ((msort_32126) m_32132) ((msort_32126) n_32133))
        end
      end
    end

def cmsort_workerU_71 :=
  fun cmsort_worker_32134 (__32135) -> (zs_32136) -> (__32137) -o
    match __32135 with
    | zero_6  =>
      lam () -o
        let c_32138 :=
          ((send1U_57) () () () () () __32137 ((msortU_67) zs_32136) ())
        in ((close_23) () c_32138)
    | succ_7 n_32139 =>
      match zs_32136 with
      | nilUU_22  =>
        lam () -o
          let c_32140 := ((send1U_57) () () () () () __32137 (nilUU_22 ) ())
          in ((close_23) () c_32140)
      | consUU_23 hd_32141 tl_32142 =>
        match tl_32142 with
        | nilUU_22  =>
          lam () -o
            let c_32143 :=
              ((send1U_57)
                () () () () () __32137 (consUU_23 hd_32141 (nilUU_22 )) ())
            in ((close_23) () c_32143)
        | consUU_23 hd_32144 tl_32145 =>
          match ((splitU_63)
                  (consUU_23 hd_32141 (consUU_23 hd_32144 tl_32145))) with
          | ex1UU_31 m_32146 n_32147 =>
            lam () -o
              let r1_32148 :=
                ((fork_28)
                  () ()
                    fun _32149 (c1_32150) -o
                      ((cmsort_worker_32134) n_32139 m_32146 c1_32150)
                      ())
                in
              let r2_32151 :=
                ((fork_28)
                  () ()
                    fun _32152 (c2_32153) -o
                      ((cmsort_worker_32134) n_32139 n_32147 c2_32153)
                      ())
                in
              let _32154 := ((recv1U_61) () () () () () r1_32148 ()) in
              match _32154 with
              | ex1UL_30 m_32155 n_32156 =>
                lam () -o
                  let __32157 := ((close_23) () n_32156 ()) in
                  let _32158 := ((recv1U_61) () () () () () r2_32151 ()) in
                  match _32158 with
                  | ex1UL_30 m_32159 n_32160 =>
                    lam () -o
                      let __32161 := ((close_23) () n_32160 ()) in
                      let zs1_32162 := ((mergeU_65) m_32155 m_32159) in
                      let zs1_32163 := ((rwlUU_37) () () () () () zs1_32162)
                      in
                      lam () -o
                        let c_32164 :=
                          ((send1U_57) () () () () () __32137 zs1_32163 ())
                        in
                        let __32165 := ((close_23) () c_32164 ()) in
                        lam () -o tt_3
                  end
              end
            end
          end
        end
      end

def cmsort_workerL_70 :=
  fun cmsort_worker_32166 (__32167) -> (zs_32168) -> (__32169) -o
    match __32167 with
    | zero_6  =>
      lam () -o
        let c_32170 :=
          ((send1L_56) () () () () () __32169 ((msortL_66) zs_32168) ())
        in ((close_23) () c_32170)
    | succ_7 n_32171 =>
      match zs_32168 with
      | nilUL_20  =>
        lam () -o
          let c_32172 := ((send1L_56) () () () () () __32169 (nilUL_20 ) ())
          in ((close_23) () c_32172)
      | consUL_21 hd_32173 tl_32174 =>
        match tl_32174 with
        | nilUL_20  =>
          lam () -o
            let c_32175 :=
              ((send1L_56)
                () () () () () __32169 (consUL_21 hd_32173 (nilUL_20 )) ())
            in ((close_23) () c_32175)
        | consUL_21 hd_32176 tl_32177 =>
          match ((splitL_62)
                  (consUL_21 hd_32173 (consUL_21 hd_32176 tl_32177))) with
          | ex1LL_28 m_32178 n_32179 =>
            lam () -o
              let r1_32180 :=
                ((fork_28)
                  () ()
                    fun _32181 (c1_32182) -o
                      ((cmsort_worker_32166) n_32171 m_32178 c1_32182)
                      ())
                in
              let r2_32183 :=
                ((fork_28)
                  () ()
                    fun _32184 (c2_32185) -o
                      ((cmsort_worker_32166) n_32171 n_32179 c2_32185)
                      ())
                in
              let _32186 := ((recv1L_60) () () () () () r1_32180 ()) in
              match _32186 with
              | ex1LL_28 m_32187 n_32188 =>
                lam () -o
                  let __32189 := ((close_23) () n_32188 ()) in
                  let _32190 := ((recv1L_60) () () () () () r2_32183 ()) in
                  match _32190 with
                  | ex1LL_28 m_32191 n_32192 =>
                    lam () -o
                      let __32193 := ((close_23) () n_32192 ()) in
                      let zs1_32194 := ((mergeL_64) m_32187 m_32191) in
                      let zs1_32195 := ((rwlLL_34) () () () () () zs1_32194)
                      in
                      lam () -o
                        let c_32196 :=
                          ((send1L_56) () () () () () __32169 zs1_32195 ())
                        in
                        let __32197 := ((close_23) () c_32196 ()) in
                        lam () -o tt_3
                  end
              end
            end
          end
        end
      end

-----------------------------------------

