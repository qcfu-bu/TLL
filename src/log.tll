[Notation {name = "|>"; body = (App [(Hole 2); (Hole 1)])};
  Notation {name = "@@"; body = (App [(Hole 1); (Hole 2)])};
  Notation {name = "="; body = (App [(Id ("eq", I)); (Hole 1); (Hole 2)])};
  Notation {name = "`"; body = (App [(Id ("sing", I)); (Hole 1)])};
  Notation {name = "&&"; body = (Id ("and", I))};
  Notation {name = "||"; body = (Id ("or", I))};
  Notation {name = "+"; body = (App [(Id ("add", I)); (Hole 1); (Hole 2)])};
  Notation {name = "-"; body = (App [(Id ("sub", I)); (Hole 1); (Hole 2)])};
  Notation {name = "*"; body = (App [(Id ("mul", I)); (Hole 1); (Hole 2)])};
  Notation {name = "/"; body = (App [(Id ("div", I)); (Hole 1); (Hole 2)])};
  Notation {name = "%"; body = (App [(Id ("rem", I)); (Hole 1); (Hole 2)])};
  Notation {name = "^"; body = (App [(Id ("pow", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<"; body = (App [(Id ("lt", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">"; body = (App [(Id ("gt", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<="; body = (App [(Id ("lte", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">="; body = (App [(Id ("gte", I)); (Hole 1); (Hole 2)])};
  Notation {name = "**"; body = (App [(Id ("prod1", I)); (Hole 1); (Hole 2)])};
  Notation {name = "::"; body = (App [(Id ("cons", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase (BOpr ("=", (Id ("m", I)), (Id ("m", I))))),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "rwl"; relv = R;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (N, U, (Id ("A", I)),
                          (Binder ("n",
                             (Pi (N, U,
                                (Pi (R, U, (Id ("A", I)),
                                   (Binder ("_", (Type (SId "r")))))),
                                (Binder ("B",
                                   (Pi (N, U,
                                      (BOpr ("=", (Id ("m", I)),
                                         (Id ("n", I)))),
                                      (Binder ("_",
                                         (Pi (R, U,
                                            (App
                                               [(Id ("B", I)); (Id ("m", I))]),
                                            (Binder ("_",
                                               (App
                                                  [(Id ("B", I));
                                                    (Id ("n", I))])
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "rwl"),
              [([(PId "A"); (PId "m"); (PId "n"); (PId "B"); (PId "refl");
                  (PId "x")],
                (Some (Id ("x", I))))]
              )),
           [I; I; I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (N, U, (Id ("A", I)),
                       (Binder ("n",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Type (SId "r")))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=", (Id ("m", I)), (Id ("n", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App [(Id ("B", I)); (Id ("m", I))]),
                                         (Binder ("_",
                                            (App
                                               [(Id ("B", I)); (Id ("n", I))])
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; E]};
  Definition {name = "rwr"; relv = R;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (N, U, (Id ("A", I)),
                          (Binder ("n",
                             (Pi (N, U,
                                (Pi (R, U, (Id ("A", I)),
                                   (Binder ("_", (Type (SId "r")))))),
                                (Binder ("B",
                                   (Pi (N, U,
                                      (BOpr ("=", (Id ("m", I)),
                                         (Id ("n", I)))),
                                      (Binder ("_",
                                         (Pi (R, U,
                                            (App
                                               [(Id ("B", I)); (Id ("n", I))]),
                                            (Binder ("_",
                                               (App
                                                  [(Id ("B", I));
                                                    (Id ("m", I))])
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "rwr"),
              [([(PId "A"); (PId "m"); (PId "n"); (PId "B"); (PId "refl");
                  (PId "x")],
                (Some (Id ("x", I))))]
              )),
           [I; I; I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (N, U, (Id ("A", I)),
                       (Binder ("n",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Type (SId "r")))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=", (Id ("m", I)), (Id ("n", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App [(Id ("B", I)); (Id ("n", I))]),
                                         (Binder ("_",
                                            (App
                                               [(Id ("B", I)); (Id ("m", I))])
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "s"))))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m", (TBase (UOpr ("`", (Id ("m", I))))))))),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "unit"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)), [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
       ));
    view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("n", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "list"; relv = R;
    body =
    (Binder (["s"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type (SId "t"))),
                 [(DConstr ("nil",
                     (TBase (App [(Id ("list", I)); (Id ("A", I))])), 
                     []));
                   (DConstr ("cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (App
                                  [(Inst ("list", [(SId "_"); (SId "t")], I));
                                    (Id ("A", I))]),
                               (Binder ("tl",
                                  (TBase
                                     (App [(Id ("list", I)); (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Inductive {name = "exists0"; relv = R;
    body =
    (Binder (["s"; "r"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("ex0",
                           (TBind (N, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("exists0", E));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "exists1"; relv = R;
    body =
    (Binder (["s"; "r"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("ex1",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("exists1", E));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "prod0"; relv = N;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (R, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))))
              )),
           (Binder ((Some "prod0"),
              [([(PId "A"); (PId "B")],
                (Some (App
                         [(Id ("exists0", E)); (Id ("A", I));
                           (Fun ((Pi (R, U, IMeta, (Binder ("_", IMeta)))),
                              (Binder (None,
                                 [([(PId "_")], (Some (Id ("B", I))))])),
                              []))
                           ])))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Type (SId "s")),
           (Binder ("A", (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "prod1"; relv = N;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (R, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))))
              )),
           (Binder ((Some "prod1"),
              [([(PId "A"); (PId "B")],
                (Some (App
                         [(Id ("exists1", E)); (Id ("A", I));
                           (Fun ((Pi (R, U, IMeta, (Binder ("_", IMeta)))),
                              (Binder (None,
                                 [([(PId "_")], (Some (Id ("B", I))))])),
                              []))
                           ])))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Type (SId "s")),
           (Binder ("A", (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "not"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I)))))),
           (Binder ((Some "not"),
              [([(PId "true")], (Some (Id ("false", I))));
                ([(PId "false")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I)))))))
       ));
    view = []};
  Definition {name = "and"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "and"),
              [([(PId "true"); (PId "true")], (Some (Id ("true", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("false", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "or"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "or"),
              [([(PId "false"); (PId "false")], (Some (Id ("false", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "xor"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, L, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "xor"),
              [([(PId "true"); (PId "true")], (Some (Id ("false", I))));
                ([(PId "false"); (PId "false")], (Some (Id ("false", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, L, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "lte"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("bool", I))))
                    ))
                 ))
              )),
           (Binder ((Some "lte"),
              [([(PId "zero"); (PId "_")], (Some (Id ("true", I))));
                ([(PId "_"); (PId "zero")], (Some (Id ("false", I))));
                ([(PConstr ("succ", [(PId "x")]));
                   (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("<=", (Id ("x", I)), (Id ("y", I))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "lt"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", (Id ("bool", I))))
                    ))
                 ))
              )),
           (Binder ((Some "lt"),
              [([(PId "x"); (PId "y")],
                (Some (BOpr ("<=", (App [(Id ("succ", I)); (Id ("x", I))]),
                         (Id ("y", I))))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x",
              (Pi (R, U, (Id ("nat", I)), (Binder ("y", (Id ("bool", I))))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "pred"; relv = R;
    body =
    (Binder ([],
       ((Fun ((Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I)))))),
           (Binder ((Some "pred"),
              [([(PId "zero")], (Some (Id ("zero", I))));
                ([(PConstr ("succ", [(PId "x")]))], (Some (Id ("x", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I)))))))
       ));
    view = []};
  Definition {name = "add"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "add"),
              [([(PId "zero"); (PId "y")], (Some (Id ("y", I))));
                ([(PConstr ("succ", [(PId "x")])); (PId "y")],
                 (Some (App
                          [(Id ("succ", I));
                            (BOpr ("+", (Id ("x", I)), (Id ("y", I))))])))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "sub"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "sub"),
              [([(PId "x"); (PId "zero")], (Some (Id ("x", I))));
                ([(PId "x"); (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("-", (App [(Id ("pred", I)); (Id ("x", I))]),
                          (Id ("y", I))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "mul"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "mul"),
              [([(PId "zero"); (PId "_")], (Some (Id ("zero", I))));
                ([(PConstr ("succ", [(PId "x")])); (PId "y")],
                 (Some (BOpr ("+", (Id ("y", I)),
                          (BOpr ("*", (Id ("x", I)), (Id ("y", I))))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "div"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))))
              )),
           (Binder ((Some "div"),
              [([(PId "x"); (PId "y")],
                (Some (Match (
                         [(R,
                           (App
                              [(Id ("lt", I)); (Id ("x", I)); (Id ("y", I))]),
                           None)],
                         None,
                         [([(PId "true")], (Some (Id ("zero", I))));
                           ([(PId "false")],
                            (Some (App
                                     [(Id ("succ", I));
                                       (BOpr ("/",
                                          (BOpr ("-", (Id ("x", I)),
                                             (Id ("y", I)))),
                                          (Id ("y", I))))
                                       ])))
                           ]
                         ))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x", (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "rem"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))))
              )),
           (Binder ((Some "rem"),
              [([(PId "x"); (PId "y")],
                (Some (BOpr ("-", (Id ("x", I)),
                         (BOpr ("*",
                            (BOpr ("/", (Id ("x", I)), (Id ("y", I)))),
                            (Id ("y", I))))
                         ))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x", (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "pow"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "pow"),
              [([(PId "_"); (PId "zero")],
                (Some (App [(Id ("succ", I)); (Id ("zero", I))])));
                ([(PId "x"); (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("*", (Id ("x", I)),
                          (BOpr ("^", (Id ("x", I)), (Id ("y", I))))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Extern {name = "proto"; relv = N; body = (Binder ([], (Type U))); view = []};
  Extern {name = "act0"; relv = N;
    body =
    (Binder (["s"],
       (Pi (R, U, (Id ("bool", I)),
          (Binder ("b",
             (Pi (R, U, (Type (SId "s")),
                (Binder ("A",
                   (Pi (R, U,
                      (Pi (R, U, (Id ("A", I)),
                         (Binder ("_", (Id ("proto", I)))))),
                      (Binder ("B", (Id ("proto", I))))))
                   ))
                ))
             ))
          ))
       ));
    view = [E; I; E]};
  Extern {name = "act1"; relv = N;
    body =
    (Binder (["s"],
       (Pi (R, U, (Id ("bool", I)),
          (Binder ("b",
             (Pi (R, U, (Type (SId "s")),
                (Binder ("A",
                   (Pi (R, U,
                      (Pi (R, U, (Id ("A", I)),
                         (Binder ("_", (Id ("proto", I)))))),
                      (Binder ("B", (Id ("proto", I))))))
                   ))
                ))
             ))
          ))
       ));
    view = [E; I; E]};
  Extern {name = "endp"; relv = N; body = (Binder ([], (Id ("proto", I))));
    view = []};
  Extern {name = "ch"; relv = N;
    body =
    (Binder ([],
       (Pi (R, U, (Id ("bool", I)),
          (Binder ("_",
             (Pi (R, U, (Id ("proto", I)), (Binder ("_", (Type L)))))))
          ))
       ));
    view = []};
  Extern {name = "close"; relv = R;
    body =
    (Binder ([],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b",
             (Pi (R, U,
                (App [(Id ("ch", I)); (Id ("b", I)); (Id ("endp", I))]),
                (Binder ("_", (IO (Id ("unit", I)))))))
             ))
          ))
       ));
    view = [I]};
  Extern {name = "send0"; relv = R;
    body =
    (Binder (["s"],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b1",
             (Pi (N, U, (Id ("bool", I)),
                (Binder ("b2",
                   (Pi (N, U, (Type (SId "s")),
                      (Binder ("A",
                         (Pi (N, U,
                            (Pi (R, U, (Id ("A", I)),
                               (Binder ("_", (Id ("proto", I)))))),
                            (Binder ("B",
                               (Pi (N, U,
                                  (BOpr ("=",
                                     (App
                                        [(Id ("xor", I)); (Id ("b1", I));
                                          (Id ("b2", I))]),
                                     (Id ("false", I)))),
                                  (Binder ("_",
                                     (Pi (R, U,
                                        (App
                                           [(Id ("ch", I)); (Id ("b1", I));
                                             (App
                                                [(Id ("act0", I));
                                                  (Id ("b2", I));
                                                  (Id ("B", I))])
                                             ]),
                                        (Binder ("_",
                                           (Pi (N, L, (Id ("A", I)),
                                              (Binder ("x",
                                                 (IO
                                                    (App
                                                       [(Id ("ch", I));
                                                         (Id ("b1", I));
                                                         (App
                                                            [(Id ("B", I));
                                                              (Id ("x", I))])
                                                         ]))
                                                 ))
                                              ))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))
                      ))
                   ))
                ))
             ))
          ))
       ));
    view = [I; I; I; I]};
  Extern {name = "send1"; relv = R;
    body =
    (Binder (["s"],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b1",
             (Pi (N, U, (Id ("bool", I)),
                (Binder ("b2",
                   (Pi (N, U, (Type (SId "s")),
                      (Binder ("A",
                         (Pi (N, U,
                            (Pi (R, U, (Id ("A", I)),
                               (Binder ("_", (Id ("proto", I)))))),
                            (Binder ("B",
                               (Pi (N, U,
                                  (BOpr ("=",
                                     (App
                                        [(Id ("xor", I)); (Id ("b1", I));
                                          (Id ("b2", I))]),
                                     (Id ("false", I)))),
                                  (Binder ("_",
                                     (Pi (R, U,
                                        (App
                                           [(Id ("ch", I)); (Id ("b1", I));
                                             (App
                                                [(Id ("act1", I));
                                                  (Id ("b2", I));
                                                  (Id ("B", I))])
                                             ]),
                                        (Binder ("_",
                                           (Pi (R, L, (Id ("A", I)),
                                              (Binder ("x",
                                                 (IO
                                                    (App
                                                       [(Id ("ch", I));
                                                         (Id ("b1", I));
                                                         (App
                                                            [(Id ("B", I));
                                                              (Id ("x", I))])
                                                         ]))
                                                 ))
                                              ))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))
                      ))
                   ))
                ))
             ))
          ))
       ));
    view = [I; I; I; I]};
  Extern {name = "recv0"; relv = R;
    body =
    (Binder (["s"],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b1",
             (Pi (N, U, (Id ("bool", I)),
                (Binder ("b2",
                   (Pi (N, U, (Type (SId "s")),
                      (Binder ("A",
                         (Pi (N, U,
                            (Pi (R, U, (Id ("A", I)),
                               (Binder ("_", (Id ("proto", I)))))),
                            (Binder ("B",
                               (Pi (N, U,
                                  (BOpr ("=",
                                     (App
                                        [(Id ("xor", I)); (Id ("b1", I));
                                          (Id ("b2", I))]),
                                     (Id ("true", I)))),
                                  (Binder ("_",
                                     (Pi (R, U,
                                        (App
                                           [(Id ("ch", I)); (Id ("b1", I));
                                             (App
                                                [(Id ("act0", I));
                                                  (Id ("b2", I));
                                                  (Id ("B", I))])
                                             ]),
                                        (Binder ("_",
                                           (IO
                                              (App
                                                 [(Id ("exists0", I));
                                                   (Fun (
                                                      (Pi (R, U,
                                                         (Id ("A", I)),
                                                         (Binder ("x", IMeta
                                                            ))
                                                         )),
                                                      (Binder (None,
                                                         [([(PId "x")],
                                                           (Some (App
                                                                    [(Id (
                                                                    "ch", I));
                                                                    (Id (
                                                                    "b1", I));
                                                                    (App
                                                                    [(Id (
                                                                    "B", I));
                                                                    (Id ("x",
                                                                    I))])])))
                                                           ]
                                                         )),
                                                      []))
                                                   ]))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))
                      ))
                   ))
                ))
             ))
          ))
       ));
    view = [I; I; I; I]};
  Extern {name = "recv1"; relv = R;
    body =
    (Binder (["s"],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b1",
             (Pi (N, U, (Id ("bool", I)),
                (Binder ("b2",
                   (Pi (N, U, (Type (SId "s")),
                      (Binder ("A",
                         (Pi (N, U,
                            (Pi (R, U, (Id ("A", I)),
                               (Binder ("_", (Id ("proto", I)))))),
                            (Binder ("B",
                               (Pi (N, U,
                                  (BOpr ("=",
                                     (App
                                        [(Id ("xor", I)); (Id ("b1", I));
                                          (Id ("b2", I))]),
                                     (Id ("true", I)))),
                                  (Binder ("_",
                                     (Pi (R, U,
                                        (App
                                           [(Id ("ch", I)); (Id ("b1", I));
                                             (App
                                                [(Id ("act1", I));
                                                  (Id ("b2", I));
                                                  (Id ("B", I))])
                                             ]),
                                        (Binder ("_",
                                           (IO
                                              (App
                                                 [(Id ("exists1", I));
                                                   (Fun (
                                                      (Pi (R, U,
                                                         (Id ("A", I)),
                                                         (Binder ("x", IMeta
                                                            ))
                                                         )),
                                                      (Binder (None,
                                                         [([(PId "x")],
                                                           (Some (App
                                                                    [(Id (
                                                                    "ch", I));
                                                                    (Id (
                                                                    "b1", I));
                                                                    (App
                                                                    [(Id (
                                                                    "B", I));
                                                                    (Id ("x",
                                                                    I))])])))
                                                           ]
                                                         )),
                                                      []))
                                                   ]))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))
                      ))
                   ))
                ))
             ))
          ))
       ));
    view = [I; I; I; I]};
  Extern {name = "fork"; relv = R;
    body =
    (Binder ([],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b",
             (Pi (N, U, (Id ("proto", I)),
                (Binder ("P",
                   (Pi (R, U,
                      (Pi (R, L,
                         (App [(Id ("ch", I)); (Id ("b", I)); (Id ("P", I))]),
                         (Binder ("_", (IO (Id ("unit", I))))))),
                      (Binder ("_",
                         (IO
                            (App
                               [(Id ("ch", I));
                                 (App [(Id ("not", I)); (Id ("b", I))]);
                                 (Id ("P", I))]))
                         ))
                      ))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "split"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("_",
                 (BOpr ("**",
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))]),
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))])
                    ))
                 ))
              )),
           (Binder ((Some "split"),
              [([(PId "nil")],
                (Some (App
                         [(Id ("ex1", I)); (Id ("nil", I)); (Id ("nil", I))])));
                ([(PBOpr ("::", (PId "x"), (PId "nil")))],
                 (Some (App
                          [(Id ("ex1", I));
                            (BOpr ("::", (Id ("x", I)), (Id ("nil", I))));
                            (Id ("nil", I))])));
                ([(PBOpr ("::", (PId "x"),
                     (PBOpr ("::", (PId "y"), (PId "zs")))))
                   ],
                 (Some (Match (
                          [(R, (App [(Id ("split", I)); (Id ("zs", I))]),
                            None)],
                          None,
                          [([(PConstr ("ex1", [(PId "xs"); (PId "ys")]))],
                            (Some (App
                                     [(Id ("ex1", I));
                                       (BOpr ("::", (Id ("x", I)),
                                          (Id ("xs", I))));
                                       (BOpr ("::", (Id ("y", I)),
                                          (Id ("ys", I))))
                                       ])))
                            ]
                          ))))
                ]
              )),
           [])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("_",
              (BOpr ("**",
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))]),
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))])
                 ))
              ))
           )))
       ));
    view = []};
  Definition {name = "merge"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("_",
                 (Pi (R, L,
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))]),
                    (Binder ("_",
                       (App
                          [(Inst ("list", [(SId "_"); (SId "t")], I));
                            (Id ("nat", I))])
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "merge"),
              [([(PId "nil"); (PId "ys")], (Some (Id ("ys", I))));
                ([(PId "xs"); (PId "nil")], (Some (Id ("xs", I))));
                ([(PBOpr ("::", (PId "x"), (PId "xs")));
                   (PBOpr ("::", (PId "y"), (PId "ys")))],
                 (Some (Match (
                          [(R, (BOpr ("<=", (Id ("x", I)), (Id ("y", I)))),
                            None)],
                          None,
                          [([(PId "true")],
                            (Some (BOpr ("::", (Id ("x", I)),
                                     (App
                                        [(Id ("merge", I)); (Id ("xs", I));
                                          (BOpr ("::", (Id ("y", I)),
                                             (Id ("ys", I))))
                                          ])
                                     ))));
                            ([(PId "false")],
                             (Some (BOpr ("::", (Id ("y", I)),
                                      (App
                                         [(Id ("merge", I));
                                           (BOpr ("::", (Id ("x", I)),
                                              (Id ("xs", I))));
                                           (Id ("ys", I))])
                                      ))))
                            ]
                          ))))
                ]
              )),
           [])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("_",
              (Pi (R, L,
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))]),
                 (Binder ("_",
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))])
                    ))
                 ))
              ))
           )))
       ));
    view = []};
  Definition {name = "msort"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("_",
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))])
                 ))
              )),
           (Binder ((Some "msort"),
              [([(PId "nil")], (Some (Id ("nil", I))));
                ([(PBOpr ("::", (PId "z"), (PId "nil")))],
                 (Some (BOpr ("::", (Id ("z", I)), (Id ("nil", I))))));
                ([(PId "zs")],
                 (Some (Match (
                          [(R, (App [(Id ("split", I)); (Id ("zs", I))]),
                            None)],
                          None,
                          [([(PConstr ("ex1", [(PId "xs"); (PId "ys")]))],
                            (Some (App
                                     [(Id ("merge", I));
                                       (App
                                          [(Id ("msort", I)); (Id ("xs", I))]);
                                       (App
                                          [(Id ("msort", I)); (Id ("ys", I))])
                                       ])))
                            ]
                          ))))
                ]
              )),
           [])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("_",
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ])
              ))
           )))
       ));
    view = []};
  Definition {name = "cmsort_ch"; relv = N;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("xs", (Type L))))),
           (Binder ((Some "cmsort_ch"),
              [([(PId "xs")],
                (Some (App
                         [(Id ("ch", I)); (Id ("true", I));
                           (App
                              [(Id ("act1", I)); (Id ("true", I));
                                (Fun (
                                   (Pi (R, U,
                                      (UOpr ("`",
                                         (App
                                            [(Id ("msort", I));
                                              (Id ("xs", I))])
                                         )),
                                      (Binder ("_", IMeta)))),
                                   (Binder (None,
                                      [([(PId "_")], (Some (Id ("endp", I))))
                                        ]
                                      )),
                                   []))
                                ])
                           ])))
                ]
              )),
           [E])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("xs", (Type L))))))
       ));
    view = [E]};
  Definition {name = "cmsort_worker"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U,
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))]),
                    (Binder ("zs",
                       (Pi (R, L,
                          (App
                             [(Inst ("cmsort_ch", [(SId "t")], I));
                               (Id ("zs", I))]),
                          (Binder ("_", (IO (Id ("unit", I)))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "cmsort_worker"),
              [([(PId "zero"); (PId "zs"); (PId "c")],
                (Some (MLet (
                         (App
                            [(Id ("send1", I)); (Id ("refl", I));
                              (Id ("c", I));
                              (App
                                 [(Id ("just", I));
                                   (App [(Id ("msort", I)); (Id ("zs", I))])])
                              ]),
                         (Binder ("c",
                            (App [(Id ("close", I)); (Id ("c", I))])))
                         ))));
                ([(PConstr ("succ", [(PId "n")])); (PId "nil"); (PId "c")],
                 (Some (MLet (
                          (App
                             [(Id ("send1", I)); (Id ("refl", I));
                               (Id ("c", I));
                               (App [(Id ("just", I)); (Id ("nil", I))])]),
                          (Binder ("c",
                             (App [(Id ("close", I)); (Id ("c", I))])))
                          ))));
                ([(PConstr ("succ", [(PId "n")]));
                   (PBOpr ("::", (PId "z"), (PId "nil"))); (PId "c")],
                 (Some (MLet (
                          (App
                             [(Id ("send1", I)); (Id ("refl", I));
                               (Id ("c", I));
                               (App
                                  [(Id ("just", I));
                                    (BOpr ("::", (Id ("z", I)),
                                       (Id ("nil", I))))
                                    ])
                               ]),
                          (Binder ("c",
                             (App [(Id ("close", I)); (Id ("c", I))])))
                          ))));
                ([(PConstr ("succ", [(PId "n")])); (PId "zs"); (PId "c")],
                 (Some (Match (
                          [(R, (App [(Id ("split", I)); (Id ("zs", I))]),
                            (Some ("h1", IMeta)));
                            (N, (Id ("refl", I)),
                             (Some ("_",
                                    (BOpr ("=",
                                       (Match ([(R, (Id ("h1", I)), None)],
                                          None,
                                          [([(PConstr ("ex1",
                                                [(PId "xs"); (PId "ys")]))
                                              ],
                                            (Some (App
                                                     [(Id ("merge", I));
                                                       (App
                                                          [(Id ("msort", I));
                                                            (Id ("xs", I))]);
                                                       (App
                                                          [(Id ("msort", I));
                                                            (Id ("ys", I))])
                                                       ])))
                                            ]
                                          )),
                                       (Match (
                                          [(R,
                                            (App
                                               [(Id ("split", I));
                                                 (Id ("zs", I))]),
                                            None)],
                                          None,
                                          [([(PConstr ("ex1",
                                                [(PId "xs"); (PId "ys")]))
                                              ],
                                            (Some (App
                                                     [(Id ("merge", I));
                                                       (App
                                                          [(Id ("msort", I));
                                                            (Id ("xs", I))]);
                                                       (App
                                                          [(Id ("msort", I));
                                                            (Id ("ys", I))])
                                                       ])))
                                            ]
                                          ))
                                       )))))
                            ],
                          None,
                          [([(PConstr ("ex1", [(PId "xs0"); (PId "ys0")]));
                              (PId "pf")],
                            (Some (MLet (
                                     (App
                                        [(Id ("fork", I)); IMeta;
                                          (Fun (
                                             (Pi (R, L, IMeta,
                                                (Binder ("c1", IMeta)))),
                                             (Binder (None,
                                                [([(PId "c1")],
                                                  (Some (App
                                                           [(Id (
                                                               "cmsort_worker",
                                                               I));
                                                             (Id ("n", I));
                                                             (Id ("xs0", I));
                                                             (Id ("c1", I))])))
                                                  ]
                                                )),
                                             []))
                                          ]),
                                     (Binder ("r1",
                                        (MLet (
                                           (App
                                              [(Id ("fork", I)); IMeta;
                                                (Fun (
                                                   (Pi (R, L, IMeta,
                                                      (Binder ("c2", IMeta))
                                                      )),
                                                   (Binder (None,
                                                      [([(PId "c2")],
                                                        (Some (App
                                                                 [(Id (
                                                                    "cmsort_worker",
                                                                    I));
                                                                   (Id ("n",
                                                                    I));
                                                                   (Id (
                                                                    "ys0", I
                                                                    ));
                                                                   (Id ("c2",
                                                                    I))
                                                                   ])))
                                                        ]
                                                      )),
                                                   []))
                                                ]),
                                           (Binder ("r2",
                                              (MLet (
                                                 (App
                                                    [(Id ("recv1", I));
                                                      (Id ("refl", I));
                                                      (Id ("r1", I))]),
                                                 (Binder ("r1",
                                                    (Match (
                                                       [(R, (Id ("r1", I)),
                                                         None)],
                                                       None,
                                                       [([(PConstr ("ex1",
                                                             [(PId "xs1");
                                                               (PId "c1")]
                                                             ))
                                                           ],
                                                         (Some (MLet (
                                                                  (App
                                                                    [(Id (
                                                                    "recv1",
                                                                    I));
                                                                    (Id (
                                                                    "refl", I
                                                                    ));
                                                                    (Id (
                                                                    "r2", I))
                                                                    ]),
                                                                  (Binder (
                                                                    "r2",
                                                                    (Match (
                                                                    [(R,
                                                                    (Id (
                                                                    "r2", I)),
                                                                    None)],
                                                                    None,
                                                                    [([(PConstr (
                                                                    "ex1",
                                                                    [(PId
                                                                    "ys1");
                                                                    (PId "c2")
                                                                    ]))],
                                                                    (Some (
                                                                    Match (
                                                                    [(R,
                                                                    (Id (
                                                                    "xs1", I
                                                                    )), None);
                                                                    (R,
                                                                    (Id (
                                                                    "ys1", I
                                                                    )), None)
                                                                    ], None,
                                                                    [([(PConstr (
                                                                    "just",
                                                                    [(PId
                                                                    "xs1")]));
                                                                    (PConstr (
                                                                    "just",
                                                                    [(PId
                                                                    "ys1")]))
                                                                    ],
                                                                    (Some (
                                                                    Let (R,
                                                                    (Ann (
                                                                    (App
                                                                    [(Id (
                                                                    "just", I
                                                                    ));
                                                                    (App
                                                                    [(Id (
                                                                    "merge",
                                                                    I));
                                                                    (Id (
                                                                    "xs1", I
                                                                    ));
                                                                    (Id (
                                                                    "ys1", I
                                                                    ))])]),
                                                                    (UOpr (
                                                                    "`",
                                                                    (App
                                                                    [(Id (
                                                                    "merge",
                                                                    I));
                                                                    (App
                                                                    [(Id (
                                                                    "msort",
                                                                    I));
                                                                    (Id (
                                                                    "xs0", I
                                                                    ))]);
                                                                    (App
                                                                    [(Id (
                                                                    "msort",
                                                                    I));
                                                                    (Id (
                                                                    "ys0", I
                                                                    ))])])))
                                                                    )),
                                                                    (Binder (
                                                                    "zs1",
                                                                    (Let (R,
                                                                    (Ann (
                                                                    (App
                                                                    [(Id (
                                                                    "rwl", I
                                                                    ));
                                                                    (Fun (
                                                                    (Pi (R,
                                                                    U, IMeta,
                                                                    (Binder (
                                                                    "x",
                                                                    IMeta)))),
                                                                    (Binder (
                                                                    None,
                                                                    [([(PId
                                                                    "x")],
                                                                    (Some (
                                                                    UOpr (
                                                                    "`",
                                                                    (Id ("x",
                                                                    I))))))]
                                                                    )), 
                                                                    []));
                                                                    (Id (
                                                                    "pf", I));
                                                                    (Id (
                                                                    "zs1", I
                                                                    ))]),
                                                                    (UOpr (
                                                                    "`",
                                                                    (App
                                                                    [(Id (
                                                                    "msort",
                                                                    I));
                                                                    (Id (
                                                                    "zs", I))
                                                                    ]))))),
                                                                    (Binder (
                                                                    "zs1",
                                                                    (MLet (
                                                                    (App
                                                                    [(Id (
                                                                    "send1",
                                                                    I));
                                                                    (Id (
                                                                    "refl", I
                                                                    ));
                                                                    (Id ("c",
                                                                    I));
                                                                    (Id (
                                                                    "zs1", I
                                                                    ))]),
                                                                    (Binder (
                                                                    "c",
                                                                    (MLet (
                                                                    (App
                                                                    [(Id (
                                                                    "close",
                                                                    I));
                                                                    (Id (
                                                                    "c1", I))
                                                                    ]),
                                                                    (Binder (
                                                                    "_",
                                                                    (MLet (
                                                                    (App
                                                                    [(Id (
                                                                    "close",
                                                                    I));
                                                                    (Id (
                                                                    "c2", I))
                                                                    ]),
                                                                    (Binder (
                                                                    "_",
                                                                    (MLet (
                                                                    (App
                                                                    [(Id (
                                                                    "close",
                                                                    I));
                                                                    (Id ("c",
                                                                    I))]),
                                                                    (Binder (
                                                                    "_",
                                                                    (Return
                                                                    (Id (
                                                                    "tt", I)))
                                                                    ))))))))
                                                                    ))))))))
                                                                    ))))))))))
                                                                    ]))))]))
                                                                    ))
                                                                  ))))
                                                         ]
                                                       ))
                                                    ))
                                                 ))
                                              ))
                                           ))
                                        ))
                                     ))))
                            ]
                          ))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U,
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))]),
                 (Binder ("zs",
                    (Pi (R, L,
                       (App
                          [(Inst ("cmsort_ch", [(SId "t")], I));
                            (Id ("zs", I))]),
                       (Binder ("_", (IO (Id ("unit", I)))))))
                    ))
                 ))
              ))
           )))
       ));
    view = []}
  ]

-----------------------------------------

#[logical]
inductive eq_1‹s_368› (A_369 : Type‹s_368›) (m_370 : A_369):
  A_369 -> U
where
| refl_1 : (eq_1‹??_1› ?_1[0;0] m_370 m_370)

#[program]
def rwl_1‹s_372,r_373› :
  ∀ {A_374 : Type‹s_372›} ->
    ∀ {m_375 : A_374} ->
      ∀ {n_376 : A_374} ->
        ∀ {B_377 : A_374 -> Type‹r_373›} ->
          {(eq_1‹??_3› ?_3[0;0] m_375 n_376)} ->
            ((B_377) m_375) -> ((B_377) n_376)
:=
  function rwl_381 :
    ∀ {A_382 : Type‹s_372›} ->
      ∀ {m_383 : A_382} ->
        ∀ {n_384 : A_382} ->
          ∀ {B_385 : A_382 -> Type‹r_373›} ->
            {(eq_1‹??_2› ?_2[0;0] m_383 n_384)} ->
              ((B_385) m_383) -> ((B_385) n_384)
  | A_389 m_390 n_391 B_392 refl_1 x_393 => x_393

#[program]
def rwr_2‹s_394,r_395› :
  ∀ {A_396 : Type‹s_394›} ->
    ∀ {m_397 : A_396} ->
      ∀ {n_398 : A_396} ->
        ∀ {B_399 : A_396 -> Type‹r_395›} ->
          {(eq_1‹??_5› ?_5[0;0] m_397 n_398)} ->
            ((B_399) n_398) -> ((B_399) m_397)
:=
  function rwr_403 :
    ∀ {A_404 : Type‹s_394›} ->
      ∀ {m_405 : A_404} ->
        ∀ {n_406 : A_404} ->
          ∀ {B_407 : A_404 -> Type‹r_395›} ->
            {(eq_1‹??_4› ?_4[0;0] m_405 n_406)} ->
              ((B_407) n_406) -> ((B_407) m_405)
  | A_411 m_412 n_413 B_414 refl_1 x_415 => x_415

#[program]
inductive sing_2‹s_416› (A_417 : Type‹s_416›):
  A_417 -> Type‹s_416›
where
| just_2 (m_419 : A_417) : (sing_2‹??_6› ?_6[0;0] m_419)

#[program]
inductive unit_3‹› : U where
| tt_3 : unit_3

#[program]
inductive bool_4‹› : U where
| true_4 : bool_4
| false_5 : bool_4

#[program]
inductive nat_5‹› : U where
| zero_6 : nat_5
| succ_7 (n_420 : nat_5) : nat_5

#[program]
inductive list_6‹s_421,t_422› (A_423 : Type‹s_421›): Type‹t_422›
where
| nil_8 : (list_6‹??_7,??_8› A_423)
| cons_9
    (hd_424 : A_423) (tl_425 : (list_6‹??_9,t_422› A_423))
    : (list_6‹??_10,??_11› A_423)

#[program]
inductive exists0_7‹s_426,r_427› (A_428 : Type‹s_426›) (B_429 : 
A_428 -> Type‹r_427›): L where
| ex0_10
    {m_431 : A_428} (n_432 : ((B_429) m_431))
    : (exists0_7‹??_12,??_13› A_428 B_429)

#[program]
inductive exists1_8‹s_433,r_434› (A_435 : Type‹s_433›) (B_436 : 
A_435 -> Type‹r_434›): L where
| ex1_11
    (m_438 : A_435) (n_439 : ((B_436) m_438))
    : (exists1_8‹??_14,??_15› A_435 B_436)

#[logical]
def prod0_3‹s_440,r_441› :
  Type‹s_440› -> Type‹r_441› -> ?_10[0;0]
:=
  function prod0_444 : Type‹s_440› -> Type‹r_441› -> ?_7[0;0]
  | A_447 B_448 =>
    (exists0_7‹??_16,??_17›
      A_447 function _449 : ?_8[0;0] -> ?_9[0;0]
            | _451 => B_448)

#[logical]
def prod1_4‹s_452,r_453› :
  Type‹s_452› -> Type‹r_453› -> ?_14[0;0]
:=
  function prod1_456 : Type‹s_452› -> Type‹r_453› -> ?_11[0;0]
  | A_459 B_460 =>
    (exists1_8‹??_18,??_19›
      A_459 function _461 : ?_12[0;0] -> ?_13[0;0]
            | _463 => B_460)

#[program]
def not_5‹› : bool_4 -> bool_4 :=
  function not_465 : bool_4 -> bool_4
  | true_4 => false_5
  | false_5 => true_4

#[program]
def and_6‹› : bool_4 -> bool_4 -> bool_4 :=
  function and_469 : bool_4 -> bool_4 -> bool_4
  | true_4 true_4 => true_4
  | _472 _473 => false_5

#[program]
def or_7‹› : bool_4 -> bool_4 -> bool_4 :=
  function or_476 : bool_4 -> bool_4 -> bool_4
  | false_5 false_5 => false_5
  | _479 _480 => true_4

#[program]
def xor_8‹› : bool_4 -> bool_4 -o bool_4 :=
  function xor_483 : bool_4 -> bool_4 -o bool_4
  | true_4 true_4 => false_5
  | false_5 false_5 => false_5
  | _486 _487 => true_4

#[program]
def lte_9‹› : nat_5 -> nat_5 -> bool_4 :=
  function lte_490 : nat_5 -> nat_5 -> bool_4
  | zero_6 _493 => true_4
  | _494 zero_6 => false_5
  | (succ_7 x_495) (succ_7 y_496) => ((lte_490) x_495 y_496)

#[program]
def lt_10‹› : nat_5 -> nat_5 -> bool_4 :=
  function lt_499 : nat_5 -> nat_5 -> bool_4
  | x_502 y_503 => ((lte_9) (succ_7‹› x_502) y_503)

#[program]
def pred_11‹› : nat_5 -> nat_5 :=
  function pred_505 : nat_5 -> nat_5
  | zero_6 => zero_6
  | (succ_7 x_507) => x_507

#[program]
def add_12‹› : nat_5 -> nat_5 -> nat_5 :=
  function add_510 : nat_5 -> nat_5 -> nat_5
  | zero_6 y_513 => y_513
  | (succ_7 x_514) y_515 => (succ_7‹› ((add_510) x_514 y_515))

#[program]
def sub_13‹› : nat_5 -> nat_5 -> nat_5 :=
  function sub_518 : nat_5 -> nat_5 -> nat_5
  | x_521 zero_6 => x_521
  | x_522 (succ_7 y_523) => ((sub_518) ((pred_11) x_522) y_523)

#[program]
def mul_14‹› : nat_5 -> nat_5 -> nat_5 :=
  function mul_526 : nat_5 -> nat_5 -> nat_5
  | zero_6 _529 => zero_6
  | (succ_7 x_530) y_531 => ((add_12) y_531 ((mul_526) x_530 y_531))

#[program]
def div_15‹› : nat_5 -> nat_5 -> ?_18[0;0] :=
  function div_534 : nat_5 -> nat_5 -> ?_15[0;0]
  | x_537 y_538 =>
    match ((lt_10) x_537 y_538) in ?_16[0;0] -o ?_17[0;0] with
    | true_4 => zero_6
    | false_5 => (succ_7‹› ((div_534) ((sub_13) x_537 y_538) y_538))

#[program]
def rem_16‹› : nat_5 -> nat_5 -> ?_20[0;0] :=
  function rem_542 : nat_5 -> nat_5 -> ?_19[0;0]
  | x_545 y_546 => ((sub_13) x_545 ((mul_14) ((div_15) x_545 y_546) y_546))

#[program]
def pow_17‹› : nat_5 -> nat_5 -> nat_5 :=
  function pow_549 : nat_5 -> nat_5 -> nat_5
  | _552 zero_6 => (succ_7‹› zero_6)
  | x_553 (succ_7 y_554) => ((mul_14) x_553 ((pow_549) x_553 y_554))

#[logical]
extern proto_18‹› : U

#[logical]
extern act0_19‹s_555› :
  bool_4 -> ∀ (A_557 : Type‹s_555›) -> A_557 -> proto_18 -> proto_18

#[logical]
extern act1_20‹s_560› :
  bool_4 -> ∀ (A_562 : Type‹s_560›) -> A_562 -> proto_18 -> proto_18

#[logical]
extern endp_21‹› : proto_18

#[logical]
extern ch_22‹› : bool_4 -> proto_18 -> L

#[program]
extern close_23‹› :
  ∀ {b_567 : bool_4} -> ((ch_22) b_567 endp_21) -> IO unit_3

#[program]
extern send0_24‹s_569› :
  ∀ {b1_570 : bool_4} ->
    ∀ {b2_571 : bool_4} ->
      ∀ {A_572 : Type‹s_569›} ->
        ∀ {B_573 : A_572 -> proto_18} ->
          {(eq_1‹??_20› ?_21[0;0] ((xor_8) b1_570 b2_571) false_5)} ->
            ((ch_22) b1_570 ((act0_19‹??_21›) b2_571 ?_22[0;0] B_573)) ->
              ∀ {x_577 : A_572} -o IO ((ch_22) b1_570 ((B_573) x_577))

#[program]
extern send1_25‹s_578› :
  ∀ {b1_579 : bool_4} ->
    ∀ {b2_580 : bool_4} ->
      ∀ {A_581 : Type‹s_578›} ->
        ∀ {B_582 : A_581 -> proto_18} ->
          {(eq_1‹??_22› ?_23[0;0] ((xor_8) b1_579 b2_580) false_5)} ->
            ((ch_22) b1_579 ((act1_20‹??_23›) b2_580 ?_24[0;0] B_582)) ->
              ∀ (x_586 : A_581) -o IO ((ch_22) b1_579 ((B_582) x_586))

#[program]
extern recv0_26‹s_587› :
  ∀ {b1_588 : bool_4} ->
    ∀ {b2_589 : bool_4} ->
      ∀ {A_590 : Type‹s_587›} ->
        ∀ {B_591 : A_590 -> proto_18} ->
          {(eq_1‹??_24› ?_25[0;0] ((xor_8) b1_588 b2_589) true_4)} ->
            ((ch_22) b1_588 ((act0_19‹??_25›) b2_589 ?_26[0;0] B_591)) ->
              IO (exists0_7‹??_26,??_27›
                   ?_28[0;0]
                   function _595 : A_590 -> ?_27[0;0]
                   | x_597 => ((ch_22) b1_588 ((B_591) x_597)))

#[program]
extern recv1_27‹s_598› :
  ∀ {b1_599 : bool_4} ->
    ∀ {b2_600 : bool_4} ->
      ∀ {A_601 : Type‹s_598›} ->
        ∀ {B_602 : A_601 -> proto_18} ->
          {(eq_1‹??_28› ?_29[0;0] ((xor_8) b1_599 b2_600) true_4)} ->
            ((ch_22) b1_599 ((act1_20‹??_29›) b2_600 ?_30[0;0] B_602)) ->
              IO (exists1_8‹??_30,??_31›
                   ?_32[0;0]
                   function _606 : A_601 -> ?_31[0;0]
                   | x_608 => ((ch_22) b1_599 ((B_602) x_608)))

#[program]
extern fork_28‹› :
  ∀ {b_609 : bool_4} ->
    ∀ {P_610 : proto_18} ->
      ((ch_22) b_609 P_610) -o IO unit_3 ->
        IO ((ch_22) ((not_5) b_609) P_610)

#[program]
def split_29‹t_613› :
  (list_6‹??_57,t_613› nat_5) ->
    ((prod1_4‹??_60,??_61›)
      (list_6‹??_58,t_613› nat_5) (list_6‹??_59,t_613› nat_5))
:=
  function split_615 :
    (list_6‹??_32,t_613› nat_5) ->
      ((prod1_4‹??_35,??_36›)
        (list_6‹??_33,t_613› nat_5) (list_6‹??_34,t_613› nat_5))
  | nil_8 =>
    (ex1_11‹??_41,??_42›
      ?_35[0;0] ?_36[0;0] (nil_8‹??_37,??_38› ?_33[0;0])
      (nil_8‹??_39,??_40› ?_34[0;0]))
  | (cons_9 x_617 nil_8) =>
    (ex1_11‹??_49,??_50›
      ?_40[0;0] ?_41[0;0]
      (cons_9‹??_45,??_46›
        ?_38[0;0] x_617 (nil_8‹??_43,??_44› ?_37[0;0]))
      (nil_8‹??_47,??_48› ?_39[0;0]))
  | (cons_9 x_618 (cons_9 y_619 zs_620)) =>
    match ((split_615) zs_620) in ?_42[0;0] -o ?_43[0;0] with
    | (ex1_11 xs_622 ys_623) =>
      (ex1_11‹??_55,??_56›
        ?_46[0;0] ?_47[0;0] (cons_9‹??_51,??_52› ?_44[0;0] x_618 xs_622)
        (cons_9‹??_53,??_54› ?_45[0;0] y_619 ys_623))

#[program]
def merge_30‹t_624› :
  (list_6‹??_73,t_624› nat_5) ->
    (list_6‹??_74,t_624› nat_5) -o (list_6‹??_75,t_624› nat_5)
:=
  function merge_627 :
    (list_6‹??_62,t_624› nat_5) ->
      (list_6‹??_63,t_624› nat_5) -o (list_6‹??_64,t_624› nat_5)
  | nil_8 ys_630 => ys_630
  | xs_631 nil_8 => xs_631
  | (cons_9 x_632 xs_633) (cons_9 y_634 ys_635) =>
    match ((lte_9) x_632 y_634) in ?_48[0;0] -o ?_49[0;0] with
    | true_4 =>
      (cons_9‹??_67,??_68›
        ?_51[0;0] x_632
        ((merge_627) xs_633 (cons_9‹??_65,??_66› ?_50[0;0] y_634 ys_635)))
    | false_5 =>
      (cons_9‹??_71,??_72›
        ?_53[0;0] y_634
        ((merge_627) (cons_9‹??_69,??_70› ?_52[0;0] x_632 xs_633) ys_635))

#[program]
def msort_31‹t_637› :
  (list_6‹??_86,t_637› nat_5) -> (list_6‹??_87,t_637› nat_5)
:=
  function msort_639 :
    (list_6‹??_76,t_637› nat_5) -> (list_6‹??_77,t_637› nat_5)
  | nil_8 => (nil_8‹??_78,??_79› ?_54[0;0])
  | (cons_9 z_641 nil_8) =>
    (cons_9‹??_82,??_83›
      ?_56[0;0] z_641 (nil_8‹??_80,??_81› ?_55[0;0]))
  | zs_642 =>
    match ((split_29‹??_84›) zs_642) in ?_57[0;0] -o ?_58[0;0] with
    | (ex1_11 xs_644 ys_645) =>
      ((merge_30‹??_85›) ((msort_639) xs_644) ((msort_639) ys_645))

#[logical]
def cmsort_ch_32‹t_646› : (list_6‹??_92,t_646› nat_5) -> L :=
  function cmsort_ch_648 : (list_6‹??_88,t_646› nat_5) -> L
  | xs_650 =>
    ((ch_22)
      true_4
      ((act1_20‹??_91›)
        true_4 ?_61[0;0]
        function _651 :
          (sing_2‹??_90› ?_59[0;0] ((msort_31‹??_89›) xs_650)) ->
            ?_60[0;0]
        | _653 => endp_21))

#[program]
def cmsort_worker_33‹t_654› :
  nat_5 ->
    ∀ (zs_656 : (list_6‹??_137,t_654› nat_5)) ->
      ((cmsort_ch_32‹t_654›) zs_656) -o IO unit_3
:=
  function cmsort_worker_658 :
    nat_5 ->
      ∀ (zs_660 : (list_6‹??_93,t_654› nat_5)) ->
        ((cmsort_ch_32‹t_654›) zs_660) -o IO unit_3
  | zero_6 zs_662 c_663 =>
    let* c_664 :=
      ((send1_25‹??_97›)
        ?_68[0;0] ?_67[0;0] ?_66[0;0] ?_65[0;0]
        (refl_1‹??_94› ?_62[0;0] ?_63[0;0]) c_663
        (just_2‹??_96› ?_64[0;0] ((msort_31‹??_95›) zs_662)))
    in ((close_23) ?_69[0;0] c_664)
  | (succ_7 n_665) nil_8 c_666 =>
    let* c_667 :=
      ((send1_25‹??_102›)
        ?_77[0;0] ?_76[0;0] ?_75[0;0] ?_74[0;0]
        (refl_1‹??_98› ?_70[0;0] ?_71[0;0]) c_666
        (just_2‹??_101› ?_73[0;0] (nil_8‹??_99,??_100› ?_72[0;0])))
    in ((close_23) ?_78[0;0] c_667)
  | (succ_7 n_668) (cons_9 z_669 nil_8) c_670 =>
    let* c_671 :=
      ((send1_25‹??_109›)
        ?_87[0;0] ?_86[0;0] ?_85[0;0] ?_84[0;0]
        (refl_1‹??_103› ?_79[0;0] ?_80[0;0]) c_670
        (just_2‹??_108›
          ?_83[0;0]
          (cons_9‹??_106,??_107›
            ?_82[0;0] z_669 (nil_8‹??_104,??_105› ?_81[0;0]))))
    in ((close_23) ?_88[0;0] c_671)
  | (succ_7 n_672) zs_673 c_674 =>
    match ((split_29‹??_110›) zs_673),
    (refl_1‹??_111› ?_89[0;0] ?_90[0;0]) in
      ∀ (h1_675 : ?_91[0;0]) -o
        {(eq_1‹??_119›
           ?_96[0;0]
           match h1_675 in ?_92[0;0] -o ?_93[0;0] with
           | (ex1_11 xs_678 ys_679) =>
             ((merge_30‹??_114›)
               ((msort_31‹??_112›) xs_678)
               ((msort_31‹??_113›) ys_679))
           match ((split_29‹??_115›) zs_673) in ?_94[0;0] -o ?_95[0;0]
           with
           | (ex1_11 xs_681 ys_682) =>
             ((merge_30‹??_118›)
               ((msort_31‹??_116›) xs_681)
               ((msort_31‹??_117›) ys_682)))} -o
          ?_97[0;0]
    with
    | (ex1_11 xs0_683 ys0_684), pf_685 =>
      let* r1_686 :=
        ((fork_28)
          ?_101[0;0] ?_98[0;0]
          function _687 : ?_99[0;0] -o ?_100[0;0]
          | c1_689 => ((cmsort_worker_658) n_672 xs0_683 c1_689))
      in
      let* r2_690 :=
        ((fork_28)
          ?_105[0;0] ?_102[0;0]
          function _691 : ?_103[0;0] -o ?_104[0;0]
          | c2_693 => ((cmsort_worker_658) n_672 ys0_684 c2_693))
      in
      let* r1_694 :=
        ((recv1_27‹??_121›)
          ?_111[0;0] ?_110[0;0] ?_109[0;0] ?_108[0;0]
          (refl_1‹??_120› ?_106[0;0] ?_107[0;0]) r1_686)
      in
      match r1_694 in ?_112[0;0] -o ?_113[0;0] with
      | (ex1_11 xs1_696 c1_697) =>
        let* r2_698 :=
          ((recv1_27‹??_123›)
            ?_119[0;0] ?_118[0;0] ?_117[0;0] ?_116[0;0]
            (refl_1‹??_122› ?_114[0;0] ?_115[0;0]) r2_690)
        in
        match r2_698 in ?_120[0;0] -o ?_121[0;0] with
        | (ex1_11 ys1_700 c2_701) =>
          match xs1_696, ys1_700 in ?_122[0;0] -o ?_123[0;0] -o ?_124[0;0]
          with
          | (just_2 xs1_704), (just_2 ys1_705) =>
            let zs1_706 :=
              ((just_2‹??_125›
                 ?_125[0;0] ((merge_30‹??_124›) xs1_704 ys1_705))
                : (sing_2‹??_129›
                    ?_126[0;0]
                    ((merge_30‹??_128›)
                      ((msort_31‹??_126›) xs0_683)
                      ((msort_31‹??_127›) ys0_684))))
            in
            let zs1_707 :=
              (((rwl_1‹??_131,??_132›)
                 ?_132[0;0] ?_131[0;0] ?_130[0;0]
                 function _708 : ?_127[0;0] -> ?_128[0;0]
                 | x_710 => (sing_2‹??_130› ?_129[0;0] x_710) pf_685
                 zs1_706)
                : (sing_2‹??_134›
                    ?_133[0;0] ((msort_31‹??_133›) zs_673)))
            in
            let* c_711 :=
              ((send1_25‹??_136›)
                ?_139[0;0] ?_138[0;0] ?_137[0;0] ?_136[0;0]
                (refl_1‹??_135› ?_134[0;0] ?_135[0;0]) c_674 zs1_707)
            in
            let* __712 := ((close_23) ?_140[0;0] c1_697) in
            let* __713 := ((close_23) ?_141[0;0] c2_701) in
            let* __714 := ((close_23) ?_142[0;0] c_711) in return tt_3

-----------------------------------------

#[logical]
inductive eq_1‹s_19222› (A_19223 : Type‹s_19222›) (m_19224 : A_19223):
  A_19223 -> U
where
| refl_1 : (eq_1‹s_19222› A_19223 m_19224 m_19224)

#[program]
def rwl_1‹s_19226,r_19227› :
  ∀ {A_19228 : Type‹s_19226›} ->
    ∀ {m_19229 : A_19228} ->
      ∀ {n_19230 : A_19228} ->
        ∀ {B_19231 : A_19228 -> Type‹r_19227›} ->
          {(eq_1‹s_19226› A_19228 m_19229 n_19230)} ->
            ((B_19231) m_19229) -> ((B_19231) n_19230)
:=
  function rwl_19235 :
    ∀ {A_19236 : Type‹s_19226›} ->
      ∀ {m_19237 : A_19236} ->
        ∀ {n_19238 : A_19236} ->
          ∀ {B_19239 : A_19236 -> Type‹r_19227›} ->
            {(eq_1‹s_19226› A_19236 m_19237 n_19238)} ->
              ((B_19239) m_19237) -> ((B_19239) n_19238)
  | A_19243 m_19244 n_19245 B_19246 refl_1 __19247 => __19247

#[program]
def rwr_2‹s_19248,r_19249› :
  ∀ {A_19250 : Type‹s_19248›} ->
    ∀ {m_19251 : A_19250} ->
      ∀ {n_19252 : A_19250} ->
        ∀ {B_19253 : A_19250 -> Type‹r_19249›} ->
          {(eq_1‹s_19248› A_19250 m_19251 n_19252)} ->
            ((B_19253) n_19252) -> ((B_19253) m_19251)
:=
  function rwr_19257 :
    ∀ {A_19258 : Type‹s_19248›} ->
      ∀ {m_19259 : A_19258} ->
        ∀ {n_19260 : A_19258} ->
          ∀ {B_19261 : A_19258 -> Type‹r_19249›} ->
            {(eq_1‹s_19248› A_19258 m_19259 n_19260)} ->
              ((B_19261) n_19260) -> ((B_19261) m_19259)
  | A_19265 m_19266 n_19267 B_19268 refl_1 __19269 => __19269

#[program]
inductive sing_2‹s_19270› (A_19271 : Type‹s_19270›):
  A_19271 -> Type‹s_19270›
where
| just_2 (m_19273 : A_19271) : (sing_2‹s_19270› A_19271 m_19273)

#[program]
inductive unit_3‹› : U where
| tt_3 : unit_3

#[program]
inductive bool_4‹› : U where
| true_4 : bool_4
| false_5 : bool_4

#[program]
inductive nat_5‹› : U where
| zero_6 : nat_5
| succ_7 (n_19274 : nat_5) : nat_5

#[program]
inductive list_6‹s_19275,t_19276› (A_19277 : Type‹s_19275›):
  Type‹t_19276›
where
| nil_8 : (list_6‹s_19275,t_19276› A_19277)
| cons_9
    (hd_19278 : A_19277) (tl_19279 : (list_6‹s_19275,t_19276› A_19277))
    : (list_6‹s_19275,t_19276› A_19277)

#[program]
inductive exists0_7‹s_19280,r_19281› (A_19282 : Type‹s_19280›) (B_19283 : 
A_19282 -> Type‹r_19281›): L where
| ex0_10
    {m_19285 : A_19282} (n_19286 : ((B_19283) m_19285))
    : (exists0_7‹s_19280,r_19281› A_19282 B_19283)

#[program]
inductive exists1_8‹s_19287,r_19288› (A_19289 : Type‹s_19287›) (B_19290 : 
A_19289 -> Type‹r_19288›): L where
| ex1_11
    (m_19292 : A_19289) (n_19293 : ((B_19290) m_19292))
    : (exists1_8‹s_19287,r_19288› A_19289 B_19290)

#[logical]
def prod0_3‹s_19294,r_19295› :
  Type‹s_19294› -> Type‹r_19295› -> L
:=
  function prod0_19298 : Type‹s_19294› -> Type‹r_19295› -> L
  | A_19301 B_19302 =>
    (exists0_7‹s_19294,r_19295›
      A_19301
      function _19303 : A_19301 -> Type‹r_19295›
      | __19305 => B_19302)

#[logical]
def prod1_4‹s_19306,r_19307› :
  Type‹s_19306› -> Type‹r_19307› -> L
:=
  function prod1_19310 : Type‹s_19306› -> Type‹r_19307› -> L
  | A_19313 B_19314 =>
    (exists1_8‹s_19306,r_19307›
      A_19313
      function _19315 : A_19313 -> Type‹r_19307›
      | __19317 => B_19314)

#[program]
def not_5‹› : bool_4 -> bool_4 :=
  function not_19319 : bool_4 -> bool_4
  | true_4 => false_5
  | false_5 => true_4

#[program]
def and_6‹› : bool_4 -> bool_4 -> bool_4 :=
  function and_19323 : bool_4 -> bool_4 -> bool_4
  | true_4 true_4 => true_4
  | true_4 false_5 => false_5
  | false_5 __19326 => false_5

#[program]
def or_7‹› : bool_4 -> bool_4 -> bool_4 :=
  function or_19329 : bool_4 -> bool_4 -> bool_4
  | true_4 __19332 => true_4
  | false_5 true_4 => true_4
  | false_5 false_5 => false_5

#[program]
def xor_8‹› : bool_4 -> bool_4 -o bool_4 :=
  function xor_19335 : bool_4 -> bool_4 -o bool_4
  | true_4 true_4 => false_5
  | true_4 false_5 => true_4
  | false_5 true_4 => true_4
  | false_5 false_5 => false_5

#[program]
def lte_9‹› : nat_5 -> nat_5 -> bool_4 :=
  function lte_19340 : nat_5 -> nat_5 -> bool_4
  | zero_6 __19343 => true_4
  | (succ_7 n_19344) zero_6 => false_5
  | (succ_7 n_19345) (succ_7 n_19346) => ((lte_19340) n_19345 n_19346)

#[program]
def lt_10‹› : nat_5 -> nat_5 -> bool_4 :=
  function lt_19349 : nat_5 -> nat_5 -> bool_4
  | x_19352 y_19353 => ((lte_9) (succ_7‹› x_19352) y_19353)

#[program]
def pred_11‹› : nat_5 -> nat_5 :=
  function pred_19355 : nat_5 -> nat_5
  | zero_6 => zero_6
  | (succ_7 n_19357) => n_19357

#[program]
def add_12‹› : nat_5 -> nat_5 -> nat_5 :=
  function add_19360 : nat_5 -> nat_5 -> nat_5
  | zero_6 __19363 => __19363
  | (succ_7 n_19364) __19365 => (succ_7‹› ((add_19360) n_19364 __19365))

#[program]
def sub_13‹› : nat_5 -> nat_5 -> nat_5 :=
  function sub_19368 : nat_5 -> nat_5 -> nat_5
  | __19371 zero_6 => __19371
  | __19372 (succ_7 n_19373) => ((sub_19368) ((pred_11) __19372) n_19373)

#[program]
def mul_14‹› : nat_5 -> nat_5 -> nat_5 :=
  function mul_19376 : nat_5 -> nat_5 -> nat_5
  | zero_6 __19379 => zero_6
  | (succ_7 n_19380) __19381 =>
    ((add_12) __19381 ((mul_19376) n_19380 __19381))

#[program]
def div_15‹› : nat_5 -> nat_5 -> nat_5 :=
  function div_19384 : nat_5 -> nat_5 -> nat_5
  | x_19387 y_19388 =>
    match ((lt_10) x_19387 y_19388) in bool_4 -o nat_5 with
    | true_4 => zero_6
    | false_5 =>
      (succ_7‹› ((div_19384) ((sub_13) x_19387 y_19388) y_19388))

#[program]
def rem_16‹› : nat_5 -> nat_5 -> nat_5 :=
  function rem_19392 : nat_5 -> nat_5 -> nat_5
  | x_19395 y_19396 =>
    ((sub_13) x_19395 ((mul_14) ((div_15) x_19395 y_19396) y_19396))

#[program]
def pow_17‹› : nat_5 -> nat_5 -> nat_5 :=
  function pow_19399 : nat_5 -> nat_5 -> nat_5
  | __19402 zero_6 => (succ_7‹› zero_6)
  | __19403 (succ_7 n_19404) =>
    ((mul_14) __19403 ((pow_19399) __19403 n_19404))

#[logical]
extern proto_18‹› : U

#[logical]
extern act0_19‹s_19405› :
  bool_4 ->
    ∀ (A_19407 : Type‹s_19405›) -> A_19407 -> proto_18 -> proto_18

#[logical]
extern act1_20‹s_19410› :
  bool_4 ->
    ∀ (A_19412 : Type‹s_19410›) -> A_19412 -> proto_18 -> proto_18

#[logical]
extern endp_21‹› : proto_18

#[logical]
extern ch_22‹› : bool_4 -> proto_18 -> L

#[program]
extern close_23‹› :
  ∀ {b_19417 : bool_4} -> ((ch_22) b_19417 endp_21) -> IO unit_3

#[program]
extern send0_24‹s_19419› :
  ∀ {b1_19420 : bool_4} ->
    ∀ {b2_19421 : bool_4} ->
      ∀ {A_19422 : Type‹s_19419›} ->
        ∀ {B_19423 : A_19422 -> proto_18} ->
          {(eq_1‹U› bool_4 ((xor_8) b1_19420 b2_19421) false_5)} ->
            ((ch_22)
              b1_19420 ((act0_19‹s_19419›) b2_19421 A_19422 B_19423)) ->
              ∀ {x_19427 : A_19422} -o
                IO ((ch_22) b1_19420 ((B_19423) x_19427))

#[program]
extern send1_25‹s_19428› :
  ∀ {b1_19429 : bool_4} ->
    ∀ {b2_19430 : bool_4} ->
      ∀ {A_19431 : Type‹s_19428›} ->
        ∀ {B_19432 : A_19431 -> proto_18} ->
          {(eq_1‹U› bool_4 ((xor_8) b1_19429 b2_19430) false_5)} ->
            ((ch_22)
              b1_19429 ((act1_20‹s_19428›) b2_19430 A_19431 B_19432)) ->
              ∀ (x_19436 : A_19431) -o
                IO ((ch_22) b1_19429 ((B_19432) x_19436))

#[program]
extern recv0_26‹s_19437› :
  ∀ {b1_19438 : bool_4} ->
    ∀ {b2_19439 : bool_4} ->
      ∀ {A_19440 : Type‹s_19437›} ->
        ∀ {B_19441 : A_19440 -> proto_18} ->
          {(eq_1‹U› bool_4 ((xor_8) b1_19438 b2_19439) true_4)} ->
            ((ch_22)
              b1_19438 ((act0_19‹s_19437›) b2_19439 A_19440 B_19441)) ->
              IO (exists0_7‹s_19437,L›
                   A_19440
                   function _19445 : A_19440 -> L
                   | __19447 => ((ch_22) b1_19438 ((B_19441) __19447)))

#[program]
extern recv1_27‹s_19448› :
  ∀ {b1_19449 : bool_4} ->
    ∀ {b2_19450 : bool_4} ->
      ∀ {A_19451 : Type‹s_19448›} ->
        ∀ {B_19452 : A_19451 -> proto_18} ->
          {(eq_1‹U› bool_4 ((xor_8) b1_19449 b2_19450) true_4)} ->
            ((ch_22)
              b1_19449 ((act1_20‹s_19448›) b2_19450 A_19451 B_19452)) ->
              IO (exists1_8‹s_19448,L›
                   A_19451
                   function _19456 : A_19451 -> L
                   | __19458 => ((ch_22) b1_19449 ((B_19452) __19458)))

#[program]
extern fork_28‹› :
  ∀ {b_19459 : bool_4} ->
    ∀ {P_19460 : proto_18} ->
      ((ch_22) b_19459 P_19460) -o IO unit_3 ->
        IO ((ch_22) ((not_5) b_19459) P_19460)

#[program]
def split_29‹t_19463› :
  (list_6‹U,t_19463› nat_5) ->
    ((prod1_4‹t_19463,t_19463›)
      (list_6‹U,t_19463› nat_5) (list_6‹U,t_19463› nat_5))
:=
  function split_19465 :
    (list_6‹U,t_19463› nat_5) ->
      ((prod1_4‹t_19463,t_19463›)
        (list_6‹U,t_19463› nat_5) (list_6‹U,t_19463› nat_5))
  | nil_8 =>
    (ex1_11‹t_19463,t_19463›
      (list_6‹U,t_19463› nat_5)
      function _19467 : (list_6‹U,t_19463› nat_5) -> Type‹t_19463›
      | __19469 => (list_6‹U,t_19463› nat_5) (nil_8‹U,t_19463› nat_5)
      (nil_8‹U,t_19463› nat_5))
  | (cons_9 hd_19470 nil_8) =>
    (ex1_11‹t_19463,t_19463›
      (list_6‹U,t_19463› nat_5)
      function _19471 : (list_6‹U,t_19463› nat_5) -> Type‹t_19463›
      | __19473 => (list_6‹U,t_19463› nat_5)
      (cons_9‹U,t_19463› nat_5 hd_19470 (nil_8‹U,t_19463› nat_5))
      (nil_8‹U,t_19463› nat_5))
  | (cons_9 hd_19474 (cons_9 hd_19475 tl_19476)) =>
    match ((split_19465) tl_19476) in
      ((prod1_4‹t_19463,t_19463›)
        (list_6‹U,t_19463› nat_5) (list_6‹U,t_19463› nat_5)) -o
        ((prod1_4‹t_19463,t_19463›)
          (list_6‹U,t_19463› nat_5) (list_6‹U,t_19463› nat_5))
    with
    | (ex1_11 m_19478 n_19479) =>
      (ex1_11‹t_19463,t_19463›
        (list_6‹U,t_19463› nat_5)
        function _19480 : (list_6‹U,t_19463› nat_5) -> Type‹t_19463›
        | __19482 => (list_6‹U,t_19463› nat_5)
        (cons_9‹U,t_19463› nat_5 hd_19474 m_19478)
        (cons_9‹U,t_19463› nat_5 hd_19475 n_19479))

#[program]
def merge_30‹t_19483› :
  (list_6‹U,t_19483› nat_5) ->
    (list_6‹U,t_19483› nat_5) -o (list_6‹U,t_19483› nat_5)
:=
  function merge_19486 :
    (list_6‹U,t_19483› nat_5) ->
      (list_6‹U,t_19483› nat_5) -o (list_6‹U,t_19483› nat_5)
  | nil_8 __19489 => __19489
  | (cons_9 hd_19490 tl_19491) nil_8 =>
    (cons_9‹U,t_19483› nat_5 hd_19490 tl_19491)
  | (cons_9 hd_19492 tl_19493) (cons_9 hd_19494 tl_19495) =>
    match ((lte_9) hd_19492 hd_19494) in
      bool_4 -o (list_6‹U,t_19483› nat_5)
    with
    | true_4 =>
      (cons_9‹U,t_19483›
        nat_5 hd_19492
        ((merge_19486)
          tl_19493 (cons_9‹U,t_19483› nat_5 hd_19494 tl_19495)))
    | false_5 =>
      (cons_9‹U,t_19483›
        nat_5 hd_19494
        ((merge_19486)
          (cons_9‹U,t_19483› nat_5 hd_19492 tl_19493) tl_19495))

#[program]
def msort_31‹t_19497› :
  (list_6‹U,t_19497› nat_5) -> (list_6‹U,t_19497› nat_5)
:=
  function msort_19499 :
    (list_6‹U,t_19497› nat_5) -> (list_6‹U,t_19497› nat_5)
  | nil_8 => (nil_8‹U,t_19497› nat_5)
  | (cons_9 hd_19501 nil_8) =>
    (cons_9‹U,t_19497› nat_5 hd_19501 (nil_8‹U,t_19497› nat_5))
  | (cons_9 hd_19502 (cons_9 hd_19503 tl_19504)) =>
    match ((split_29‹t_19497›)
            (cons_9‹U,t_19497›
              nat_5 hd_19502 (cons_9‹U,t_19497› nat_5 hd_19503 tl_19504))) in
      ((prod1_4‹t_19497,t_19497›)
        (list_6‹U,t_19497› nat_5) (list_6‹U,t_19497› nat_5)) -o
        (list_6‹U,t_19497› nat_5)
    with
    | (ex1_11 m_19506 n_19507) =>
      ((merge_30‹t_19497›)
        ((msort_19499) m_19506) ((msort_19499) n_19507))

#[logical]
def cmsort_ch_32‹t_19508› : (list_6‹U,t_19508› nat_5) -> L :=
  function cmsort_ch_19510 : (list_6‹U,t_19508› nat_5) -> L
  | xs_19512 =>
    ((ch_22)
      true_4
      ((act1_20‹t_19508›)
        true_4
        (sing_2‹t_19508›
          (list_6‹U,t_19508› nat_5) ((msort_31‹t_19508›) xs_19512))
        function _19513 :
          (sing_2‹t_19508›
            (list_6‹U,t_19508› nat_5) ((msort_31‹t_19508›) xs_19512)) ->
            proto_18
        | __19515 => endp_21))

#[program]
def cmsort_worker_33‹t_19516› :
  nat_5 ->
    ∀ (zs_19518 : (list_6‹U,t_19516› nat_5)) ->
      ((cmsort_ch_32‹t_19516›) zs_19518) -o IO unit_3
:=
  function cmsort_worker_19520 :
    nat_5 ->
      ∀ (zs_19522 : (list_6‹U,t_19516› nat_5)) ->
        ((cmsort_ch_32‹t_19516›) zs_19522) -o IO unit_3
  | zero_6 zs_19524 __19525 =>
    let* c_19526 :=
      ((send1_25‹t_19516›)
        true_4 true_4
        (sing_2‹t_19516›
          (list_6‹U,t_19516› nat_5) ((msort_31‹t_19516›) zs_19524))
        function _19527 :
          (sing_2‹t_19516›
            (list_6‹U,t_19516› nat_5) ((msort_31‹t_19516›) zs_19524)) ->
            proto_18
        | __19529 => endp_21 (refl_1‹U› bool_4 ((xor_8) true_4 true_4))
        __19525
        (just_2‹t_19516›
          (list_6‹U,t_19516› nat_5) ((msort_31‹t_19516›) zs_19524)))
    in ((close_23) true_4 c_19526)
  | (succ_7 n_19530) nil_8 __19531 =>
    let* c_19532 :=
      ((send1_25‹t_19516›)
        true_4 true_4
        (sing_2‹t_19516›
          (list_6‹U,t_19516› nat_5)
          ((msort_31‹t_19516›) (nil_8‹U,t_19516› nat_5)))
        function _19533 :
          (sing_2‹t_19516›
            (list_6‹U,t_19516› nat_5)
            ((msort_31‹t_19516›) (nil_8‹U,t_19516› nat_5))) ->
            proto_18
        | __19535 => endp_21 (refl_1‹U› bool_4 ((xor_8) true_4 true_4))
        __19531
        (just_2‹t_19516›
          (list_6‹U,t_19516› nat_5) (nil_8‹U,t_19516› nat_5)))
    in ((close_23) true_4 c_19532)
  | (succ_7 n_19536) (cons_9 hd_19537 nil_8) __19538 =>
    let* c_19539 :=
      ((send1_25‹t_19516›)
        true_4 true_4
        (sing_2‹t_19516›
          (list_6‹U,t_19516› nat_5)
          ((msort_31‹t_19516›)
            (cons_9‹U,t_19516›
              nat_5 hd_19537 (nil_8‹U,t_19516› nat_5))))
        function _19540 :
          (sing_2‹t_19516›
            (list_6‹U,t_19516› nat_5)
            ((msort_31‹t_19516›)
              (cons_9‹U,t_19516›
                nat_5 hd_19537 (nil_8‹U,t_19516› nat_5)))) ->
            proto_18
        | __19542 => endp_21 (refl_1‹U› bool_4 ((xor_8) true_4 true_4))
        __19538
        (just_2‹t_19516›
          (list_6‹U,t_19516› nat_5)
          (cons_9‹U,t_19516› nat_5 hd_19537 (nil_8‹U,t_19516› nat_5))))
    in ((close_23) true_4 c_19539)
  | (succ_7 n_19543) (cons_9 hd_19544 (cons_9 hd_19545 tl_19546)) __19547 =>
    match ((split_29‹t_19516›)
            (cons_9‹U,t_19516›
              nat_5 hd_19544 (cons_9‹U,t_19516› nat_5 hd_19545 tl_19546))),
    (refl_1‹t_19516›
      (list_6‹U,t_19516› nat_5)
      match ((split_29‹t_19516›)
              (cons_9‹U,t_19516›
                nat_5 hd_19544
                (cons_9‹U,t_19516› nat_5 hd_19545 tl_19546))) in
        ((prod1_4‹t_19516,t_19516›)
          (list_6‹U,t_19516› nat_5) (list_6‹U,t_19516› nat_5)) -o
          (list_6‹U,t_19516› nat_5)
      with
      | (ex1_11 m_19549 n_19550) =>
        ((merge_30‹t_19516›)
          ((msort_31‹t_19516›) m_19549) ((msort_31‹t_19516›) n_19550))) in
      ∀ (h1_19551 :
        ((prod1_4‹t_19516,t_19516›)
          (list_6‹U,t_19516› nat_5) (list_6‹U,t_19516› nat_5))) -o
        {(eq_1‹t_19516›
           (list_6‹U,t_19516› nat_5)
           match h1_19551 in
             ((prod1_4‹t_19516,t_19516›)
               (list_6‹U,t_19516› nat_5) (list_6‹U,t_19516› nat_5)) -o
               (list_6‹U,t_19516› nat_5)
           with
           | (ex1_11 m_19554 n_19555) =>
             ((merge_30‹t_19516›)
               ((msort_31‹t_19516›) m_19554)
               ((msort_31‹t_19516›) n_19555))
           match ((split_29‹t_19516›)
                   (cons_9‹U,t_19516›
                     nat_5 hd_19544
                     (cons_9‹U,t_19516› nat_5 hd_19545 tl_19546))) in
             ((prod1_4‹t_19516,t_19516›)
               (list_6‹U,t_19516› nat_5) (list_6‹U,t_19516› nat_5)) -o
               (list_6‹U,t_19516› nat_5)
           with
           | (ex1_11 m_19557 n_19558) =>
             ((merge_30‹t_19516›)
               ((msort_31‹t_19516›) m_19557)
               ((msort_31‹t_19516›) n_19558)))} -o
          IO unit_3
    with
    | (ex1_11 m_19559 n_19560), __19561 =>
      let* r1_19562 :=
        ((fork_28)
          true_4
          ((act1_20‹t_19516›)
            true_4
            (sing_2‹t_19516›
              (list_6‹U,t_19516› nat_5) ((msort_31‹t_19516›) m_19559))
            function _19563 :
              (sing_2‹t_19516›
                (list_6‹U,t_19516› nat_5)
                ((msort_31‹t_19516›) m_19559)) -> proto_18
            | __19565 => endp_21)
          function _19566 :
            ((ch_22)
              true_4
              ((act1_20‹t_19516›)
                true_4
                (sing_2‹t_19516›
                  (list_6‹U,t_19516› nat_5)
                  ((msort_31‹t_19516›) m_19559))
                function _19568 :
                  (sing_2‹t_19516›
                    (list_6‹U,t_19516› nat_5)
                    ((msort_31‹t_19516›) m_19559)) -> proto_18
                | __19570 => endp_21)) -o
              IO unit_3
          | __19571 => ((cmsort_worker_19520) n_19543 m_19559 __19571))
      in
      let* r2_19572 :=
        ((fork_28)
          true_4
          ((act1_20‹t_19516›)
            true_4
            (sing_2‹t_19516›
              (list_6‹U,t_19516› nat_5) ((msort_31‹t_19516›) n_19560))
            function _19573 :
              (sing_2‹t_19516›
                (list_6‹U,t_19516› nat_5)
                ((msort_31‹t_19516›) n_19560)) -> proto_18
            | __19575 => endp_21)
          function _19576 :
            ((ch_22)
              true_4
              ((act1_20‹t_19516›)
                true_4
                (sing_2‹t_19516›
                  (list_6‹U,t_19516› nat_5)
                  ((msort_31‹t_19516›) n_19560))
                function _19578 :
                  (sing_2‹t_19516›
                    (list_6‹U,t_19516› nat_5)
                    ((msort_31‹t_19516›) n_19560)) -> proto_18
                | __19580 => endp_21)) -o
              IO unit_3
          | __19581 => ((cmsort_worker_19520) n_19543 n_19560 __19581))
      in
      let* r1_19582 :=
        ((recv1_27‹t_19516›)
          ((not_5) true_4) true_4
          (sing_2‹t_19516›
            (list_6‹U,t_19516› nat_5) ((msort_31‹t_19516›) m_19559))
          function _19583 :
            (sing_2‹t_19516›
              (list_6‹U,t_19516› nat_5) ((msort_31‹t_19516›) m_19559)) ->
              proto_18
          | __19585 => endp_21
          (refl_1‹U› bool_4 ((xor_8) ((not_5) true_4) true_4)) r1_19562)
      in
      match r1_19582 in
        (exists1_8‹t_19516,L›
          (sing_2‹t_19516›
            (list_6‹U,t_19516› nat_5) ((msort_31‹t_19516›) m_19559))
          function _19587 :
            (sing_2‹t_19516›
              (list_6‹U,t_19516› nat_5) ((msort_31‹t_19516›) m_19559)) ->
              L
          | __19589 =>
            ((ch_22)
              ((not_5) true_4)
              ((function _19590 :
                  (sing_2‹t_19516›
                    (list_6‹U,t_19516› nat_5)
                    ((msort_31‹t_19516›) m_19559)) -> proto_18
                | __19592 => endp_21) __19589))) -o
          IO unit_3
      with
      | (ex1_11 m_19593 n_19594) =>
        let* r2_19595 :=
          ((recv1_27‹t_19516›)
            ((not_5) true_4) true_4
            (sing_2‹t_19516›
              (list_6‹U,t_19516› nat_5) ((msort_31‹t_19516›) n_19560))
            function _19596 :
              (sing_2‹t_19516›
                (list_6‹U,t_19516› nat_5)
                ((msort_31‹t_19516›) n_19560)) -> proto_18
            | __19598 => endp_21
            (refl_1‹U› bool_4 ((xor_8) ((not_5) true_4) true_4)) r2_19572)
        in
        match r2_19595 in
          (exists1_8‹t_19516,L›
            (sing_2‹t_19516›
              (list_6‹U,t_19516› nat_5) ((msort_31‹t_19516›) n_19560))
            function _19600 :
              (sing_2‹t_19516›
                (list_6‹U,t_19516› nat_5)
                ((msort_31‹t_19516›) n_19560)) -> L
            | __19602 =>
              ((ch_22)
                ((not_5) true_4)
                ((function _19603 :
                    (sing_2‹t_19516›
                      (list_6‹U,t_19516› nat_5)
                      ((msort_31‹t_19516›) n_19560)) -> proto_18
                  | __19605 => endp_21) __19602))) -o
            IO unit_3
        with
        | (ex1_11 m_19606 n_19607) =>
          match m_19593, m_19606 in
            (sing_2‹t_19516›
              (list_6‹U,t_19516› nat_5) ((msort_31‹t_19516›) m_19559)) -o
              (sing_2‹t_19516›
                (list_6‹U,t_19516› nat_5)
                ((msort_31‹t_19516›) n_19560)) -o IO unit_3
          with
          | (just_2 m_19610), (just_2 m_19611) =>
            let zs1_19612 :=
              ((just_2‹t_19516›
                 (list_6‹U,t_19516› nat_5)
                 ((merge_30‹t_19516›) m_19610 m_19611))
                : (sing_2‹t_19516›
                    (list_6‹U,t_19516› nat_5)
                    ((merge_30‹t_19516›)
                      ((msort_31‹t_19516›) m_19559)
                      ((msort_31‹t_19516›) n_19560))))
            in
            let zs1_19613 :=
              (((rwl_1‹t_19516,t_19516›)
                 (list_6‹U,t_19516› nat_5)
                 ((merge_30‹t_19516›)
                   ((msort_31‹t_19516›) m_19559)
                   ((msort_31‹t_19516›) n_19560))
                 match ((split_29‹t_19516›)
                         (cons_9‹U,t_19516›
                           nat_5 hd_19544
                           (cons_9‹U,t_19516› nat_5 hd_19545 tl_19546))) in
                   ((prod1_4‹t_19516,t_19516›)
                     (list_6‹U,t_19516› nat_5)
                     (list_6‹U,t_19516› nat_5)) -o
                     (list_6‹U,t_19516› nat_5)
                 with
                 | (ex1_11 m_19615 n_19616) =>
                   ((merge_30‹t_19516›)
                     ((msort_31‹t_19516›) m_19615)
                     ((msort_31‹t_19516›) n_19616))
                 function _19617 :
                   (list_6‹U,t_19516› nat_5) -> Type‹t_19516›
                 | __19619 =>
                   (sing_2‹t_19516›
                     (list_6‹U,t_19516› nat_5) __19619)
                 __19561 zs1_19612)
                : (sing_2‹t_19516›
                    (list_6‹U,t_19516› nat_5)
                    ((msort_31‹t_19516›)
                      (cons_9‹U,t_19516›
                        nat_5 hd_19544
                        (cons_9‹U,t_19516› nat_5 hd_19545 tl_19546)))))
            in
            let* c_19620 :=
              ((send1_25‹t_19516›)
                true_4 true_4
                (sing_2‹t_19516›
                  (list_6‹U,t_19516› nat_5)
                  ((msort_31‹t_19516›)
                    (cons_9‹U,t_19516›
                      nat_5 hd_19544
                      (cons_9‹U,t_19516› nat_5 hd_19545 tl_19546))))
                function _19621 :
                  (sing_2‹t_19516›
                    (list_6‹U,t_19516› nat_5)
                    ((msort_31‹t_19516›)
                      (cons_9‹U,t_19516›
                        nat_5 hd_19544
                        (cons_9‹U,t_19516› nat_5 hd_19545 tl_19546)))) ->
                    proto_18
                | __19623 => endp_21
                (refl_1‹U› bool_4 ((xor_8) true_4 true_4)) __19547
                zs1_19613)
            in
            let* __19624 := ((close_23) ((not_5) true_4) n_19594) in
            let* __19625 := ((close_23) ((not_5) true_4) n_19607) in
            let* __19626 := ((close_23) true_4 c_19620) in return tt_3

-----------------------------------------

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
def rwlUU_37 :=
  fun rwl_31264 {A_31265} -> {m_31266} -> {n_31267} -> {B_31268} ->
  {__31269} -> (__31270) -> match {NULL} with
                            | reflU_13  => __31270
                            end

#[program]
def rwlUL_36 :=
  fun rwl_31271 {A_31272} -> {m_31273} -> {n_31274} -> {B_31275} ->
  {__31276} -> (__31277) -> match {NULL} with
                            | reflU_13  => __31277
                            end

#[program]
def rwlLU_35 :=
  fun rwl_31278 {A_31279} -> {m_31280} -> {n_31281} -> {B_31282} ->
  {__31283} -> (__31284) -> match {NULL} with
                            | reflL_12  => __31284
                            end

#[program]
def rwlLL_34 :=
  fun rwl_31285 {A_31286} -> {m_31287} -> {n_31288} -> {B_31289} ->
  {__31290} -> (__31291) -> match {NULL} with
                            | reflL_12  => __31291
                            end

#[program]
def rwrUU_41 :=
  fun rwr_31292 {A_31293} -> {m_31294} -> {n_31295} -> {B_31296} ->
  {__31297} -> (__31298) -> match {NULL} with
                            | reflU_13  => __31298
                            end

#[program]
def rwrUL_40 :=
  fun rwr_31299 {A_31300} -> {m_31301} -> {n_31302} -> {B_31303} ->
  {__31304} -> (__31305) -> match {NULL} with
                            | reflU_13  => __31305
                            end

#[program]
def rwrLU_39 :=
  fun rwr_31306 {A_31307} -> {m_31308} -> {n_31309} -> {B_31310} ->
  {__31311} -> (__31312) -> match {NULL} with
                            | reflL_12  => __31312
                            end

#[program]
def rwrLL_38 :=
  fun rwr_31313 {A_31314} -> {m_31315} -> {n_31316} -> {B_31317} ->
  {__31318} -> (__31319) -> match {NULL} with
                            | reflL_12  => __31319
                            end

#[program]
inductive singU_12 where
| justU_15 of layout[R]

#[program]
inductive singL_11 where
| justL_14 of layout[R]

#[program]
inductive unit_3 where
| tt_3 of layout[]

#[program]
inductive bool_4 where
| true_4 of layout[]
| false_5 of layout[]

#[program]
inductive nat_5 where
| zero_6 of layout[]
| succ_7 of layout[R]

#[program]
inductive listUU_16 where
| nilUU_22 of layout[]
| consUU_23 of layout[R, R]

#[program]
inductive listUL_15 where
| nilUL_20 of layout[]
| consUL_21 of layout[R, R]

#[program]
inductive listLU_14 where
| nilLU_18 of layout[]

#[program]
inductive listLL_13 where
| nilLL_16 of layout[]
| consLL_17 of layout[R, R]

#[program]
inductive exists0UU_20 where
| ex0UU_27 of layout[N, R]

#[program]
inductive exists0UL_19 where
| ex0UL_26 of layout[N, R]

#[program]
inductive exists0LU_18 where
| ex0LU_25 of layout[N, R]

#[program]
inductive exists0LL_17 where
| ex0LL_24 of layout[N, R]

#[program]
inductive exists1UU_24 where
| ex1UU_31 of layout[R, R]

#[program]
inductive exists1UL_23 where
| ex1UL_30 of layout[R, R]

#[program]
inductive exists1LU_22 where
| ex1LU_29 of layout[R, R]

#[program]
inductive exists1LL_21 where
| ex1LL_28 of layout[R, R]

#[logical]
def prod0UU_45 := NULL

#[logical]
def prod0UL_44 := NULL

#[logical]
def prod0LU_43 := NULL

#[logical]
def prod0LL_42 := NULL

#[logical]
def prod1UU_49 := NULL

#[logical]
def prod1UL_48 := NULL

#[logical]
def prod1LU_47 := NULL

#[logical]
def prod1LL_46 := NULL

#[program]
def not_5 :=
  fun not_31320 (__31321) ->
    match __31321 with
    | true_4  => false_5 | false_5  => true_4
    end

#[program]
def and_6 :=
  fun and_31322 (__31323) -> (__31324) ->
    match __31323 with
    | true_4  =>
      match __31324 with
      | true_4  => true_4 | false_5  => false_5
      end
    | false_5  => false_5
    end

#[program]
def or_7 :=
  fun or_31325 (__31326) -> (__31327) ->
    match __31326 with
    | true_4  => true_4
    | false_5  =>
      match __31327 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def xor_8 :=
  fun xor_31328 (__31329) -> (__31330) -o
    match __31329 with
    | true_4  =>
      match __31330 with
      | true_4  => false_5 | false_5  => true_4
      end
    | false_5  =>
      match __31330 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def lte_9 :=
  fun lte_31331 (__31332) -> (__31333) ->
    match __31332 with
    | zero_6  => true_4
    | succ_7 n_31334 =>
      match __31333 with
      | zero_6  => false_5 | succ_7 n_31335 => ((lte_31331) n_31334 n_31335)
      end
    end

#[program]
def lt_10 :=
  fun lt_31336 (x_31337) -> (y_31338) -> ((lte_9) (succ_7 x_31337) y_31338)

#[program]
def pred_11 :=
  fun pred_31339 (__31340) ->
    match __31340 with
    | zero_6  => zero_6 | succ_7 n_31341 => n_31341
    end

#[program]
def add_12 :=
  fun add_31342 (__31343) -> (__31344) ->
    match __31343 with
    | zero_6  => __31344
    | succ_7 n_31345 => (succ_7 ((add_31342) n_31345 __31344))
    end

#[program]
def sub_13 :=
  fun sub_31346 (__31347) -> (__31348) ->
    match __31348 with
    | zero_6  => __31347
    | succ_7 n_31349 => ((sub_31346) ((pred_11) __31347) n_31349)
    end

#[program]
def mul_14 :=
  fun mul_31350 (__31351) -> (__31352) ->
    match __31351 with
    | zero_6  => zero_6
    | succ_7 n_31353 => ((add_12) __31352 ((mul_31350) n_31353 __31352))
    end

#[program]
def div_15 :=
  fun div_31354 (x_31355) -> (y_31356) ->
    match ((lt_10) x_31355 y_31356) with
    | true_4  => zero_6
    | false_5  => (succ_7 ((div_31354) ((sub_13) x_31355 y_31356) y_31356))
    end

#[program]
def rem_16 :=
  fun rem_31357 (x_31358) -> (y_31359) ->
    ((sub_13) x_31358 ((mul_14) ((div_15) x_31358 y_31359) y_31359))

#[program]
def pow_17 :=
  fun pow_31360 (__31361) -> (__31362) ->
    match __31362 with
    | zero_6  => (succ_7 zero_6)
    | succ_7 n_31363 => ((mul_14) __31361 ((pow_31360) __31361 n_31363))
    end

#[logical]
extern proto_18

#[logical]
extern act0U_51

#[logical]
extern act0L_50

#[logical]
extern act1U_53

#[logical]
extern act1L_52

#[logical]
extern endp_21

#[logical]
extern ch_22

#[program]
extern close_23

#[program]
extern send0U_55

#[program]
extern send0L_54

#[program]
extern send1U_57

#[program]
extern send1L_56

#[program]
extern recv0U_59

#[program]
extern recv0L_58

#[program]
extern recv1U_61

#[program]
extern recv1L_60

#[program]
extern fork_28

#[program]
def splitU_63 :=
  fun split_31364 (__31365) ->
    match __31365 with
    | nilUU_22  => (ex1UU_31 nilUU_22 nilUU_22)
    | consUU_23 hd_31366 tl_31367 =>
      match tl_31367 with
      | nilUU_22  => (ex1UU_31 (consUU_23 hd_31366 nilUU_22) nilUU_22)
      | consUU_23 hd_31368 tl_31369 =>
        match ((split_31364) tl_31369) with
        | ex1UU_31 m_31370 n_31371 =>
          (ex1UU_31
            (consUU_23 hd_31366 m_31370) (consUU_23 hd_31368 n_31371))
        end
      end
    end

#[program]
def splitL_62 :=
  fun split_31372 (__31373) ->
    match __31373 with
    | nilUL_20  => (ex1LL_28 nilUL_20 nilUL_20)
    | consUL_21 hd_31374 tl_31375 =>
      match tl_31375 with
      | nilUL_20  => (ex1LL_28 (consUL_21 hd_31374 nilUL_20) nilUL_20)
      | consUL_21 hd_31376 tl_31377 =>
        match ((split_31372) tl_31377) with
        | ex1LL_28 m_31378 n_31379 =>
          (ex1LL_28
            (consUL_21 hd_31374 m_31378) (consUL_21 hd_31376 n_31379))
        end
      end
    end

#[program]
def mergeU_65 :=
  fun merge_31380 (__31381) -> (__31382) -o
    match __31381 with
    | nilUU_22  => __31382
    | consUU_23 hd_31383 tl_31384 =>
      match __31382 with
      | nilUU_22  => (consUU_23 hd_31383 tl_31384)
      | consUU_23 hd_31385 tl_31386 =>
        match ((lte_9) hd_31383 hd_31385) with
        | true_4  =>
          (consUU_23
            hd_31383 ((merge_31380) tl_31384 (consUU_23 hd_31385 tl_31386)))
        | false_5  =>
          (consUU_23
            hd_31385 ((merge_31380) (consUU_23 hd_31383 tl_31384) tl_31386))
        end
      end
    end

#[program]
def mergeL_64 :=
  fun merge_31387 (__31388) -> (__31389) -o
    match __31388 with
    | nilUL_20  => __31389
    | consUL_21 hd_31390 tl_31391 =>
      match __31389 with
      | nilUL_20  => (consUL_21 hd_31390 tl_31391)
      | consUL_21 hd_31392 tl_31393 =>
        match ((lte_9) hd_31390 hd_31392) with
        | true_4  =>
          (consUL_21
            hd_31390 ((merge_31387) tl_31391 (consUL_21 hd_31392 tl_31393)))
        | false_5  =>
          (consUL_21
            hd_31392 ((merge_31387) (consUL_21 hd_31390 tl_31391) tl_31393))
        end
      end
    end

#[program]
def msortU_67 :=
  fun msort_31394 (__31395) ->
    match __31395 with
    | nilUU_22  => nilUU_22
    | consUU_23 hd_31396 tl_31397 =>
      match tl_31397 with
      | nilUU_22  => (consUU_23 hd_31396 nilUU_22)
      | consUU_23 hd_31398 tl_31399 =>
        match ((splitU_63)
                (consUU_23 hd_31396 (consUU_23 hd_31398 tl_31399))) with
        | ex1UU_31 m_31400 n_31401 =>
          ((mergeU_65) ((msort_31394) m_31400) ((msort_31394) n_31401))
        end
      end
    end

#[program]
def msortL_66 :=
  fun msort_31402 (__31403) ->
    match __31403 with
    | nilUL_20  => nilUL_20
    | consUL_21 hd_31404 tl_31405 =>
      match tl_31405 with
      | nilUL_20  => (consUL_21 hd_31404 nilUL_20)
      | consUL_21 hd_31406 tl_31407 =>
        match ((splitL_62)
                (consUL_21 hd_31404 (consUL_21 hd_31406 tl_31407))) with
        | ex1LL_28 m_31408 n_31409 =>
          ((mergeL_64) ((msort_31402) m_31408) ((msort_31402) n_31409))
        end
      end
    end

#[logical]
def cmsort_chU_69 := NULL

#[logical]
def cmsort_chL_68 := NULL

#[program]
def cmsort_workerU_71 :=
  fun cmsort_worker_31410 (__31411) -> (zs_31412) -> (__31413) -o
    match __31411 with
    | zero_6  =>
      let* c_31414 :=
        ((send1U_57)
          NULL NULL NULL NULL NULL __31413 (justU_15 ((msortU_67) zs_31412)))
      in ((close_23) NULL c_31414)
    | succ_7 n_31415 =>
      match zs_31412 with
      | nilUU_22  =>
        let* c_31416 :=
          ((send1U_57) NULL NULL NULL NULL NULL __31413 (justU_15 nilUU_22))
        in ((close_23) NULL c_31416)
      | consUU_23 hd_31417 tl_31418 =>
        match tl_31418 with
        | nilUU_22  =>
          let* c_31419 :=
            ((send1U_57)
              NULL NULL NULL NULL NULL __31413
              (justU_15 (consUU_23 hd_31417 nilUU_22)))
          in ((close_23) NULL c_31419)
        | consUU_23 hd_31420 tl_31421 =>
          match ((splitU_63)
                  (consUU_23 hd_31417 (consUU_23 hd_31420 tl_31421))) with
          | ex1UU_31 m_31422 n_31423 =>
            let* r1_31424 :=
              ((fork_28)
                NULL NULL
                fun _31425 (c1_31426) -o
                  ((cmsort_worker_31410) n_31415 m_31422 c1_31426))
              in
            let* r2_31427 :=
              ((fork_28)
                NULL NULL
                fun _31428 (c2_31429) -o
                  ((cmsort_worker_31410) n_31415 n_31423 c2_31429))
              in
            let* r1_31430 := ((recv1U_61) NULL NULL NULL NULL NULL r1_31424)
            in
            match r1_31430 with
            | ex1UL_30 m_31431 n_31432 =>
              let* r2_31433 :=
                ((recv1U_61) NULL NULL NULL NULL NULL r2_31427)
              in
              match r2_31433 with
              | ex1UL_30 m_31434 n_31435 =>
                match m_31431 with
                | justU_15 m_31436 =>
                  match m_31434 with
                  | justU_15 m_31437 =>
                    let zs1_31438 := (justU_15 ((mergeU_65) m_31436 m_31437))
                    in
                    let zs1_31439 :=
                      ((rwlUU_37) NULL NULL NULL NULL NULL zs1_31438)
                    in
                    let* c_31440 :=
                      ((send1U_57)
                        NULL NULL NULL NULL NULL __31413 zs1_31439)
                    in
                    let* __31441 := ((close_23) NULL n_31432) in
                    let* __31442 := ((close_23) NULL n_31435) in
                    let* __31443 := ((close_23) NULL c_31440) in return tt_3
                  end
                end
              end
            end end
          end
        end
      end

#[program]
def cmsort_workerL_70 :=
  fun cmsort_worker_31444 (__31445) -> (zs_31446) -> (__31447) -o
    match __31445 with
    | zero_6  =>
      let* c_31448 :=
        ((send1L_56)
          NULL NULL NULL NULL NULL __31447 (justL_14 ((msortL_66) zs_31446)))
      in ((close_23) NULL c_31448)
    | succ_7 n_31449 =>
      match zs_31446 with
      | nilUL_20  =>
        let* c_31450 :=
          ((send1L_56) NULL NULL NULL NULL NULL __31447 (justL_14 nilUL_20))
        in ((close_23) NULL c_31450)
      | consUL_21 hd_31451 tl_31452 =>
        match tl_31452 with
        | nilUL_20  =>
          let* c_31453 :=
            ((send1L_56)
              NULL NULL NULL NULL NULL __31447
              (justL_14 (consUL_21 hd_31451 nilUL_20)))
          in ((close_23) NULL c_31453)
        | consUL_21 hd_31454 tl_31455 =>
          match ((splitL_62)
                  (consUL_21 hd_31451 (consUL_21 hd_31454 tl_31455))) with
          | ex1LL_28 m_31456 n_31457 =>
            let* r1_31458 :=
              ((fork_28)
                NULL NULL
                fun _31459 (c1_31460) -o
                  ((cmsort_worker_31444) n_31449 m_31456 c1_31460))
              in
            let* r2_31461 :=
              ((fork_28)
                NULL NULL
                fun _31462 (c2_31463) -o
                  ((cmsort_worker_31444) n_31449 n_31457 c2_31463))
              in
            let* r1_31464 := ((recv1L_60) NULL NULL NULL NULL NULL r1_31458)
            in
            match r1_31464 with
            | ex1LL_28 m_31465 n_31466 =>
              let* r2_31467 :=
                ((recv1L_60) NULL NULL NULL NULL NULL r2_31461)
              in
              match r2_31467 with
              | ex1LL_28 m_31468 n_31469 =>
                match m_31465 with
                | justL_14 m_31470 =>
                  match m_31468 with
                  | justL_14 m_31471 =>
                    let zs1_31472 := (justL_14 ((mergeL_64) m_31470 m_31471))
                    in
                    let zs1_31473 :=
                      ((rwlLL_34) NULL NULL NULL NULL NULL zs1_31472)
                    in
                    let* c_31474 :=
                      ((send1L_56)
                        NULL NULL NULL NULL NULL __31447 zs1_31473)
                    in
                    let* __31475 := ((close_23) NULL n_31466) in
                    let* __31476 := ((close_23) NULL n_31469) in
                    let* __31477 := ((close_23) NULL c_31474) in return tt_3
                  end
                end
              end
            end end
          end
        end
      end

-----------------------------------------

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
def rwlUU_37 :=
  fun rwl_31692 {A_31693} -> {m_31694} -> {n_31695} -> {B_31696} ->
  {__31697} -> (__31698) -> __31698

#[program]
def rwlUL_36 :=
  fun rwl_31699 {A_31700} -> {m_31701} -> {n_31702} -> {B_31703} ->
  {__31704} -> (__31705) -> __31705

#[program]
def rwlLU_35 :=
  fun rwl_31706 {A_31707} -> {m_31708} -> {n_31709} -> {B_31710} ->
  {__31711} -> (__31712) -> __31712

#[program]
def rwlLL_34 :=
  fun rwl_31713 {A_31714} -> {m_31715} -> {n_31716} -> {B_31717} ->
  {__31718} -> (__31719) -> __31719

#[program]
def rwrUU_41 :=
  fun rwr_31720 {A_31721} -> {m_31722} -> {n_31723} -> {B_31724} ->
  {__31725} -> (__31726) -> __31726

#[program]
def rwrUL_40 :=
  fun rwr_31727 {A_31728} -> {m_31729} -> {n_31730} -> {B_31731} ->
  {__31732} -> (__31733) -> __31733

#[program]
def rwrLU_39 :=
  fun rwr_31734 {A_31735} -> {m_31736} -> {n_31737} -> {B_31738} ->
  {__31739} -> (__31740) -> __31740

#[program]
def rwrLL_38 :=
  fun rwr_31741 {A_31742} -> {m_31743} -> {n_31744} -> {B_31745} ->
  {__31746} -> (__31747) -> __31747

#[program]
inductive singU_12 where
| justU_15 of layout[R]

#[program]
inductive singL_11 where
| justL_14 of layout[R]

#[program]
inductive unit_3 where
| tt_3 of layout[]

#[program]
inductive bool_4 where
| true_4 of layout[]
| false_5 of layout[]

#[program]
inductive nat_5 where
| zero_6 of layout[]
| succ_7 of layout[R]

#[program]
inductive listUU_16 where
| nilUU_22 of layout[]
| consUU_23 of layout[R, R]

#[program]
inductive listUL_15 where
| nilUL_20 of layout[]
| consUL_21 of layout[R, R]

#[program]
inductive listLU_14 where
| nilLU_18 of layout[]

#[program]
inductive listLL_13 where
| nilLL_16 of layout[]
| consLL_17 of layout[R, R]

#[program]
inductive exists0UU_20 where
| ex0UU_27 of layout[N, R]

#[program]
inductive exists0UL_19 where
| ex0UL_26 of layout[N, R]

#[program]
inductive exists0LU_18 where
| ex0LU_25 of layout[N, R]

#[program]
inductive exists0LL_17 where
| ex0LL_24 of layout[N, R]

#[program]
inductive exists1UU_24 where
| ex1UU_31 of layout[R, R]

#[program]
inductive exists1UL_23 where
| ex1UL_30 of layout[R, R]

#[program]
inductive exists1LU_22 where
| ex1LU_29 of layout[R, R]

#[program]
inductive exists1LL_21 where
| ex1LL_28 of layout[R, R]

#[logical]
def prod0UU_45 := NULL

#[logical]
def prod0UL_44 := NULL

#[logical]
def prod0LU_43 := NULL

#[logical]
def prod0LL_42 := NULL

#[logical]
def prod1UU_49 := NULL

#[logical]
def prod1UL_48 := NULL

#[logical]
def prod1LU_47 := NULL

#[logical]
def prod1LL_46 := NULL

#[program]
def not_5 :=
  fun not_31748 (__31749) ->
    match __31749 with
    | true_4  => false_5 | false_5  => true_4
    end

#[program]
def and_6 :=
  fun and_31750 (__31751) -> (__31752) ->
    match __31751 with
    | true_4  =>
      match __31752 with
      | true_4  => true_4 | false_5  => false_5
      end
    | false_5  => false_5
    end

#[program]
def or_7 :=
  fun or_31753 (__31754) -> (__31755) ->
    match __31754 with
    | true_4  => true_4
    | false_5  =>
      match __31755 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def xor_8 :=
  fun xor_31756 (__31757) -> (__31758) -o
    match __31757 with
    | true_4  =>
      match __31758 with
      | true_4  => false_5 | false_5  => true_4
      end
    | false_5  =>
      match __31758 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def lte_9 :=
  fun lte_31759 (__31760) -> (__31761) ->
    match __31760 with
    | zero_6  => true_4
    | succ_7 n_31762 =>
      match __31761 with
      | zero_6  => false_5 | succ_7 n_31763 => ((lte_31759) n_31762 n_31763)
      end
    end

#[program]
def lt_10 :=
  fun lt_31764 (x_31765) -> (y_31766) -> ((lte_9) (succ_7 x_31765) y_31766)

#[program]
def pred_11 :=
  fun pred_31767 (__31768) ->
    match __31768 with
    | zero_6  => zero_6 | succ_7 n_31769 => n_31769
    end

#[program]
def add_12 :=
  fun add_31770 (__31771) -> (__31772) ->
    match __31771 with
    | zero_6  => __31772
    | succ_7 n_31773 => (succ_7 ((add_31770) n_31773 __31772))
    end

#[program]
def sub_13 :=
  fun sub_31774 (__31775) -> (__31776) ->
    match __31776 with
    | zero_6  => __31775
    | succ_7 n_31777 => ((sub_31774) ((pred_11) __31775) n_31777)
    end

#[program]
def mul_14 :=
  fun mul_31778 (__31779) -> (__31780) ->
    match __31779 with
    | zero_6  => zero_6
    | succ_7 n_31781 => ((add_12) __31780 ((mul_31778) n_31781 __31780))
    end

#[program]
def div_15 :=
  fun div_31782 (x_31783) -> (y_31784) ->
    match ((lt_10) x_31783 y_31784) with
    | true_4  => zero_6
    | false_5  => (succ_7 ((div_31782) ((sub_13) x_31783 y_31784) y_31784))
    end

#[program]
def rem_16 :=
  fun rem_31785 (x_31786) -> (y_31787) ->
    ((sub_13) x_31786 ((mul_14) ((div_15) x_31786 y_31787) y_31787))

#[program]
def pow_17 :=
  fun pow_31788 (__31789) -> (__31790) ->
    match __31790 with
    | zero_6  => (succ_7 zero_6)
    | succ_7 n_31791 => ((mul_14) __31789 ((pow_31788) __31789 n_31791))
    end

#[logical]
extern proto_18

#[logical]
extern act0U_51

#[logical]
extern act0L_50

#[logical]
extern act1U_53

#[logical]
extern act1L_52

#[logical]
extern endp_21

#[logical]
extern ch_22

#[program]
extern close_23

#[program]
extern send0U_55

#[program]
extern send0L_54

#[program]
extern send1U_57

#[program]
extern send1L_56

#[program]
extern recv0U_59

#[program]
extern recv0L_58

#[program]
extern recv1U_61

#[program]
extern recv1L_60

#[program]
extern fork_28

#[program]
def splitU_63 :=
  fun split_31792 (__31793) ->
    match __31793 with
    | nilUU_22  => (ex1UU_31 nilUU_22 nilUU_22)
    | consUU_23 hd_31794 tl_31795 =>
      match tl_31795 with
      | nilUU_22  => (ex1UU_31 (consUU_23 hd_31794 nilUU_22) nilUU_22)
      | consUU_23 hd_31796 tl_31797 =>
        match ((split_31792) tl_31797) with
        | ex1UU_31 m_31798 n_31799 =>
          (ex1UU_31
            (consUU_23 hd_31794 m_31798) (consUU_23 hd_31796 n_31799))
        end
      end
    end

#[program]
def splitL_62 :=
  fun split_31800 (__31801) ->
    match __31801 with
    | nilUL_20  => (ex1LL_28 nilUL_20 nilUL_20)
    | consUL_21 hd_31802 tl_31803 =>
      match tl_31803 with
      | nilUL_20  => (ex1LL_28 (consUL_21 hd_31802 nilUL_20) nilUL_20)
      | consUL_21 hd_31804 tl_31805 =>
        match ((split_31800) tl_31805) with
        | ex1LL_28 m_31806 n_31807 =>
          (ex1LL_28
            (consUL_21 hd_31802 m_31806) (consUL_21 hd_31804 n_31807))
        end
      end
    end

#[program]
def mergeU_65 :=
  fun merge_31808 (__31809) -> (__31810) -o
    match __31809 with
    | nilUU_22  => __31810
    | consUU_23 hd_31811 tl_31812 =>
      match __31810 with
      | nilUU_22  => (consUU_23 hd_31811 tl_31812)
      | consUU_23 hd_31813 tl_31814 =>
        match ((lte_9) hd_31811 hd_31813) with
        | true_4  =>
          (consUU_23
            hd_31811 ((merge_31808) tl_31812 (consUU_23 hd_31813 tl_31814)))
        | false_5  =>
          (consUU_23
            hd_31813 ((merge_31808) (consUU_23 hd_31811 tl_31812) tl_31814))
        end
      end
    end

#[program]
def mergeL_64 :=
  fun merge_31815 (__31816) -> (__31817) -o
    match __31816 with
    | nilUL_20  => __31817
    | consUL_21 hd_31818 tl_31819 =>
      match __31817 with
      | nilUL_20  => (consUL_21 hd_31818 tl_31819)
      | consUL_21 hd_31820 tl_31821 =>
        match ((lte_9) hd_31818 hd_31820) with
        | true_4  =>
          (consUL_21
            hd_31818 ((merge_31815) tl_31819 (consUL_21 hd_31820 tl_31821)))
        | false_5  =>
          (consUL_21
            hd_31820 ((merge_31815) (consUL_21 hd_31818 tl_31819) tl_31821))
        end
      end
    end

#[program]
def msortU_67 :=
  fun msort_31822 (__31823) ->
    match __31823 with
    | nilUU_22  => nilUU_22
    | consUU_23 hd_31824 tl_31825 =>
      match tl_31825 with
      | nilUU_22  => (consUU_23 hd_31824 nilUU_22)
      | consUU_23 hd_31826 tl_31827 =>
        match ((splitU_63)
                (consUU_23 hd_31824 (consUU_23 hd_31826 tl_31827))) with
        | ex1UU_31 m_31828 n_31829 =>
          ((mergeU_65) ((msort_31822) m_31828) ((msort_31822) n_31829))
        end
      end
    end

#[program]
def msortL_66 :=
  fun msort_31830 (__31831) ->
    match __31831 with
    | nilUL_20  => nilUL_20
    | consUL_21 hd_31832 tl_31833 =>
      match tl_31833 with
      | nilUL_20  => (consUL_21 hd_31832 nilUL_20)
      | consUL_21 hd_31834 tl_31835 =>
        match ((splitL_62)
                (consUL_21 hd_31832 (consUL_21 hd_31834 tl_31835))) with
        | ex1LL_28 m_31836 n_31837 =>
          ((mergeL_64) ((msort_31830) m_31836) ((msort_31830) n_31837))
        end
      end
    end

#[logical]
def cmsort_chU_69 := NULL

#[logical]
def cmsort_chL_68 := NULL

#[program]
def cmsort_workerU_71 :=
  fun cmsort_worker_31838 (__31839) -> (zs_31840) -> (__31841) -o
    match __31839 with
    | zero_6  =>
      let* c_31842 :=
        ((send1U_57)
          NULL NULL NULL NULL NULL __31841 (justU_15 ((msortU_67) zs_31840)))
      in ((close_23) NULL c_31842)
    | succ_7 n_31843 =>
      match zs_31840 with
      | nilUU_22  =>
        let* c_31844 :=
          ((send1U_57) NULL NULL NULL NULL NULL __31841 (justU_15 nilUU_22))
        in ((close_23) NULL c_31844)
      | consUU_23 hd_31845 tl_31846 =>
        match tl_31846 with
        | nilUU_22  =>
          let* c_31847 :=
            ((send1U_57)
              NULL NULL NULL NULL NULL __31841
              (justU_15 (consUU_23 hd_31845 nilUU_22)))
          in ((close_23) NULL c_31847)
        | consUU_23 hd_31848 tl_31849 =>
          match ((splitU_63)
                  (consUU_23 hd_31845 (consUU_23 hd_31848 tl_31849))) with
          | ex1UU_31 m_31850 n_31851 =>
            let* r1_31852 :=
              ((fork_28)
                NULL NULL
                fun _31853 (c1_31854) -o
                  ((cmsort_worker_31838) n_31843 m_31850 c1_31854))
              in
            let* r2_31855 :=
              ((fork_28)
                NULL NULL
                fun _31856 (c2_31857) -o
                  ((cmsort_worker_31838) n_31843 n_31851 c2_31857))
              in
            let* r1_31858 := ((recv1U_61) NULL NULL NULL NULL NULL r1_31852)
            in
            match r1_31858 with
            | ex1UL_30 m_31859 n_31860 =>
              let* r2_31861 :=
                ((recv1U_61) NULL NULL NULL NULL NULL r2_31855)
              in
              match r2_31861 with
              | ex1UL_30 m_31862 n_31863 =>
                match m_31859 with
                | justU_15 m_31864 =>
                  match m_31862 with
                  | justU_15 m_31865 =>
                    let zs1_31866 := (justU_15 ((mergeU_65) m_31864 m_31865))
                    in
                    let zs1_31867 :=
                      ((rwlUU_37) NULL NULL NULL NULL NULL zs1_31866)
                    in
                    let* c_31868 :=
                      ((send1U_57)
                        NULL NULL NULL NULL NULL __31841 zs1_31867)
                    in
                    let* __31869 := ((close_23) NULL n_31860) in
                    let* __31870 := ((close_23) NULL n_31863) in
                    let* __31871 := ((close_23) NULL c_31868) in return tt_3
                  end
                end
              end
            end end
          end
        end
      end

#[program]
def cmsort_workerL_70 :=
  fun cmsort_worker_31872 (__31873) -> (zs_31874) -> (__31875) -o
    match __31873 with
    | zero_6  =>
      let* c_31876 :=
        ((send1L_56)
          NULL NULL NULL NULL NULL __31875 (justL_14 ((msortL_66) zs_31874)))
      in ((close_23) NULL c_31876)
    | succ_7 n_31877 =>
      match zs_31874 with
      | nilUL_20  =>
        let* c_31878 :=
          ((send1L_56) NULL NULL NULL NULL NULL __31875 (justL_14 nilUL_20))
        in ((close_23) NULL c_31878)
      | consUL_21 hd_31879 tl_31880 =>
        match tl_31880 with
        | nilUL_20  =>
          let* c_31881 :=
            ((send1L_56)
              NULL NULL NULL NULL NULL __31875
              (justL_14 (consUL_21 hd_31879 nilUL_20)))
          in ((close_23) NULL c_31881)
        | consUL_21 hd_31882 tl_31883 =>
          match ((splitL_62)
                  (consUL_21 hd_31879 (consUL_21 hd_31882 tl_31883))) with
          | ex1LL_28 m_31884 n_31885 =>
            let* r1_31886 :=
              ((fork_28)
                NULL NULL
                fun _31887 (c1_31888) -o
                  ((cmsort_worker_31872) n_31877 m_31884 c1_31888))
              in
            let* r2_31889 :=
              ((fork_28)
                NULL NULL
                fun _31890 (c2_31891) -o
                  ((cmsort_worker_31872) n_31877 n_31885 c2_31891))
              in
            let* r1_31892 := ((recv1L_60) NULL NULL NULL NULL NULL r1_31886)
            in
            match r1_31892 with
            | ex1LL_28 m_31893 n_31894 =>
              let* r2_31895 :=
                ((recv1L_60) NULL NULL NULL NULL NULL r2_31889)
              in
              match r2_31895 with
              | ex1LL_28 m_31896 n_31897 =>
                match m_31893 with
                | justL_14 m_31898 =>
                  match m_31896 with
                  | justL_14 m_31899 =>
                    let zs1_31900 := (justL_14 ((mergeL_64) m_31898 m_31899))
                    in
                    let zs1_31901 :=
                      ((rwlLL_34) NULL NULL NULL NULL NULL zs1_31900)
                    in
                    let* c_31902 :=
                      ((send1L_56)
                        NULL NULL NULL NULL NULL __31875 zs1_31901)
                    in
                    let* __31903 := ((close_23) NULL n_31894) in
                    let* __31904 := ((close_23) NULL n_31897) in
                    let* __31905 := ((close_23) NULL c_31902) in return tt_3
                  end
                end
              end
            end end
          end
        end
      end

-----------------------------------------

