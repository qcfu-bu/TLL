[Notation {name = "|>"; body = (App [(Hole 2); (Hole 1)])};
  Notation {name = "@@"; body = (App [(Hole 1); (Hole 2)])};
  Notation {name = "="; body = (App [(Id ("eq", I)); (Hole 1); (Hole 2)])};
  Notation {name = "`"; body = (App [(Id ("sing", I)); (Hole 1)])};
  Notation {name = "&&"; body = (Id ("and", I))};
  Notation {name = "||"; body = (Id ("or", I))};
  Notation {name = "+"; body = (App [(Id ("add", I)); (Hole 1); (Hole 2)])};
  Notation {name = "-"; body = (App [(Id ("sub", I)); (Hole 1); (Hole 2)])};
  Notation {name = "*"; body = (App [(Id ("mul", I)); (Hole 1); (Hole 2)])};
  Notation {name = "/"; body = (App [(Id ("div", I)); (Hole 1); (Hole 2)])};
  Notation {name = "%"; body = (App [(Id ("rem", I)); (Hole 1); (Hole 2)])};
  Notation {name = "^"; body = (App [(Id ("pow", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<"; body = (App [(Id ("lt", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">"; body = (App [(Id ("gt", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<="; body = (App [(Id ("lte", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">="; body = (App [(Id ("gte", I)); (Hole 1); (Hole 2)])};
  Notation {name = "**";
    body =
    (App [(Inst ("prod", [(SId "_"); (SId "_"); L], I)); (Hole 1); (Hole 2)])};
  Notation {name = "::"; body = (App [(Id ("cons", I)); (Hole 1); (Hole 2)])};
  Notation {name = ";";
    body = (MLet ((Hole 1), (Binder ((PId "_"), (Hole 2)))))};
  Notation {name = "(,)"; body = (App [(Id ("pair", I)); (Hole 1); (Hole 2)])};
  Notation {name = "\226\159\168,{}\226\159\169";
    body = (App [(Id ("ex", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "unit"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)), [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
       ));
    view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "list"; relv = R;
    body =
    (Binder ([],
       (PBind ((Type U),
          (Binder ("A",
             (PBase
                ((TBase (Type U)),
                 [(DConstr ("nil",
                     (TBase (App [(Id ("list", I)); (Id ("A", I))])), 
                     []));
                   (DConstr ("cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (App [(Id ("list", I)); (Id ("A", I))]),
                               (Binder ("tl",
                                  (TBase
                                     (App [(Id ("list", I)); (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase
                              (App
                                 [(Id ("eq", I)); (Id ("m", I));
                                   (Id ("m", I))])),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "exists"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("ex",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (N,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("pf",
                                       (TBase
                                          (App
                                             [(Id ("exists", I));
                                               (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "s"))))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m",
                           (TBase (App [(Id ("sing", I)); (Id ("m", I))]))))
                        )),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "prod"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Type (SId "r")),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("pair",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R, (Id ("B", I)),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("prod", I));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [E; E]};
  Definition {name = "exists_sing"; relv = R;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U,
                          (App
                             [(Inst ("exists",
                                 [(SId "_"); (SId "_"); (SId "t")], I));
                               (Fun (
                                  (Pi (R, U, (Id ("A", I)),
                                     (Binder ("a", IMeta)))),
                                  (Binder (None,
                                     [([(PId "a")],
                                       (Some (BOpr ("=", (Id ("a", I)),
                                                (Id ("m", I))))))
                                       ]
                                     )),
                                  []))
                               ]),
                          (Binder ("_", (UOpr ("`", (Id ("m", I))))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "exists_sing"),
              [([(PId "A"); (PId "m");
                  (PBOpr ("\226\159\168,{}\226\159\169", (PId "x"),
                     (PId "refl")))
                  ],
                (Some (App [(Id ("just", I)); (Id ("x", I))])))]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U,
                       (App
                          [(Inst ("exists",
                              [(SId "_"); (SId "_"); (SId "t")], I));
                            (Fun (
                               (Pi (R, U, (Id ("A", I)),
                                  (Binder ("a", IMeta)))),
                               (Binder (None,
                                  [([(PId "a")],
                                    (Some (BOpr ("=", (Id ("a", I)),
                                             (Id ("m", I))))))
                                    ]
                                  )),
                               []))
                            ]),
                       (Binder ("_", (UOpr ("`", (Id ("m", I))))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "sing_exists"; relv = R;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                          (Binder ("_",
                             (App
                                [(Inst ("exists",
                                    [(SId "_"); (SId "_"); (SId "t")], I));
                                  (Fun (
                                     (Pi (R, U, (Id ("A", I)),
                                        (Binder ("a", IMeta)))),
                                     (Binder (None,
                                        [([(PId "a")],
                                          (Some (BOpr ("=", (Id ("a", I)),
                                                   (Id ("m", I))))))
                                          ]
                                        )),
                                     []))
                                  ])
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_exists"),
              [([(PId "A"); (PId "m"); (PConstr ("just", [(PId "x")]))],
                (Some (BOpr ("\226\159\168,{}\226\159\169", (Id ("x", I)),
                         (Id ("refl", I))))))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                       (Binder ("_",
                          (App
                             [(Inst ("exists",
                                 [(SId "_"); (SId "_"); (SId "t")], I));
                               (Fun (
                                  (Pi (R, U, (Id ("A", I)),
                                     (Binder ("a", IMeta)))),
                                  (Binder (None,
                                     [([(PId "a")],
                                       (Some (BOpr ("=", (Id ("a", I)),
                                                (Id ("m", I))))))
                                       ]
                                     )),
                                  []))
                               ])
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "sing_exists_equiv1"; relv = N;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                          (Binder ("x",
                             (BOpr ("=",
                                (App
                                   [(Id ("exists_sing", I));
                                     (App
                                        [(Inst ("sing_exists",
                                            [(SId "_"); (SId "t")], I));
                                          (Id ("x", I))])
                                     ]),
                                (Id ("x", I))))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_exists_equiv1"),
              [([(PId "A"); (PId "m"); (PConstr ("just", [(PId "x")]))],
                (Some (Id ("refl", I))))]
              )),
           [E; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                       (Binder ("x",
                          (BOpr ("=",
                             (App
                                [(Id ("exists_sing", I));
                                  (App
                                     [(Inst ("sing_exists",
                                         [(SId "_"); (SId "t")], I));
                                       (Id ("x", I))])
                                  ]),
                             (Id ("x", I))))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "sing_exists_equiv2"; relv = N;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U,
                          (App
                             [(Inst ("exists",
                                 [(SId "_"); (SId "_"); (SId "t")], I));
                               (Fun (
                                  (Pi (R, U, (Id ("A", I)),
                                     (Binder ("a", IMeta)))),
                                  (Binder (None,
                                     [([(PId "a")],
                                       (Some (BOpr ("=", (Id ("a", I)),
                                                (Id ("m", I))))))
                                       ]
                                     )),
                                  []))
                               ]),
                          (Binder ("x",
                             (BOpr ("=",
                                (App
                                   [(Id ("sing_exists", I));
                                     (App
                                        [(Id ("exists_sing", I));
                                          (Id ("x", I))])
                                     ]),
                                (Id ("x", I))))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_exists_equiv2"),
              [([(PId "A"); (PId "m");
                  (PBOpr ("\226\159\168,{}\226\159\169", (PId "x"),
                     (PId "refl")))
                  ],
                (Some (Id ("refl", I))))]
              )),
           [E; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U,
                       (App
                          [(Inst ("exists",
                              [(SId "_"); (SId "_"); (SId "t")], I));
                            (Fun (
                               (Pi (R, U, (Id ("A", I)),
                                  (Binder ("a", IMeta)))),
                               (Binder (None,
                                  [([(PId "a")],
                                    (Some (BOpr ("=", (Id ("a", I)),
                                             (Id ("m", I))))))
                                    ]
                                  )),
                               []))
                            ]),
                       (Binder ("x",
                          (BOpr ("=",
                             (App
                                [(Id ("sing_exists", I));
                                  (App
                                     [(Id ("exists_sing", I)); (Id ("x", I))])
                                  ]),
                             (Id ("x", I))))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "sing_double"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                          (Binder ("_",
                             (Pi (R, L, (UOpr ("`", (Id ("m", I)))),
                                (Binder ("_",
                                   (BOpr ("**", (Id ("A", I)), (Id ("A", I))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_double"),
              [([(PId "A"); (PId "m"); (PConstr ("just", [(PId "x")]));
                  (PConstr ("just", [(PId "y")]))],
                (Some (Let (N,
                         (Ann ((Id ("refl", I)),
                            (BOpr ("=", (Id ("x", I)), (Id ("y", I)))))),
                         (Binder ((PId "pf"),
                            (BOpr ("(,)", (Id ("x", I)), (Id ("y", I))))))
                         ))))
                ]
              )),
           [E; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                       (Binder ("_",
                          (Pi (R, L, (UOpr ("`", (Id ("m", I)))),
                             (Binder ("_",
                                (BOpr ("**", (Id ("A", I)), (Id ("A", I))))))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "axiom_K"; relv = N;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type U),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (BOpr ("=", (Id ("m", I)), (Id ("m", I)))),
                          (Binder ("x",
                             (BOpr ("=", (Id ("x", I)), (Id ("refl", I))))))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "axiom_K"),
              [([(PId "A"); (PId "m"); (PId "refl")], (Some (Id ("refl", I))))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type U),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (BOpr ("=", (Id ("m", I)), (Id ("m", I)))),
                       (Binder ("x",
                          (BOpr ("=", (Id ("x", I)), (Id ("refl", I))))))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]}
  ]

-----------------------------------------

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_136 : nat_3) : nat_3

#[program]
inductive list_4‹› (A_137 : U): U where
| nil_6 : (list_4 A_137)
| cons_7 (hd_138 : A_137) (tl_139 : (list_4 A_137)) : (list_4 A_137)

#[logical]
inductive eq_5‹s_140› (A_141 : Type‹s_140›) (m_142 : A_141):
  A_141 -> U
where
| refl_8 : (eq_5‹??_1› ?_1[0;0] m_142 m_142)

#[program]
inductive exists_6‹s_144,r_145,t_146› (A_147 : Type‹s_144›) (B_148 : 
A_147 -> Type‹r_145›): Type‹t_146› where
| ex_9
    (m_150 : A_147) {pf_151 : ((B_148) m_150)}
    : (exists_6‹??_2,??_3,??_4› ?_2[0;0] B_148)

#[program]
inductive sing_7‹s_152› (A_153 : Type‹s_152›):
  A_153 -> Type‹s_152›
where
| just_10 (m_155 : A_153) : (sing_7‹??_5› ?_3[0;0] m_155)

#[program]
inductive prod_8‹s_156,r_157,t_158› (A_159 : Type‹s_156›) (B_160 : Type‹r_157›):
  Type‹t_158›
where
| pair_11
    (m_161 : A_159) (n_162 : B_160)
    : (prod_8‹??_6,??_7,??_8› A_159 B_160)

#[program]
def exists_sing_1‹s_163,t_164› :
  ∀ {A_165 : Type‹s_163›} ->
    ∀ {m_166 : A_165} ->
      (exists_6‹??_14,??_15,t_164›
        ?_11[0;0]
        function _168 : A_165 -> ?_9[0;0]
        | a_170 => (eq_5‹??_16› ?_10[0;0] a_170 m_166)) ->
        (sing_7‹??_17› ?_12[0;0] m_166)
:=
  function exists_sing_171 :
    ∀ {A_172 : Type‹s_163›} ->
      ∀ {m_173 : A_172} ->
        (exists_6‹??_9,??_10,t_164›
          ?_6[0;0]
          function _175 : A_172 -> ?_4[0;0]
          | a_177 => (eq_5‹??_11› ?_5[0;0] a_177 m_173)) ->
          (sing_7‹??_12› ?_7[0;0] m_173)
  | A_178 m_179 (ex_9 x_180 refl_8) => (just_10‹??_13› ?_8[0;0] x_180)

#[program]
def sing_exists_2‹s_181,t_182› :
  ∀ {A_183 : Type‹s_181›} ->
    ∀ {m_184 : A_183} ->
      (sing_7‹??_26› ?_21[0;0] m_184) ->
        (exists_6‹??_27,??_28,t_182›
          ?_24[0;0]
          function _186 : A_183 -> ?_22[0;0]
          | a_188 => (eq_5‹??_29› ?_23[0;0] a_188 m_184))
:=
  function sing_exists_189 :
    ∀ {A_190 : Type‹s_181›} ->
      ∀ {m_191 : A_190} ->
        (sing_7‹??_18› ?_13[0;0] m_191) ->
          (exists_6‹??_19,??_20,t_182›
            ?_16[0;0]
            function _193 : A_190 -> ?_14[0;0]
            | a_195 => (eq_5‹??_21› ?_15[0;0] a_195 m_191))
  | A_196 m_197 (just_10 x_198) =>
    (ex_9‹??_23,??_24,??_25›
      ?_19[0;0] ?_20[0;0] x_198 (refl_8‹??_22› ?_17[0;0] ?_18[0;0]))

#[logical]
def sing_exists_equiv1_3‹s_199,t_200› :
  ∀ {A_201 : Type‹s_199›} ->
    ∀ {m_202 : A_201} ->
      ∀ (x_203 : (sing_7‹??_36› ?_33[0;0] m_202)) ->
        (eq_5‹??_40›
          ?_38[0;0]
          ((exists_sing_1‹??_38,??_39›)
            ?_37[0;0] ?_36[0;0]
            ((sing_exists_2‹??_37,t_200›) ?_35[0;0] ?_34[0;0] x_203))
          x_203)
:=
  function sing_exists_equiv1_204 :
    ∀ {A_205 : Type‹s_199›} ->
      ∀ {m_206 : A_205} ->
        ∀ (x_207 : (sing_7‹??_30› ?_25[0;0] m_206)) ->
          (eq_5‹??_34›
            ?_30[0;0]
            ((exists_sing_1‹??_32,??_33›)
              ?_29[0;0] ?_28[0;0]
              ((sing_exists_2‹??_31,t_200›) ?_27[0;0] ?_26[0;0] x_207))
            x_207)
  | A_208 m_209 (just_10 x_210) => (refl_8‹??_35› ?_31[0;0] ?_32[0;0])

#[logical]
def sing_exists_equiv2_4‹s_211,t_212› :
  ∀ {A_213 : Type‹s_211›} ->
    ∀ {m_214 : A_213} ->
      ∀ (x_215 :
        (exists_6‹??_50,??_51,t_212›
          ?_51[0;0]
          function _216 : A_213 -> ?_49[0;0]
          | a_218 => (eq_5‹??_52› ?_50[0;0] a_218 m_214))) ->
        (eq_5‹??_57›
          ?_56[0;0]
          ((sing_exists_2‹??_55,??_56›)
            ?_55[0;0] ?_54[0;0]
            ((exists_sing_1‹??_53,??_54›) ?_53[0;0] ?_52[0;0] x_215))
          x_215)
:=
  function sing_exists_equiv2_219 :
    ∀ {A_220 : Type‹s_211›} ->
      ∀ {m_221 : A_220} ->
        ∀ (x_222 :
          (exists_6‹??_41,??_42,t_212›
            ?_41[0;0]
            function _223 : A_220 -> ?_39[0;0]
            | a_225 => (eq_5‹??_43› ?_40[0;0] a_225 m_221))) ->
          (eq_5‹??_48›
            ?_46[0;0]
            ((sing_exists_2‹??_46,??_47›)
              ?_45[0;0] ?_44[0;0]
              ((exists_sing_1‹??_44,??_45›) ?_43[0;0] ?_42[0;0] x_222))
            x_222)
  | A_226 m_227 (ex_9 x_228 refl_8) =>
    (refl_8‹??_49› ?_47[0;0] ?_48[0;0])

#[program]
def sing_double_5‹s_229› :
  ∀ {A_230 : Type‹s_229›} ->
    ∀ {m_231 : A_230} ->
      (sing_7‹??_67› ?_64[0;0] m_231) ->
        (sing_7‹??_68› ?_65[0;0] m_231) -o
          (prod_8‹??_69,??_70,L› A_230 A_230)
:=
  function sing_double_234 :
    ∀ {A_235 : Type‹s_229›} ->
      ∀ {m_236 : A_235} ->
        (sing_7‹??_58› ?_57[0;0] m_236) ->
          (sing_7‹??_59› ?_58[0;0] m_236) -o
            (prod_8‹??_60,??_61,L› A_235 A_235)
  | A_239 m_240 (just_10 x_241) (just_10 y_242) =>
    let {pf_243} :=
      ((refl_8‹??_62› ?_59[0;0] ?_60[0;0])
        : (eq_5‹??_63› ?_61[0;0] x_241 y_242))
    in (pair_11‹??_64,??_65,??_66› ?_62[0;0] ?_63[0;0] x_241 y_242)

#[logical]
def axiom_K_6‹› :
  ∀ {A_244 : U} ->
    ∀ {m_245 : A_244} ->
      ∀ (x_246 : (eq_5‹??_75› ?_72[0;0] m_245 m_245)) ->
        (eq_5‹??_77›
          ?_75[0;0] x_246 (refl_8‹??_76› ?_73[0;0] ?_74[0;0]))
:=
  function axiom_K_247 :
    ∀ {A_248 : U} ->
      ∀ {m_249 : A_248} ->
        ∀ (x_250 : (eq_5‹??_71› ?_66[0;0] m_249 m_249)) ->
          (eq_5‹??_73›
            ?_69[0;0] x_250 (refl_8‹??_72› ?_67[0;0] ?_68[0;0]))
  | A_251 m_252 refl_8 => (refl_8‹??_74› ?_70[0;0] ?_71[0;0])

-----------------------------------------

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_4138 : nat_3) : nat_3

#[program]
inductive list_4‹› (A_4139 : U): U where
| nil_6 : (list_4 A_4139)
| cons_7 (hd_4140 : A_4139) (tl_4141 : (list_4 A_4139)) : (list_4 A_4139)

#[logical]
inductive eq_5‹s_4142› (A_4143 : Type‹s_4142›) (m_4144 : A_4143):
  A_4143 -> U
where
| refl_8 : (eq_5‹s_4142› A_4143 m_4144 m_4144)

#[program]
inductive exists_6‹s_4146,r_4147,t_4148› (A_4149 : Type‹s_4146›) (B_4150 : 
A_4149 -> Type‹r_4147›): Type‹t_4148› where
| ex_9
    (m_4152 : A_4149) {pf_4153 : ((B_4150) m_4152)}
    : (exists_6‹s_4146,r_4147,t_4148› A_4149 B_4150)

#[program]
inductive sing_7‹s_4154› (A_4155 : Type‹s_4154›):
  A_4155 -> Type‹s_4154›
where
| just_10 (m_4157 : A_4155) : (sing_7‹s_4154› A_4155 m_4157)

#[program]
inductive prod_8‹s_4158,r_4159,t_4160› (A_4161 : Type‹s_4158›) (B_4162 : Type‹r_4159›):
  Type‹t_4160›
where
| pair_11
    (m_4163 : A_4161) (n_4164 : B_4162)
    : (prod_8‹s_4158,r_4159,t_4160› A_4161 B_4162)

#[program]
def exists_sing_1‹s_4165,t_4166› :
  ∀ {A_4167 : Type‹s_4165›} ->
    ∀ {m_4168 : A_4167} ->
      (exists_6‹s_4165,U,t_4166›
        A_4167
        function _4170 : A_4167 -> U
        | __4172 => (eq_5‹s_4165› A_4167 __4172 m_4168)) ->
        (sing_7‹s_4165› A_4167 m_4168)
:=
  function exists_sing_4173 :
    ∀ {A_4174 : Type‹s_4165›} ->
      ∀ {m_4175 : A_4174} ->
        (exists_6‹s_4165,U,t_4166›
          A_4174
          function _4177 : A_4174 -> U
          | __4179 => (eq_5‹s_4165› A_4174 __4179 m_4175)) ->
          (sing_7‹s_4165› A_4174 m_4175)
  | A_4180 m_4181 (ex_9 m_4182 refl_8) => (just_10‹s_4165› A_4180 m_4182)

#[program]
def sing_exists_2‹s_4183,t_4184› :
  ∀ {A_4185 : Type‹s_4183›} ->
    ∀ {m_4186 : A_4185} ->
      (sing_7‹s_4183› A_4185 m_4186) ->
        (exists_6‹s_4183,U,t_4184›
          A_4185
          function _4188 : A_4185 -> U
          | __4190 => (eq_5‹s_4183› A_4185 __4190 m_4186))
:=
  function sing_exists_4191 :
    ∀ {A_4192 : Type‹s_4183›} ->
      ∀ {m_4193 : A_4192} ->
        (sing_7‹s_4183› A_4192 m_4193) ->
          (exists_6‹s_4183,U,t_4184›
            A_4192
            function _4195 : A_4192 -> U
            | __4197 => (eq_5‹s_4183› A_4192 __4197 m_4193))
  | A_4198 m_4199 (just_10 m_4200) =>
    (ex_9‹s_4183,U,t_4184›
      A_4198
      function _4201 : A_4198 -> U
      | __4203 => (eq_5‹s_4183› A_4198 __4203 m_4200) m_4200
      (refl_8‹s_4183› A_4198 m_4200))

#[logical]
def sing_exists_equiv1_3‹s_4204,t_4205› :
  ∀ {A_4206 : Type‹s_4204›} ->
    ∀ {m_4207 : A_4206} ->
      ∀ (x_4208 : (sing_7‹s_4204› A_4206 m_4207)) ->
        (eq_5‹s_4204›
          (sing_7‹s_4204› A_4206 m_4207)
          ((exists_sing_1‹s_4204,t_4205›)
            A_4206 m_4207
            ((sing_exists_2‹s_4204,t_4205›) A_4206 m_4207 x_4208))
          x_4208)
:=
  function sing_exists_equiv1_4209 :
    ∀ {A_4210 : Type‹s_4204›} ->
      ∀ {m_4211 : A_4210} ->
        ∀ (x_4212 : (sing_7‹s_4204› A_4210 m_4211)) ->
          (eq_5‹s_4204›
            (sing_7‹s_4204› A_4210 m_4211)
            ((exists_sing_1‹s_4204,t_4205›)
              A_4210 m_4211
              ((sing_exists_2‹s_4204,t_4205›) A_4210 m_4211 x_4212))
            x_4212)
  | A_4213 m_4214 (just_10 m_4215) =>
    (refl_8‹s_4204›
      (sing_7‹s_4204› A_4213 m_4215)
      ((exists_sing_1‹s_4204,t_4205›)
        A_4213 m_4215
        ((sing_exists_2‹s_4204,t_4205›)
          A_4213 m_4215 (just_10‹s_4204› A_4213 m_4215))))

#[logical]
def sing_exists_equiv2_4‹s_4216,t_4217› :
  ∀ {A_4218 : Type‹s_4216›} ->
    ∀ {m_4219 : A_4218} ->
      ∀ (x_4220 :
        (exists_6‹s_4216,U,t_4217›
          A_4218
          function _4221 : A_4218 -> U
          | __4223 => (eq_5‹s_4216› A_4218 __4223 m_4219))) ->
        (eq_5‹t_4217›
          (exists_6‹s_4216,U,t_4217›
            A_4218
            function _4224 : A_4218 -> U
            | __4226 => (eq_5‹s_4216› A_4218 __4226 m_4219))
          ((sing_exists_2‹s_4216,t_4217›)
            A_4218 m_4219
            ((exists_sing_1‹s_4216,t_4217›) A_4218 m_4219 x_4220))
          x_4220)
:=
  function sing_exists_equiv2_4227 :
    ∀ {A_4228 : Type‹s_4216›} ->
      ∀ {m_4229 : A_4228} ->
        ∀ (x_4230 :
          (exists_6‹s_4216,U,t_4217›
            A_4228
            function _4231 : A_4228 -> U
            | __4233 => (eq_5‹s_4216› A_4228 __4233 m_4229))) ->
          (eq_5‹t_4217›
            (exists_6‹s_4216,U,t_4217›
              A_4228
              function _4234 : A_4228 -> U
              | __4236 => (eq_5‹s_4216› A_4228 __4236 m_4229))
            ((sing_exists_2‹s_4216,t_4217›)
              A_4228 m_4229
              ((exists_sing_1‹s_4216,t_4217›) A_4228 m_4229 x_4230))
            x_4230)
  | A_4237 m_4238 (ex_9 m_4239 refl_8) =>
    (refl_8‹t_4217›
      (exists_6‹s_4216,U,t_4217›
        A_4237
        function _4240 : A_4237 -> U
        | __4242 => (eq_5‹s_4216› A_4237 __4242 m_4239))
      ((sing_exists_2‹s_4216,t_4217›)
        A_4237 m_4239
        ((exists_sing_1‹s_4216,t_4217›)
          A_4237 m_4239
          (ex_9‹s_4216,U,t_4217›
            A_4237
            function _4243 : A_4237 -> U
            | __4245 => (eq_5‹s_4216› A_4237 __4245 m_4239) m_4239
            (refl_8‹s_4216› A_4237 m_4239)))))

#[program]
def sing_double_5‹s_4246› :
  ∀ {A_4247 : Type‹s_4246›} ->
    ∀ {m_4248 : A_4247} ->
      (sing_7‹s_4246› A_4247 m_4248) ->
        (sing_7‹s_4246› A_4247 m_4248) -o
          (prod_8‹s_4246,s_4246,L› A_4247 A_4247)
:=
  function sing_double_4251 :
    ∀ {A_4252 : Type‹s_4246›} ->
      ∀ {m_4253 : A_4252} ->
        (sing_7‹s_4246› A_4252 m_4253) ->
          (sing_7‹s_4246› A_4252 m_4253) -o
            (prod_8‹s_4246,s_4246,L› A_4252 A_4252)
  | A_4256 m_4257 (just_10 m_4258) (just_10 m_4259) =>
    let {pf_4260} :=
      ((refl_8‹s_4246› A_4256 m_4258)
        : (eq_5‹s_4246› A_4256 m_4258 m_4259))
    in (pair_11‹s_4246,s_4246,L› A_4256 A_4256 m_4258 m_4259)

#[logical]
def axiom_K_6‹› :
  ∀ {A_4261 : U} ->
    ∀ {m_4262 : A_4261} ->
      ∀ (x_4263 : (eq_5‹U› A_4261 m_4262 m_4262)) ->
        (eq_5‹U›
          (eq_5‹U› A_4261 m_4262 m_4262) x_4263
          (refl_8‹U› A_4261 m_4262))
:=
  function axiom_K_4264 :
    ∀ {A_4265 : U} ->
      ∀ {m_4266 : A_4265} ->
        ∀ (x_4267 : (eq_5‹U› A_4265 m_4266 m_4266)) ->
          (eq_5‹U›
            (eq_5‹U› A_4265 m_4266 m_4266) x_4267
            (refl_8‹U› A_4265 m_4266))
  | A_4268 m_4269 refl_8 =>
    (refl_8‹U›
      (eq_5‹U› A_4268 m_4269 m_4269) (refl_8‹U› A_4268 m_4269))

-----------------------------------------

#[program]
inductive unit_1 where
| tt_1 of layout[]

#[program]
inductive bool_2 where
| true_2 of layout[]
| false_3 of layout[]

#[program]
inductive nat_3 where
| zero_4 of layout[]
| succ_5 of layout[R]

#[program]
inductive list_4 where
| nil_6 of layout[]
| cons_7 of layout[R, R]

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
inductive existsUUU_18 where
| exUUU_21 of layout[R, N]

#[program]
inductive existsUUL_17 where
| exUUL_20 of layout[R, N]

#[program]
inductive existsULU_16 where
| exULU_19 of layout[R, N]

#[program]
inductive existsULL_15 where
| exULL_18 of layout[R, N]

#[program]
inductive existsLUU_14 where


#[program]
inductive existsLUL_13 where
| exLUL_16 of layout[R, N]

#[program]
inductive existsLLU_12 where


#[program]
inductive existsLLL_11 where
| exLLL_14 of layout[R, N]

#[program]
inductive singU_20 where
| justU_23 of layout[R]

#[program]
inductive singL_19 where
| justL_22 of layout[R]

#[program]
inductive prodUUU_28 where
| pairUUU_31 of layout[R, R]

#[program]
inductive prodUUL_27 where
| pairUUL_30 of layout[R, R]

#[program]
inductive prodULU_26 where


#[program]
inductive prodULL_25 where
| pairULL_28 of layout[R, R]

#[program]
inductive prodLUU_24 where


#[program]
inductive prodLUL_23 where
| pairLUL_26 of layout[R, R]

#[program]
inductive prodLLU_22 where


#[program]
inductive prodLLL_21 where
| pairLLL_24 of layout[R, R]

#[program]
def exists_singUU_10 :=
  fun exists_sing_7128 {A_7129} -> {m_7130} -> (__7131) ->
    match __7131 with
    | exUUU_21 m_7132 pf_7133 =>
      match {NULL} with
      | reflU_13  => (justU_23 m_7132)
      end
    end

#[program]
def exists_singUL_9 :=
  fun exists_sing_7134 {A_7135} -> {m_7136} -> (__7137) ->
    match __7137 with
    | exUUL_20 m_7138 pf_7139 =>
      match {NULL} with
      | reflU_13  => (justU_23 m_7138)
      end
    end

#[program]
def exists_singLU_8 :=
  fun exists_sing_7140 {A_7141} -> {m_7142} -> (__7143) ->
    match __7143 with
    
    end

#[program]
def exists_singLL_7 :=
  fun exists_sing_7144 {A_7145} -> {m_7146} -> (__7147) ->
    match __7147 with
    | exLUL_16 m_7148 pf_7149 =>
      match {NULL} with
      | reflL_12  => (justL_22 m_7148)
      end
    end

#[program]
def sing_existsUU_14 :=
  fun sing_exists_7150 {A_7151} -> {m_7152} -> (__7153) ->
    match __7153 with
    | justU_23 m_7154 => (exUUU_21 m_7154 NULL)
    end

#[program]
def sing_existsUL_13 :=
  fun sing_exists_7155 {A_7156} -> {m_7157} -> (__7158) ->
    match __7158 with
    | justU_23 m_7159 => (exUUL_20 m_7159 NULL)
    end

#[program]
def sing_existsLL_11 :=
  fun sing_exists_7160 {A_7161} -> {m_7162} -> (__7163) ->
    match __7163 with
    | justL_22 m_7164 => (exLUL_16 m_7164 NULL)
    end

#[logical]
def sing_exists_equiv1UU_18 := NULL

#[logical]
def sing_exists_equiv1UL_17 := NULL

#[logical]
def sing_exists_equiv1LL_15 := NULL

#[logical]
def sing_exists_equiv2UU_22 := NULL

#[logical]
def sing_exists_equiv2UL_21 := NULL

#[logical]
def sing_exists_equiv2LL_19 := NULL

#[program]
def sing_doubleU_24 :=
  fun sing_double_7165 {A_7166} -> {m_7167} -> (__7168) -> (__7169) -o
    match __7168 with
    | justU_23 m_7170 =>
      match __7169 with
      | justU_23 m_7171 => (pairUUL_30 m_7170 m_7171)
      end
    end

#[program]
def sing_doubleL_23 :=
  fun sing_double_7172 {A_7173} -> {m_7174} -> (__7175) -> (__7176) -o
    match __7175 with
    | justL_22 m_7177 =>
      match __7176 with
      | justL_22 m_7178 => (pairLLL_24 m_7177 m_7178)
      end
    end

#[logical]
def axiom_K_6 := NULL

-----------------------------------------

#[program]
inductive unit_1 where
| tt_1 of layout[]

#[program]
inductive bool_2 where
| true_2 of layout[]
| false_3 of layout[]

#[program]
inductive nat_3 where
| zero_4 of layout[]
| succ_5 of layout[R]

#[program]
inductive list_4 where
| nil_6 of layout[]
| cons_7 of layout[R, R]

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
inductive existsUUU_18 where
| exUUU_21 of layout[R, N]

#[program]
inductive existsUUL_17 where
| exUUL_20 of layout[R, N]

#[program]
inductive existsULU_16 where
| exULU_19 of layout[R, N]

#[program]
inductive existsULL_15 where
| exULL_18 of layout[R, N]

#[program]
inductive existsLUU_14 where


#[program]
inductive existsLUL_13 where
| exLUL_16 of layout[R, N]

#[program]
inductive existsLLU_12 where


#[program]
inductive existsLLL_11 where
| exLLL_14 of layout[R, N]

#[program]
inductive singU_20 where
| justU_23 of layout[R]

#[program]
inductive singL_19 where
| justL_22 of layout[R]

#[program]
inductive prodUUU_28 where
| pairUUU_31 of layout[R, R]

#[program]
inductive prodUUL_27 where
| pairUUL_30 of layout[R, R]

#[program]
inductive prodULU_26 where


#[program]
inductive prodULL_25 where
| pairULL_28 of layout[R, R]

#[program]
inductive prodLUU_24 where


#[program]
inductive prodLUL_23 where
| pairLUL_26 of layout[R, R]

#[program]
inductive prodLLU_22 where


#[program]
inductive prodLLL_21 where
| pairLLL_24 of layout[R, R]

#[program]
def exists_singUU_10 :=
  fun exists_sing_7230 {A_7231} -> {m_7232} -> (__7233) ->
    match __7233 with
    | exUUU_21 m_7234 pf_7235 => (justU_23 m_7234)
    end

#[program]
def exists_singUL_9 :=
  fun exists_sing_7236 {A_7237} -> {m_7238} -> (__7239) ->
    match __7239 with
    | exUUL_20 m_7240 pf_7241 => (justU_23 m_7240)
    end

#[program]
def exists_singLU_8 :=
  fun exists_sing_7242 {A_7243} -> {m_7244} -> (__7245) -> !!

#[program]
def exists_singLL_7 :=
  fun exists_sing_7246 {A_7247} -> {m_7248} -> (__7249) ->
    match __7249 with
    | exLUL_16 m_7250 pf_7251 => (justL_22 m_7250)
    end

#[program]
def sing_existsUU_14 :=
  fun sing_exists_7252 {A_7253} -> {m_7254} -> (__7255) ->
    match __7255 with
    | justU_23 m_7256 => (exUUU_21 m_7256 NULL)
    end

#[program]
def sing_existsUL_13 :=
  fun sing_exists_7257 {A_7258} -> {m_7259} -> (__7260) ->
    match __7260 with
    | justU_23 m_7261 => (exUUL_20 m_7261 NULL)
    end

#[program]
def sing_existsLL_11 :=
  fun sing_exists_7262 {A_7263} -> {m_7264} -> (__7265) ->
    match __7265 with
    | justL_22 m_7266 => (exLUL_16 m_7266 NULL)
    end

#[logical]
def sing_exists_equiv1UU_18 := NULL

#[logical]
def sing_exists_equiv1UL_17 := NULL

#[logical]
def sing_exists_equiv1LL_15 := NULL

#[logical]
def sing_exists_equiv2UU_22 := NULL

#[logical]
def sing_exists_equiv2UL_21 := NULL

#[logical]
def sing_exists_equiv2LL_19 := NULL

#[program]
def sing_doubleU_24 :=
  fun sing_double_7267 {A_7268} -> {m_7269} -> (__7270) -> (__7271) -o
    match __7270 with
    | justU_23 m_7272 =>
      match __7271 with
      | justU_23 m_7273 => (pairUUL_30 m_7272 m_7273)
      end
    end

#[program]
def sing_doubleL_23 :=
  fun sing_double_7274 {A_7275} -> {m_7276} -> (__7277) -> (__7278) -o
    match __7277 with
    | justL_22 m_7279 =>
      match __7278 with
      | justL_22 m_7280 => (pairLLL_24 m_7279 m_7280)
      end
    end

#[logical]
def axiom_K_6 := NULL

-----------------------------------------

