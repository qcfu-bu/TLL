[Notation {name = "|>"; body = (App [(Hole 2); (Hole 1)])};
  Notation {name = "@@"; body = (App [(Hole 1); (Hole 2)])};
  Notation {name = "="; body = (App [(Id ("eq", I)); (Hole 1); (Hole 2)])};
  Notation {name = "`"; body = (App [(Id ("sing", I)); (Hole 1)])};
  Notation {name = "&&"; body = (App [(Id ("and", I)); (Hole 1); (Hole 2)])};
  Notation {name = "||"; body = (App [(Id ("or", I)); (Hole 1); (Hole 2)])};
  Notation {name = "+"; body = (App [(Id ("add", I)); (Hole 1); (Hole 2)])};
  Notation {name = "-"; body = (App [(Id ("sub", I)); (Hole 1); (Hole 2)])};
  Notation {name = "*"; body = (App [(Id ("mul", I)); (Hole 1); (Hole 2)])};
  Notation {name = "/"; body = (App [(Id ("div", I)); (Hole 1); (Hole 2)])};
  Notation {name = "%"; body = (App [(Id ("rem", I)); (Hole 1); (Hole 2)])};
  Notation {name = "^"; body = (App [(Id ("pow", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<"; body = (App [(Id ("lt", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">"; body = (App [(Id ("gt", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<="; body = (App [(Id ("lte", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">="; body = (App [(Id ("gte", I)); (Hole 1); (Hole 2)])};
  Notation {name = "\195\151";
    body = (App [(Id ("prod1", I)); (Hole 1); (Hole 2)])};
  Notation {name = "::"; body = (App [(Id ("cons", I)); (Hole 1); (Hole 2)])};
  Notation {name = ";";
    body = (MLet ((Hole 1), (Binder ((PId "_"), (Hole 2)))))};
  Notation {name = "\226\159\168{},\226\159\169";
    body = (App [(Id ("ex0", I)); (Hole 1); (Hole 2)])};
  Notation {name = "\226\159\168,\226\159\169";
    body = (App [(Id ("ex1", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase (BOpr ("=", (Id ("m", I)), (Id ("m", I))))),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "rwl"; relv = R;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (N, U, (Id ("A", I)),
                          (Binder ("n",
                             (Pi (N, U,
                                (Pi (R, U, (Id ("A", I)),
                                   (Binder ("_", (Type (SId "r")))))),
                                (Binder ("B",
                                   (Pi (N, U,
                                      (BOpr ("=", (Id ("m", I)),
                                         (Id ("n", I)))),
                                      (Binder ("_",
                                         (Pi (R, U,
                                            (App
                                               [(Id ("B", I)); (Id ("m", I))]),
                                            (Binder ("_",
                                               (App
                                                  [(Id ("B", I));
                                                    (Id ("n", I))])
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "rwl"),
              [([(PId "A"); (PId "m"); (PId "n"); (PId "B"); (PId "refl");
                  (PId "x")],
                (Some (Id ("x", I))))]
              )),
           [I; I; I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (N, U, (Id ("A", I)),
                       (Binder ("n",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Type (SId "r")))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=", (Id ("m", I)), (Id ("n", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App [(Id ("B", I)); (Id ("m", I))]),
                                         (Binder ("_",
                                            (App
                                               [(Id ("B", I)); (Id ("n", I))])
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; E]};
  Definition {name = "rwr"; relv = R;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (N, U, (Id ("A", I)),
                          (Binder ("n",
                             (Pi (N, U,
                                (Pi (R, U, (Id ("A", I)),
                                   (Binder ("_", (Type (SId "r")))))),
                                (Binder ("B",
                                   (Pi (N, U,
                                      (BOpr ("=", (Id ("m", I)),
                                         (Id ("n", I)))),
                                      (Binder ("_",
                                         (Pi (R, U,
                                            (App
                                               [(Id ("B", I)); (Id ("n", I))]),
                                            (Binder ("_",
                                               (App
                                                  [(Id ("B", I));
                                                    (Id ("m", I))])
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "rwr"),
              [([(PId "A"); (PId "m"); (PId "n"); (PId "B"); (PId "refl");
                  (PId "x")],
                (Some (Id ("x", I))))]
              )),
           [I; I; I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (N, U, (Id ("A", I)),
                       (Binder ("n",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Type (SId "r")))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=", (Id ("m", I)), (Id ("n", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App [(Id ("B", I)); (Id ("n", I))]),
                                         (Binder ("_",
                                            (App
                                               [(Id ("B", I)); (Id ("m", I))])
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "s"))))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m", (TBase (UOpr ("`", (Id ("m", I))))))))),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "unit"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)), [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
       ));
    view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("n", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "list"; relv = R;
    body =
    (Binder (["s"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type (SId "t"))),
                 [(DConstr ("nil",
                     (TBase (App [(Id ("list", I)); (Id ("A", I))])), 
                     []));
                   (DConstr ("cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (App
                                  [(Inst ("list", [(SId "_"); (SId "t")], I));
                                    (Id ("A", I))]),
                               (Binder ("tl",
                                  (TBase
                                     (App [(Id ("list", I)); (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Inductive {name = "exists0"; relv = R;
    body =
    (Binder (["s"; "r"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("ex0",
                           (TBind (N, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("exists0", E));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "exists1"; relv = R;
    body =
    (Binder (["s"; "r"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("ex1",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("exists1", E));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "prod0"; relv = N;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (R, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))))
              )),
           (Binder ((Some "prod0"),
              [([(PId "A"); (PId "B")],
                (Some (App
                         [(Id ("exists0", E)); (Id ("A", I));
                           (Fun ((Pi (R, U, IMeta, (Binder ("_", IMeta)))),
                              (Binder (None,
                                 [([(PId "_")], (Some (Id ("B", I))))])),
                              []))
                           ])))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Type (SId "s")),
           (Binder ("A", (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "prod1"; relv = N;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (R, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))))
              )),
           (Binder ((Some "prod1"),
              [([(PId "A"); (PId "B")],
                (Some (App
                         [(Id ("exists1", E)); (Id ("A", I));
                           (Fun ((Pi (R, U, IMeta, (Binder ("_", IMeta)))),
                              (Binder (None,
                                 [([(PId "_")], (Some (Id ("B", I))))])),
                              []))
                           ])))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Type (SId "s")),
           (Binder ("A", (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "not"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I)))))),
           (Binder ((Some "not"),
              [([(PId "true")], (Some (Id ("false", I))));
                ([(PId "false")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I)))))))
       ));
    view = []};
  Definition {name = "and"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "and"),
              [([(PId "true"); (PId "true")], (Some (Id ("true", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("false", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "or"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "or"),
              [([(PId "false"); (PId "false")], (Some (Id ("false", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "xor"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, L, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "xor"),
              [([(PId "true"); (PId "true")], (Some (Id ("false", I))));
                ([(PId "false"); (PId "false")], (Some (Id ("false", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, L, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "lte"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("bool", I))))
                    ))
                 ))
              )),
           (Binder ((Some "lte"),
              [([(PId "zero"); (PId "_")], (Some (Id ("true", I))));
                ([(PId "_"); (PId "zero")], (Some (Id ("false", I))));
                ([(PConstr ("succ", [(PId "x")]));
                   (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("<=", (Id ("x", I)), (Id ("y", I))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "lt"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", (Id ("bool", I))))
                    ))
                 ))
              )),
           (Binder ((Some "lt"),
              [([(PId "x"); (PId "y")],
                (Some (BOpr ("<=", (App [(Id ("succ", I)); (Id ("x", I))]),
                         (Id ("y", I))))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x",
              (Pi (R, U, (Id ("nat", I)), (Binder ("y", (Id ("bool", I))))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "pred"; relv = R;
    body =
    (Binder ([],
       ((Fun ((Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I)))))),
           (Binder ((Some "pred"),
              [([(PId "zero")], (Some (Id ("zero", I))));
                ([(PConstr ("succ", [(PId "x")]))], (Some (Id ("x", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I)))))))
       ));
    view = []};
  Definition {name = "add"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "add"),
              [([(PId "zero"); (PId "y")], (Some (Id ("y", I))));
                ([(PConstr ("succ", [(PId "x")])); (PId "y")],
                 (Some (App
                          [(Id ("succ", I));
                            (BOpr ("+", (Id ("x", I)), (Id ("y", I))))])))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "sub"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "sub"),
              [([(PId "x"); (PId "zero")], (Some (Id ("x", I))));
                ([(PId "x"); (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("-", (App [(Id ("pred", I)); (Id ("x", I))]),
                          (Id ("y", I))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "mul"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "mul"),
              [([(PId "zero"); (PId "_")], (Some (Id ("zero", I))));
                ([(PConstr ("succ", [(PId "x")])); (PId "y")],
                 (Some (BOpr ("+", (Id ("y", I)),
                          (BOpr ("*", (Id ("x", I)), (Id ("y", I))))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "div"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))))
              )),
           (Binder ((Some "div"),
              [([(PId "x"); (PId "y")],
                (Some (Match (
                         [(R,
                           (App
                              [(Id ("lt", I)); (Id ("x", I)); (Id ("y", I))]),
                           None)],
                         None,
                         [([(PId "true")], (Some (Id ("zero", I))));
                           ([(PId "false")],
                            (Some (Let (R,
                                     (Fun (
                                        (Pi (R, U, (Id ("nat", I)),
                                           (Binder ("x",
                                              (Pi (R, U, (Id ("nat", I)),
                                                 (Binder ("y", IMeta))))
                                              ))
                                           )),
                                        (Binder ((Some "loop"),
                                           [([(PId "x"); (PId "y")],
                                             (Some (Match (
                                                      [(R,
                                                        (BOpr ("-",
                                                           (Id ("x", I)),
                                                           (App
                                                              [(Id ("pred", I
                                                                  ));
                                                                (Id ("y", I))
                                                                ])
                                                           )),
                                                        None)],
                                                      None,
                                                      [([(PId "zero")],
                                                        (Some (Id ("zero", I
                                                                 ))));
                                                        ([(PConstr ("succ",
                                                             [(PId "x")]))
                                                           ],
                                                         (Some (App
                                                                  [(Id (
                                                                    "succ", I
                                                                    ));
                                                                    (
                                                                    App
                                                                    [(Id (
                                                                    "loop", I
                                                                    ));
                                                                    (Id ("x",
                                                                    I));
                                                                    (Id ("y",
                                                                    I))])])))
                                                        ]
                                                      ))))
                                             ]
                                           )),
                                        [])),
                                     (Binder ((PId "loop"),
                                        (App
                                           [(Id ("loop", I)); (Id ("x", I));
                                             (Id ("y", I))])
                                        ))
                                     ))))
                           ]
                         ))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x", (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "rem"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))))
              )),
           (Binder ((Some "rem"),
              [([(PId "x"); (PId "y")],
                (Some (BOpr ("-", (Id ("x", I)),
                         (BOpr ("*",
                            (BOpr ("/", (Id ("x", I)), (Id ("y", I)))),
                            (Id ("y", I))))
                         ))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x", (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "pow"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "pow"),
              [([(PId "_"); (PId "zero")],
                (Some (App [(Id ("succ", I)); (Id ("zero", I))])));
                ([(PId "x"); (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("*", (Id ("x", I)),
                          (BOpr ("^", (Id ("x", I)), (Id ("y", I))))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Extern {name = "proto"; relv = N; body = (Binder ([], (None, (Type U))));
    view = []};
  Extern {name = "act0"; relv = N;
    body =
    (Binder (["s"],
       (None,
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("b",
              (Pi (R, U, (Type (SId "s")),
                 (Binder ("A",
                    (Pi (R, U,
                       (Pi (R, U, (Id ("A", I)),
                          (Binder ("_", (Id ("proto", I)))))),
                       (Binder ("B", (Id ("proto", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; I; E]};
  Extern {name = "act1"; relv = N;
    body =
    (Binder (["s"],
       (None,
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("b",
              (Pi (R, U, (Type (SId "s")),
                 (Binder ("A",
                    (Pi (R, U,
                       (Pi (R, U, (Id ("A", I)),
                          (Binder ("_", (Id ("proto", I)))))),
                       (Binder ("B", (Id ("proto", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; I; E]};
  Extern {name = "endp"; relv = N;
    body = (Binder ([], (None, (Id ("proto", I))))); view = []};
  Extern {name = "ch"; relv = N;
    body =
    (Binder ([],
       (None,
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("proto", I)), (Binder ("_", (Type L)))))))
           )))
       ));
    view = []};
  Extern {name = "close"; relv = R;
    body =
    (Binder ([],
       (None,
        (Pi (N, U, (Id ("bool", I)),
           (Binder ("b",
              (Pi (R, U,
                 (App [(Id ("ch", I)); (Id ("b", I)); (Id ("endp", I))]),
                 (Binder ("_", (IO (Id ("unit", I)))))))
              ))
           )))
       ));
    view = [I]};
  Extern {name = "send0"; relv = R;
    body =
    (Binder (["s"],
       (None,
        (Pi (N, U, (Id ("bool", I)),
           (Binder ("b1",
              (Pi (N, U, (Id ("bool", I)),
                 (Binder ("b2",
                    (Pi (N, U, (Type (SId "s")),
                       (Binder ("A",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Id ("proto", I)))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=",
                                      (App
                                         [(Id ("xor", I)); (Id ("b1", I));
                                           (Id ("b2", I))]),
                                      (Id ("false", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App
                                            [(Id ("ch", I)); (Id ("b1", I));
                                              (App
                                                 [(Id ("act0", I));
                                                   (Id ("b2", I));
                                                   (Id ("B", I))])
                                              ]),
                                         (Binder ("_",
                                            (Pi (N, L, (Id ("A", I)),
                                               (Binder ("x",
                                                  (IO
                                                     (App
                                                        [(Id ("ch", I));
                                                          (Id ("b1", I));
                                                          (App
                                                             [(Id ("B", I));
                                                               (Id ("x", I))])
                                                          ]))
                                                  ))
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; I]};
  Extern {name = "send1"; relv = R;
    body =
    (Binder (["s"],
       (None,
        (Pi (N, U, (Id ("bool", I)),
           (Binder ("b1",
              (Pi (N, U, (Id ("bool", I)),
                 (Binder ("b2",
                    (Pi (N, U, (Type (SId "s")),
                       (Binder ("A",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Id ("proto", I)))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=",
                                      (App
                                         [(Id ("xor", I)); (Id ("b1", I));
                                           (Id ("b2", I))]),
                                      (Id ("false", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App
                                            [(Id ("ch", I)); (Id ("b1", I));
                                              (App
                                                 [(Id ("act1", I));
                                                   (Id ("b2", I));
                                                   (Id ("B", I))])
                                              ]),
                                         (Binder ("_",
                                            (Pi (R, L, (Id ("A", I)),
                                               (Binder ("x",
                                                  (IO
                                                     (App
                                                        [(Id ("ch", I));
                                                          (Id ("b1", I));
                                                          (App
                                                             [(Id ("B", I));
                                                               (Id ("x", I))])
                                                          ]))
                                                  ))
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; I]};
  Extern {name = "recv0"; relv = R;
    body =
    (Binder (["s"],
       (None,
        (Pi (N, U, (Id ("bool", I)),
           (Binder ("b1",
              (Pi (N, U, (Id ("bool", I)),
                 (Binder ("b2",
                    (Pi (N, U, (Type (SId "s")),
                       (Binder ("A",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Id ("proto", I)))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=",
                                      (App
                                         [(Id ("xor", I)); (Id ("b1", I));
                                           (Id ("b2", I))]),
                                      (Id ("true", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App
                                            [(Id ("ch", I)); (Id ("b1", I));
                                              (App
                                                 [(Id ("act0", I));
                                                   (Id ("b2", I));
                                                   (Id ("B", I))])
                                              ]),
                                         (Binder ("_",
                                            (IO
                                               (App
                                                  [(Id ("exists0", I));
                                                    (Fun (
                                                       (Pi (R, U,
                                                          (Id ("A", I)),
                                                          (Binder ("x", IMeta
                                                             ))
                                                          )),
                                                       (Binder (None,
                                                          [([(PId "x")],
                                                            (Some (App
                                                                    [(Id (
                                                                    "ch", I));
                                                                    (Id (
                                                                    "b1", I));
                                                                    (App
                                                                    [(Id (
                                                                    "B", I));
                                                                    (Id ("x",
                                                                    I))])])))
                                                            ]
                                                          )),
                                                       []))
                                                    ]))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; I]};
  Extern {name = "recv1"; relv = R;
    body =
    (Binder (["s"],
       (None,
        (Pi (N, U, (Id ("bool", I)),
           (Binder ("b1",
              (Pi (N, U, (Id ("bool", I)),
                 (Binder ("b2",
                    (Pi (N, U, (Type (SId "s")),
                       (Binder ("A",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Id ("proto", I)))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=",
                                      (App
                                         [(Id ("xor", I)); (Id ("b1", I));
                                           (Id ("b2", I))]),
                                      (Id ("true", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App
                                            [(Id ("ch", I)); (Id ("b1", I));
                                              (App
                                                 [(Id ("act1", I));
                                                   (Id ("b2", I));
                                                   (Id ("B", I))])
                                              ]),
                                         (Binder ("_",
                                            (IO
                                               (App
                                                  [(Id ("exists1", I));
                                                    (Fun (
                                                       (Pi (R, U,
                                                          (Id ("A", I)),
                                                          (Binder ("x", IMeta
                                                             ))
                                                          )),
                                                       (Binder (None,
                                                          [([(PId "x")],
                                                            (Some (App
                                                                    [(Id (
                                                                    "ch", I));
                                                                    (Id (
                                                                    "b1", I));
                                                                    (App
                                                                    [(Id (
                                                                    "B", I));
                                                                    (Id ("x",
                                                                    I))])])))
                                                            ]
                                                          )),
                                                       []))
                                                    ]))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; I]};
  Extern {name = "fork"; relv = R;
    body =
    (Binder ([],
       (None,
        (Pi (N, U, (Id ("bool", I)),
           (Binder ("b",
              (Pi (N, U, (Id ("proto", I)),
                 (Binder ("P",
                    (Pi (R, U,
                       (Pi (R, L,
                          (App [(Id ("ch", I)); (Id ("b", I)); (Id ("P", I))]),
                          (Binder ("_", (IO (Id ("unit", I))))))),
                       (Binder ("_",
                          (IO
                             (App
                                [(Id ("ch", I));
                                  (App [(Id ("not", I)); (Id ("b", I))]);
                                  (Id ("P", I))]))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "split"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("_",
                 (BOpr ("\195\151",
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))]),
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))])
                    ))
                 ))
              )),
           (Binder ((Some "split"),
              [([(PId "nil")],
                (Some (BOpr ("\226\159\168,\226\159\169", (Id ("nil", I)),
                         (Id ("nil", I))))));
                ([(PBOpr ("::", (PId "x"), (PId "nil")))],
                 (Some (BOpr ("\226\159\168,\226\159\169",
                          (BOpr ("::", (Id ("x", I)), (Id ("nil", I)))),
                          (Id ("nil", I))))));
                ([(PBOpr ("::", (PId "x"),
                     (PBOpr ("::", (PId "y"), (PId "zs")))))
                   ],
                 (Some (Let (R, (App [(Id ("split", I)); (Id ("zs", I))]),
                          (Binder (
                             (PBOpr ("\226\159\168,\226\159\169", (PId "xs"),
                                (PId "ys"))),
                             (BOpr ("\226\159\168,\226\159\169",
                                (BOpr ("::", (Id ("x", I)), (Id ("xs", I)))),
                                (BOpr ("::", (Id ("y", I)), (Id ("ys", I))))
                                ))
                             ))
                          ))))
                ]
              )),
           [])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("_",
              (BOpr ("\195\151",
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))]),
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))])
                 ))
              ))
           )))
       ));
    view = []};
  Definition {name = "merge"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("_",
                 (Pi (R, L,
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))]),
                    (Binder ("_",
                       (App
                          [(Inst ("list", [(SId "_"); (SId "t")], I));
                            (Id ("nat", I))])
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "merge"),
              [([(PId "nil"); (PId "ys")], (Some (Id ("ys", I))));
                ([(PId "xs"); (PId "nil")], (Some (Id ("xs", I))));
                ([(PBOpr ("::", (PId "x"), (PId "xs")));
                   (PBOpr ("::", (PId "y"), (PId "ys")))],
                 (Some (Match (
                          [(R, (BOpr ("<=", (Id ("x", I)), (Id ("y", I)))),
                            None)],
                          None,
                          [([(PId "true")],
                            (Some (BOpr ("::", (Id ("x", I)),
                                     (App
                                        [(Id ("merge", I)); (Id ("xs", I));
                                          (BOpr ("::", (Id ("y", I)),
                                             (Id ("ys", I))))
                                          ])
                                     ))));
                            ([(PId "false")],
                             (Some (BOpr ("::", (Id ("y", I)),
                                      (App
                                         [(Id ("merge", I));
                                           (BOpr ("::", (Id ("x", I)),
                                              (Id ("xs", I))));
                                           (Id ("ys", I))])
                                      ))))
                            ]
                          ))))
                ]
              )),
           [])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("_",
              (Pi (R, L,
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))]),
                 (Binder ("_",
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))])
                    ))
                 ))
              ))
           )))
       ));
    view = []};
  Definition {name = "msort"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("_",
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))])
                 ))
              )),
           (Binder ((Some "msort"),
              [([(PId "nil")], (Some (Id ("nil", I))));
                ([(PBOpr ("::", (PId "z"), (PId "nil")))],
                 (Some (BOpr ("::", (Id ("z", I)), (Id ("nil", I))))));
                ([(PId "zs")],
                 (Some (Let (R, (App [(Id ("split", I)); (Id ("zs", I))]),
                          (Binder (
                             (PBOpr ("\226\159\168,\226\159\169", (PId "xs"),
                                (PId "ys"))),
                             (App
                                [(Id ("merge", I));
                                  (App [(Id ("msort", I)); (Id ("xs", I))]);
                                  (App [(Id ("msort", I)); (Id ("ys", I))])])
                             ))
                          ))))
                ]
              )),
           [])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("_",
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ])
              ))
           )))
       ));
    view = []};
  Definition {name = "cmsort_ch"; relv = N;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("xs", (Type L))))),
           (Binder ((Some "cmsort_ch"),
              [([(PId "xs")],
                (Some (App
                         [(Id ("ch", I)); (Id ("true", I));
                           (App
                              [(Id ("act1", I)); (Id ("true", I));
                                (Fun (
                                   (Pi (R, U,
                                      (UOpr ("`",
                                         (App
                                            [(Id ("msort", I));
                                              (Id ("xs", I))])
                                         )),
                                      (Binder ("_", IMeta)))),
                                   (Binder (None,
                                      [([(PId "_")], (Some (Id ("endp", I))))
                                        ]
                                      )),
                                   []))
                                ])
                           ])))
                ]
              )),
           [E])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("xs", (Type L))))))
       ));
    view = [E]};
  Definition {name = "cmsort_worker"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U,
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))]),
                    (Binder ("zs",
                       (Pi (R, L,
                          (App
                             [(Inst ("cmsort_ch", [(SId "t")], I));
                               (Id ("zs", I))]),
                          (Binder ("_", (IO (Id ("unit", I)))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "cmsort_worker"),
              [([(PId "zero"); (PId "zs"); (PId "c")],
                (Some (MLet (
                         (App
                            [(Id ("send1", I)); (Id ("refl", I));
                              (Id ("c", I));
                              (App
                                 [(Id ("just", I));
                                   (App [(Id ("msort", I)); (Id ("zs", I))])])
                              ]),
                         (Binder ((PId "c"),
                            (App [(Id ("close", I)); (Id ("c", I))])))
                         ))));
                ([(PConstr ("succ", [(PId "n")])); (PId "nil"); (PId "c")],
                 (Some (MLet (
                          (App
                             [(Id ("send1", I)); (Id ("refl", I));
                               (Id ("c", I));
                               (App [(Id ("just", I)); (Id ("nil", I))])]),
                          (Binder ((PId "c"),
                             (App [(Id ("close", I)); (Id ("c", I))])))
                          ))));
                ([(PConstr ("succ", [(PId "n")]));
                   (PBOpr ("::", (PId "z"), (PId "nil"))); (PId "c")],
                 (Some (MLet (
                          (App
                             [(Id ("send1", I)); (Id ("refl", I));
                               (Id ("c", I));
                               (App
                                  [(Id ("just", I));
                                    (BOpr ("::", (Id ("z", I)),
                                       (Id ("nil", I))))
                                    ])
                               ]),
                          (Binder ((PId "c"),
                             (App [(Id ("close", I)); (Id ("c", I))])))
                          ))));
                ([(PConstr ("succ", [(PId "n")])); (PId "zs"); (PId "c")],
                 (Some (Match (
                          [(R, (App [(Id ("split", I)); (Id ("zs", I))]),
                            (Some ("h1", IMeta)));
                            (N, (Id ("refl", I)),
                             (Some ("_",
                                    (BOpr ("=",
                                       (Let (R, (Id ("h1", I)),
                                          (Binder (
                                             (PBOpr (
                                                "\226\159\168,\226\159\169",
                                                (PId "xs"), (PId "ys"))),
                                             (App
                                                [(Id ("merge", I));
                                                  (App
                                                     [(Id ("msort", I));
                                                       (Id ("xs", I))]);
                                                  (App
                                                     [(Id ("msort", I));
                                                       (Id ("ys", I))])
                                                  ])
                                             ))
                                          )),
                                       (Let (R,
                                          (App
                                             [(Id ("split", I));
                                               (Id ("zs", I))]),
                                          (Binder (
                                             (PBOpr (
                                                "\226\159\168,\226\159\169",
                                                (PId "xs"), (PId "ys"))),
                                             (App
                                                [(Id ("merge", I));
                                                  (App
                                                     [(Id ("msort", I));
                                                       (Id ("xs", I))]);
                                                  (App
                                                     [(Id ("msort", I));
                                                       (Id ("ys", I))])
                                                  ])
                                             ))
                                          ))
                                       )))))
                            ],
                          None,
                          [([(PBOpr ("\226\159\168,\226\159\169",
                                (PId "xs0"), (PId "ys0")));
                              (PId "pf")],
                            (Some (MLet (
                                     (App
                                        [(Id ("fork", I));
                                          (Fun (
                                             (Pi (R, L, IMeta,
                                                (Binder ("c1", IMeta)))),
                                             (Binder (None,
                                                [([(PId "c1")],
                                                  (Some (App
                                                           [(Id (
                                                               "cmsort_worker",
                                                               I));
                                                             (Id ("n", I));
                                                             (Id ("xs0", I));
                                                             (Id ("c1", I))])))
                                                  ]
                                                )),
                                             []))
                                          ]),
                                     (Binder ((PId "r1"),
                                        (MLet (
                                           (App
                                              [(Id ("fork", I));
                                                (Fun (
                                                   (Pi (R, L, IMeta,
                                                      (Binder ("c2", IMeta))
                                                      )),
                                                   (Binder (None,
                                                      [([(PId "c2")],
                                                        (Some (App
                                                                 [(Id (
                                                                    "cmsort_worker",
                                                                    I));
                                                                   (Id ("n",
                                                                    I));
                                                                   (Id (
                                                                    "ys0", I
                                                                    ));
                                                                   (Id ("c2",
                                                                    I))
                                                                   ])))
                                                        ]
                                                      )),
                                                   []))
                                                ]),
                                           (Binder ((PId "r2"),
                                              (MLet (
                                                 (App
                                                    [(Id ("recv1", I));
                                                      (Id ("refl", I));
                                                      (Id ("r1", I))]),
                                                 (Binder (
                                                    (PBOpr (
                                                       "\226\159\168,\226\159\169",
                                                       (PId "xs1"),
                                                       (PId "c1"))),
                                                    (MLet (
                                                       (App
                                                          [(Id ("recv1", I));
                                                            (Id ("refl", I));
                                                            (Id ("r2", I))]),
                                                       (Binder (
                                                          (PBOpr (
                                                             "\226\159\168,\226\159\169",
                                                             (PId "ys1"),
                                                             (PId "c2"))),
                                                          (Match (
                                                             [(R,
                                                               (Id ("xs1", I
                                                                  )),
                                                               None);
                                                               (R,
                                                                (Id ("ys1", I
                                                                   )),
                                                                None)
                                                               ],
                                                             None,
                                                             [([(PConstr (
                                                                   "just",
                                                                   [(PId
                                                                    "xs1")]
                                                                   ));
                                                                 (PConstr (
                                                                    "just",
                                                                    [(PId
                                                                    "ys1")]))
                                                                 ],
                                                               (Some (
                                                               Let (R,
                                                                 (Ann (
                                                                    (
                                                                    App
                                                                    [(Id (
                                                                    "just", I
                                                                    ));
                                                                    (App
                                                                    [(Id (
                                                                    "merge",
                                                                    I));
                                                                    (Id (
                                                                    "xs1", I
                                                                    ));
                                                                    (Id (
                                                                    "ys1", I
                                                                    ))])]),
                                                                    (
                                                                    UOpr (
                                                                    "`",
                                                                    (App
                                                                    [(Id (
                                                                    "merge",
                                                                    I));
                                                                    (App
                                                                    [(Id (
                                                                    "msort",
                                                                    I));
                                                                    (Id (
                                                                    "xs0", I
                                                                    ))]);
                                                                    (App
                                                                    [(Id (
                                                                    "msort",
                                                                    I));
                                                                    (Id (
                                                                    "ys0", I
                                                                    ))])])))
                                                                    )),
                                                                 (Binder (
                                                                    (
                                                                    PId "zs1"),
                                                                    (
                                                                    Let (R,
                                                                    (Ann (
                                                                    (App
                                                                    [(Id (
                                                                    "rwl", I
                                                                    ));
                                                                    (Fun (
                                                                    (Pi (R,
                                                                    U, IMeta,
                                                                    (Binder (
                                                                    "x",
                                                                    IMeta)))),
                                                                    (Binder (
                                                                    None,
                                                                    [([(PId
                                                                    "x")],
                                                                    (Some (
                                                                    UOpr (
                                                                    "`",
                                                                    (Id ("x",
                                                                    I))))))]
                                                                    )), 
                                                                    []));
                                                                    (Id (
                                                                    "pf", I));
                                                                    (Id (
                                                                    "zs1", I
                                                                    ))]),
                                                                    (UOpr (
                                                                    "`",
                                                                    (App
                                                                    [(Id (
                                                                    "msort",
                                                                    I));
                                                                    (Id (
                                                                    "zs", I))
                                                                    ]))))),
                                                                    (Binder (
                                                                    (PId
                                                                    "zs1"),
                                                                    (MLet (
                                                                    (App
                                                                    [(Id (
                                                                    "send1",
                                                                    I));
                                                                    (Id (
                                                                    "refl", I
                                                                    ));
                                                                    (Id ("c",
                                                                    I));
                                                                    (Id (
                                                                    "zs1", I
                                                                    ))]),
                                                                    (Binder (
                                                                    (PId "c"),
                                                                    (MLet (
                                                                    (App
                                                                    [(Id (
                                                                    "close",
                                                                    I));
                                                                    (Id (
                                                                    "c1", I))
                                                                    ]),
                                                                    (Binder (
                                                                    (PId "_"),
                                                                    (MLet (
                                                                    (App
                                                                    [(Id (
                                                                    "close",
                                                                    I));
                                                                    (Id (
                                                                    "c2", I))
                                                                    ]),
                                                                    (Binder (
                                                                    (PId "_"),
                                                                    (MLet (
                                                                    (App
                                                                    [(Id (
                                                                    "close",
                                                                    I));
                                                                    (Id ("c",
                                                                    I))]),
                                                                    (Binder (
                                                                    (PId "_"),
                                                                    (Return
                                                                    (Id (
                                                                    "tt", I)))
                                                                    ))))))))
                                                                    ))))))))
                                                                    ))))))
                                                                 ))))
                                                               ]
                                                             ))
                                                          ))
                                                       ))
                                                    ))
                                                 ))
                                              ))
                                           ))
                                        ))
                                     ))))
                            ]
                          ))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U,
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))]),
                 (Binder ("zs",
                    (Pi (R, L,
                       (App
                          [(Inst ("cmsort_ch", [(SId "t")], I));
                            (Id ("zs", I))]),
                       (Binder ("_", (IO (Id ("unit", I)))))))
                    ))
                 ))
              ))
           )))
       ));
    view = []}
  ]

-----------------------------------------

#[logical]
inductive eq_1s_398 (A_399 : Types_398) (m_400 : A_399):
  A_399 -> U
where
| refl_1 : (eq_1??_1 ?_1[0;0] m_400 m_400)

#[program]
def rwl_1s_402,r_403 :
   {A_404 : Types_402} ->
     {m_405 : A_404} ->
       {n_406 : A_404} ->
         {B_407 : A_404 -> Typer_403} ->
          {(eq_1??_3 ?_3[0;0] m_405 n_406)} ->
            ((B_407) m_405) -> ((B_407) n_406)
:=
  function rwl_411 :
     {A_412 : Types_402} ->
       {m_413 : A_412} ->
         {n_414 : A_412} ->
           {B_415 : A_412 -> Typer_403} ->
            {(eq_1??_2 ?_2[0;0] m_413 n_414)} ->
              ((B_415) m_413) -> ((B_415) n_414)
  | A_419 m_420 n_421 B_422 refl_1 x_423 => x_423

#[program]
def rwr_2s_424,r_425 :
   {A_426 : Types_424} ->
     {m_427 : A_426} ->
       {n_428 : A_426} ->
         {B_429 : A_426 -> Typer_425} ->
          {(eq_1??_5 ?_5[0;0] m_427 n_428)} ->
            ((B_429) n_428) -> ((B_429) m_427)
:=
  function rwr_433 :
     {A_434 : Types_424} ->
       {m_435 : A_434} ->
         {n_436 : A_434} ->
           {B_437 : A_434 -> Typer_425} ->
            {(eq_1??_4 ?_4[0;0] m_435 n_436)} ->
              ((B_437) n_436) -> ((B_437) m_435)
  | A_441 m_442 n_443 B_444 refl_1 x_445 => x_445

#[program]
inductive sing_2s_446 (A_447 : Types_446):
  A_447 -> Types_446
where
| just_2 (m_449 : A_447) : (sing_2??_6 ?_6[0;0] m_449)

#[program]
inductive unit_3 : U where
| tt_3 : unit_3

#[program]
inductive bool_4 : U where
| true_4 : bool_4
| false_5 : bool_4

#[program]
inductive nat_5 : U where
| zero_6 : nat_5
| succ_7 (n_450 : nat_5) : nat_5

#[program]
inductive list_6s_451,t_452 (A_453 : Types_451): Typet_452
where
| nil_8 : (list_6??_7,??_8 A_453)
| cons_9
    (hd_454 : A_453) (tl_455 : (list_6??_9,t_452 A_453))
    : (list_6??_10,??_11 A_453)

#[program]
inductive exists0_7s_456,r_457 (A_458 : Types_456) (B_459 : 
A_458 -> Typer_457): L where
| ex0_10
    {m_461 : A_458} (n_462 : ((B_459) m_461))
    : (exists0_7??_12,??_13 A_458 B_459)

#[program]
inductive exists1_8s_463,r_464 (A_465 : Types_463) (B_466 : 
A_465 -> Typer_464): L where
| ex1_11
    (m_468 : A_465) (n_469 : ((B_466) m_468))
    : (exists1_8??_14,??_15 A_465 B_466)

#[logical]
def prod0_3s_470,r_471 :
  Types_470 -> Typer_471 -> ?_10[0;0]
:=
  function prod0_474 : Types_470 -> Typer_471 -> ?_7[0;0]
  | A_477 B_478 =>
    (exists0_7??_16,??_17
      A_477 function _479 : ?_8[0;0] -> ?_9[0;0]
            | _481 => B_478)

#[logical]
def prod1_4s_482,r_483 :
  Types_482 -> Typer_483 -> ?_14[0;0]
:=
  function prod1_486 : Types_482 -> Typer_483 -> ?_11[0;0]
  | A_489 B_490 =>
    (exists1_8??_18,??_19
      A_489 function _491 : ?_12[0;0] -> ?_13[0;0]
            | _493 => B_490)

#[program]
def not_5 : bool_4 -> bool_4 :=
  function not_495 : bool_4 -> bool_4
  | true_4 => false_5
  | false_5 => true_4

#[program]
def and_6 : bool_4 -> bool_4 -> bool_4 :=
  function and_499 : bool_4 -> bool_4 -> bool_4
  | true_4 true_4 => true_4
  | _502 _503 => false_5

#[program]
def or_7 : bool_4 -> bool_4 -> bool_4 :=
  function or_506 : bool_4 -> bool_4 -> bool_4
  | false_5 false_5 => false_5
  | _509 _510 => true_4

#[program]
def xor_8 : bool_4 -> bool_4 -o bool_4 :=
  function xor_513 : bool_4 -> bool_4 -o bool_4
  | true_4 true_4 => false_5
  | false_5 false_5 => false_5
  | _516 _517 => true_4

#[program]
def lte_9 : nat_5 -> nat_5 -> bool_4 :=
  function lte_520 : nat_5 -> nat_5 -> bool_4
  | zero_6 _523 => true_4
  | _524 zero_6 => false_5
  | (succ_7 x_525) (succ_7 y_526) => ((lte_520) x_525 y_526)

#[program]
def lt_10 : nat_5 -> nat_5 -> bool_4 :=
  function lt_529 : nat_5 -> nat_5 -> bool_4
  | x_532 y_533 => ((lte_9) (succ_7 x_532) y_533)

#[program]
def pred_11 : nat_5 -> nat_5 :=
  function pred_535 : nat_5 -> nat_5
  | zero_6 => zero_6
  | (succ_7 x_537) => x_537

#[program]
def add_12 : nat_5 -> nat_5 -> nat_5 :=
  function add_540 : nat_5 -> nat_5 -> nat_5
  | zero_6 y_543 => y_543
  | (succ_7 x_544) y_545 => (succ_7 ((add_540) x_544 y_545))

#[program]
def sub_13 : nat_5 -> nat_5 -> nat_5 :=
  function sub_548 : nat_5 -> nat_5 -> nat_5
  | x_551 zero_6 => x_551
  | x_552 (succ_7 y_553) => ((sub_548) ((pred_11) x_552) y_553)

#[program]
def mul_14 : nat_5 -> nat_5 -> nat_5 :=
  function mul_556 : nat_5 -> nat_5 -> nat_5
  | zero_6 _559 => zero_6
  | (succ_7 x_560) y_561 => ((add_12) y_561 ((mul_556) x_560 y_561))

#[program]
def div_15 : nat_5 -> nat_5 -> ?_21[0;0] :=
  function div_564 : nat_5 -> nat_5 -> ?_15[0;0]
  | x_567 y_568 =>
    match ((lt_10) x_567 y_568) in ?_16[0;0] -o ?_17[0;0] with
    | true_4 => zero_6
    | false_5 =>
      let loop_570 :=
        function loop_571 : nat_5 -> nat_5 -> ?_18[0;0]
        | x_574 y_575 =>
          match ((sub_13) x_574 ((pred_11) y_575)) in ?_19[0;0] -o ?_20[0;0]
          with
          | zero_6 => zero_6
          | (succ_7 x_577) => (succ_7 ((loop_571) x_577 y_575))
      in ((loop_570) x_567 y_568)

#[program]
def rem_16 : nat_5 -> nat_5 -> ?_23[0;0] :=
  function rem_580 : nat_5 -> nat_5 -> ?_22[0;0]
  | x_583 y_584 => ((sub_13) x_583 ((mul_14) ((div_15) x_583 y_584) y_584))

#[program]
def pow_17 : nat_5 -> nat_5 -> nat_5 :=
  function pow_587 : nat_5 -> nat_5 -> nat_5
  | _590 zero_6 => (succ_7 zero_6)
  | x_591 (succ_7 y_592) => ((mul_14) x_591 ((pow_587) x_591 y_592))

#[logical]
extern proto_18 : U

#[logical]
extern act0_19s_593 :
  bool_4 ->  (A_595 : Types_593) -> A_595 -> proto_18 -> proto_18

#[logical]
extern act1_20s_598 :
  bool_4 ->  (A_600 : Types_598) -> A_600 -> proto_18 -> proto_18

#[logical]
extern endp_21 : proto_18

#[logical]
extern ch_22 : bool_4 -> proto_18 -> L

#[program]
extern close_23 :
   {b_605 : bool_4} -> ((ch_22) b_605 endp_21) -> IO unit_3

#[program]
extern send0_24s_607 :
   {b1_608 : bool_4} ->
     {b2_609 : bool_4} ->
       {A_610 : Types_607} ->
         {B_611 : A_610 -> proto_18} ->
          {(eq_1??_20 ?_24[0;0] ((xor_8) b1_608 b2_609) false_5)} ->
            ((ch_22) b1_608 ((act0_19??_21) b2_609 ?_25[0;0] B_611)) ->
               {x_615 : A_610} -o IO ((ch_22) b1_608 ((B_611) x_615))

#[program]
extern send1_25s_616 :
   {b1_617 : bool_4} ->
     {b2_618 : bool_4} ->
       {A_619 : Types_616} ->
         {B_620 : A_619 -> proto_18} ->
          {(eq_1??_22 ?_26[0;0] ((xor_8) b1_617 b2_618) false_5)} ->
            ((ch_22) b1_617 ((act1_20??_23) b2_618 ?_27[0;0] B_620)) ->
               (x_624 : A_619) -o IO ((ch_22) b1_617 ((B_620) x_624))

#[program]
extern recv0_26s_625 :
   {b1_626 : bool_4} ->
     {b2_627 : bool_4} ->
       {A_628 : Types_625} ->
         {B_629 : A_628 -> proto_18} ->
          {(eq_1??_24 ?_28[0;0] ((xor_8) b1_626 b2_627) true_4)} ->
            ((ch_22) b1_626 ((act0_19??_25) b2_627 ?_29[0;0] B_629)) ->
              IO (exists0_7??_26,??_27
                   ?_31[0;0]
                   function _633 : A_628 -> ?_30[0;0]
                   | x_635 => ((ch_22) b1_626 ((B_629) x_635)))

#[program]
extern recv1_27s_636 :
   {b1_637 : bool_4} ->
     {b2_638 : bool_4} ->
       {A_639 : Types_636} ->
         {B_640 : A_639 -> proto_18} ->
          {(eq_1??_28 ?_32[0;0] ((xor_8) b1_637 b2_638) true_4)} ->
            ((ch_22) b1_637 ((act1_20??_29) b2_638 ?_33[0;0] B_640)) ->
              IO (exists1_8??_30,??_31
                   ?_35[0;0]
                   function _644 : A_639 -> ?_34[0;0]
                   | x_646 => ((ch_22) b1_637 ((B_640) x_646)))

#[program]
extern fork_28 :
   {b_647 : bool_4} ->
     {P_648 : proto_18} ->
      ((ch_22) b_647 P_648) -o IO unit_3 ->
        IO ((ch_22) ((not_5) b_647) P_648)

#[program]
def split_29t_651 :
  (list_6??_57,t_651 nat_5) ->
    ((prod1_4??_60,??_61)
      (list_6??_58,t_651 nat_5) (list_6??_59,t_651 nat_5))
:=
  function split_653 :
    (list_6??_32,t_651 nat_5) ->
      ((prod1_4??_35,??_36)
        (list_6??_33,t_651 nat_5) (list_6??_34,t_651 nat_5))
  | nil_8 =>
    (ex1_11??_41,??_42
      ?_38[0;0] ?_39[0;0] (nil_8??_37,??_38 ?_36[0;0])
      (nil_8??_39,??_40 ?_37[0;0]))
  | (cons_9 x_655 nil_8) =>
    (ex1_11??_49,??_50
      ?_43[0;0] ?_44[0;0]
      (cons_9??_45,??_46
        ?_41[0;0] x_655 (nil_8??_43,??_44 ?_40[0;0]))
      (nil_8??_47,??_48 ?_42[0;0]))
  | (cons_9 x_656 (cons_9 y_657 zs_658)) =>
    match ((split_653) zs_658) in ?_50[0;0] -o ?_49[0;0] with
    | (ex1_11 xs_660 ys_661) =>
      (ex1_11??_55,??_56
        ?_47[0;0] ?_48[0;0] (cons_9??_51,??_52 ?_45[0;0] x_656 xs_660)
        (cons_9??_53,??_54 ?_46[0;0] y_657 ys_661))

#[program]
def merge_30t_662 :
  (list_6??_73,t_662 nat_5) ->
    (list_6??_74,t_662 nat_5) -o (list_6??_75,t_662 nat_5)
:=
  function merge_665 :
    (list_6??_62,t_662 nat_5) ->
      (list_6??_63,t_662 nat_5) -o (list_6??_64,t_662 nat_5)
  | nil_8 ys_668 => ys_668
  | xs_669 nil_8 => xs_669
  | (cons_9 x_670 xs_671) (cons_9 y_672 ys_673) =>
    match ((lte_9) x_670 y_672) in ?_51[0;0] -o ?_52[0;0] with
    | true_4 =>
      (cons_9??_67,??_68
        ?_54[0;0] x_670
        ((merge_665) xs_671 (cons_9??_65,??_66 ?_53[0;0] y_672 ys_673)))
    | false_5 =>
      (cons_9??_71,??_72
        ?_56[0;0] y_672
        ((merge_665) (cons_9??_69,??_70 ?_55[0;0] x_670 xs_671) ys_673))

#[program]
def msort_31t_675 :
  (list_6??_86,t_675 nat_5) -> (list_6??_87,t_675 nat_5)
:=
  function msort_677 :
    (list_6??_76,t_675 nat_5) -> (list_6??_77,t_675 nat_5)
  | nil_8 => (nil_8??_78,??_79 ?_57[0;0])
  | (cons_9 z_679 nil_8) =>
    (cons_9??_82,??_83
      ?_59[0;0] z_679 (nil_8??_80,??_81 ?_58[0;0]))
  | zs_680 =>
    match ((split_29??_84) zs_680) in ?_61[0;0] -o ?_60[0;0] with
    | (ex1_11 xs_682 ys_683) =>
      ((merge_30??_85) ((msort_677) xs_682) ((msort_677) ys_683))

#[logical]
def cmsort_ch_32t_684 : (list_6??_92,t_684 nat_5) -> L :=
  function cmsort_ch_686 : (list_6??_88,t_684 nat_5) -> L
  | xs_688 =>
    ((ch_22)
      true_4
      ((act1_20??_91)
        true_4 ?_64[0;0]
        function _689 :
          (sing_2??_90 ?_62[0;0] ((msort_31??_89) xs_688)) ->
            ?_63[0;0]
        | _691 => endp_21))

#[program]
def cmsort_worker_33t_692 :
  nat_5 ->
     (zs_694 : (list_6??_137,t_692 nat_5)) ->
      ((cmsort_ch_32t_692) zs_694) -o IO unit_3
:=
  function cmsort_worker_696 :
    nat_5 ->
       (zs_698 : (list_6??_93,t_692 nat_5)) ->
        ((cmsort_ch_32t_692) zs_698) -o IO unit_3
  | zero_6 zs_700 c_701 =>
    let* c_702 :=
      ((send1_25??_97)
        ?_71[0;0] ?_70[0;0] ?_69[0;0] ?_68[0;0]
        (refl_1??_94 ?_65[0;0] ?_66[0;0]) c_701
        (just_2??_96 ?_67[0;0] ((msort_31??_95) zs_700)))
    in ((close_23) ?_72[0;0] c_702)
  | (succ_7 n_703) nil_8 c_704 =>
    let* c_705 :=
      ((send1_25??_102)
        ?_80[0;0] ?_79[0;0] ?_78[0;0] ?_77[0;0]
        (refl_1??_98 ?_73[0;0] ?_74[0;0]) c_704
        (just_2??_101 ?_76[0;0] (nil_8??_99,??_100 ?_75[0;0])))
    in ((close_23) ?_81[0;0] c_705)
  | (succ_7 n_706) (cons_9 z_707 nil_8) c_708 =>
    let* c_709 :=
      ((send1_25??_109)
        ?_90[0;0] ?_89[0;0] ?_88[0;0] ?_87[0;0]
        (refl_1??_103 ?_82[0;0] ?_83[0;0]) c_708
        (just_2??_108
          ?_86[0;0]
          (cons_9??_106,??_107
            ?_85[0;0] z_707 (nil_8??_104,??_105 ?_84[0;0]))))
    in ((close_23) ?_91[0;0] c_709)
  | (succ_7 n_710) zs_711 c_712 =>
    match ((split_29??_110) zs_711),
    (refl_1??_111 ?_92[0;0] ?_93[0;0]) in
       (h1_713 : ?_94[0;0]) -o
        {(eq_1??_119
           ?_99[0;0]
           match h1_713 in ?_96[0;0] -o ?_95[0;0] with
           | (ex1_11 xs_716 ys_717) =>
             ((merge_30??_114)
               ((msort_31??_112) xs_716)
               ((msort_31??_113) ys_717))
           match ((split_29??_115) zs_711) in ?_98[0;0] -o ?_97[0;0]
           with
           | (ex1_11 xs_719 ys_720) =>
             ((merge_30??_118)
               ((msort_31??_116) xs_719)
               ((msort_31??_117) ys_720)))} -o
          ?_100[0;0]
    with
    | (ex1_11 xs0_721 ys0_722), pf_723 =>
      let* r1_724 :=
        ((fork_28)
          ?_104[0;0] ?_103[0;0]
          function _725 : ?_101[0;0] -o ?_102[0;0]
          | c1_727 => ((cmsort_worker_696) n_710 xs0_721 c1_727))
      in
      let* r2_728 :=
        ((fork_28)
          ?_108[0;0] ?_107[0;0]
          function _729 : ?_105[0;0] -o ?_106[0;0]
          | c2_731 => ((cmsort_worker_696) n_710 ys0_722 c2_731))
      in
      let* _732 :=
        ((recv1_27??_121)
          ?_114[0;0] ?_113[0;0] ?_112[0;0] ?_111[0;0]
          (refl_1??_120 ?_109[0;0] ?_110[0;0]) r1_724)
      in
      match _732 in ?_145[0;0] -o ?_144[0;0] with
      | (ex1_11 xs1_734 c1_735) =>
        let* _736 :=
          ((recv1_27??_123)
            ?_120[0;0] ?_119[0;0] ?_118[0;0] ?_117[0;0]
            (refl_1??_122 ?_115[0;0] ?_116[0;0]) r2_728)
        in
        match _736 in ?_143[0;0] -o ?_142[0;0] with
        | (ex1_11 ys1_738 c2_739) =>
          match xs1_734, ys1_738 in ?_121[0;0] -o ?_122[0;0] -o ?_123[0;0]
          with
          | (just_2 xs1_742), (just_2 ys1_743) =>
            let zs1_744 :=
              ((just_2??_125
                 ?_124[0;0] ((merge_30??_124) xs1_742 ys1_743))
                : (sing_2??_129
                    ?_125[0;0]
                    ((merge_30??_128)
                      ((msort_31??_126) xs0_721)
                      ((msort_31??_127) ys0_722))))
            in
            let zs1_745 :=
              (((rwl_1??_131,??_132)
                 ?_131[0;0] ?_130[0;0] ?_129[0;0]
                 function _746 : ?_126[0;0] -> ?_127[0;0]
                 | x_748 => (sing_2??_130 ?_128[0;0] x_748) pf_723
                 zs1_744)
                : (sing_2??_134
                    ?_132[0;0] ((msort_31??_133) zs_711)))
            in
            let* c_749 :=
              ((send1_25??_136)
                ?_138[0;0] ?_137[0;0] ?_136[0;0] ?_135[0;0]
                (refl_1??_135 ?_133[0;0] ?_134[0;0]) c_712 zs1_745)
            in
            let* __750 := ((close_23) ?_139[0;0] c1_735) in
            let* __751 := ((close_23) ?_140[0;0] c2_739) in
            let* __752 := ((close_23) ?_141[0;0] c_749) in return tt_3

-----------------------------------------

#[logical]
inductive eq_1s_19476 (A_19477 : Types_19476) (m_19478 : A_19477):
  A_19477 -> U
where
| refl_1 : (eq_1s_19476 A_19477 m_19478 m_19478)

#[program]
def rwl_1s_19480,r_19481 :
   {A_19482 : Types_19480} ->
     {m_19483 : A_19482} ->
       {n_19484 : A_19482} ->
         {B_19485 : A_19482 -> Typer_19481} ->
          {(eq_1s_19480 A_19482 m_19483 n_19484)} ->
            ((B_19485) m_19483) -> ((B_19485) n_19484)
:=
  function rwl_19489 :
     {A_19490 : Types_19480} ->
       {m_19491 : A_19490} ->
         {n_19492 : A_19490} ->
           {B_19493 : A_19490 -> Typer_19481} ->
            {(eq_1s_19480 A_19490 m_19491 n_19492)} ->
              ((B_19493) m_19491) -> ((B_19493) n_19492)
  | A_19497 m_19498 n_19499 B_19500 refl_1 __19501 => __19501

#[program]
def rwr_2s_19502,r_19503 :
   {A_19504 : Types_19502} ->
     {m_19505 : A_19504} ->
       {n_19506 : A_19504} ->
         {B_19507 : A_19504 -> Typer_19503} ->
          {(eq_1s_19502 A_19504 m_19505 n_19506)} ->
            ((B_19507) n_19506) -> ((B_19507) m_19505)
:=
  function rwr_19511 :
     {A_19512 : Types_19502} ->
       {m_19513 : A_19512} ->
         {n_19514 : A_19512} ->
           {B_19515 : A_19512 -> Typer_19503} ->
            {(eq_1s_19502 A_19512 m_19513 n_19514)} ->
              ((B_19515) n_19514) -> ((B_19515) m_19513)
  | A_19519 m_19520 n_19521 B_19522 refl_1 __19523 => __19523

#[program]
inductive sing_2s_19524 (A_19525 : Types_19524):
  A_19525 -> Types_19524
where
| just_2 (m_19527 : A_19525) : (sing_2s_19524 A_19525 m_19527)

#[program]
inductive unit_3 : U where
| tt_3 : unit_3

#[program]
inductive bool_4 : U where
| true_4 : bool_4
| false_5 : bool_4

#[program]
inductive nat_5 : U where
| zero_6 : nat_5
| succ_7 (n_19528 : nat_5) : nat_5

#[program]
inductive list_6s_19529,t_19530 (A_19531 : Types_19529):
  Typet_19530
where
| nil_8 : (list_6s_19529,t_19530 A_19531)
| cons_9
    (hd_19532 : A_19531) (tl_19533 : (list_6s_19529,t_19530 A_19531))
    : (list_6s_19529,t_19530 A_19531)

#[program]
inductive exists0_7s_19534,r_19535 (A_19536 : Types_19534) (B_19537 : 
A_19536 -> Typer_19535): L where
| ex0_10
    {m_19539 : A_19536} (n_19540 : ((B_19537) m_19539))
    : (exists0_7s_19534,r_19535 A_19536 B_19537)

#[program]
inductive exists1_8s_19541,r_19542 (A_19543 : Types_19541) (B_19544 : 
A_19543 -> Typer_19542): L where
| ex1_11
    (m_19546 : A_19543) (n_19547 : ((B_19544) m_19546))
    : (exists1_8s_19541,r_19542 A_19543 B_19544)

#[logical]
def prod0_3s_19548,r_19549 :
  Types_19548 -> Typer_19549 -> L
:=
  function prod0_19552 : Types_19548 -> Typer_19549 -> L
  | A_19555 B_19556 =>
    (exists0_7s_19548,r_19549
      A_19555
      function _19557 : A_19555 -> Typer_19549
      | __19559 => B_19556)

#[logical]
def prod1_4s_19560,r_19561 :
  Types_19560 -> Typer_19561 -> L
:=
  function prod1_19564 : Types_19560 -> Typer_19561 -> L
  | A_19567 B_19568 =>
    (exists1_8s_19560,r_19561
      A_19567
      function _19569 : A_19567 -> Typer_19561
      | __19571 => B_19568)

#[program]
def not_5 : bool_4 -> bool_4 :=
  function not_19573 : bool_4 -> bool_4
  | true_4 => false_5
  | false_5 => true_4

#[program]
def and_6 : bool_4 -> bool_4 -> bool_4 :=
  function and_19577 : bool_4 -> bool_4 -> bool_4
  | true_4 true_4 => true_4
  | true_4 false_5 => false_5
  | false_5 __19580 => false_5

#[program]
def or_7 : bool_4 -> bool_4 -> bool_4 :=
  function or_19583 : bool_4 -> bool_4 -> bool_4
  | true_4 __19586 => true_4
  | false_5 true_4 => true_4
  | false_5 false_5 => false_5

#[program]
def xor_8 : bool_4 -> bool_4 -o bool_4 :=
  function xor_19589 : bool_4 -> bool_4 -o bool_4
  | true_4 true_4 => false_5
  | true_4 false_5 => true_4
  | false_5 true_4 => true_4
  | false_5 false_5 => false_5

#[program]
def lte_9 : nat_5 -> nat_5 -> bool_4 :=
  function lte_19594 : nat_5 -> nat_5 -> bool_4
  | zero_6 __19597 => true_4
  | (succ_7 n_19598) zero_6 => false_5
  | (succ_7 n_19599) (succ_7 n_19600) => ((lte_19594) n_19599 n_19600)

#[program]
def lt_10 : nat_5 -> nat_5 -> bool_4 :=
  function lt_19603 : nat_5 -> nat_5 -> bool_4
  | x_19606 y_19607 => ((lte_9) (succ_7 x_19606) y_19607)

#[program]
def pred_11 : nat_5 -> nat_5 :=
  function pred_19609 : nat_5 -> nat_5
  | zero_6 => zero_6
  | (succ_7 n_19611) => n_19611

#[program]
def add_12 : nat_5 -> nat_5 -> nat_5 :=
  function add_19614 : nat_5 -> nat_5 -> nat_5
  | zero_6 __19617 => __19617
  | (succ_7 n_19618) __19619 => (succ_7 ((add_19614) n_19618 __19619))

#[program]
def sub_13 : nat_5 -> nat_5 -> nat_5 :=
  function sub_19622 : nat_5 -> nat_5 -> nat_5
  | __19625 zero_6 => __19625
  | __19626 (succ_7 n_19627) => ((sub_19622) ((pred_11) __19626) n_19627)

#[program]
def mul_14 : nat_5 -> nat_5 -> nat_5 :=
  function mul_19630 : nat_5 -> nat_5 -> nat_5
  | zero_6 __19633 => zero_6
  | (succ_7 n_19634) __19635 =>
    ((add_12) __19635 ((mul_19630) n_19634 __19635))

#[program]
def div_15 : nat_5 -> nat_5 -> nat_5 :=
  function div_19638 : nat_5 -> nat_5 -> nat_5
  | x_19641 y_19642 =>
    match ((lt_10) x_19641 y_19642) in bool_4 -o nat_5 with
    | true_4 => zero_6
    | false_5 =>
      let loop_19644 :=
        function loop_19645 : nat_5 -> nat_5 -> nat_5
        | x_19648 y_19649 =>
          match ((sub_13) x_19648 ((pred_11) y_19649)) in nat_5 -o nat_5 with
          | zero_6 => zero_6
          | (succ_7 n_19651) => (succ_7 ((loop_19645) n_19651 y_19649))
      in ((loop_19644) x_19641 y_19642)

#[program]
def rem_16 : nat_5 -> nat_5 -> nat_5 :=
  function rem_19654 : nat_5 -> nat_5 -> nat_5
  | x_19657 y_19658 =>
    ((sub_13) x_19657 ((mul_14) ((div_15) x_19657 y_19658) y_19658))

#[program]
def pow_17 : nat_5 -> nat_5 -> nat_5 :=
  function pow_19661 : nat_5 -> nat_5 -> nat_5
  | __19664 zero_6 => (succ_7 zero_6)
  | __19665 (succ_7 n_19666) =>
    ((mul_14) __19665 ((pow_19661) __19665 n_19666))

#[logical]
extern proto_18 : U

#[logical]
extern act0_19s_19667 :
  bool_4 ->
     (A_19669 : Types_19667) -> A_19669 -> proto_18 -> proto_18

#[logical]
extern act1_20s_19672 :
  bool_4 ->
     (A_19674 : Types_19672) -> A_19674 -> proto_18 -> proto_18

#[logical]
extern endp_21 : proto_18

#[logical]
extern ch_22 : bool_4 -> proto_18 -> L

#[program]
extern close_23 :
   {b_19679 : bool_4} -> ((ch_22) b_19679 endp_21) -> IO unit_3

#[program]
extern send0_24s_19681 :
   {b1_19682 : bool_4} ->
     {b2_19683 : bool_4} ->
       {A_19684 : Types_19681} ->
         {B_19685 : A_19684 -> proto_18} ->
          {(eq_1U bool_4 ((xor_8) b1_19682 b2_19683) false_5)} ->
            ((ch_22)
              b1_19682 ((act0_19s_19681) b2_19683 A_19684 B_19685)) ->
               {x_19689 : A_19684} -o
                IO ((ch_22) b1_19682 ((B_19685) x_19689))

#[program]
extern send1_25s_19690 :
   {b1_19691 : bool_4} ->
     {b2_19692 : bool_4} ->
       {A_19693 : Types_19690} ->
         {B_19694 : A_19693 -> proto_18} ->
          {(eq_1U bool_4 ((xor_8) b1_19691 b2_19692) false_5)} ->
            ((ch_22)
              b1_19691 ((act1_20s_19690) b2_19692 A_19693 B_19694)) ->
               (x_19698 : A_19693) -o
                IO ((ch_22) b1_19691 ((B_19694) x_19698))

#[program]
extern recv0_26s_19699 :
   {b1_19700 : bool_4} ->
     {b2_19701 : bool_4} ->
       {A_19702 : Types_19699} ->
         {B_19703 : A_19702 -> proto_18} ->
          {(eq_1U bool_4 ((xor_8) b1_19700 b2_19701) true_4)} ->
            ((ch_22)
              b1_19700 ((act0_19s_19699) b2_19701 A_19702 B_19703)) ->
              IO (exists0_7s_19699,L
                   A_19702
                   function _19707 : A_19702 -> L
                   | __19709 => ((ch_22) b1_19700 ((B_19703) __19709)))

#[program]
extern recv1_27s_19710 :
   {b1_19711 : bool_4} ->
     {b2_19712 : bool_4} ->
       {A_19713 : Types_19710} ->
         {B_19714 : A_19713 -> proto_18} ->
          {(eq_1U bool_4 ((xor_8) b1_19711 b2_19712) true_4)} ->
            ((ch_22)
              b1_19711 ((act1_20s_19710) b2_19712 A_19713 B_19714)) ->
              IO (exists1_8s_19710,L
                   A_19713
                   function _19718 : A_19713 -> L
                   | __19720 => ((ch_22) b1_19711 ((B_19714) __19720)))

#[program]
extern fork_28 :
   {b_19721 : bool_4} ->
     {P_19722 : proto_18} ->
      ((ch_22) b_19721 P_19722) -o IO unit_3 ->
        IO ((ch_22) ((not_5) b_19721) P_19722)

#[program]
def split_29t_19725 :
  (list_6U,t_19725 nat_5) ->
    ((prod1_4t_19725,t_19725)
      (list_6U,t_19725 nat_5) (list_6U,t_19725 nat_5))
:=
  function split_19727 :
    (list_6U,t_19725 nat_5) ->
      ((prod1_4t_19725,t_19725)
        (list_6U,t_19725 nat_5) (list_6U,t_19725 nat_5))
  | nil_8 =>
    (ex1_11t_19725,t_19725
      (list_6U,t_19725 nat_5)
      function _19729 : (list_6U,t_19725 nat_5) -> Typet_19725
      | __19731 => (list_6U,t_19725 nat_5) (nil_8U,t_19725 nat_5)
      (nil_8U,t_19725 nat_5))
  | (cons_9 hd_19732 nil_8) =>
    (ex1_11t_19725,t_19725
      (list_6U,t_19725 nat_5)
      function _19733 : (list_6U,t_19725 nat_5) -> Typet_19725
      | __19735 => (list_6U,t_19725 nat_5)
      (cons_9U,t_19725 nat_5 hd_19732 (nil_8U,t_19725 nat_5))
      (nil_8U,t_19725 nat_5))
  | (cons_9 hd_19736 (cons_9 hd_19737 tl_19738)) =>
    match ((split_19727) tl_19738) in
      ((prod1_4t_19725,t_19725)
        (list_6U,t_19725 nat_5) (list_6U,t_19725 nat_5)) -o
        ((prod1_4t_19725,t_19725)
          (list_6U,t_19725 nat_5) (list_6U,t_19725 nat_5))
    with
    | (ex1_11 m_19740 n_19741) =>
      (ex1_11t_19725,t_19725
        (list_6U,t_19725 nat_5)
        function _19742 : (list_6U,t_19725 nat_5) -> Typet_19725
        | __19744 => (list_6U,t_19725 nat_5)
        (cons_9U,t_19725 nat_5 hd_19736 m_19740)
        (cons_9U,t_19725 nat_5 hd_19737 n_19741))

#[program]
def merge_30t_19745 :
  (list_6U,t_19745 nat_5) ->
    (list_6U,t_19745 nat_5) -o (list_6U,t_19745 nat_5)
:=
  function merge_19748 :
    (list_6U,t_19745 nat_5) ->
      (list_6U,t_19745 nat_5) -o (list_6U,t_19745 nat_5)
  | nil_8 __19751 => __19751
  | (cons_9 hd_19752 tl_19753) nil_8 =>
    (cons_9U,t_19745 nat_5 hd_19752 tl_19753)
  | (cons_9 hd_19754 tl_19755) (cons_9 hd_19756 tl_19757) =>
    match ((lte_9) hd_19754 hd_19756) in
      bool_4 -o (list_6U,t_19745 nat_5)
    with
    | true_4 =>
      (cons_9U,t_19745
        nat_5 hd_19754
        ((merge_19748)
          tl_19755 (cons_9U,t_19745 nat_5 hd_19756 tl_19757)))
    | false_5 =>
      (cons_9U,t_19745
        nat_5 hd_19756
        ((merge_19748)
          (cons_9U,t_19745 nat_5 hd_19754 tl_19755) tl_19757))

#[program]
def msort_31t_19759 :
  (list_6U,t_19759 nat_5) -> (list_6U,t_19759 nat_5)
:=
  function msort_19761 :
    (list_6U,t_19759 nat_5) -> (list_6U,t_19759 nat_5)
  | nil_8 => (nil_8U,t_19759 nat_5)
  | (cons_9 hd_19763 nil_8) =>
    (cons_9U,t_19759 nat_5 hd_19763 (nil_8U,t_19759 nat_5))
  | (cons_9 hd_19764 (cons_9 hd_19765 tl_19766)) =>
    match ((split_29t_19759)
            (cons_9U,t_19759
              nat_5 hd_19764 (cons_9U,t_19759 nat_5 hd_19765 tl_19766))) in
      ((prod1_4t_19759,t_19759)
        (list_6U,t_19759 nat_5) (list_6U,t_19759 nat_5)) -o
        (list_6U,t_19759 nat_5)
    with
    | (ex1_11 m_19768 n_19769) =>
      ((merge_30t_19759)
        ((msort_19761) m_19768) ((msort_19761) n_19769))

#[logical]
def cmsort_ch_32t_19770 : (list_6U,t_19770 nat_5) -> L :=
  function cmsort_ch_19772 : (list_6U,t_19770 nat_5) -> L
  | xs_19774 =>
    ((ch_22)
      true_4
      ((act1_20t_19770)
        true_4
        (sing_2t_19770
          (list_6U,t_19770 nat_5) ((msort_31t_19770) xs_19774))
        function _19775 :
          (sing_2t_19770
            (list_6U,t_19770 nat_5) ((msort_31t_19770) xs_19774)) ->
            proto_18
        | __19777 => endp_21))

#[program]
def cmsort_worker_33t_19778 :
  nat_5 ->
     (zs_19780 : (list_6U,t_19778 nat_5)) ->
      ((cmsort_ch_32t_19778) zs_19780) -o IO unit_3
:=
  function cmsort_worker_19782 :
    nat_5 ->
       (zs_19784 : (list_6U,t_19778 nat_5)) ->
        ((cmsort_ch_32t_19778) zs_19784) -o IO unit_3
  | zero_6 zs_19786 __19787 =>
    let* c_19788 :=
      ((send1_25t_19778)
        true_4 true_4
        (sing_2t_19778
          (list_6U,t_19778 nat_5) ((msort_31t_19778) zs_19786))
        function _19789 :
          (sing_2t_19778
            (list_6U,t_19778 nat_5) ((msort_31t_19778) zs_19786)) ->
            proto_18
        | __19791 => endp_21 (refl_1U bool_4 ((xor_8) true_4 true_4))
        __19787
        (just_2t_19778
          (list_6U,t_19778 nat_5) ((msort_31t_19778) zs_19786)))
    in ((close_23) true_4 c_19788)
  | (succ_7 n_19792) nil_8 __19793 =>
    let* c_19794 :=
      ((send1_25t_19778)
        true_4 true_4
        (sing_2t_19778
          (list_6U,t_19778 nat_5)
          ((msort_31t_19778) (nil_8U,t_19778 nat_5)))
        function _19795 :
          (sing_2t_19778
            (list_6U,t_19778 nat_5)
            ((msort_31t_19778) (nil_8U,t_19778 nat_5))) ->
            proto_18
        | __19797 => endp_21 (refl_1U bool_4 ((xor_8) true_4 true_4))
        __19793
        (just_2t_19778
          (list_6U,t_19778 nat_5) (nil_8U,t_19778 nat_5)))
    in ((close_23) true_4 c_19794)
  | (succ_7 n_19798) (cons_9 hd_19799 nil_8) __19800 =>
    let* c_19801 :=
      ((send1_25t_19778)
        true_4 true_4
        (sing_2t_19778
          (list_6U,t_19778 nat_5)
          ((msort_31t_19778)
            (cons_9U,t_19778
              nat_5 hd_19799 (nil_8U,t_19778 nat_5))))
        function _19802 :
          (sing_2t_19778
            (list_6U,t_19778 nat_5)
            ((msort_31t_19778)
              (cons_9U,t_19778
                nat_5 hd_19799 (nil_8U,t_19778 nat_5)))) ->
            proto_18
        | __19804 => endp_21 (refl_1U bool_4 ((xor_8) true_4 true_4))
        __19800
        (just_2t_19778
          (list_6U,t_19778 nat_5)
          (cons_9U,t_19778 nat_5 hd_19799 (nil_8U,t_19778 nat_5))))
    in ((close_23) true_4 c_19801)
  | (succ_7 n_19805) (cons_9 hd_19806 (cons_9 hd_19807 tl_19808)) __19809 =>
    match ((split_29t_19778)
            (cons_9U,t_19778
              nat_5 hd_19806 (cons_9U,t_19778 nat_5 hd_19807 tl_19808))),
    (refl_1t_19778
      (list_6U,t_19778 nat_5)
      match ((split_29t_19778)
              (cons_9U,t_19778
                nat_5 hd_19806
                (cons_9U,t_19778 nat_5 hd_19807 tl_19808))) in
        ((prod1_4t_19778,t_19778)
          (list_6U,t_19778 nat_5) (list_6U,t_19778 nat_5)) -o
          (list_6U,t_19778 nat_5)
      with
      | (ex1_11 m_19811 n_19812) =>
        ((merge_30t_19778)
          ((msort_31t_19778) m_19811) ((msort_31t_19778) n_19812))) in
       (h1_19813 :
        ((prod1_4t_19778,t_19778)
          (list_6U,t_19778 nat_5) (list_6U,t_19778 nat_5))) -o
        {(eq_1t_19778
           (list_6U,t_19778 nat_5)
           match h1_19813 in
             ((prod1_4t_19778,t_19778)
               (list_6U,t_19778 nat_5) (list_6U,t_19778 nat_5)) -o
               (list_6U,t_19778 nat_5)
           with
           | (ex1_11 m_19816 n_19817) =>
             ((merge_30t_19778)
               ((msort_31t_19778) m_19816)
               ((msort_31t_19778) n_19817))
           match ((split_29t_19778)
                   (cons_9U,t_19778
                     nat_5 hd_19806
                     (cons_9U,t_19778 nat_5 hd_19807 tl_19808))) in
             ((prod1_4t_19778,t_19778)
               (list_6U,t_19778 nat_5) (list_6U,t_19778 nat_5)) -o
               (list_6U,t_19778 nat_5)
           with
           | (ex1_11 m_19819 n_19820) =>
             ((merge_30t_19778)
               ((msort_31t_19778) m_19819)
               ((msort_31t_19778) n_19820)))} -o
          IO unit_3
    with
    | (ex1_11 m_19821 n_19822), __19823 =>
      let* r1_19824 :=
        ((fork_28)
          true_4
          ((act1_20t_19778)
            true_4
            (sing_2t_19778
              (list_6U,t_19778 nat_5) ((msort_31t_19778) m_19821))
            function _19825 :
              (sing_2t_19778
                (list_6U,t_19778 nat_5)
                ((msort_31t_19778) m_19821)) -> proto_18
            | __19827 => endp_21)
          function _19828 :
            ((ch_22)
              true_4
              ((act1_20t_19778)
                true_4
                (sing_2t_19778
                  (list_6U,t_19778 nat_5)
                  ((msort_31t_19778) m_19821))
                function _19830 :
                  (sing_2t_19778
                    (list_6U,t_19778 nat_5)
                    ((msort_31t_19778) m_19821)) -> proto_18
                | __19832 => endp_21)) -o
              IO unit_3
          | __19833 => ((cmsort_worker_19782) n_19805 m_19821 __19833))
      in
      let* r2_19834 :=
        ((fork_28)
          true_4
          ((act1_20t_19778)
            true_4
            (sing_2t_19778
              (list_6U,t_19778 nat_5) ((msort_31t_19778) n_19822))
            function _19835 :
              (sing_2t_19778
                (list_6U,t_19778 nat_5)
                ((msort_31t_19778) n_19822)) -> proto_18
            | __19837 => endp_21)
          function _19838 :
            ((ch_22)
              true_4
              ((act1_20t_19778)
                true_4
                (sing_2t_19778
                  (list_6U,t_19778 nat_5)
                  ((msort_31t_19778) n_19822))
                function _19840 :
                  (sing_2t_19778
                    (list_6U,t_19778 nat_5)
                    ((msort_31t_19778) n_19822)) -> proto_18
                | __19842 => endp_21)) -o
              IO unit_3
          | __19843 => ((cmsort_worker_19782) n_19805 n_19822 __19843))
      in
      let* _19844 :=
        ((recv1_27t_19778)
          ((not_5) true_4) true_4
          (sing_2t_19778
            (list_6U,t_19778 nat_5) ((msort_31t_19778) m_19821))
          function _19845 :
            (sing_2t_19778
              (list_6U,t_19778 nat_5) ((msort_31t_19778) m_19821)) ->
              proto_18
          | __19847 => endp_21
          (refl_1U bool_4 ((xor_8) ((not_5) true_4) true_4)) r1_19824)
      in
      match _19844 in
        (exists1_8t_19778,L
          (sing_2t_19778
            (list_6U,t_19778 nat_5) ((msort_31t_19778) m_19821))
          function _19849 :
            (sing_2t_19778
              (list_6U,t_19778 nat_5) ((msort_31t_19778) m_19821)) ->
              L
          | __19851 =>
            ((ch_22)
              ((not_5) true_4)
              ((function _19852 :
                  (sing_2t_19778
                    (list_6U,t_19778 nat_5)
                    ((msort_31t_19778) m_19821)) -> proto_18
                | __19854 => endp_21) __19851))) -o
          IO unit_3
      with
      | (ex1_11 m_19855 n_19856) =>
        let* _19857 :=
          ((recv1_27t_19778)
            ((not_5) true_4) true_4
            (sing_2t_19778
              (list_6U,t_19778 nat_5) ((msort_31t_19778) n_19822))
            function _19858 :
              (sing_2t_19778
                (list_6U,t_19778 nat_5)
                ((msort_31t_19778) n_19822)) -> proto_18
            | __19860 => endp_21
            (refl_1U bool_4 ((xor_8) ((not_5) true_4) true_4)) r2_19834)
        in
        match _19857 in
          (exists1_8t_19778,L
            (sing_2t_19778
              (list_6U,t_19778 nat_5) ((msort_31t_19778) n_19822))
            function _19862 :
              (sing_2t_19778
                (list_6U,t_19778 nat_5)
                ((msort_31t_19778) n_19822)) -> L
            | __19864 =>
              ((ch_22)
                ((not_5) true_4)
                ((function _19865 :
                    (sing_2t_19778
                      (list_6U,t_19778 nat_5)
                      ((msort_31t_19778) n_19822)) -> proto_18
                  | __19867 => endp_21) __19864))) -o
            IO unit_3
        with
        | (ex1_11 m_19868 n_19869) =>
          match m_19855, m_19868 in
            (sing_2t_19778
              (list_6U,t_19778 nat_5) ((msort_31t_19778) m_19821)) -o
              (sing_2t_19778
                (list_6U,t_19778 nat_5)
                ((msort_31t_19778) n_19822)) -o IO unit_3
          with
          | (just_2 m_19872), (just_2 m_19873) =>
            let zs1_19874 :=
              ((just_2t_19778
                 (list_6U,t_19778 nat_5)
                 ((merge_30t_19778) m_19872 m_19873))
                : (sing_2t_19778
                    (list_6U,t_19778 nat_5)
                    ((merge_30t_19778)
                      ((msort_31t_19778) m_19821)
                      ((msort_31t_19778) n_19822))))
            in
            let zs1_19875 :=
              (((rwl_1t_19778,t_19778)
                 (list_6U,t_19778 nat_5)
                 ((merge_30t_19778)
                   ((msort_31t_19778) m_19821)
                   ((msort_31t_19778) n_19822))
                 match ((split_29t_19778)
                         (cons_9U,t_19778
                           nat_5 hd_19806
                           (cons_9U,t_19778 nat_5 hd_19807 tl_19808))) in
                   ((prod1_4t_19778,t_19778)
                     (list_6U,t_19778 nat_5)
                     (list_6U,t_19778 nat_5)) -o
                     (list_6U,t_19778 nat_5)
                 with
                 | (ex1_11 m_19877 n_19878) =>
                   ((merge_30t_19778)
                     ((msort_31t_19778) m_19877)
                     ((msort_31t_19778) n_19878))
                 function _19879 :
                   (list_6U,t_19778 nat_5) -> Typet_19778
                 | __19881 =>
                   (sing_2t_19778
                     (list_6U,t_19778 nat_5) __19881)
                 __19823 zs1_19874)
                : (sing_2t_19778
                    (list_6U,t_19778 nat_5)
                    ((msort_31t_19778)
                      (cons_9U,t_19778
                        nat_5 hd_19806
                        (cons_9U,t_19778 nat_5 hd_19807 tl_19808)))))
            in
            let* c_19882 :=
              ((send1_25t_19778)
                true_4 true_4
                (sing_2t_19778
                  (list_6U,t_19778 nat_5)
                  ((msort_31t_19778)
                    (cons_9U,t_19778
                      nat_5 hd_19806
                      (cons_9U,t_19778 nat_5 hd_19807 tl_19808))))
                function _19883 :
                  (sing_2t_19778
                    (list_6U,t_19778 nat_5)
                    ((msort_31t_19778)
                      (cons_9U,t_19778
                        nat_5 hd_19806
                        (cons_9U,t_19778 nat_5 hd_19807 tl_19808)))) ->
                    proto_18
                | __19885 => endp_21
                (refl_1U bool_4 ((xor_8) true_4 true_4)) __19809
                zs1_19875)
            in
            let* __19886 := ((close_23) ((not_5) true_4) n_19856) in
            let* __19887 := ((close_23) ((not_5) true_4) n_19869) in
            let* __19888 := ((close_23) true_4 c_19882) in return tt_3

-----------------------------------------

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
def rwlUU_37 :=
  fun rwl_31599 {A_31600} -> {m_31601} -> {n_31602} -> {B_31603} ->
  {__31604} -> (__31605) ->
    match {NULL} with
    | reflU_13  => __31605
    end

#[program]
def rwlUL_36 :=
  fun rwl_31606 {A_31607} -> {m_31608} -> {n_31609} -> {B_31610} ->
  {__31611} -> (__31612) ->
    match {NULL} with
    | reflU_13  => __31612
    end

#[program]
def rwlLU_35 :=
  fun rwl_31613 {A_31614} -> {m_31615} -> {n_31616} -> {B_31617} ->
  {__31618} -> (__31619) ->
    match {NULL} with
    | reflL_12  => __31619
    end

#[program]
def rwlLL_34 :=
  fun rwl_31620 {A_31621} -> {m_31622} -> {n_31623} -> {B_31624} ->
  {__31625} -> (__31626) ->
    match {NULL} with
    | reflL_12  => __31626
    end

#[program]
def rwrUU_41 :=
  fun rwr_31627 {A_31628} -> {m_31629} -> {n_31630} -> {B_31631} ->
  {__31632} -> (__31633) ->
    match {NULL} with
    | reflU_13  => __31633
    end

#[program]
def rwrUL_40 :=
  fun rwr_31634 {A_31635} -> {m_31636} -> {n_31637} -> {B_31638} ->
  {__31639} -> (__31640) ->
    match {NULL} with
    | reflU_13  => __31640
    end

#[program]
def rwrLU_39 :=
  fun rwr_31641 {A_31642} -> {m_31643} -> {n_31644} -> {B_31645} ->
  {__31646} -> (__31647) ->
    match {NULL} with
    | reflL_12  => __31647
    end

#[program]
def rwrLL_38 :=
  fun rwr_31648 {A_31649} -> {m_31650} -> {n_31651} -> {B_31652} ->
  {__31653} -> (__31654) ->
    match {NULL} with
    | reflL_12  => __31654
    end

#[program]
inductive singU_12 where
| justU_15 of layout[R]

#[program]
inductive singL_11 where
| justL_14 of layout[R]

#[program]
inductive unit_3 where
| tt_3 of layout[]

#[program]
inductive bool_4 where
| true_4 of layout[]
| false_5 of layout[]

#[program]
inductive nat_5 where
| zero_6 of layout[]
| succ_7 of layout[R]

#[program]
inductive listUU_16 where
| nilUU_22 of layout[]
| consUU_23 of layout[R, R]

#[program]
inductive listUL_15 where
| nilUL_20 of layout[]
| consUL_21 of layout[R, R]

#[program]
inductive listLU_14 where
| nilLU_18 of layout[]

#[program]
inductive listLL_13 where
| nilLL_16 of layout[]
| consLL_17 of layout[R, R]

#[program]
inductive exists0UU_20 where
| ex0UU_27 of layout[N, R]

#[program]
inductive exists0UL_19 where
| ex0UL_26 of layout[N, R]

#[program]
inductive exists0LU_18 where
| ex0LU_25 of layout[N, R]

#[program]
inductive exists0LL_17 where
| ex0LL_24 of layout[N, R]

#[program]
inductive exists1UU_24 where
| ex1UU_31 of layout[R, R]

#[program]
inductive exists1UL_23 where
| ex1UL_30 of layout[R, R]

#[program]
inductive exists1LU_22 where
| ex1LU_29 of layout[R, R]

#[program]
inductive exists1LL_21 where
| ex1LL_28 of layout[R, R]

#[logical]
def prod0UU_45 := NULL

#[logical]
def prod0UL_44 := NULL

#[logical]
def prod0LU_43 := NULL

#[logical]
def prod0LL_42 := NULL

#[logical]
def prod1UU_49 := NULL

#[logical]
def prod1UL_48 := NULL

#[logical]
def prod1LU_47 := NULL

#[logical]
def prod1LL_46 := NULL

#[program]
def not_5 :=
  fun not_31655 (__31656) ->
    match __31656 with
    | true_4  => false_5 | false_5  => true_4
    end

#[program]
def and_6 :=
  fun and_31657 (__31658) -> (__31659) ->
    match __31658 with
    | true_4  =>
      match __31659 with
      | true_4  => true_4 | false_5  => false_5
      end
    | false_5  => false_5
    end

#[program]
def or_7 :=
  fun or_31660 (__31661) -> (__31662) ->
    match __31661 with
    | true_4  => true_4
    | false_5  =>
      match __31662 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def xor_8 :=
  fun xor_31663 (__31664) -> (__31665) -o
    match __31664 with
    | true_4  =>
      match __31665 with
      | true_4  => false_5 | false_5  => true_4
      end
    | false_5  =>
      match __31665 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def lte_9 :=
  fun lte_31666 (__31667) -> (__31668) ->
    match __31667 with
    | zero_6  => true_4
    | succ_7 n_31669 =>
      match __31668 with
      | zero_6  => false_5 | succ_7 n_31670 => ((lte_31666) n_31669 n_31670)
      end
    end

#[program]
def lt_10 :=
  fun lt_31671 (x_31672) -> (y_31673) ->
    ((lte_9) (succ_7 x_31672) y_31673)

#[program]
def pred_11 :=
  fun pred_31674 (__31675) ->
    match __31675 with
    | zero_6  => zero_6 | succ_7 n_31676 => n_31676
    end

#[program]
def add_12 :=
  fun add_31677 (__31678) -> (__31679) ->
    match __31678 with
    | zero_6  => __31679
    | succ_7 n_31680 => (succ_7 ((add_31677) n_31680 __31679))
    end

#[program]
def sub_13 :=
  fun sub_31681 (__31682) -> (__31683) ->
    match __31683 with
    | zero_6  => __31682
    | succ_7 n_31684 => ((sub_31681) ((pred_11) __31682) n_31684)
    end

#[program]
def mul_14 :=
  fun mul_31685 (__31686) -> (__31687) ->
    match __31686 with
    | zero_6  => zero_6
    | succ_7 n_31688 => ((add_12) __31687 ((mul_31685) n_31688 __31687))
    end

#[program]
def div_15 :=
  fun div_31689 (x_31690) -> (y_31691) ->
    match ((lt_10) x_31690 y_31691) with
    | true_4  => zero_6
    | false_5  =>
      let loop_31692 :=
        fun loop_31693 (x_31694) -> (y_31695) ->
          match ((sub_13) x_31694 ((pred_11) y_31695)) with
          | zero_6  => zero_6
          | succ_7 n_31696 => (succ_7 ((loop_31693) n_31696 y_31695))
          end
      in ((loop_31692) x_31690 y_31691)
    end

#[program]
def rem_16 :=
  fun rem_31697 (x_31698) -> (y_31699) ->
    ((sub_13) x_31698 ((mul_14) ((div_15) x_31698 y_31699) y_31699))

#[program]
def pow_17 :=
  fun pow_31700 (__31701) -> (__31702) ->
    match __31702 with
    | zero_6  => (succ_7 zero_6)
    | succ_7 n_31703 => ((mul_14) __31701 ((pow_31700) __31701 n_31703))
    end

#[logical]
extern proto_18

#[logical]
extern act0U_51

#[logical]
extern act0L_50

#[logical]
extern act1U_53

#[logical]
extern act1L_52

#[logical]
extern endp_21

#[logical]
extern ch_22

#[program]
extern close_23

#[program]
extern send0U_55

#[program]
extern send0L_54

#[program]
extern send1U_57

#[program]
extern send1L_56

#[program]
extern recv0U_59

#[program]
extern recv0L_58

#[program]
extern recv1U_61

#[program]
extern recv1L_60

#[program]
extern fork_28

#[program]
def splitU_63 :=
  fun split_31704 (__31705) ->
    match __31705 with
    | nilUU_22  => (ex1UU_31 nilUU_22 nilUU_22)
    | consUU_23 hd_31706 tl_31707 =>
      match tl_31707 with
      | nilUU_22  => (ex1UU_31 (consUU_23 hd_31706 nilUU_22) nilUU_22)
      | consUU_23 hd_31708 tl_31709 =>
        match ((split_31704) tl_31709) with
        | ex1UU_31 m_31710 n_31711 =>
          (ex1UU_31
            (consUU_23 hd_31706 m_31710) (consUU_23 hd_31708 n_31711))
        end
      end
    end

#[program]
def splitL_62 :=
  fun split_31712 (__31713) ->
    match __31713 with
    | nilUL_20  => (ex1LL_28 nilUL_20 nilUL_20)
    | consUL_21 hd_31714 tl_31715 =>
      match tl_31715 with
      | nilUL_20  => (ex1LL_28 (consUL_21 hd_31714 nilUL_20) nilUL_20)
      | consUL_21 hd_31716 tl_31717 =>
        match ((split_31712) tl_31717) with
        | ex1LL_28 m_31718 n_31719 =>
          (ex1LL_28
            (consUL_21 hd_31714 m_31718) (consUL_21 hd_31716 n_31719))
        end
      end
    end

#[program]
def mergeU_65 :=
  fun merge_31720 (__31721) -> (__31722) -o
    match __31721 with
    | nilUU_22  => __31722
    | consUU_23 hd_31723 tl_31724 =>
      match __31722 with
      | nilUU_22  => (consUU_23 hd_31723 tl_31724)
      | consUU_23 hd_31725 tl_31726 =>
        match ((lte_9) hd_31723 hd_31725) with
        | true_4  =>
          (consUU_23
            hd_31723 ((merge_31720) tl_31724 (consUU_23 hd_31725 tl_31726)))
        | false_5  =>
          (consUU_23
            hd_31725 ((merge_31720) (consUU_23 hd_31723 tl_31724) tl_31726))
        end
      end
    end

#[program]
def mergeL_64 :=
  fun merge_31727 (__31728) -> (__31729) -o
    match __31728 with
    | nilUL_20  => __31729
    | consUL_21 hd_31730 tl_31731 =>
      match __31729 with
      | nilUL_20  => (consUL_21 hd_31730 tl_31731)
      | consUL_21 hd_31732 tl_31733 =>
        match ((lte_9) hd_31730 hd_31732) with
        | true_4  =>
          (consUL_21
            hd_31730 ((merge_31727) tl_31731 (consUL_21 hd_31732 tl_31733)))
        | false_5  =>
          (consUL_21
            hd_31732 ((merge_31727) (consUL_21 hd_31730 tl_31731) tl_31733))
        end
      end
    end

#[program]
def msortU_67 :=
  fun msort_31734 (__31735) ->
    match __31735 with
    | nilUU_22  => nilUU_22
    | consUU_23 hd_31736 tl_31737 =>
      match tl_31737 with
      | nilUU_22  => (consUU_23 hd_31736 nilUU_22)
      | consUU_23 hd_31738 tl_31739 =>
        match ((splitU_63)
                (consUU_23 hd_31736 (consUU_23 hd_31738 tl_31739))) with
        | ex1UU_31 m_31740 n_31741 =>
          ((mergeU_65) ((msort_31734) m_31740) ((msort_31734) n_31741))
        end
      end
    end

#[program]
def msortL_66 :=
  fun msort_31742 (__31743) ->
    match __31743 with
    | nilUL_20  => nilUL_20
    | consUL_21 hd_31744 tl_31745 =>
      match tl_31745 with
      | nilUL_20  => (consUL_21 hd_31744 nilUL_20)
      | consUL_21 hd_31746 tl_31747 =>
        match ((splitL_62)
                (consUL_21 hd_31744 (consUL_21 hd_31746 tl_31747))) with
        | ex1LL_28 m_31748 n_31749 =>
          ((mergeL_64) ((msort_31742) m_31748) ((msort_31742) n_31749))
        end
      end
    end

#[logical]
def cmsort_chU_69 := NULL

#[logical]
def cmsort_chL_68 := NULL

#[program]
def cmsort_workerU_71 :=
  fun cmsort_worker_31750 (__31751) -> (zs_31752) -> (__31753) -o
    match __31751 with
    | zero_6  =>
      let* c_31754 :=
        ((send1U_57)
          NULL NULL NULL NULL NULL __31753 (justU_15 ((msortU_67) zs_31752)))
      in ((close_23) NULL c_31754)
    | succ_7 n_31755 =>
      match zs_31752 with
      | nilUU_22  =>
        let* c_31756 :=
          ((send1U_57) NULL NULL NULL NULL NULL __31753 (justU_15 nilUU_22))
        in ((close_23) NULL c_31756)
      | consUU_23 hd_31757 tl_31758 =>
        match tl_31758 with
        | nilUU_22  =>
          let* c_31759 :=
            ((send1U_57)
              NULL NULL NULL NULL NULL __31753
              (justU_15 (consUU_23 hd_31757 nilUU_22)))
          in ((close_23) NULL c_31759)
        | consUU_23 hd_31760 tl_31761 =>
          match ((splitU_63)
                  (consUU_23 hd_31757 (consUU_23 hd_31760 tl_31761))) with
          | ex1UU_31 m_31762 n_31763 =>
            let* r1_31764 :=
              ((fork_28)
                NULL NULL
                fun _31765 (c1_31766) -o
                  ((cmsort_worker_31750) n_31755 m_31762 c1_31766))
            in
            let* r2_31767 :=
              ((fork_28)
                NULL NULL
                fun _31768 (c2_31769) -o
                  ((cmsort_worker_31750) n_31755 n_31763 c2_31769))
            in
            let* _31770 := ((recv1U_61) NULL NULL NULL NULL NULL r1_31764) in
            match _31770 with
            | ex1UL_30 m_31771 n_31772 =>
              let* _31773 := ((recv1U_61) NULL NULL NULL NULL NULL r2_31767)
              in
              match _31773 with
              | ex1UL_30 m_31774 n_31775 =>
                match m_31771 with
                | justU_15 m_31776 =>
                  match m_31774 with
                  | justU_15 m_31777 =>
                    let zs1_31778 := (justU_15 ((mergeU_65) m_31776 m_31777))
                    in
                    let zs1_31779 :=
                      ((rwlUU_37) NULL NULL NULL NULL NULL zs1_31778)
                    in
                    let* c_31780 :=
                      ((send1U_57)
                        NULL NULL NULL NULL NULL __31753 zs1_31779)
                    in
                    let* __31781 := ((close_23) NULL n_31772) in
                    let* __31782 := ((close_23) NULL n_31775) in
                    let* __31783 := ((close_23) NULL c_31780) in return tt_3
                  end
                end
              end
            end
          end
        end
      end
    end

#[program]
def cmsort_workerL_70 :=
  fun cmsort_worker_31784 (__31785) -> (zs_31786) -> (__31787) -o
    match __31785 with
    | zero_6  =>
      let* c_31788 :=
        ((send1L_56)
          NULL NULL NULL NULL NULL __31787 (justL_14 ((msortL_66) zs_31786)))
      in ((close_23) NULL c_31788)
    | succ_7 n_31789 =>
      match zs_31786 with
      | nilUL_20  =>
        let* c_31790 :=
          ((send1L_56) NULL NULL NULL NULL NULL __31787 (justL_14 nilUL_20))
        in ((close_23) NULL c_31790)
      | consUL_21 hd_31791 tl_31792 =>
        match tl_31792 with
        | nilUL_20  =>
          let* c_31793 :=
            ((send1L_56)
              NULL NULL NULL NULL NULL __31787
              (justL_14 (consUL_21 hd_31791 nilUL_20)))
          in ((close_23) NULL c_31793)
        | consUL_21 hd_31794 tl_31795 =>
          match ((splitL_62)
                  (consUL_21 hd_31791 (consUL_21 hd_31794 tl_31795))) with
          | ex1LL_28 m_31796 n_31797 =>
            let* r1_31798 :=
              ((fork_28)
                NULL NULL
                fun _31799 (c1_31800) -o
                  ((cmsort_worker_31784) n_31789 m_31796 c1_31800))
            in
            let* r2_31801 :=
              ((fork_28)
                NULL NULL
                fun _31802 (c2_31803) -o
                  ((cmsort_worker_31784) n_31789 n_31797 c2_31803))
            in
            let* _31804 := ((recv1L_60) NULL NULL NULL NULL NULL r1_31798) in
            match _31804 with
            | ex1LL_28 m_31805 n_31806 =>
              let* _31807 := ((recv1L_60) NULL NULL NULL NULL NULL r2_31801)
              in
              match _31807 with
              | ex1LL_28 m_31808 n_31809 =>
                match m_31805 with
                | justL_14 m_31810 =>
                  match m_31808 with
                  | justL_14 m_31811 =>
                    let zs1_31812 := (justL_14 ((mergeL_64) m_31810 m_31811))
                    in
                    let zs1_31813 :=
                      ((rwlLL_34) NULL NULL NULL NULL NULL zs1_31812)
                    in
                    let* c_31814 :=
                      ((send1L_56)
                        NULL NULL NULL NULL NULL __31787 zs1_31813)
                    in
                    let* __31815 := ((close_23) NULL n_31806) in
                    let* __31816 := ((close_23) NULL n_31809) in
                    let* __31817 := ((close_23) NULL c_31814) in return tt_3
                  end
                end
              end
            end
          end
        end
      end
    end

-----------------------------------------

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
def rwlUU_37 :=
  fun rwl_32037 {A_32038} -> {m_32039} -> {n_32040} -> {B_32041} ->
  {__32042} -> (__32043) ->
    __32043

#[program]
def rwlUL_36 :=
  fun rwl_32044 {A_32045} -> {m_32046} -> {n_32047} -> {B_32048} ->
  {__32049} -> (__32050) ->
    __32050

#[program]
def rwlLU_35 :=
  fun rwl_32051 {A_32052} -> {m_32053} -> {n_32054} -> {B_32055} ->
  {__32056} -> (__32057) ->
    __32057

#[program]
def rwlLL_34 :=
  fun rwl_32058 {A_32059} -> {m_32060} -> {n_32061} -> {B_32062} ->
  {__32063} -> (__32064) ->
    __32064

#[program]
def rwrUU_41 :=
  fun rwr_32065 {A_32066} -> {m_32067} -> {n_32068} -> {B_32069} ->
  {__32070} -> (__32071) ->
    __32071

#[program]
def rwrUL_40 :=
  fun rwr_32072 {A_32073} -> {m_32074} -> {n_32075} -> {B_32076} ->
  {__32077} -> (__32078) ->
    __32078

#[program]
def rwrLU_39 :=
  fun rwr_32079 {A_32080} -> {m_32081} -> {n_32082} -> {B_32083} ->
  {__32084} -> (__32085) ->
    __32085

#[program]
def rwrLL_38 :=
  fun rwr_32086 {A_32087} -> {m_32088} -> {n_32089} -> {B_32090} ->
  {__32091} -> (__32092) ->
    __32092

#[program]
inductive singU_12 where
| justU_15 of layout[R]

#[program]
inductive singL_11 where
| justL_14 of layout[R]

#[program]
inductive unit_3 where
| tt_3 of layout[]

#[program]
inductive bool_4 where
| true_4 of layout[]
| false_5 of layout[]

#[program]
inductive nat_5 where
| zero_6 of layout[]
| succ_7 of layout[R]

#[program]
inductive listUU_16 where
| nilUU_22 of layout[]
| consUU_23 of layout[R, R]

#[program]
inductive listUL_15 where
| nilUL_20 of layout[]
| consUL_21 of layout[R, R]

#[program]
inductive listLU_14 where
| nilLU_18 of layout[]

#[program]
inductive listLL_13 where
| nilLL_16 of layout[]
| consLL_17 of layout[R, R]

#[program]
inductive exists0UU_20 where
| ex0UU_27 of layout[N, R]

#[program]
inductive exists0UL_19 where
| ex0UL_26 of layout[N, R]

#[program]
inductive exists0LU_18 where
| ex0LU_25 of layout[N, R]

#[program]
inductive exists0LL_17 where
| ex0LL_24 of layout[N, R]

#[program]
inductive exists1UU_24 where
| ex1UU_31 of layout[R, R]

#[program]
inductive exists1UL_23 where
| ex1UL_30 of layout[R, R]

#[program]
inductive exists1LU_22 where
| ex1LU_29 of layout[R, R]

#[program]
inductive exists1LL_21 where
| ex1LL_28 of layout[R, R]

#[logical]
def prod0UU_45 := NULL

#[logical]
def prod0UL_44 := NULL

#[logical]
def prod0LU_43 := NULL

#[logical]
def prod0LL_42 := NULL

#[logical]
def prod1UU_49 := NULL

#[logical]
def prod1UL_48 := NULL

#[logical]
def prod1LU_47 := NULL

#[logical]
def prod1LL_46 := NULL

#[program]
def not_5 :=
  fun not_32093 (__32094) ->
    match __32094 with
    | true_4  => false_5 | false_5  => true_4
    end

#[program]
def and_6 :=
  fun and_32095 (__32096) -> (__32097) ->
    match __32096 with
    | true_4  =>
      match __32097 with
      | true_4  => true_4 | false_5  => false_5
      end
    | false_5  => false_5
    end

#[program]
def or_7 :=
  fun or_32098 (__32099) -> (__32100) ->
    match __32099 with
    | true_4  => true_4
    | false_5  =>
      match __32100 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def xor_8 :=
  fun xor_32101 (__32102) -> (__32103) -o
    match __32102 with
    | true_4  =>
      match __32103 with
      | true_4  => false_5 | false_5  => true_4
      end
    | false_5  =>
      match __32103 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def lte_9 :=
  fun lte_32104 (__32105) -> (__32106) ->
    match __32105 with
    | zero_6  => true_4
    | succ_7 n_32107 =>
      match __32106 with
      | zero_6  => false_5 | succ_7 n_32108 => ((lte_32104) n_32107 n_32108)
      end
    end

#[program]
def lt_10 :=
  fun lt_32109 (x_32110) -> (y_32111) ->
    ((lte_9) (succ_7 x_32110) y_32111)

#[program]
def pred_11 :=
  fun pred_32112 (__32113) ->
    match __32113 with
    | zero_6  => zero_6 | succ_7 n_32114 => n_32114
    end

#[program]
def add_12 :=
  fun add_32115 (__32116) -> (__32117) ->
    match __32116 with
    | zero_6  => __32117
    | succ_7 n_32118 => (succ_7 ((add_32115) n_32118 __32117))
    end

#[program]
def sub_13 :=
  fun sub_32119 (__32120) -> (__32121) ->
    match __32121 with
    | zero_6  => __32120
    | succ_7 n_32122 => ((sub_32119) ((pred_11) __32120) n_32122)
    end

#[program]
def mul_14 :=
  fun mul_32123 (__32124) -> (__32125) ->
    match __32124 with
    | zero_6  => zero_6
    | succ_7 n_32126 => ((add_12) __32125 ((mul_32123) n_32126 __32125))
    end

#[program]
def div_15 :=
  fun div_32127 (x_32128) -> (y_32129) ->
    match ((lt_10) x_32128 y_32129) with
    | true_4  => zero_6
    | false_5  =>
      let loop_32130 :=
        fun loop_32131 (x_32132) -> (y_32133) ->
          match ((sub_13) x_32132 ((pred_11) y_32133)) with
          | zero_6  => zero_6
          | succ_7 n_32134 => (succ_7 ((loop_32131) n_32134 y_32133))
          end
      in ((loop_32130) x_32128 y_32129)
    end

#[program]
def rem_16 :=
  fun rem_32135 (x_32136) -> (y_32137) ->
    ((sub_13) x_32136 ((mul_14) ((div_15) x_32136 y_32137) y_32137))

#[program]
def pow_17 :=
  fun pow_32138 (__32139) -> (__32140) ->
    match __32140 with
    | zero_6  => (succ_7 zero_6)
    | succ_7 n_32141 => ((mul_14) __32139 ((pow_32138) __32139 n_32141))
    end

#[logical]
extern proto_18

#[logical]
extern act0U_51

#[logical]
extern act0L_50

#[logical]
extern act1U_53

#[logical]
extern act1L_52

#[logical]
extern endp_21

#[logical]
extern ch_22

#[program]
extern close_23

#[program]
extern send0U_55

#[program]
extern send0L_54

#[program]
extern send1U_57

#[program]
extern send1L_56

#[program]
extern recv0U_59

#[program]
extern recv0L_58

#[program]
extern recv1U_61

#[program]
extern recv1L_60

#[program]
extern fork_28

#[program]
def splitU_63 :=
  fun split_32142 (__32143) ->
    match __32143 with
    | nilUU_22  => (ex1UU_31 nilUU_22 nilUU_22)
    | consUU_23 hd_32144 tl_32145 =>
      match tl_32145 with
      | nilUU_22  => (ex1UU_31 (consUU_23 hd_32144 nilUU_22) nilUU_22)
      | consUU_23 hd_32146 tl_32147 =>
        match ((split_32142) tl_32147) with
        | ex1UU_31 m_32148 n_32149 =>
          (ex1UU_31
            (consUU_23 hd_32144 m_32148) (consUU_23 hd_32146 n_32149))
        end
      end
    end

#[program]
def splitL_62 :=
  fun split_32150 (__32151) ->
    match __32151 with
    | nilUL_20  => (ex1LL_28 nilUL_20 nilUL_20)
    | consUL_21 hd_32152 tl_32153 =>
      match tl_32153 with
      | nilUL_20  => (ex1LL_28 (consUL_21 hd_32152 nilUL_20) nilUL_20)
      | consUL_21 hd_32154 tl_32155 =>
        match ((split_32150) tl_32155) with
        | ex1LL_28 m_32156 n_32157 =>
          (ex1LL_28
            (consUL_21 hd_32152 m_32156) (consUL_21 hd_32154 n_32157))
        end
      end
    end

#[program]
def mergeU_65 :=
  fun merge_32158 (__32159) -> (__32160) -o
    match __32159 with
    | nilUU_22  => __32160
    | consUU_23 hd_32161 tl_32162 =>
      match __32160 with
      | nilUU_22  => (consUU_23 hd_32161 tl_32162)
      | consUU_23 hd_32163 tl_32164 =>
        match ((lte_9) hd_32161 hd_32163) with
        | true_4  =>
          (consUU_23
            hd_32161 ((merge_32158) tl_32162 (consUU_23 hd_32163 tl_32164)))
        | false_5  =>
          (consUU_23
            hd_32163 ((merge_32158) (consUU_23 hd_32161 tl_32162) tl_32164))
        end
      end
    end

#[program]
def mergeL_64 :=
  fun merge_32165 (__32166) -> (__32167) -o
    match __32166 with
    | nilUL_20  => __32167
    | consUL_21 hd_32168 tl_32169 =>
      match __32167 with
      | nilUL_20  => (consUL_21 hd_32168 tl_32169)
      | consUL_21 hd_32170 tl_32171 =>
        match ((lte_9) hd_32168 hd_32170) with
        | true_4  =>
          (consUL_21
            hd_32168 ((merge_32165) tl_32169 (consUL_21 hd_32170 tl_32171)))
        | false_5  =>
          (consUL_21
            hd_32170 ((merge_32165) (consUL_21 hd_32168 tl_32169) tl_32171))
        end
      end
    end

#[program]
def msortU_67 :=
  fun msort_32172 (__32173) ->
    match __32173 with
    | nilUU_22  => nilUU_22
    | consUU_23 hd_32174 tl_32175 =>
      match tl_32175 with
      | nilUU_22  => (consUU_23 hd_32174 nilUU_22)
      | consUU_23 hd_32176 tl_32177 =>
        match ((splitU_63)
                (consUU_23 hd_32174 (consUU_23 hd_32176 tl_32177))) with
        | ex1UU_31 m_32178 n_32179 =>
          ((mergeU_65) ((msort_32172) m_32178) ((msort_32172) n_32179))
        end
      end
    end

#[program]
def msortL_66 :=
  fun msort_32180 (__32181) ->
    match __32181 with
    | nilUL_20  => nilUL_20
    | consUL_21 hd_32182 tl_32183 =>
      match tl_32183 with
      | nilUL_20  => (consUL_21 hd_32182 nilUL_20)
      | consUL_21 hd_32184 tl_32185 =>
        match ((splitL_62)
                (consUL_21 hd_32182 (consUL_21 hd_32184 tl_32185))) with
        | ex1LL_28 m_32186 n_32187 =>
          ((mergeL_64) ((msort_32180) m_32186) ((msort_32180) n_32187))
        end
      end
    end

#[logical]
def cmsort_chU_69 := NULL

#[logical]
def cmsort_chL_68 := NULL

#[program]
def cmsort_workerU_71 :=
  fun cmsort_worker_32188 (__32189) -> (zs_32190) -> (__32191) -o
    match __32189 with
    | zero_6  =>
      let* c_32192 :=
        ((send1U_57)
          NULL NULL NULL NULL NULL __32191 (justU_15 ((msortU_67) zs_32190)))
      in ((close_23) NULL c_32192)
    | succ_7 n_32193 =>
      match zs_32190 with
      | nilUU_22  =>
        let* c_32194 :=
          ((send1U_57) NULL NULL NULL NULL NULL __32191 (justU_15 nilUU_22))
        in ((close_23) NULL c_32194)
      | consUU_23 hd_32195 tl_32196 =>
        match tl_32196 with
        | nilUU_22  =>
          let* c_32197 :=
            ((send1U_57)
              NULL NULL NULL NULL NULL __32191
              (justU_15 (consUU_23 hd_32195 nilUU_22)))
          in ((close_23) NULL c_32197)
        | consUU_23 hd_32198 tl_32199 =>
          match ((splitU_63)
                  (consUU_23 hd_32195 (consUU_23 hd_32198 tl_32199))) with
          | ex1UU_31 m_32200 n_32201 =>
            let* r1_32202 :=
              ((fork_28)
                NULL NULL
                fun _32203 (c1_32204) -o
                  ((cmsort_worker_32188) n_32193 m_32200 c1_32204))
            in
            let* r2_32205 :=
              ((fork_28)
                NULL NULL
                fun _32206 (c2_32207) -o
                  ((cmsort_worker_32188) n_32193 n_32201 c2_32207))
            in
            let* _32208 := ((recv1U_61) NULL NULL NULL NULL NULL r1_32202) in
            match _32208 with
            | ex1UL_30 m_32209 n_32210 =>
              let* _32211 := ((recv1U_61) NULL NULL NULL NULL NULL r2_32205)
              in
              match _32211 with
              | ex1UL_30 m_32212 n_32213 =>
                match m_32209 with
                | justU_15 m_32214 =>
                  match m_32212 with
                  | justU_15 m_32215 =>
                    let zs1_32216 := (justU_15 ((mergeU_65) m_32214 m_32215))
                    in
                    let zs1_32217 :=
                      ((rwlUU_37) NULL NULL NULL NULL NULL zs1_32216)
                    in
                    let* c_32218 :=
                      ((send1U_57)
                        NULL NULL NULL NULL NULL __32191 zs1_32217)
                    in
                    let* __32219 := ((close_23) NULL n_32210) in
                    let* __32220 := ((close_23) NULL n_32213) in
                    let* __32221 := ((close_23) NULL c_32218) in return tt_3
                  end
                end
              end
            end
          end
        end
      end
    end

#[program]
def cmsort_workerL_70 :=
  fun cmsort_worker_32222 (__32223) -> (zs_32224) -> (__32225) -o
    match __32223 with
    | zero_6  =>
      let* c_32226 :=
        ((send1L_56)
          NULL NULL NULL NULL NULL __32225 (justL_14 ((msortL_66) zs_32224)))
      in ((close_23) NULL c_32226)
    | succ_7 n_32227 =>
      match zs_32224 with
      | nilUL_20  =>
        let* c_32228 :=
          ((send1L_56) NULL NULL NULL NULL NULL __32225 (justL_14 nilUL_20))
        in ((close_23) NULL c_32228)
      | consUL_21 hd_32229 tl_32230 =>
        match tl_32230 with
        | nilUL_20  =>
          let* c_32231 :=
            ((send1L_56)
              NULL NULL NULL NULL NULL __32225
              (justL_14 (consUL_21 hd_32229 nilUL_20)))
          in ((close_23) NULL c_32231)
        | consUL_21 hd_32232 tl_32233 =>
          match ((splitL_62)
                  (consUL_21 hd_32229 (consUL_21 hd_32232 tl_32233))) with
          | ex1LL_28 m_32234 n_32235 =>
            let* r1_32236 :=
              ((fork_28)
                NULL NULL
                fun _32237 (c1_32238) -o
                  ((cmsort_worker_32222) n_32227 m_32234 c1_32238))
            in
            let* r2_32239 :=
              ((fork_28)
                NULL NULL
                fun _32240 (c2_32241) -o
                  ((cmsort_worker_32222) n_32227 n_32235 c2_32241))
            in
            let* _32242 := ((recv1L_60) NULL NULL NULL NULL NULL r1_32236) in
            match _32242 with
            | ex1LL_28 m_32243 n_32244 =>
              let* _32245 := ((recv1L_60) NULL NULL NULL NULL NULL r2_32239)
              in
              match _32245 with
              | ex1LL_28 m_32246 n_32247 =>
                match m_32243 with
                | justL_14 m_32248 =>
                  match m_32246 with
                  | justL_14 m_32249 =>
                    let zs1_32250 := (justL_14 ((mergeL_64) m_32248 m_32249))
                    in
                    let zs1_32251 :=
                      ((rwlLL_34) NULL NULL NULL NULL NULL zs1_32250)
                    in
                    let* c_32252 :=
                      ((send1L_56)
                        NULL NULL NULL NULL NULL __32225 zs1_32251)
                    in
                    let* __32253 := ((close_23) NULL n_32244) in
                    let* __32254 := ((close_23) NULL n_32247) in
                    let* __32255 := ((close_23) NULL c_32252) in return tt_3
                  end
                end
              end
            end
          end
        end
      end
    end

-----------------------------------------

def rwlUU_37 :=
  fun rwl_32495 () -> () -> () -> () -> () -> (__32496) -> __32496

def rwlUL_36 :=
  fun rwl_32497 () -> () -> () -> () -> () -> (__32498) -> __32498

def rwlLU_35 :=
  fun rwl_32499 () -> () -> () -> () -> () -> (__32500) -> __32500

def rwlLL_34 :=
  fun rwl_32501 () -> () -> () -> () -> () -> (__32502) -> __32502

def rwrUU_41 :=
  fun rwr_32503 () -> () -> () -> () -> () -> (__32504) -> __32504

def rwrUL_40 :=
  fun rwr_32505 () -> () -> () -> () -> () -> (__32506) -> __32506

def rwrLU_39 :=
  fun rwr_32507 () -> () -> () -> () -> () -> (__32508) -> __32508

def rwrLL_38 :=
  fun rwr_32509 () -> () -> () -> () -> () -> (__32510) -> __32510

def not_5 :=
  fun not_32511 (__32512) ->
    match __32512 with
    | true_4 => false_5 | false_5 => true_4
    end

def and_6 :=
  fun and_32513 (__32514) -> (__32515) ->
    match __32514 with
    | true_4 =>
      match __32515 with
      | true_4 => true_4 | false_5 => false_5
      end
    | false_5 => false_5
    end

def or_7 :=
  fun or_32516 (__32517) -> (__32518) ->
    match __32517 with
    | true_4 => true_4
    | false_5 =>
      match __32518 with
      | true_4 => true_4 | false_5 => false_5
      end
    end

def xor_8 :=
  fun xor_32519 (__32520) -> (__32521) -o
    match __32520 with
    | true_4 =>
      match __32521 with
      | true_4 => false_5 | false_5 => true_4
      end
    | false_5 =>
      match __32521 with
      | true_4 => true_4 | false_5 => false_5
      end
    end

def lte_9 :=
  fun lte_32522 (__32523) -> (__32524) ->
    match __32523 with
    | zero_6  => true_4
    | succ_7 n_32525 =>
      match __32524 with
      | zero_6  => false_5 | succ_7 n_32526 => ((lte_32522) n_32525 n_32526)
      end
    end

def lt_10 :=
  fun lt_32527 (x_32528) -> (y_32529) -> ((lte_9) (succ_7 x_32528) y_32529)

def pred_11 :=
  fun pred_32530 (__32531) ->
    match __32531 with
    | zero_6  => (zero_6 ) | succ_7 n_32532 => n_32532
    end

def add_12 :=
  fun add_32533 (__32534) -> (__32535) ->
    match __32534 with
    | zero_6  => __32535
    | succ_7 n_32536 => (succ_7 ((add_32533) n_32536 __32535))
    end

def sub_13 :=
  fun sub_32537 (__32538) -> (__32539) ->
    match __32539 with
    | zero_6  => __32538
    | succ_7 n_32540 => ((sub_32537) ((pred_11) __32538) n_32540)
    end

def mul_14 :=
  fun mul_32541 (__32542) -> (__32543) ->
    match __32542 with
    | zero_6  => (zero_6 )
    | succ_7 n_32544 => ((add_12) __32543 ((mul_32541) n_32544 __32543))
    end

def div_15 :=
  fun div_32545 (x_32546) -> (y_32547) ->
    match ((lt_10) x_32546 y_32547) with
    | true_4 => (zero_6 )
    | false_5 =>
      let loop_32548 :=
        fun loop_32549 (x_32550) -> (y_32551) ->
          match ((sub_13) x_32550 ((pred_11) y_32551)) with
          | zero_6  => (zero_6 )
          | succ_7 n_32552 => (succ_7 ((loop_32549) n_32552 y_32551))
          end
        in
      ((loop_32548) x_32546 y_32547)
    end

def rem_16 :=
  fun rem_32553 (x_32554) -> (y_32555) ->
    ((sub_13) x_32554 ((mul_14) ((div_15) x_32554 y_32555) y_32555))

def pow_17 :=
  fun pow_32556 (__32557) -> (__32558) ->
    match __32558 with
    | zero_6  => (succ_7 (zero_6 ))
    | succ_7 n_32559 => ((mul_14) __32557 ((pow_32556) __32557 n_32559))
    end

def splitU_63 :=
  fun split_32560 (__32561) ->
    match __32561 with
    | nilUU_22  => (ex1UU_31 (nilUU_22 ) (nilUU_22 ))
    | consUU_23 hd_32562 tl_32563 =>
      match tl_32563 with
      | nilUU_22  => (ex1UU_31 (consUU_23 hd_32562 (nilUU_22 )) (nilUU_22 ))
      | consUU_23 hd_32564 tl_32565 =>
        match ((split_32560) tl_32565) with
        | ex1UU_31 m_32566 n_32567 =>
          (ex1UU_31
            (consUU_23 hd_32562 m_32566) (consUU_23 hd_32564 n_32567))
        end
      end
    end

def splitL_62 :=
  fun split_32568 (__32569) ->
    match __32569 with
    | nilUL_20  => (ex1LL_28 (nilUL_20 ) (nilUL_20 ))
    | consUL_21 hd_32570 tl_32571 =>
      match tl_32571 with
      | nilUL_20  => (ex1LL_28 (consUL_21 hd_32570 (nilUL_20 )) (nilUL_20 ))
      | consUL_21 hd_32572 tl_32573 =>
        match ((split_32568) tl_32573) with
        | ex1LL_28 m_32574 n_32575 =>
          (ex1LL_28
            (consUL_21 hd_32570 m_32574) (consUL_21 hd_32572 n_32575))
        end
      end
    end

def mergeU_65 :=
  fun merge_32576 (__32577) -> (__32578) -o
    match __32577 with
    | nilUU_22  => __32578
    | consUU_23 hd_32579 tl_32580 =>
      match __32578 with
      | nilUU_22  => (consUU_23 hd_32579 tl_32580)
      | consUU_23 hd_32581 tl_32582 =>
        match ((lte_9) hd_32579 hd_32581) with
        | true_4 =>
          (consUU_23
            hd_32579 ((merge_32576) tl_32580 (consUU_23 hd_32581 tl_32582)))
        | false_5 =>
          (consUU_23
            hd_32581 ((merge_32576) (consUU_23 hd_32579 tl_32580) tl_32582))
        end
      end
    end

def mergeL_64 :=
  fun merge_32583 (__32584) -> (__32585) -o
    match __32584 with
    | nilUL_20  => __32585
    | consUL_21 hd_32586 tl_32587 =>
      match __32585 with
      | nilUL_20  => (consUL_21 hd_32586 tl_32587)
      | consUL_21 hd_32588 tl_32589 =>
        match ((lte_9) hd_32586 hd_32588) with
        | true_4 =>
          (consUL_21
            hd_32586 ((merge_32583) tl_32587 (consUL_21 hd_32588 tl_32589)))
        | false_5 =>
          (consUL_21
            hd_32588 ((merge_32583) (consUL_21 hd_32586 tl_32587) tl_32589))
        end
      end
    end

def msortU_67 :=
  fun msort_32590 (__32591) ->
    match __32591 with
    | nilUU_22  => (nilUU_22 )
    | consUU_23 hd_32592 tl_32593 =>
      match tl_32593 with
      | nilUU_22  => (consUU_23 hd_32592 (nilUU_22 ))
      | consUU_23 hd_32594 tl_32595 =>
        match ((splitU_63)
                (consUU_23 hd_32592 (consUU_23 hd_32594 tl_32595))) with
        | ex1UU_31 m_32596 n_32597 =>
          ((mergeU_65) ((msort_32590) m_32596) ((msort_32590) n_32597))
        end
      end
    end

def msortL_66 :=
  fun msort_32598 (__32599) ->
    match __32599 with
    | nilUL_20  => (nilUL_20 )
    | consUL_21 hd_32600 tl_32601 =>
      match tl_32601 with
      | nilUL_20  => (consUL_21 hd_32600 (nilUL_20 ))
      | consUL_21 hd_32602 tl_32603 =>
        match ((splitL_62)
                (consUL_21 hd_32600 (consUL_21 hd_32602 tl_32603))) with
        | ex1LL_28 m_32604 n_32605 =>
          ((mergeL_64) ((msort_32598) m_32604) ((msort_32598) n_32605))
        end
      end
    end

def cmsort_workerU_71 :=
  fun cmsort_worker_32606 (__32607) -> (zs_32608) -> (__32609) -o
    match __32607 with
    | zero_6  =>
      lam () -o
        let c_32610 :=
          ((send1U_57) () () () () () __32609 ((msortU_67) zs_32608) ())
        in ((close_23) () c_32610)
    | succ_7 n_32611 =>
      match zs_32608 with
      | nilUU_22  =>
        lam () -o
          let c_32612 := ((send1U_57) () () () () () __32609 (nilUU_22 ) ())
          in ((close_23) () c_32612)
      | consUU_23 hd_32613 tl_32614 =>
        match tl_32614 with
        | nilUU_22  =>
          lam () -o
            let c_32615 :=
              ((send1U_57)
                () () () () () __32609 (consUU_23 hd_32613 (nilUU_22 )) ())
            in ((close_23) () c_32615)
        | consUU_23 hd_32616 tl_32617 =>
          match ((splitU_63)
                  (consUU_23 hd_32613 (consUU_23 hd_32616 tl_32617))) with
          | ex1UU_31 m_32618 n_32619 =>
            lam () -o
              let r1_32620 :=
                ((fork_28)
                  () ()
                    fun _32621 (c1_32622) -o
                      ((cmsort_worker_32606) n_32611 m_32618 c1_32622)
                      ())
                in
              let r2_32623 :=
                ((fork_28)
                  () ()
                    fun _32624 (c2_32625) -o
                      ((cmsort_worker_32606) n_32611 n_32619 c2_32625)
                      ())
                in
              let _32626 := ((recv1U_61) () () () () () r1_32620 ()) in
              match _32626 with
              | ex1UL_30 m_32627 n_32628 =>
                lam () -o
                  let _32629 := ((recv1U_61) () () () () () r2_32623 ()) in
                  match _32629 with
                  | ex1UL_30 m_32630 n_32631 =>
                    let zs1_32632 := ((mergeU_65) m_32627 m_32630) in
                    let zs1_32633 := ((rwlUU_37) () () () () () zs1_32632) in
                    lam () -o
                      let c_32634 :=
                        ((send1U_57) () () () () () __32609 zs1_32633 ())
                      in
                      let __32635 := ((close_23) () n_32628 ()) in
                      let __32636 := ((close_23) () n_32631 ()) in
                      let __32637 := ((close_23) () c_32634 ()) in
                      lam () -o tt_3
                  end
              end
            end
          end
        end
      end

def cmsort_workerL_70 :=
  fun cmsort_worker_32638 (__32639) -> (zs_32640) -> (__32641) -o
    match __32639 with
    | zero_6  =>
      lam () -o
        let c_32642 :=
          ((send1L_56) () () () () () __32641 ((msortL_66) zs_32640) ())
        in ((close_23) () c_32642)
    | succ_7 n_32643 =>
      match zs_32640 with
      | nilUL_20  =>
        lam () -o
          let c_32644 := ((send1L_56) () () () () () __32641 (nilUL_20 ) ())
          in ((close_23) () c_32644)
      | consUL_21 hd_32645 tl_32646 =>
        match tl_32646 with
        | nilUL_20  =>
          lam () -o
            let c_32647 :=
              ((send1L_56)
                () () () () () __32641 (consUL_21 hd_32645 (nilUL_20 )) ())
            in ((close_23) () c_32647)
        | consUL_21 hd_32648 tl_32649 =>
          match ((splitL_62)
                  (consUL_21 hd_32645 (consUL_21 hd_32648 tl_32649))) with
          | ex1LL_28 m_32650 n_32651 =>
            lam () -o
              let r1_32652 :=
                ((fork_28)
                  () ()
                    fun _32653 (c1_32654) -o
                      ((cmsort_worker_32638) n_32643 m_32650 c1_32654)
                      ())
                in
              let r2_32655 :=
                ((fork_28)
                  () ()
                    fun _32656 (c2_32657) -o
                      ((cmsort_worker_32638) n_32643 n_32651 c2_32657)
                      ())
                in
              let _32658 := ((recv1L_60) () () () () () r1_32652 ()) in
              match _32658 with
              | ex1LL_28 m_32659 n_32660 =>
                lam () -o
                  let _32661 := ((recv1L_60) () () () () () r2_32655 ()) in
                  match _32661 with
                  | ex1LL_28 m_32662 n_32663 =>
                    let zs1_32664 := ((mergeL_64) m_32659 m_32662) in
                    let zs1_32665 := ((rwlLL_34) () () () () () zs1_32664) in
                    lam () -o
                      let c_32666 :=
                        ((send1L_56) () () () () () __32641 zs1_32665 ())
                      in
                      let __32667 := ((close_23) () n_32660 ()) in
                      let __32668 := ((close_23) () n_32663 ()) in
                      let __32669 := ((close_23) () c_32666 ()) in
                      lam () -o tt_3
                  end
              end
            end
          end
        end
      end

-----------------------------------------

