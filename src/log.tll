[Notation {name = "|>"; body = (App [(Hole 2); (Hole 1)])};
  Notation {name = "@@"; body = (App [(Hole 1); (Hole 2)])};
  Notation {name = "="; body = (App [(Id ("eq", I)); (Hole 1); (Hole 2)])};
  Notation {name = "`"; body = (App [(Id ("sing", I)); (Hole 1)])};
  Notation {name = "&&"; body = (Id ("and", I))};
  Notation {name = "||"; body = (Id ("or", I))};
  Notation {name = "+"; body = (App [(Id ("add", I)); (Hole 1); (Hole 2)])};
  Notation {name = "-"; body = (App [(Id ("sub", I)); (Hole 1); (Hole 2)])};
  Notation {name = "*"; body = (App [(Id ("mul", I)); (Hole 1); (Hole 2)])};
  Notation {name = "/"; body = (App [(Id ("div", I)); (Hole 1); (Hole 2)])};
  Notation {name = "%"; body = (App [(Id ("rem", I)); (Hole 1); (Hole 2)])};
  Notation {name = "^"; body = (App [(Id ("pow", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<"; body = (App [(Id ("lt", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">"; body = (App [(Id ("gt", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<="; body = (App [(Id ("lte", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">="; body = (App [(Id ("gte", I)); (Hole 1); (Hole 2)])};
  Notation {name = "**"; body = (App [(Id ("prod1", I)); (Hole 1); (Hole 2)])};
  Notation {name = "::"; body = (App [(Id ("cons", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase (BOpr ("=", (Id ("m", I)), (Id ("m", I))))),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "unit"; relv = R;
    body =
    (Binder (["s"],
       (PBase
          ((TBase (Type (SId "s"))),
           [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
       ));
    view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type L)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type L)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder ([],
       (PBind ((Type L),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)), (Binder ("_", (TBase (Type L)))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m", (TBase (UOpr ("`", (Id ("m", I))))))))),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "apair"; relv = R;
    body =
    (Binder ([],
       (PBind ((Type L),
          (Binder ("A",
             (PBind ((Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("apair_intro",
                           (TBind (N, (Id ("A", I)),
                              (Binder ("x",
                                 (TBind (R,
                                    (Pi (R, L, (Id ("bool", I)),
                                       (Binder ("b",
                                          (Match ([(R, (Id ("b", I)), None)],
                                             None,
                                             [([(PId "true")],
                                               (Some (UOpr ("`",
                                                        (Id ("x", I))))));
                                               ([(PId "false")],
                                                (Some (App
                                                         [(Id ("B", I));
                                                           (Id ("x", I))])))
                                               ]
                                             ))
                                          ))
                                       )),
                                    (Binder ("select",
                                       (TBase
                                          (App
                                             [(Id ("apair", I));
                                               (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [I; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "sing_elim"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type L),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("x",
                       (Pi (R, U, (UOpr ("`", (Id ("x", I)))),
                          (Binder ("_", (Id ("A", I))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_elim"),
              [([(PId "A"); (PId "x"); (PConstr ("just", [(PId "x")]))],
                (Some (Id ("x", I))))]
              )),
           [I; I])),
        (Pi (N, U, (Type L),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("x",
                    (Pi (R, U, (UOpr ("`", (Id ("x", I)))),
                       (Binder ("_", (Id ("A", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "sing_uniq"; relv = N;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Type L),
              (Binder ("A",
                 (Pi (R, U, (Id ("A", I)),
                    (Binder ("x0",
                       (Pi (R, U, (UOpr ("`", (Id ("x0", I)))),
                          (Binder ("x",
                             (BOpr ("=", (Id ("x0", I)),
                                (App [(Id ("sing_elim", I)); (Id ("x", I))])
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_uniq"),
              [([(PId "A"); (PId "x0"); (PConstr ("just", [(PId "_")]))],
                (Some (Id ("refl", I))))]
              )),
           [I; I])),
        (Pi (R, U, (Type L),
           (Binder ("A",
              (Pi (R, U, (Id ("A", I)),
                 (Binder ("x0",
                    (Pi (R, U, (UOpr ("`", (Id ("x0", I)))),
                       (Binder ("x",
                          (BOpr ("=", (Id ("x0", I)),
                             (App [(Id ("sing_elim", I)); (Id ("x", I))])))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "proj1"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type L),
              (Binder ("A",
                 (Pi (N, U,
                    (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                    (Binder ("B",
                       (Pi (R, U,
                          (App
                             [(Id ("apair", E)); (Id ("A", I)); (Id ("B", I))
                               ]),
                          (Binder ("_", (Id ("A", I))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "proj1"),
              [([(PId "A"); (PId "B");
                  (PConstr ("apair_intro", [(PId "_"); (PId "select")]))],
                (Some (App
                         [(Id ("sing_elim", I));
                           (App [(Id ("select", I)); (Id ("true", I))])])))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type L),
           (Binder ("A",
              (Pi (N, U,
                 (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                 (Binder ("B",
                    (Pi (R, U,
                       (App [(Id ("apair", E)); (Id ("A", I)); (Id ("B", I))]),
                       (Binder ("_", (Id ("A", I))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "proj2"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type L),
              (Binder ("A",
                 (Pi (N, U,
                    (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                    (Binder ("B",
                       (Pi (R, U,
                          (App
                             [(Id ("apair", E)); (Id ("A", I)); (Id ("B", I))
                               ]),
                          (Binder ("x",
                             (App
                                [(Id ("B", I));
                                  (App [(Id ("proj1", I)); (Id ("x", I))])])
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "proj2"),
              [([(PId "A"); (PId "B");
                  (PConstr ("apair_intro", [(PId "x"); (PId "select")]))],
                (Some (Match (
                         [(N, (Id ("x", I)), (Some ("x0", IMeta)));
                           (N, (App [(Id ("select", I)); (Id ("true", I))]),
                            (Some ("a0", (UOpr ("`", (Id ("x", I)))))));
                           (N,
                            (App
                               [(Id ("sing_uniq", I));
                                 (App [(Id ("select", I)); (Id ("true", I))])
                                 ]),
                            (Some ("_",
                                   (BOpr ("=", (Id ("x0", I)),
                                      (App
                                         [(Id ("sing_elim", I));
                                           (Id ("a0", I))])
                                      )))));
                           (R, (App [(Id ("select", I)); (Id ("false", I))]),
                            (Some ("_", (App [(Id ("B", I)); (Id ("x0", I))]))))
                           ],
                         (Some (App
                                  [(Id ("B", I));
                                    (App
                                       [(Id ("sing_elim", I)); (Id ("a0", I))
                                         ])
                                    ])),
                         [([(PId "_"); (PId "_"); (PId "refl"); (PId "b")],
                           (Some (Id ("b", I))))]
                         ))))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type L),
           (Binder ("A",
              (Pi (N, U,
                 (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type L))))),
                 (Binder ("B",
                    (Pi (R, U,
                       (App [(Id ("apair", E)); (Id ("A", I)); (Id ("B", I))]),
                       (Binder ("x",
                          (App
                             [(Id ("B", I));
                               (App [(Id ("proj1", I)); (Id ("x", I))])])
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "bool2nat"; relv = R;
    body =
    (Binder ([],
       ((Fun ((Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("nat", I)))))),
           (Binder ((Some "bool2nat"),
              [([(PId "true")],
                (Some (App [(Id ("succ", I)); (Id ("zero", I))])));
                ([(PId "false")], (Some (Id ("zero", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("nat", I)))))))
       ));
    view = []};
  Definition {name = "free_bool"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_", (Inst ("unit", [U], I)))))),
           (Binder ((Some "free_bool"),
              [([(PId "true")], (Some (Id ("tt", I))));
                ([(PId "false")], (Some (Id ("tt", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Inst ("unit", [U], I))))
           )))
       ));
    view = []};
  Definition {name = "free_nat"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_", (Inst ("unit", [U], I)))))),
           (Binder ((Some "free_nat"),
              [([(PId "zero")], (Some (Id ("tt", I))));
                ([(PConstr ("succ", [(PId "n")]))],
                 (Some (App [(Id ("free_nat", I)); (Id ("n", I))])))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Inst ("unit", [U], I)))))))
       ));
    view = []};
  Definition {name = "my_apair"; relv = R;
    body =
    (Binder ([],
       ((Let (R, (Id ("false", I)),
           (Binder ("my_val",
              (App
                 [(Id ("apair_intro", I));
                   (Fun (IMeta,
                      (Binder (None,
                         [([(PId "true")],
                           (Some (App [(Id ("just", I)); (Id ("my_val", I))])));
                           ([(PId "false")],
                            (Some (App
                                     [(Id ("bool2nat", I));
                                       (Id ("my_val", I))])))
                           ]
                         )),
                      []))
                   ])
              ))
           )),
        (App
           [(Id ("apair", I));
             (Fun ((Pi (R, U, (Id ("bool", I)), (Binder ("b", IMeta)))),
                (Binder (None,
                   [([(PId "b")],
                     (Some (Match ([(R, (Id ("b", I)), None)], None,
                              [([(PId "true")],
                                (Some (Inst ("unit", [L], I))));
                                ([(PId "false")], (Some (Id ("nat", I))))]
                              ))))
                     ]
                   )),
                []))
             ]))
       ));
    view = []};
  Definition {name = "_"; relv = R;
    body =
    (Binder ([],
       ((App
           [(Id ("free_bool", I));
             (App [(Id ("proj1", I)); (Id ("my_apair", I))])]),
        (Inst ("unit", [U], I)))
       ));
    view = []}
  ]

-----------------------------------------

#[logical]
inductive eq_1‹s_93› (A_94 : Type‹s_93›) (m_95 : A_94): A_94 -> U
where
| refl_1 : (eq_1‹??_1› ?_1[0;0] m_95 m_95)

#[program]
inductive unit_2‹s_97› : Type‹s_97› where
| tt_2 : unit_2‹??_2›

#[program]
inductive bool_3‹› : L where
| true_3 : bool_3
| false_4 : bool_3

#[program]
inductive nat_4‹› : L where
| zero_5 : nat_4
| succ_6 (pred_98 : nat_4) : nat_4

#[program]
inductive sing_5‹› (A_99 : L): A_99 -> L where
| just_7 (m_101 : A_99) : (sing_5 ?_2[0;0] m_101)

#[program]
inductive apair_6‹› (A_102 : L) (B_103 : A_102 -> L): L where
| apair_intro_8
    {x_105 : A_102}
    (select_106 : ∀ (b_107 : bool_3) -o
                    match b_107 in ?_3[0;0] -o ?_4[0;0] with
                    | true_3 => (sing_5 ?_5[0;0] x_105)
                    | false_4 => ((B_103) x_105))
    : (apair_6 ?_6[0;0] B_103)

#[program]
def sing_elim_1‹› :
  ∀ {A_109 : L} -> ∀ {x_110 : A_109} -> (sing_5 ?_8[0;0] x_110) -> A_109
:=
  function sing_elim_112 :
    ∀ {A_113 : L} ->
      ∀ {x_114 : A_113} -> (sing_5 ?_7[0;0] x_114) -> A_113
  | A_116 x_117 (just_7 x_118) => x_118

#[logical]
def sing_uniq_2‹› :
  ∀ (A_119 : L) ->
    ∀ (x0_120 : A_119) ->
      ∀ (x_121 : (sing_5 ?_15[0;0] x0_120)) ->
        (eq_1‹??_5›
          ?_18[0;0] x0_120 ((sing_elim_1) ?_17[0;0] ?_16[0;0] x_121))
:=
  function sing_uniq_122 :
    ∀ (A_123 : L) ->
      ∀ (x0_124 : A_123) ->
        ∀ (x_125 : (sing_5 ?_9[0;0] x0_124)) ->
          (eq_1‹??_3›
            ?_12[0;0] x0_124 ((sing_elim_1) ?_11[0;0] ?_10[0;0] x_125))
  | A_126 x0_127 (just_7 _128) => (refl_1‹??_4› ?_13[0;0] ?_14[0;0])

#[program]
def proj1_3‹› :
  ∀ {A_129 : L} ->
    ∀ {B_130 : A_129 -> L} -> (apair_6 A_129 B_130) -> A_129
:=
  function proj1_133 :
    ∀ {A_134 : L} ->
      ∀ {B_135 : A_134 -> L} -> (apair_6 A_134 B_135) -> A_134
  | A_138 B_139 (apair_intro_8 _140 select_141) =>
    ((sing_elim_1) ?_20[0;0] ?_19[0;0] ((select_141) true_3))

#[program]
def proj2_4‹› :
  ∀ {A_142 : L} ->
    ∀ {B_143 : A_142 -> L} ->
      ∀ (x_145 : (apair_6 A_142 B_143)) ->
        ((B_143) ((proj1_3) ?_33[0;0] ?_32[0;0] x_145))
:=
  function proj2_146 :
    ∀ {A_147 : L} ->
      ∀ {B_148 : A_147 -> L} ->
        ∀ (x_150 : (apair_6 A_147 B_148)) ->
          ((B_148) ((proj1_3) ?_22[0;0] ?_21[0;0] x_150))
  | A_151 B_152 (apair_intro_8 x_153 select_154) =>
    match x_153, ((select_154) true_3),
    ((sing_uniq_2) ?_24[0;0] ?_23[0;0] ((select_154) true_3)),
    ((select_154) false_4) in
      ∀ {x0_155 : ?_25[0;0]} -o
        ∀ {a0_156 : (sing_5 ?_26[0;0] x_153)} -o
          {(eq_1‹??_6›
             ?_29[0;0] x0_155 ((sing_elim_1) ?_28[0;0] ?_27[0;0] a0_156))} -o
            ((B_152) x0_155) -o
              ((B_152) ((sing_elim_1) ?_31[0;0] ?_30[0;0] a0_156))
    with
    | _159, _160, refl_1, b_161 => b_161

#[program]
def bool2nat_5‹› : bool_3 -> nat_4 :=
  function bool2nat_163 : bool_3 -> nat_4
  | true_3 => (succ_6‹› zero_5)
  | false_4 => zero_5

#[program]
def free_bool_6‹› : bool_3 -> unit_2‹U› :=
  function free_bool_166 : bool_3 -> unit_2‹U›
  | true_3 => tt_2‹??_7›
  | false_4 => tt_2‹??_8›

#[program]
def free_nat_7‹› : nat_4 -> unit_2‹U› :=
  function free_nat_169 : nat_4 -> unit_2‹U›
  | zero_5 => tt_2‹??_9›
  | (succ_6 n_171) => ((free_nat_169) n_171)

#[program]
def my_apair_8‹› :
  (apair_6
    ?_42[0;0]
    function _172 : bool_3 -> ?_39[0;0]
    | b_174 =>
      match b_174 in ?_40[0;0] -o ?_41[0;0] with
      | true_3 => unit_2‹L›
      | false_4 => nat_4)
:=
  let my_val_176 := false_4 in
  (apair_intro_8‹›
    ?_37[0;0] ?_38[0;0] ?_36[0;0]
    function _177 : ?_34[0;0]
    | true_3 => (just_7‹› ?_35[0;0] my_val_176)
    | false_4 => ((bool2nat_5) my_val_176))

#[program]
def __9‹› : unit_2‹U› :=
  ((free_bool_6) ((proj1_3) ?_44[0;0] ?_43[0;0] my_apair_8))

-----------------------------------------

#[logical]
inductive eq_1‹s_2076› (A_2077 : Type‹s_2076›) (m_2078 : A_2077):
  A_2077 -> U
where
| refl_1 : (eq_1‹s_2076› A_2077 m_2078 m_2078)

#[program]
inductive unit_2‹s_2080› : Type‹s_2080› where
| tt_2 : unit_2‹s_2080›

#[program]
inductive bool_3‹› : L where
| true_3 : bool_3
| false_4 : bool_3

#[program]
inductive nat_4‹› : L where
| zero_5 : nat_4
| succ_6 (pred_2081 : nat_4) : nat_4

#[program]
inductive sing_5‹› (A_2082 : L): A_2082 -> L where
| just_7 (m_2084 : A_2082) : (sing_5 A_2082 m_2084)

#[program]
inductive apair_6‹› (A_2085 : L) (B_2086 : A_2085 -> L): L where
| apair_intro_8
    {x_2088 : A_2085}
    (select_2089 : ∀ (b_2090 : bool_3) -o
                     match b_2090 in bool_3 -o L with
                     | true_3 => (sing_5 A_2085 x_2088)
                     | false_4 => ((B_2086) x_2088))
    : (apair_6 A_2085 B_2086)

#[program]
def sing_elim_1‹› :
  ∀ {A_2092 : L} ->
    ∀ {x_2093 : A_2092} -> (sing_5 A_2092 x_2093) -> A_2092
:=
  function sing_elim_2095 :
    ∀ {A_2096 : L} ->
      ∀ {x_2097 : A_2096} -> (sing_5 A_2096 x_2097) -> A_2096
  | A_2099 x_2100 (just_7 m_2101) => m_2101

#[logical]
def sing_uniq_2‹› :
  ∀ (A_2102 : L) ->
    ∀ (x0_2103 : A_2102) ->
      ∀ (x_2104 : (sing_5 A_2102 x0_2103)) ->
        (eq_1‹L› A_2102 x0_2103 ((sing_elim_1) A_2102 x0_2103 x_2104))
:=
  function sing_uniq_2105 :
    ∀ (A_2106 : L) ->
      ∀ (x0_2107 : A_2106) ->
        ∀ (x_2108 : (sing_5 A_2106 x0_2107)) ->
          (eq_1‹L› A_2106 x0_2107 ((sing_elim_1) A_2106 x0_2107 x_2108))
  | A_2109 x0_2110 (just_7 m_2111) => (refl_1‹L› A_2109 m_2111)

#[program]
def proj1_3‹› :
  ∀ {A_2112 : L} ->
    ∀ {B_2113 : A_2112 -> L} -> (apair_6 A_2112 B_2113) -> A_2112
:=
  function proj1_2116 :
    ∀ {A_2117 : L} ->
      ∀ {B_2118 : A_2117 -> L} -> (apair_6 A_2117 B_2118) -> A_2117
  | A_2121 B_2122 (apair_intro_8 x_2123 select_2124) =>
    ((sing_elim_1) A_2121 x_2123 ((select_2124) true_3))

#[program]
def proj2_4‹› :
  ∀ {A_2125 : L} ->
    ∀ {B_2126 : A_2125 -> L} ->
      ∀ (x_2128 : (apair_6 A_2125 B_2126)) ->
        ((B_2126) ((proj1_3) A_2125 B_2126 x_2128))
:=
  function proj2_2129 :
    ∀ {A_2130 : L} ->
      ∀ {B_2131 : A_2130 -> L} ->
        ∀ (x_2133 : (apair_6 A_2130 B_2131)) ->
          ((B_2131) ((proj1_3) A_2130 B_2131 x_2133))
  | A_2134 B_2135 (apair_intro_8 x_2136 select_2137) =>
    match x_2136, ((select_2137) true_3),
    ((sing_uniq_2) A_2134 x_2136 ((select_2137) true_3)),
    ((select_2137) false_4) in
      ∀ {x0_2138 : A_2134} -o
        ∀ {a0_2139 : (sing_5 A_2134 x_2136)} -o
          {(eq_1‹L› A_2134 x0_2138 ((sing_elim_1) A_2134 x_2136 a0_2139))} -o
            ((B_2135) x0_2138) -o
              ((B_2135) ((sing_elim_1) A_2134 x_2136 a0_2139))
    with
    | x0_2142, a0_2143, refl_1, __2144 => __2144

#[program]
def bool2nat_5‹› : bool_3 -> nat_4 :=
  function bool2nat_2146 : bool_3 -> nat_4
  | true_3 => (succ_6‹› zero_5)
  | false_4 => zero_5

#[program]
def free_bool_6‹› : bool_3 -> unit_2‹U› :=
  function free_bool_2149 : bool_3 -> unit_2‹U›
  | true_3 => tt_2‹U›
  | false_4 => tt_2‹U›

#[program]
def free_nat_7‹› : nat_4 -> unit_2‹U› :=
  function free_nat_2152 : nat_4 -> unit_2‹U›
  | zero_5 => tt_2‹U›
  | (succ_6 pred_2154) => ((free_nat_2152) pred_2154)

#[program]
def my_apair_8‹› :
  (apair_6
    bool_3
    function _2155 : bool_3 -> L
    | __2157 =>
      match __2157 in bool_3 -o L with
      | true_3 => unit_2‹L›
      | false_4 => nat_4)
:=
  let my_val_2159 := false_4 in
  (apair_intro_8‹›
    bool_3
    function _2160 : bool_3 -> L
    | __2162 =>
      match __2162 in bool_3 -o L with
      | true_3 => unit_2‹L›
      | false_4 => nat_4
    my_val_2159
    function _2164 :
      ∀ (b_2165 : bool_3) -o
        match b_2165 in bool_3 -o L with
        | true_3 => (sing_5 bool_3 my_val_2159)
        | false_4 =>
          ((function _2167 : bool_3 -> L
            | __2169 =>
              match __2169 in bool_3 -o L with
              | true_3 => unit_2‹L›
              | false_4 => nat_4)
            my_val_2159)
    | true_3 => (just_7‹› bool_3 my_val_2159)
    | false_4 => ((bool2nat_5) my_val_2159))

#[program]
def __9‹› : unit_2‹U› :=
  ((free_bool_6)
    ((proj1_3)
      bool_3
      function _2171 : bool_3 -> L
      | __2173 =>
        match __2173 in bool_3 -o L with
        | true_3 => unit_2‹L›
        | false_4 => nat_4
      my_apair_8))

-----------------------------------------

#[logical]
inductive eqU_8 where
| reflU_10 of layout[]

#[logical]
inductive eqL_7 where
| reflL_9 of layout[]

#[program]
inductive unitU_10 where
| ttU_12 of layout[]

#[program]
inductive unitL_9 where
| ttL_11 of layout[]

#[program]
inductive bool_3 where
| true_3 of layout[]
| false_4 of layout[]

#[program]
inductive nat_4 where
| zero_5 of layout[]
| succ_6 of layout[R]

#[program]
inductive sing_5 where
| just_7 of layout[R]

#[program]
inductive apair_6 where
| apair_intro_8 of layout[N, R]

#[program]
def sing_elim_1 :=
  fun sing_elim_2710 {A_2711} -> {x_2712} -> (__2713) ->
    match __2713 with
    | just_7 m_2714 => m_2714
    end

#[logical]
def sing_uniq_2 := NULL

#[program]
def proj1_3 :=
  fun proj1_2715 {A_2716} -> {B_2717} -> (__2718) ->
    match __2718 with
    | apair_intro_8 x_2719 select_2720 =>
      ((sing_elim_1) NULL NULL ((select_2720) true_3))
    end

#[program]
def proj2_4 :=
  fun proj2_2721 {A_2722} -> {B_2723} -> (x_2724) ->
    match x_2724 with
    | apair_intro_8 x_2725 select_2726 =>
      match {NULL} with
      | reflL_9  => ((select_2726) false_4)
      end
    end

#[program]
def bool2nat_5 :=
  fun bool2nat_2727 (__2728) ->
    match __2728 with
    | true_3  => (succ_6 zero_5) | false_4  => zero_5
    end

#[program]
def free_bool_6 :=
  fun free_bool_2729 (__2730) ->
    match __2730 with
    | true_3  => ttU_12 | false_4  => ttU_12
    end

#[program]
def free_nat_7 :=
  fun free_nat_2731 (__2732) ->
    match __2732 with
    | zero_5  => ttU_12 | succ_6 pred_2733 => ((free_nat_2731) pred_2733)
    end

#[program]
def my_apair_8 :=
  let my_val_2734 := false_4 in
  (apair_intro_8
    NULL
    fun _2735 (b_2736) -o
      match b_2736 with
      | true_3  => (just_7 my_val_2734)
      | false_4  => ((bool2nat_5) my_val_2734)
      end)

#[program]
def __9 := ((free_bool_6) ((proj1_3) NULL NULL my_apair_8))

-----------------------------------------

#[logical]
inductive eqU_8 where
| reflU_10 of layout[]

#[logical]
inductive eqL_7 where
| reflL_9 of layout[]

#[program]
inductive unitU_10 where
| ttU_12 of layout[]

#[program]
inductive unitL_9 where
| ttL_11 of layout[]

#[program]
inductive bool_3 where
| true_3 of layout[]
| false_4 of layout[]

#[program]
inductive nat_4 where
| zero_5 of layout[]
| succ_6 of layout[R]

#[program]
inductive sing_5 where
| just_7 of layout[R]

#[program]
inductive apair_6 where
| apair_intro_8 of layout[N, R]

#[program]
def sing_elim_1 :=
  fun sing_elim_2764 {A_2765} -> {x_2766} -> (__2767) ->
    match __2767 with
    | just_7 m_2768 => m_2768
    end

#[logical]
def sing_uniq_2 := NULL

#[program]
def proj1_3 :=
  fun proj1_2769 {A_2770} -> {B_2771} -> (__2772) ->
    match __2772 with
    | apair_intro_8 x_2773 select_2774 =>
      ((sing_elim_1) NULL NULL ((select_2774) true_3))
    end

#[program]
def proj2_4 :=
  fun proj2_2775 {A_2776} -> {B_2777} -> (x_2778) ->
    match x_2778 with
    | apair_intro_8 x_2779 select_2780 => ((select_2780) false_4)
    end

#[program]
def bool2nat_5 :=
  fun bool2nat_2781 (__2782) ->
    match __2782 with
    | true_3  => (succ_6 zero_5) | false_4  => zero_5
    end

#[program]
def free_bool_6 :=
  fun free_bool_2783 (__2784) ->
    match __2784 with
    | true_3  => ttU_12 | false_4  => ttU_12
    end

#[program]
def free_nat_7 :=
  fun free_nat_2785 (__2786) ->
    match __2786 with
    | zero_5  => ttU_12 | succ_6 pred_2787 => ((free_nat_2785) pred_2787)
    end

#[program]
def my_apair_8 :=
  let my_val_2788 := false_4 in
  (apair_intro_8
    NULL
    fun _2789 (b_2790) -o
      match b_2790 with
      | true_3  => (just_7 my_val_2788)
      | false_4  => ((bool2nat_5) my_val_2788)
      end)

#[program]
def __9 := ((free_bool_6) ((proj1_3) NULL NULL my_apair_8))

-----------------------------------------

