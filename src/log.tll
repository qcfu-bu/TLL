[Inductive {name = "unit"; relv = R;
   body =
   (Binder ([],
      (PBase
         ((TBase (Type U)), [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
      ));
   view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase
                              (App
                                 [(Id ("eq", I)); (Id ("m", I));
                                   (Id ("m", I))])),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "exists"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("ex",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (N,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("pf",
                                       (TBase
                                          (App
                                             [(Id ("exists", I));
                                               (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "s"))))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m",
                           (TBase (App [(Id ("sing", I)); (Id ("m", I))]))))
                        )),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "list"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type U)),
                 [(DConstr ("nil",
                     (TBase (App [(Id ("list", I)); (Id ("A", I))])), 
                     []));
                   (DConstr ("cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (App [(Id ("list", I)); (Id ("A", I))]),
                               (Binder ("tl",
                                  (TBase
                                     (App [(Id ("list", I)); (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Inductive {name = "vec"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("nat", I)), (Binder ("_", (TBase (Type U))))
                    )),
                 [(DConstr ("vnil",
                     (TBase
                        (App
                           [(Id ("vec", I)); (Id ("A", I)); (Id ("zero", I))])),
                     []));
                   (DConstr ("vcons",
                      (TBind (N, (Id ("nat", I)),
                         (Binder ("n",
                            (TBind (R, (Id ("A", I)),
                               (Binder ("hd",
                                  (TBind (R,
                                     (App
                                        [(Inst ("vec", [(SId "s")], I));
                                          (Id ("A", I)); (Id ("n", I))]),
                                     (Binder ("tl",
                                        (TBase
                                           (App
                                              [(Id ("vec", I));
                                                (Id ("A", I));
                                                (App
                                                   [(Id ("succ", I));
                                                     (Id ("n", I))])
                                                ]))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         )),
                      [I; E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Definition {name = "uncons2"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("nat", I)),
                    (Binder ("n",
                       (Pi (R, U,
                          (App
                             [(Id ("vec", I)); (Id ("A", I)); (Id ("n", I))]),
                          (Binder ("_",
                             (Pi (R, U,
                                (App
                                   [(Id ("vec", I)); (Id ("A", I));
                                     (Id ("n", I))]),
                                (Binder ("_", (Id ("unit", I))))))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "uncons2"),
              [([(PId "A"); (PId "n"); (PId "vnil"); (PId "vnil")],
                (Some (Id ("tt", I))));
                ([(PId "A"); (PId "n"); (PId "vnil");
                   (PConstr ("vcons", [(PId "_"); (PId "_"); (PId "_")]))],
                 None);
                ([(PId "A"); (PId "n");
                   (PConstr ("vcons", [(PId "_"); (PId "_"); (PId "_")]));
                   (PConstr ("vcons", [(PId "_"); (PId "_"); (PId "_")]))],
                 (Some (Id ("tt", I))))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("nat", I)),
                 (Binder ("n",
                    (Pi (R, U,
                       (App [(Id ("vec", I)); (Id ("A", I)); (Id ("n", I))]),
                       (Binder ("_",
                          (Pi (R, U,
                             (App
                                [(Id ("vec", I)); (Id ("A", I));
                                  (Id ("n", I))]),
                             (Binder ("_", (Id ("unit", I))))))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]}
  ]

-----------------------------------------

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_71 : nat_3) : nat_3

#[logical]
inductive eq_4‹s_72› (A_73 : Type‹s_72›) (m_74 : A_73): A_73 -> U
where
| refl_6 : (eq_4‹??_1› ?_1 m_74 m_74)

#[program]
inductive exists_5‹s_76,r_77,t_78› (A_79 : Type‹s_76›) (B_80 : 
A_79 -> Type‹r_77›): Type‹t_78› where
| ex_7
    (m_82 : A_79) {pf_83 : ((B_80) m_82)}
    : (exists_5‹??_2,??_3,??_4› ?_2 B_80)

#[program]
inductive sing_6‹s_84› (A_85 : Type‹s_84›): A_85 -> Type‹s_84›
where
| just_8 (m_87 : A_85) : (sing_6‹??_5› ?_3 m_87)

#[program]
inductive list_7‹s_88› (A_89 : Type‹s_88›): U where
| nil_9 : (list_7‹??_6› A_89)
| cons_10
    (hd_90 : A_89) (tl_91 : (list_7‹??_7› A_89))
    : (list_7‹??_8› A_89)

#[program]
inductive vec_8‹s_92› (A_93 : Type‹s_92›): nat_3 -> U where
| vnil_11 : (vec_8‹??_9› A_93 zero_4)
| vcons_12
    {n_95 : nat_3} (hd_96 : A_93) (tl_97 : (vec_8‹s_92› A_93 n_95))
    : (vec_8‹??_10› A_93 (succ_5‹› n_95))

#[program]
def uncons2_1‹s_98› :
  ∀ {A_99 : Type‹s_98›} ->
    ∀ {n_100 : nat_3} ->
      (vec_8‹??_13› A_99 n_100) ->
        (vec_8‹??_14› A_99 n_100) -> unit_1
:=
  function uncons2_103 :
    ∀ {A_104 : Type‹s_98›} ->
      ∀ {n_105 : nat_3} ->
        (vec_8‹??_11› A_104 n_105) ->
          (vec_8‹??_12› A_104 n_105) -> unit_1
  | A_108 n_109 vnil_11 vnil_11 => tt_1
  | A_110 n_111 vnil_11 (vcons_12 _112 _113 _114) =>
  | A_115 n_116 (vcons_12 _117 _118 _119) (vcons_12 _120 _121 _122) => tt_1

-----------------------------------------

inductive-------------------------
infer_tm(unit_1)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(bool_2)
infer_tm(bool_2)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(nat_3)
infer_tm(nat_3)
infer_tm(nat_3)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(Type‹s_125›)
infer_tm(A_126)
infer_tm(A_126)
infer_tm(Type‹s_129›)
infer_tm(A_130)
assert_equal1( A_130, ?_1)
assert_equal1( m_131, m_131)
infer_tm((eq_4‹??_1› ?_1 m_131 m_131))
check_tm( ?_1, Type‹??_1›)
check_tm( m_131, ?_1)
infer_tm(m_131)
assert_equal1( ?_1, A_130)
check_tm( m_131, ?_1)
infer_tm(m_131)
assert_equal1( ?_1, A_130)
simpl_tm ~expand:false( ?_1, A_130)
simpl_tm ~expand:false( A_130, A_130)
simpl_tm ~expand:false( A_130, A_130)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_132
    
  |}
  imeta_meta {|
    ?_1 <= A_135
    
  |}
  eqns {|
    
  |}
end_dump
infer_tm(Type‹s_129›)
check_tm( A_130, Type‹s_129›)
infer_tm(A_130)
assert_equal1( Type‹s_129›, Type‹s_129›)
----------------------------------

inductive-------------------------
infer_tm(Type‹s_147›)
infer_tm(A_150 -> Type‹r_148›)
infer_tm(A_150)
infer_tm(Type‹r_148›)
infer_tm(Type‹s_154›)
infer_tm(A_157 -> Type‹r_155›)
infer_tm(A_157)
infer_tm(Type‹r_155›)
infer_tm(A_157)
infer_tm(((B_158) m_161))
infer_tm(B_158)
check_tm( m_161, A_157)
infer_tm(m_161)
assert_equal1( A_157, A_157)
assert_equal1( A_157, ?_2)
assert_equal1( B_158, B_158)
infer_tm((exists_5‹??_2,??_3,??_4› ?_2 B_158))
check_tm( ?_2, Type‹??_2›)
check_tm( B_158, ?_2 -> Type‹??_3›)
infer_tm(B_158)
assert_equal1( ?_2 -> Type‹??_3›, A_157 -> Type‹r_155›)
simpl_tm ~expand:false( ?_2 -> Type‹??_3›, A_157 -> Type‹r_155›)
simpl_tm ~expand:false( ?_2, A_157)
simpl_tm ~expand:false( Type‹??_3›, Type‹r_155›)
simpl_tm ~expand:false( A_157, A_157)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_172
    ??_2 <= s_175
    ??_3 <= r_177
    ??_4 <= t_179
    
  |}
  imeta_meta {|
    ?_1 <= A_184
    ?_2 <= A_191
    
  |}
  eqns {|
    
  |}
end_dump
infer_tm(Type‹s_154›)
check_tm( A_157, Type‹s_154›)
infer_tm(A_157)
assert_equal1( Type‹s_154›, Type‹s_154›)
----------------------------------

inductive-------------------------
infer_tm(Type‹s_224›)
infer_tm(A_225)
infer_tm(Type‹s_227›)
infer_tm(A_228)
assert_equal1( A_228, ?_3)
infer_tm((sing_6‹??_5› ?_3 m_229))
check_tm( ?_3, Type‹??_5›)
check_tm( m_229, ?_3)
infer_tm(m_229)
assert_equal1( ?_3, A_228)
simpl_tm ~expand:false( ?_3, A_228)
simpl_tm ~expand:false( A_228, A_228)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_230
    ??_2 <= s_233
    ??_3 <= r_235
    ??_4 <= t_237
    ??_5 <= s_240
    
  |}
  imeta_meta {|
    ?_1 <= A_243
    ?_2 <= A_250
    ?_3 <= A_253
    
  |}
  eqns {|
    
  |}
end_dump
infer_tm(Type‹s_227›)
check_tm( A_228, Type‹s_227›)
infer_tm(A_228)
assert_equal1( Type‹s_227›, Type‹s_227›)
----------------------------------

inductive-------------------------
infer_tm(Type‹s_266›)
infer_tm(Type‹s_268›)
assert_equal1( A_269, A_269)
infer_tm((list_7‹??_6› A_269))
check_tm( A_269, Type‹??_6›)
infer_tm(A_269)
assert_equal1( Type‹??_6›, Type‹s_268›)
simpl_tm ~expand:false( Type‹??_6›, Type‹s_268›)
infer_tm(Type‹s_270›)
infer_tm(A_271)
infer_tm((list_7‹??_7› A_271))
check_tm( A_271, Type‹??_7›)
infer_tm(A_271)
assert_equal1( Type‹??_7›, Type‹s_270›)
simpl_tm ~expand:false( Type‹??_7›, Type‹s_270›)
assert_equal1( A_271, A_271)
infer_tm((list_7‹??_8› A_271))
check_tm( A_271, Type‹??_8›)
infer_tm(A_271)
assert_equal1( Type‹??_8›, Type‹s_270›)
simpl_tm ~expand:false( Type‹??_8›, Type‹s_270›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_274
    ??_2 <= s_277
    ??_3 <= r_279
    ??_4 <= t_281
    ??_5 <= s_284
    ??_6 <= s_285
    ??_7 <= s_286
    ??_8 <= s_287
    
  |}
  imeta_meta {|
    ?_1 <= A_290
    ?_2 <= A_297
    ?_3 <= A_300
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(Type‹s_316›)
infer_tm(nat_3)
infer_tm(Type‹s_319›)
assert_equal1( A_320, A_320)
infer_tm((vec_8‹??_9› A_320 zero_4))
check_tm( A_320, Type‹??_9›)
infer_tm(A_320)
assert_equal1( Type‹??_9›, Type‹s_319›)
check_tm( zero_4, nat_3)
infer_tm(zero_4)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_9›, Type‹s_319›)
infer_tm(Type‹s_321›)
infer_tm(nat_3)
infer_tm(A_322)
infer_tm((vec_8‹s_321› A_322 n_323))
check_tm( A_322, Type‹s_321›)
infer_tm(A_322)
assert_equal1( Type‹s_321›, Type‹s_321›)
check_tm( n_323, nat_3)
infer_tm(n_323)
assert_equal1( nat_3, nat_3)
assert_equal1( A_322, A_322)
infer_tm((vec_8‹??_10› A_322 (succ_5‹› n_323)))
check_tm( A_322, Type‹??_10›)
infer_tm(A_322)
assert_equal1( Type‹??_10›, Type‹s_321›)
check_tm( (succ_5‹› n_323), nat_3)
infer_tm((succ_5‹› n_323))
check_tm( n_323, nat_3)
infer_tm(n_323)
assert_equal1( nat_3, nat_3)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_10›, Type‹s_321›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_326
    ??_2 <= s_329
    ??_3 <= r_331
    ??_4 <= t_333
    ??_5 <= s_336
    ??_6 <= s_337
    ??_7 <= s_338
    ??_8 <= s_339
    ??_9 <= s_340
    ??_10 <= s_341
    
  |}
  imeta_meta {|
    ?_1 <= A_344
    ?_2 <= A_351
    ?_3 <= A_354
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

definition-------------------------
infer_tm(∀ {A_377 : Type‹s_376›} ->
           ∀ {n_378 : nat_3} ->
             (vec_8‹??_13› A_377 n_378) ->
               (vec_8‹??_14› A_377 n_378) -> unit_1)
infer_tm(Type‹s_376›)
infer_tm(∀ {n_382 : nat_3} ->
           (vec_8‹??_13› A_381 n_382) ->
             (vec_8‹??_14› A_381 n_382) -> unit_1)
infer_tm(nat_3)
infer_tm((vec_8‹??_13› A_381 n_385) ->
           (vec_8‹??_14› A_381 n_385) -> unit_1)
infer_tm((vec_8‹??_13› A_381 n_385))
check_tm( A_381, Type‹??_13›)
infer_tm(A_381)
assert_equal1( Type‹??_13›, Type‹s_376›)
check_tm( n_385, nat_3)
infer_tm(n_385)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_13›, Type‹s_376›)
infer_tm((vec_8‹??_14› A_381 n_385) -> unit_1)
infer_tm((vec_8‹??_14› A_381 n_385))
check_tm( A_381, Type‹??_14›)
infer_tm(A_381)
assert_equal1( Type‹??_14›, Type‹s_376›)
check_tm( n_385, nat_3)
infer_tm(n_385)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_14›, Type‹s_376›)
infer_tm(unit_1)
check_tm(
  function uncons2_391 :
    ∀ {A_392 : Type‹s_376›} ->
      ∀ {n_393 : nat_3} ->
        (vec_8‹??_11› A_392 n_393) ->
          (vec_8‹??_12› A_392 n_393) -> unit_1
  | A_396 n_397 vnil_11 vnil_11 => tt_1
  | A_398 n_399 vnil_11 (vcons_12 _400 _401 _402) =>
  | A_403 n_404 (vcons_12 _405 _406 _407) (vcons_12 _408 _409 _410) => tt_1,
  ∀ {A_411 : Type‹s_376›} ->
    ∀ {n_412 : nat_3} ->
      (vec_8‹??_13› A_411 n_412) ->
        (vec_8‹??_14› A_411 n_412) -> unit_1)
infer_tm(∀ {A_416 : Type‹s_376›} ->
           ∀ {n_417 : nat_3} ->
             (vec_8‹??_11› A_416 n_417) ->
               (vec_8‹??_12› A_416 n_417) -> unit_1)
infer_tm(Type‹s_376›)
infer_tm(∀ {n_421 : nat_3} ->
           (vec_8‹??_11› A_420 n_421) ->
             (vec_8‹??_12› A_420 n_421) -> unit_1)
infer_tm(nat_3)
infer_tm((vec_8‹??_11› A_420 n_424) ->
           (vec_8‹??_12› A_420 n_424) -> unit_1)
infer_tm((vec_8‹??_11› A_420 n_424))
check_tm( A_420, Type‹??_11›)
infer_tm(A_420)
assert_equal1( Type‹??_11›, Type‹s_376›)
check_tm( n_424, nat_3)
infer_tm(n_424)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_11›, Type‹s_376›)
infer_tm((vec_8‹??_12› A_420 n_424) -> unit_1)
infer_tm((vec_8‹??_12› A_420 n_424))
check_tm( A_420, Type‹??_12›)
infer_tm(A_420)
assert_equal1( Type‹??_12›, Type‹s_376›)
check_tm( n_424, nat_3)
infer_tm(n_424)
assert_equal1( nat_3, nat_3)
simpl_tm ~expand:false( Type‹??_12›, Type‹s_376›)
infer_tm(unit_1)
assert_equal1(
  ∀ {A_430 : Type‹s_376›} ->
    ∀ {n_431 : nat_3} ->
      (vec_8‹??_13› A_430 n_431) ->
        (vec_8‹??_14› A_430 n_431) -> unit_1,
  ∀ {A_434 : Type‹s_376›} ->
    ∀ {n_435 : nat_3} ->
      (vec_8‹??_11› A_434 n_435) ->
        (vec_8‹??_12› A_434 n_435) -> unit_1)
simpl_tm ~expand:false(
  ∀ {A_477 : Type‹s_376›} ->
    ∀ {n_478 : nat_3} ->
      (vec_8‹s_376› A_477 n_478) ->
        (vec_8‹s_376› A_477 n_478) -> unit_1,
  ∀ {A_481 : Type‹s_376›} ->
    ∀ {n_482 : nat_3} ->
      (vec_8‹s_376› A_481 n_482) ->
        (vec_8‹s_376› A_481 n_482) -> unit_1)
simpl_tm ~expand:false( Type‹s_376›, Type‹s_376›)
simpl_tm ~expand:false(
  ∀ {n_486 : nat_3} ->
    (vec_8‹s_376› A_485 n_486) ->
      (vec_8‹s_376› A_485 n_486) -> unit_1,
  ∀ {n_489 : nat_3} ->
    (vec_8‹s_376› A_485 n_489) ->
      (vec_8‹s_376› A_485 n_489) -> unit_1)
simpl_tm ~expand:false( nat_3, nat_3)
simpl_tm ~expand:false(
  (vec_8‹s_376› A_485 n_492) -> (vec_8‹s_376› A_485 n_492) -> unit_1,
  (vec_8‹s_376› A_485 n_492) -> (vec_8‹s_376› A_485 n_492) -> unit_1)
simpl_tm ~expand:false( (vec_8‹s_376› A_485 n_492),
  (vec_8‹s_376› A_485 n_492))
simpl_tm ~expand:false( A_485, A_485)
simpl_tm ~expand:false( n_492, n_492)
simpl_tm ~expand:false( (vec_8‹s_376› A_485 n_492) -> unit_1,
  (vec_8‹s_376› A_485 n_492) -> unit_1)
simpl_tm ~expand:false( (vec_8‹s_376› A_485 n_492),
  (vec_8‹s_376› A_485 n_492))
simpl_tm ~expand:false( A_485, A_485)
simpl_tm ~expand:false( n_492, n_492)
simpl_tm ~expand:false( unit_1, unit_1)
check_cls {|
  prblm {| ;
    {|  ::: [A_448, n_449, vnil_11, vnil_11] =>? tt_1 |}
    () ::: [A_450, n_451, vnil_11, (vcons_12 _452 _453 _454)] =>? !!
    {|  ::: [A_455, n_456, (vcons_12 _457 _458 _459), (vcons_12 _460 _461 _462)] =>?
         tt_1
    |}
  |}
|}
case_intro
case_intro
case_intro
case_intro
case_splitting
splitting_on(vnil_11)
case_splitting
splitting_on(vnil_11)
case_coverage{|
  prblm {|
    eq_term?( (vec_8‹s_376› #A_508 #n_509),
      (vec_8‹s_376› #A_508 zero_4))
    eq_term?( (vec_8‹s_376› #A_508 #n_509),
      (vec_8‹s_376› #A_508 zero_4));
    {| eq_pat?( #A_508, A_448 : Type‹s_376›)
       eq_pat?( #n_509, n_449 : nat_3) ::: [] =>? tt_1
    |}
  |}
|}
unify_pprbm(
  eq_term?( (vec_8‹s_376› #A_508 #n_509),
    (vec_8‹s_376› #A_508 zero_4))
  eq_term?( (vec_8‹s_376› #A_508 #n_509),
    (vec_8‹s_376› #A_508 zero_4))
  eq_pat?( #A_508, A_448 : Type‹s_376›)
  eq_pat?( #n_509, n_449 : nat_3)
)
simpl_pprbm ~expand:false( (vec_8‹s_376› #A_508 #n_509),
  (vec_8‹s_376› #A_508 zero_4))
simpl_pprbm ~expand:false( #A_508, #A_508)
simpl_pprbm ~expand:false( #n_509, zero_4)
simpl_pprbm ~expand:false( (vec_8‹s_376› #A_508 #n_509),
  (vec_8‹s_376› #A_508 zero_4))
simpl_pprbm ~expand:false( #A_508, #A_508)
simpl_pprbm ~expand:false( #n_509, zero_4)
simpl_pprbm ~expand:false( #A_508, #A_448)
simpl_pprbm ~expand:false( #n_509, #n_449)
simpl_pprbm ~expand:false( zero_4, #n_509)
simpl_pprbm ~expand:false( zero_4, zero_4)
simpl_pprbm ~expand:false( #A_508, #A_448)
simpl_pprbm ~expand:false( zero_4, #n_449)
case_coverage_ok( tt_1, unit_1)
check_tm( tt_1, unit_1)
infer_tm(tt_1)
assert_equal1( unit_1, unit_1)
splitting_on(vcons_12)
case_coverage{|
  prblm {|
    eq_term?( (vec_8‹s_376› #A_508 #n_509),
      (vec_8‹s_376› #A_508 (succ_5‹› #n_533)))
    eq_term?( (vec_8‹s_376› #A_508 #n_509),
      (vec_8‹s_376› #A_508 zero_4));
    (eq_pat?( #A_508, A_450 : Type‹s_376›)
     eq_pat?( #n_509, n_451 : nat_3)
     eq_pat?( #n_533, _452 : nat_3)
     eq_pat?( #hd_534, _453 : #A_508)
     eq_pat?( #tl_535, _454 : (vec_8‹s_376› #A_508 #n_533))) ::: [] =>? !!
  |}
|}
unify_pprbm(
  eq_term?( (vec_8‹s_376› #A_508 #n_509),
    (vec_8‹s_376› #A_508 (succ_5‹› #n_533)))
  eq_term?( (vec_8‹s_376› #A_508 #n_509),
    (vec_8‹s_376› #A_508 zero_4))
)
simpl_pprbm ~expand:false( (vec_8‹s_376› #A_508 #n_509),
  (vec_8‹s_376› #A_508 (succ_5‹› #n_533)))
simpl_pprbm ~expand:false( #A_508, #A_508)
simpl_pprbm ~expand:false( #n_509, (succ_5‹› #n_533))
simpl_pprbm ~expand:false( (vec_8‹s_376› #A_508 #n_509),
  (vec_8‹s_376› #A_508 zero_4))
simpl_pprbm ~expand:false( #A_508, #A_508)
simpl_pprbm ~expand:false( #n_509, zero_4)
simpl_pprbm ~expand:false( (succ_5‹› #n_533), #n_509)
simpl_pprbm ~expand:false( zero_4, (succ_5‹› #n_533))
simpl_pprbm ~expand:true( zero_4, (succ_5‹› #n_533))
splitting_on(vcons_12)
case_splitting
splitting_on(vnil_11)
case_empty
unify_pprbm(
  eq_term?( (vec_8‹s_376› #A_508 #n_509),
    (vec_8‹s_376› #A_508 zero_4))
  eq_term?( (vec_8‹s_376› #A_508 #n_509),
    (vec_8‹s_376› #A_508 (succ_5‹› #n_543)))
)
simpl_pprbm ~expand:false( (vec_8‹s_376› #A_508 #n_509),
  (vec_8‹s_376› #A_508 zero_4))
simpl_pprbm ~expand:false( #A_508, #A_508)
simpl_pprbm ~expand:false( #n_509, zero_4)
simpl_pprbm ~expand:false( (vec_8‹s_376› #A_508 #n_509),
  (vec_8‹s_376› #A_508 (succ_5‹› #n_543)))
simpl_pprbm ~expand:false( #A_508, #A_508)
simpl_pprbm ~expand:false( #n_509, (succ_5‹› #n_543))
simpl_pprbm ~expand:false( zero_4, #n_509)
simpl_pprbm ~expand:false( (succ_5‹› #n_543), zero_4)
simpl_pprbm ~expand:true( (succ_5‹› #n_543), zero_4)
splitting_on(vcons_12)
case_coverage{|
  prblm {|
    eq_term?( (vec_8‹s_376› #A_508 #n_509),
      (vec_8‹s_376› #A_508 (succ_5‹› #n_560)))
    eq_term?( (vec_8‹s_376› #A_508 #n_509),
      (vec_8‹s_376› #A_508 (succ_5‹› #n_543)));
    {| eq_pat?( #A_508, A_455 : Type‹s_376›)
       eq_pat?( #n_509, n_456 : nat_3)
       eq_pat?( #n_543, _457 : nat_3)
       eq_pat?( #hd_544, _458 : #A_508)
       eq_pat?( #tl_545, _459 : (vec_8‹s_376› #A_508 #n_543))
       eq_pat?( #n_560, _460 : nat_3)
       eq_pat?( #hd_561, _461 : #A_508)
       eq_pat?( #tl_562, _462 : (vec_8‹s_376› #A_508 #n_560)) ::: [] =>?
         tt_1
    |}
  |}
|}
unify_pprbm(
  eq_term?( (vec_8‹s_376› #A_508 #n_509),
    (vec_8‹s_376› #A_508 (succ_5‹› #n_560)))
  eq_term?( (vec_8‹s_376› #A_508 #n_509),
    (vec_8‹s_376› #A_508 (succ_5‹› #n_543)))
  eq_pat?( #A_508, A_455 : Type‹s_376›)
  eq_pat?( #n_509, n_456 : nat_3)
  eq_pat?( #n_543, _457 : nat_3)
  eq_pat?( #hd_544, _458 : #A_508)
  eq_pat?( #tl_545, _459 : (vec_8‹s_376› #A_508 #n_543))
  eq_pat?( #n_560, _460 : nat_3)
  eq_pat?( #hd_561, _461 : #A_508)
  eq_pat?( #tl_562, _462 : (vec_8‹s_376› #A_508 #n_560))
)
simpl_pprbm ~expand:false( (vec_8‹s_376› #A_508 #n_509),
  (vec_8‹s_376› #A_508 (succ_5‹› #n_560)))
simpl_pprbm ~expand:false( #A_508, #A_508)
simpl_pprbm ~expand:false( #n_509, (succ_5‹› #n_560))
simpl_pprbm ~expand:false( (vec_8‹s_376› #A_508 #n_509),
  (vec_8‹s_376› #A_508 (succ_5‹› #n_543)))
simpl_pprbm ~expand:false( #A_508, #A_508)
simpl_pprbm ~expand:false( #n_509, (succ_5‹› #n_543))
simpl_pprbm ~expand:false( #A_508, #A_455)
simpl_pprbm ~expand:false( #n_509, #n_456)
simpl_pprbm ~expand:false( #n_543, #_457)
simpl_pprbm ~expand:false( #hd_544, #_458)
simpl_pprbm ~expand:false( #tl_545, #_459)
simpl_pprbm ~expand:false( #n_560, #_460)
simpl_pprbm ~expand:false( #hd_561, #_461)
simpl_pprbm ~expand:false( #tl_562, #_462)
simpl_pprbm ~expand:false( (succ_5‹› #n_560), #n_509)
simpl_pprbm ~expand:false( (succ_5‹› #n_543), (succ_5‹› #n_560))
simpl_pprbm ~expand:false( #n_543, #n_560)
simpl_pprbm ~expand:false( #A_508, #A_455)
simpl_pprbm ~expand:false( (succ_5‹› #n_560), #n_456)
simpl_pprbm ~expand:false( #n_560, #_457)
simpl_pprbm ~expand:false( #hd_544, #_458)
simpl_pprbm ~expand:false( #tl_545, #_459)
simpl_pprbm ~expand:false( #n_560, #_460)
simpl_pprbm ~expand:false( #hd_561, #_461)
simpl_pprbm ~expand:false( #tl_562, #_462)
case_coverage_ok( tt_1, unit_1)
check_tm( tt_1, unit_1)
infer_tm(tt_1)
assert_equal1( unit_1, unit_1)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_577
    ??_2 <= s_580
    ??_3 <= r_582
    ??_4 <= t_584
    ??_5 <= s_587
    ??_6 <= s_588
    ??_7 <= s_589
    ??_8 <= s_590
    ??_9 <= s_591
    ??_10 <= s_592
    ??_11 <= s_593
    ??_12 <= s_594
    ??_13 <= s_595
    ??_14 <= s_596
    
  |}
  imeta_meta {|
    ?_1 <= A_599
    ?_2 <= A_606
    ?_3 <= A_609
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

smeta_meta {|
  ??_1 <= s_647
  ??_2 <= s_650
  ??_3 <= r_652
  ??_4 <= t_654
  ??_5 <= s_657
  ??_6 <= s_658
  ??_7 <= s_659
  ??_8 <= s_660
  ??_9 <= s_661
  ??_10 <= s_662
  ??_11 <= s_663
  ??_12 <= s_664
  ??_13 <= s_665
  ??_14 <= s_666
  
|}
imeta_meta {|
  ?_1 <= A_669
  ?_2 <= A_676
  ?_3 <= A_679
  
|}
#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_808 : nat_3) : nat_3

#[logical]
inductive eq_4‹s_809› (A_810 : Type‹s_809›) (m_811 : A_810):
  A_810 -> U
where
| refl_6 : (eq_4‹s_809› A_810 m_811 m_811)

#[program]
inductive exists_5‹s_813,r_814,t_815› (A_816 : Type‹s_813›) (B_817 : 
A_816 -> Type‹r_814›): Type‹t_815› where
| ex_7
    (m_819 : A_816) {pf_820 : ((B_817) m_819)}
    : (exists_5‹s_813,r_814,t_815› A_816 B_817)

#[program]
inductive sing_6‹s_821› (A_822 : Type‹s_821›):
  A_822 -> Type‹s_821›
where
| just_8 (m_824 : A_822) : (sing_6‹s_821› A_822 m_824)

#[program]
inductive list_7‹s_825› (A_826 : Type‹s_825›): U where
| nil_9 : (list_7‹s_825› A_826)
| cons_10
    (hd_827 : A_826) (tl_828 : (list_7‹s_825› A_826))
    : (list_7‹s_825› A_826)

#[program]
inductive vec_8‹s_829› (A_830 : Type‹s_829›): nat_3 -> U where
| vnil_11 : (vec_8‹s_829› A_830 zero_4)
| vcons_12
    {n_832 : nat_3} (hd_833 : A_830)
    (tl_834 : (vec_8‹s_829› A_830 n_832))
    : (vec_8‹s_829› A_830 (succ_5‹› n_832))

#[program]
def uncons2_1‹s_835› :
  ∀ {A_836 : Type‹s_835›} ->
    ∀ {n_837 : nat_3} ->
      (vec_8‹s_835› A_836 n_837) ->
        (vec_8‹s_835› A_836 n_837) -> unit_1
:=
  function uncons2_840 :
    ∀ {A_841 : Type‹s_835›} ->
      ∀ {n_842 : nat_3} ->
        (vec_8‹s_835› A_841 n_842) ->
          (vec_8‹s_835› A_841 n_842) -> unit_1
  | A_845 n_846 vnil_11 vnil_11 => tt_1
  | A_847 n_848 vnil_11 (vcons_12 _849 _850 _851) =>
  | A_852 n_853 (vcons_12 _854 _855 _856) (vcons_12 _857 _858 _859) => tt_1

-----------------------------------------

