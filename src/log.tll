[Notation {name = "|>"; body = (App [(Hole 2); (Hole 1)])};
  Notation {name = "@@"; body = (App [(Hole 1); (Hole 2)])};
  Notation {name = "="; body = (App [(Id ("eq", I)); (Hole 1); (Hole 2)])};
  Notation {name = "`"; body = (App [(Id ("sing", I)); (Hole 1)])};
  Notation {name = "&&"; body = (App [(Id ("and", I)); (Hole 1); (Hole 2)])};
  Notation {name = "||"; body = (App [(Id ("or", I)); (Hole 1); (Hole 2)])};
  Notation {name = "+"; body = (App [(Id ("add", I)); (Hole 1); (Hole 2)])};
  Notation {name = "-"; body = (App [(Id ("sub", I)); (Hole 1); (Hole 2)])};
  Notation {name = "*"; body = (App [(Id ("mul", I)); (Hole 1); (Hole 2)])};
  Notation {name = "/"; body = (App [(Id ("div", I)); (Hole 1); (Hole 2)])};
  Notation {name = "%"; body = (App [(Id ("rem", I)); (Hole 1); (Hole 2)])};
  Notation {name = "^"; body = (App [(Id ("pow", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<"; body = (App [(Id ("lt", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">"; body = (App [(Id ("gt", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<="; body = (App [(Id ("lte", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">="; body = (App [(Id ("gte", I)); (Hole 1); (Hole 2)])};
  Notation {name = "**"; body = (App [(Id ("prod1", I)); (Hole 1); (Hole 2)])};
  Notation {name = "::"; body = (App [(Id ("cons", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase (BOpr ("=", (Id ("m", I)), (Id ("m", I))))),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "rwl"; relv = R;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (N, U, (Id ("A", I)),
                          (Binder ("n",
                             (Pi (N, U,
                                (Pi (R, U, (Id ("A", I)),
                                   (Binder ("_", (Type (SId "r")))))),
                                (Binder ("B",
                                   (Pi (N, U,
                                      (BOpr ("=", (Id ("m", I)),
                                         (Id ("n", I)))),
                                      (Binder ("_",
                                         (Pi (R, U,
                                            (App
                                               [(Id ("B", I)); (Id ("m", I))]),
                                            (Binder ("_",
                                               (App
                                                  [(Id ("B", I));
                                                    (Id ("n", I))])
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "rwl"),
              [([(PId "A"); (PId "m"); (PId "n"); (PId "B"); (PId "refl");
                  (PId "x")],
                (Some (Id ("x", I))))]
              )),
           [I; I; I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (N, U, (Id ("A", I)),
                       (Binder ("n",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Type (SId "r")))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=", (Id ("m", I)), (Id ("n", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App [(Id ("B", I)); (Id ("m", I))]),
                                         (Binder ("_",
                                            (App
                                               [(Id ("B", I)); (Id ("n", I))])
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; E]};
  Definition {name = "rwr"; relv = R;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (N, U, (Id ("A", I)),
                          (Binder ("n",
                             (Pi (N, U,
                                (Pi (R, U, (Id ("A", I)),
                                   (Binder ("_", (Type (SId "r")))))),
                                (Binder ("B",
                                   (Pi (N, U,
                                      (BOpr ("=", (Id ("m", I)),
                                         (Id ("n", I)))),
                                      (Binder ("_",
                                         (Pi (R, U,
                                            (App
                                               [(Id ("B", I)); (Id ("n", I))]),
                                            (Binder ("_",
                                               (App
                                                  [(Id ("B", I));
                                                    (Id ("m", I))])
                                               ))
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "rwr"),
              [([(PId "A"); (PId "m"); (PId "n"); (PId "B"); (PId "refl");
                  (PId "x")],
                (Some (Id ("x", I))))]
              )),
           [I; I; I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (N, U, (Id ("A", I)),
                       (Binder ("n",
                          (Pi (N, U,
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("_", (Type (SId "r")))))),
                             (Binder ("B",
                                (Pi (N, U,
                                   (BOpr ("=", (Id ("m", I)), (Id ("n", I)))),
                                   (Binder ("_",
                                      (Pi (R, U,
                                         (App [(Id ("B", I)); (Id ("n", I))]),
                                         (Binder ("_",
                                            (App
                                               [(Id ("B", I)); (Id ("m", I))])
                                            ))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I; I; E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "s"))))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m", (TBase (UOpr ("`", (Id ("m", I))))))))),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "unit"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)), [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
       ));
    view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("n", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "list"; relv = R;
    body =
    (Binder (["s"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type (SId "t"))),
                 [(DConstr ("nil",
                     (TBase (App [(Id ("list", I)); (Id ("A", I))])), 
                     []));
                   (DConstr ("cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (App
                                  [(Inst ("list", [(SId "_"); (SId "t")], I));
                                    (Id ("A", I))]),
                               (Binder ("tl",
                                  (TBase
                                     (App [(Id ("list", I)); (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Inductive {name = "exists0"; relv = R;
    body =
    (Binder (["s"; "r"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("ex0",
                           (TBind (N, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("exists0", E));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "exists1"; relv = R;
    body =
    (Binder (["s"; "r"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("ex1",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("exists1", E));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "prod0"; relv = N;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (R, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))))
              )),
           (Binder ((Some "prod0"),
              [([(PId "A"); (PId "B")],
                (Some (App
                         [(Id ("exists0", E)); (Id ("A", I));
                           (Fun ((Pi (R, U, IMeta, (Binder ("_", IMeta)))),
                              (Binder (None,
                                 [([(PId "_")], (Some (Id ("B", I))))])),
                              []))
                           ])))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Type (SId "s")),
           (Binder ("A", (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "prod1"; relv = N;
    body =
    (Binder (["s"; "r"],
       ((Fun (
           (Pi (R, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))))
              )),
           (Binder ((Some "prod1"),
              [([(PId "A"); (PId "B")],
                (Some (App
                         [(Id ("exists1", E)); (Id ("A", I));
                           (Fun ((Pi (R, U, IMeta, (Binder ("_", IMeta)))),
                              (Binder (None,
                                 [([(PId "_")], (Some (Id ("B", I))))])),
                              []))
                           ])))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Type (SId "s")),
           (Binder ("A", (Pi (R, U, (Type (SId "r")), (Binder ("B", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "not"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I)))))),
           (Binder ((Some "not"),
              [([(PId "true")], (Some (Id ("false", I))));
                ([(PId "false")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I)))))))
       ));
    view = []};
  Definition {name = "and"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "and"),
              [([(PId "true"); (PId "true")], (Some (Id ("true", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("false", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "or"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "or"),
              [([(PId "false"); (PId "false")], (Some (Id ("false", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "xor"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, L, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "xor"),
              [([(PId "true"); (PId "true")], (Some (Id ("false", I))));
                ([(PId "false"); (PId "false")], (Some (Id ("false", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, L, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "lte"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("bool", I))))
                    ))
                 ))
              )),
           (Binder ((Some "lte"),
              [([(PId "zero"); (PId "_")], (Some (Id ("true", I))));
                ([(PId "_"); (PId "zero")], (Some (Id ("false", I))));
                ([(PConstr ("succ", [(PId "x")]));
                   (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("<=", (Id ("x", I)), (Id ("y", I))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Definition {name = "lt"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", (Id ("bool", I))))
                    ))
                 ))
              )),
           (Binder ((Some "lt"),
              [([(PId "x"); (PId "y")],
                (Some (BOpr ("<=", (App [(Id ("succ", I)); (Id ("x", I))]),
                         (Id ("y", I))))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x",
              (Pi (R, U, (Id ("nat", I)), (Binder ("y", (Id ("bool", I))))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "pred"; relv = R;
    body =
    (Binder ([],
       ((Fun ((Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I)))))),
           (Binder ((Some "pred"),
              [([(PId "zero")], (Some (Id ("zero", I))));
                ([(PConstr ("succ", [(PId "x")]))], (Some (Id ("x", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I)))))))
       ));
    view = []};
  Definition {name = "add"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "add"),
              [([(PId "zero"); (PId "y")], (Some (Id ("y", I))));
                ([(PConstr ("succ", [(PId "x")])); (PId "y")],
                 (Some (App
                          [(Id ("succ", I));
                            (BOpr ("+", (Id ("x", I)), (Id ("y", I))))])))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "sub"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "sub"),
              [([(PId "x"); (PId "zero")], (Some (Id ("x", I))));
                ([(PId "x"); (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("-", (App [(Id ("pred", I)); (Id ("x", I))]),
                          (Id ("y", I))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "mul"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "mul"),
              [([(PId "zero"); (PId "_")], (Some (Id ("zero", I))));
                ([(PConstr ("succ", [(PId "x")])); (PId "y")],
                 (Some (BOpr ("+", (Id ("y", I)),
                          (BOpr ("*", (Id ("x", I)), (Id ("y", I))))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Definition {name = "div"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))))
              )),
           (Binder ((Some "div"),
              [([(PId "x"); (PId "y")],
                (Some (Match (
                         [(R,
                           (App
                              [(Id ("lt", I)); (Id ("x", I)); (Id ("y", I))]),
                           None)],
                         None,
                         [([(PId "true")], (Some (Id ("zero", I))));
                           ([(PId "false")],
                            (Some (App
                                     [(Id ("succ", I));
                                       (BOpr ("/",
                                          (BOpr ("-", (Id ("x", I)),
                                             (Id ("y", I)))),
                                          (Id ("y", I))))
                                       ])))
                           ]
                         ))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x", (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "rem"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("x",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))))
              )),
           (Binder ((Some "rem"),
              [([(PId "x"); (PId "y")],
                (Some (BOpr ("-", (Id ("x", I)),
                         (BOpr ("*",
                            (BOpr ("/", (Id ("x", I)), (Id ("y", I)))),
                            (Id ("y", I))))
                         ))))
                ]
              )),
           [E; E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("x", (Pi (R, U, (Id ("nat", I)), (Binder ("y", IMeta))))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "pow"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))
                    ))
                 ))
              )),
           (Binder ((Some "pow"),
              [([(PId "_"); (PId "zero")],
                (Some (App [(Id ("succ", I)); (Id ("zero", I))])));
                ([(PId "x"); (PConstr ("succ", [(PId "y")]))],
                 (Some (BOpr ("*", (Id ("x", I)),
                          (BOpr ("^", (Id ("x", I)), (Id ("y", I))))))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U, (Id ("nat", I)), (Binder ("_", (Id ("nat", I))))))))
           )))
       ));
    view = []};
  Extern {name = "proto"; relv = N; body = (Binder ([], (Type U))); view = []};
  Extern {name = "act0"; relv = N;
    body =
    (Binder (["s"],
       (Pi (R, U, (Id ("bool", I)),
          (Binder ("b",
             (Pi (R, U, (Type (SId "s")),
                (Binder ("A",
                   (Pi (R, U,
                      (Pi (R, U, (Id ("A", I)),
                         (Binder ("_", (Id ("proto", I)))))),
                      (Binder ("B", (Id ("proto", I))))))
                   ))
                ))
             ))
          ))
       ));
    view = [E; I; E]};
  Extern {name = "act1"; relv = N;
    body =
    (Binder (["s"],
       (Pi (R, U, (Id ("bool", I)),
          (Binder ("b",
             (Pi (R, U, (Type (SId "s")),
                (Binder ("A",
                   (Pi (R, U,
                      (Pi (R, U, (Id ("A", I)),
                         (Binder ("_", (Id ("proto", I)))))),
                      (Binder ("B", (Id ("proto", I))))))
                   ))
                ))
             ))
          ))
       ));
    view = [E; I; E]};
  Extern {name = "endp"; relv = N; body = (Binder ([], (Id ("proto", I))));
    view = []};
  Extern {name = "ch"; relv = N;
    body =
    (Binder ([],
       (Pi (R, U, (Id ("bool", I)),
          (Binder ("_",
             (Pi (R, U, (Id ("proto", I)), (Binder ("_", (Type L)))))))
          ))
       ));
    view = []};
  Extern {name = "close"; relv = R;
    body =
    (Binder ([],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b",
             (Pi (R, U,
                (App [(Id ("ch", I)); (Id ("b", I)); (Id ("endp", I))]),
                (Binder ("_", (IO (Id ("unit", I)))))))
             ))
          ))
       ));
    view = [I]};
  Extern {name = "send0"; relv = R;
    body =
    (Binder (["s"],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b1",
             (Pi (N, U, (Id ("bool", I)),
                (Binder ("b2",
                   (Pi (N, U, (Type (SId "s")),
                      (Binder ("A",
                         (Pi (N, U,
                            (Pi (R, U, (Id ("A", I)),
                               (Binder ("_", (Id ("proto", I)))))),
                            (Binder ("B",
                               (Pi (N, U,
                                  (BOpr ("=",
                                     (App
                                        [(Id ("xor", I)); (Id ("b1", I));
                                          (Id ("b2", I))]),
                                     (Id ("false", I)))),
                                  (Binder ("_",
                                     (Pi (R, U,
                                        (App
                                           [(Id ("ch", I)); (Id ("b1", I));
                                             (App
                                                [(Id ("act0", I));
                                                  (Id ("b2", I));
                                                  (Id ("B", I))])
                                             ]),
                                        (Binder ("_",
                                           (Pi (N, L, (Id ("A", I)),
                                              (Binder ("x",
                                                 (IO
                                                    (App
                                                       [(Id ("ch", I));
                                                         (Id ("b1", I));
                                                         (App
                                                            [(Id ("B", I));
                                                              (Id ("x", I))])
                                                         ]))
                                                 ))
                                              ))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))
                      ))
                   ))
                ))
             ))
          ))
       ));
    view = [I; I; I; I]};
  Extern {name = "send1"; relv = R;
    body =
    (Binder (["s"],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b1",
             (Pi (N, U, (Id ("bool", I)),
                (Binder ("b2",
                   (Pi (N, U, (Type (SId "s")),
                      (Binder ("A",
                         (Pi (N, U,
                            (Pi (R, U, (Id ("A", I)),
                               (Binder ("_", (Id ("proto", I)))))),
                            (Binder ("B",
                               (Pi (N, U,
                                  (BOpr ("=",
                                     (App
                                        [(Id ("xor", I)); (Id ("b1", I));
                                          (Id ("b2", I))]),
                                     (Id ("false", I)))),
                                  (Binder ("_",
                                     (Pi (R, U,
                                        (App
                                           [(Id ("ch", I)); (Id ("b1", I));
                                             (App
                                                [(Id ("act1", I));
                                                  (Id ("b2", I));
                                                  (Id ("B", I))])
                                             ]),
                                        (Binder ("_",
                                           (Pi (R, L, (Id ("A", I)),
                                              (Binder ("x",
                                                 (IO
                                                    (App
                                                       [(Id ("ch", I));
                                                         (Id ("b1", I));
                                                         (App
                                                            [(Id ("B", I));
                                                              (Id ("x", I))])
                                                         ]))
                                                 ))
                                              ))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))
                      ))
                   ))
                ))
             ))
          ))
       ));
    view = [I; I; I; I]};
  Extern {name = "recv0"; relv = R;
    body =
    (Binder (["s"],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b1",
             (Pi (N, U, (Id ("bool", I)),
                (Binder ("b2",
                   (Pi (N, U, (Type (SId "s")),
                      (Binder ("A",
                         (Pi (N, U,
                            (Pi (R, U, (Id ("A", I)),
                               (Binder ("_", (Id ("proto", I)))))),
                            (Binder ("B",
                               (Pi (N, U,
                                  (BOpr ("=",
                                     (App
                                        [(Id ("xor", I)); (Id ("b1", I));
                                          (Id ("b2", I))]),
                                     (Id ("true", I)))),
                                  (Binder ("_",
                                     (Pi (R, U,
                                        (App
                                           [(Id ("ch", I)); (Id ("b1", I));
                                             (App
                                                [(Id ("act0", I));
                                                  (Id ("b2", I));
                                                  (Id ("B", I))])
                                             ]),
                                        (Binder ("_",
                                           (IO
                                              (App
                                                 [(Id ("exists0", I));
                                                   (Fun (
                                                      (Pi (R, U,
                                                         (Id ("A", I)),
                                                         (Binder ("x", IMeta
                                                            ))
                                                         )),
                                                      (Binder (None,
                                                         [([(PId "x")],
                                                           (Some (App
                                                                    [(Id (
                                                                    "ch", I));
                                                                    (Id (
                                                                    "b1", I));
                                                                    (App
                                                                    [(Id (
                                                                    "B", I));
                                                                    (Id ("x",
                                                                    I))])])))
                                                           ]
                                                         )),
                                                      []))
                                                   ]))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))
                      ))
                   ))
                ))
             ))
          ))
       ));
    view = [I; I; I; I]};
  Extern {name = "recv1"; relv = R;
    body =
    (Binder (["s"],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b1",
             (Pi (N, U, (Id ("bool", I)),
                (Binder ("b2",
                   (Pi (N, U, (Type (SId "s")),
                      (Binder ("A",
                         (Pi (N, U,
                            (Pi (R, U, (Id ("A", I)),
                               (Binder ("_", (Id ("proto", I)))))),
                            (Binder ("B",
                               (Pi (N, U,
                                  (BOpr ("=",
                                     (App
                                        [(Id ("xor", I)); (Id ("b1", I));
                                          (Id ("b2", I))]),
                                     (Id ("true", I)))),
                                  (Binder ("_",
                                     (Pi (R, U,
                                        (App
                                           [(Id ("ch", I)); (Id ("b1", I));
                                             (App
                                                [(Id ("act1", I));
                                                  (Id ("b2", I));
                                                  (Id ("B", I))])
                                             ]),
                                        (Binder ("_",
                                           (IO
                                              (App
                                                 [(Id ("exists1", I));
                                                   (Fun (
                                                      (Pi (R, U,
                                                         (Id ("A", I)),
                                                         (Binder ("x", IMeta
                                                            ))
                                                         )),
                                                      (Binder (None,
                                                         [([(PId "x")],
                                                           (Some (App
                                                                    [(Id (
                                                                    "ch", I));
                                                                    (Id (
                                                                    "b1", I));
                                                                    (App
                                                                    [(Id (
                                                                    "B", I));
                                                                    (Id ("x",
                                                                    I))])])))
                                                           ]
                                                         )),
                                                      []))
                                                   ]))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))
                      ))
                   ))
                ))
             ))
          ))
       ));
    view = [I; I; I; I]};
  Extern {name = "fork"; relv = R;
    body =
    (Binder ([],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b",
             (Pi (N, U, (Id ("proto", I)),
                (Binder ("P",
                   (Pi (R, U,
                      (Pi (R, L,
                         (App [(Id ("ch", I)); (Id ("b", I)); (Id ("P", I))]),
                         (Binder ("_", (IO (Id ("unit", I))))))),
                      (Binder ("_",
                         (IO
                            (App
                               [(Id ("ch", I));
                                 (App [(Id ("not", I)); (Id ("b", I))]);
                                 (Id ("P", I))]))
                         ))
                      ))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "split"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("_",
                 (BOpr ("**",
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))]),
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))])
                    ))
                 ))
              )),
           (Binder ((Some "split"),
              [([(PId "nil")],
                (Some (App
                         [(Id ("ex1", I)); (Id ("nil", I)); (Id ("nil", I))])));
                ([(PBOpr ("::", (PId "x"), (PId "nil")))],
                 (Some (App
                          [(Id ("ex1", I));
                            (BOpr ("::", (Id ("x", I)), (Id ("nil", I))));
                            (Id ("nil", I))])));
                ([(PBOpr ("::", (PId "x"),
                     (PBOpr ("::", (PId "y"), (PId "zs")))))
                   ],
                 (Some (Match (
                          [(R, (App [(Id ("split", I)); (Id ("zs", I))]),
                            None)],
                          None,
                          [([(PConstr ("ex1", [(PId "xs"); (PId "ys")]))],
                            (Some (App
                                     [(Id ("ex1", I));
                                       (BOpr ("::", (Id ("x", I)),
                                          (Id ("xs", I))));
                                       (BOpr ("::", (Id ("y", I)),
                                          (Id ("ys", I))))
                                       ])))
                            ]
                          ))))
                ]
              )),
           [])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("_",
              (BOpr ("**",
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))]),
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))])
                 ))
              ))
           )))
       ));
    view = []};
  Definition {name = "merge"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("_",
                 (Pi (R, L,
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))]),
                    (Binder ("_",
                       (App
                          [(Inst ("list", [(SId "_"); (SId "t")], I));
                            (Id ("nat", I))])
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "merge"),
              [([(PId "nil"); (PId "ys")], (Some (Id ("ys", I))));
                ([(PId "xs"); (PId "nil")], (Some (Id ("xs", I))));
                ([(PBOpr ("::", (PId "x"), (PId "xs")));
                   (PBOpr ("::", (PId "y"), (PId "ys")))],
                 (Some (Match (
                          [(R, (BOpr ("<=", (Id ("x", I)), (Id ("y", I)))),
                            None)],
                          None,
                          [([(PId "true")],
                            (Some (BOpr ("::", (Id ("x", I)),
                                     (App
                                        [(Id ("merge", I)); (Id ("xs", I));
                                          (BOpr ("::", (Id ("y", I)),
                                             (Id ("ys", I))))
                                          ])
                                     ))));
                            ([(PId "false")],
                             (Some (BOpr ("::", (Id ("y", I)),
                                      (App
                                         [(Id ("merge", I));
                                           (BOpr ("::", (Id ("x", I)),
                                              (Id ("xs", I))));
                                           (Id ("ys", I))])
                                      ))))
                            ]
                          ))))
                ]
              )),
           [])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("_",
              (Pi (R, L,
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))]),
                 (Binder ("_",
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))])
                    ))
                 ))
              ))
           )))
       ));
    view = []};
  Definition {name = "msort"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("_",
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))])
                 ))
              )),
           (Binder ((Some "msort"),
              [([(PId "nil")], (Some (Id ("nil", I))));
                ([(PBOpr ("::", (PId "z"), (PId "nil")))],
                 (Some (BOpr ("::", (Id ("z", I)), (Id ("nil", I))))));
                ([(PId "zs")],
                 (Some (Let (R, (App [(Id ("split", I)); (Id ("zs", I))]),
                          (Binder (
                             (PConstr ("ex1", [(PId "xs"); (PId "ys")])),
                             (App
                                [(Id ("merge", I));
                                  (App [(Id ("msort", I)); (Id ("xs", I))]);
                                  (App [(Id ("msort", I)); (Id ("ys", I))])])
                             ))
                          ))))
                ]
              )),
           [])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("_",
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ])
              ))
           )))
       ));
    view = []};
  Definition {name = "cmsort_ch"; relv = N;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U,
              (App
                 [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))
                   ]),
              (Binder ("xs", (Type L))))),
           (Binder ((Some "cmsort_ch"),
              [([(PId "xs")],
                (Some (App
                         [(Id ("ch", I)); (Id ("true", I));
                           (App
                              [(Id ("act1", I)); (Id ("true", I));
                                (Fun (
                                   (Pi (R, U,
                                      (UOpr ("`",
                                         (App
                                            [(Id ("msort", I));
                                              (Id ("xs", I))])
                                         )),
                                      (Binder ("_", IMeta)))),
                                   (Binder (None,
                                      [([(PId "_")], (Some (Id ("endp", I))))
                                        ]
                                      )),
                                   []))
                                ])
                           ])))
                ]
              )),
           [E])),
        (Pi (R, U,
           (App [(Inst ("list", [(SId "_"); (SId "t")], I)); (Id ("nat", I))]),
           (Binder ("xs", (Type L))))))
       ));
    view = [E]};
  Definition {name = "cmsort_worker"; relv = R;
    body =
    (Binder (["t"],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("_",
                 (Pi (R, U,
                    (App
                       [(Inst ("list", [(SId "_"); (SId "t")], I));
                         (Id ("nat", I))]),
                    (Binder ("zs",
                       (Pi (R, L,
                          (App
                             [(Inst ("cmsort_ch", [(SId "t")], I));
                               (Id ("zs", I))]),
                          (Binder ("_", (IO (Id ("unit", I)))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "cmsort_worker"),
              [([(PId "zero"); (PId "zs"); (PId "c")],
                (Some (MLet (
                         (App
                            [(Id ("send1", I)); (Id ("refl", I));
                              (Id ("c", I));
                              (App
                                 [(Id ("just", I));
                                   (App [(Id ("msort", I)); (Id ("zs", I))])])
                              ]),
                         (Binder ((PId "c"),
                            (App [(Id ("close", I)); (Id ("c", I))])))
                         ))));
                ([(PConstr ("succ", [(PId "n")])); (PId "nil"); (PId "c")],
                 (Some (MLet (
                          (App
                             [(Id ("send1", I)); (Id ("refl", I));
                               (Id ("c", I));
                               (App [(Id ("just", I)); (Id ("nil", I))])]),
                          (Binder ((PId "c"),
                             (App [(Id ("close", I)); (Id ("c", I))])))
                          ))));
                ([(PConstr ("succ", [(PId "n")]));
                   (PBOpr ("::", (PId "z"), (PId "nil"))); (PId "c")],
                 (Some (MLet (
                          (App
                             [(Id ("send1", I)); (Id ("refl", I));
                               (Id ("c", I));
                               (App
                                  [(Id ("just", I));
                                    (BOpr ("::", (Id ("z", I)),
                                       (Id ("nil", I))))
                                    ])
                               ]),
                          (Binder ((PId "c"),
                             (App [(Id ("close", I)); (Id ("c", I))])))
                          ))));
                ([(PConstr ("succ", [(PId "n")])); (PId "zs"); (PId "c")],
                 (Some (Match (
                          [(R, (App [(Id ("split", I)); (Id ("zs", I))]),
                            (Some ("h1", IMeta)));
                            (N, (Id ("refl", I)),
                             (Some ("_",
                                    (BOpr ("=",
                                       (Match ([(R, (Id ("h1", I)), None)],
                                          None,
                                          [([(PConstr ("ex1",
                                                [(PId "xs"); (PId "ys")]))
                                              ],
                                            (Some (App
                                                     [(Id ("merge", I));
                                                       (App
                                                          [(Id ("msort", I));
                                                            (Id ("xs", I))]);
                                                       (App
                                                          [(Id ("msort", I));
                                                            (Id ("ys", I))])
                                                       ])))
                                            ]
                                          )),
                                       (Match (
                                          [(R,
                                            (App
                                               [(Id ("split", I));
                                                 (Id ("zs", I))]),
                                            None)],
                                          None,
                                          [([(PConstr ("ex1",
                                                [(PId "xs"); (PId "ys")]))
                                              ],
                                            (Some (App
                                                     [(Id ("merge", I));
                                                       (App
                                                          [(Id ("msort", I));
                                                            (Id ("xs", I))]);
                                                       (App
                                                          [(Id ("msort", I));
                                                            (Id ("ys", I))])
                                                       ])))
                                            ]
                                          ))
                                       )))))
                            ],
                          None,
                          [([(PConstr ("ex1", [(PId "xs0"); (PId "ys0")]));
                              (PId "pf")],
                            (Some (MLet (
                                     (App
                                        [(Id ("fork", I)); IMeta;
                                          (Fun (
                                             (Pi (R, L, IMeta,
                                                (Binder ("c1", IMeta)))),
                                             (Binder (None,
                                                [([(PId "c1")],
                                                  (Some (App
                                                           [(Id (
                                                               "cmsort_worker",
                                                               I));
                                                             (Id ("n", I));
                                                             (Id ("xs0", I));
                                                             (Id ("c1", I))])))
                                                  ]
                                                )),
                                             []))
                                          ]),
                                     (Binder ((PId "r1"),
                                        (MLet (
                                           (App
                                              [(Id ("fork", I)); IMeta;
                                                (Fun (
                                                   (Pi (R, L, IMeta,
                                                      (Binder ("c2", IMeta))
                                                      )),
                                                   (Binder (None,
                                                      [([(PId "c2")],
                                                        (Some (App
                                                                 [(Id (
                                                                    "cmsort_worker",
                                                                    I));
                                                                   (Id ("n",
                                                                    I));
                                                                   (Id (
                                                                    "ys0", I
                                                                    ));
                                                                   (Id ("c2",
                                                                    I))
                                                                   ])))
                                                        ]
                                                      )),
                                                   []))
                                                ]),
                                           (Binder ((PId "r2"),
                                              (MLet (
                                                 (App
                                                    [(Id ("recv1", I));
                                                      (Id ("refl", I));
                                                      (Id ("r1", I))]),
                                                 (Binder (
                                                    (PConstr ("ex1",
                                                       [(PId "xs1");
                                                         (PId "c1")]
                                                       )),
                                                    (MLet (
                                                       (App
                                                          [(Id ("recv1", I));
                                                            (Id ("refl", I));
                                                            (Id ("r2", I))]),
                                                       (Binder (
                                                          (PConstr ("ex1",
                                                             [(PId "ys1");
                                                               (PId "c2")]
                                                             )),
                                                          (Match (
                                                             [(R,
                                                               (Id ("xs1", I
                                                                  )),
                                                               None);
                                                               (R,
                                                                (Id ("ys1", I
                                                                   )),
                                                                None)
                                                               ],
                                                             None,
                                                             [([(PConstr (
                                                                   "just",
                                                                   [(PId
                                                                    "xs1")]
                                                                   ));
                                                                 (PConstr (
                                                                    "just",
                                                                    [(PId
                                                                    "ys1")]))
                                                                 ],
                                                               (Some (
                                                               Let (R,
                                                                 (Ann (
                                                                    (
                                                                    App
                                                                    [(Id (
                                                                    "just", I
                                                                    ));
                                                                    (App
                                                                    [(Id (
                                                                    "merge",
                                                                    I));
                                                                    (Id (
                                                                    "xs1", I
                                                                    ));
                                                                    (Id (
                                                                    "ys1", I
                                                                    ))])]),
                                                                    (
                                                                    UOpr (
                                                                    "`",
                                                                    (App
                                                                    [(Id (
                                                                    "merge",
                                                                    I));
                                                                    (App
                                                                    [(Id (
                                                                    "msort",
                                                                    I));
                                                                    (Id (
                                                                    "xs0", I
                                                                    ))]);
                                                                    (App
                                                                    [(Id (
                                                                    "msort",
                                                                    I));
                                                                    (Id (
                                                                    "ys0", I
                                                                    ))])])))
                                                                    )),
                                                                 (Binder (
                                                                    (
                                                                    PId "zs1"),
                                                                    (
                                                                    Let (R,
                                                                    (Ann (
                                                                    (App
                                                                    [(Id (
                                                                    "rwl", I
                                                                    ));
                                                                    (Fun (
                                                                    (Pi (R,
                                                                    U, IMeta,
                                                                    (Binder (
                                                                    "x",
                                                                    IMeta)))),
                                                                    (Binder (
                                                                    None,
                                                                    [([(PId
                                                                    "x")],
                                                                    (Some (
                                                                    UOpr (
                                                                    "`",
                                                                    (Id ("x",
                                                                    I))))))]
                                                                    )), 
                                                                    []));
                                                                    (Id (
                                                                    "pf", I));
                                                                    (Id (
                                                                    "zs1", I
                                                                    ))]),
                                                                    (UOpr (
                                                                    "`",
                                                                    (App
                                                                    [(Id (
                                                                    "msort",
                                                                    I));
                                                                    (Id (
                                                                    "zs", I))
                                                                    ]))))),
                                                                    (Binder (
                                                                    (PId
                                                                    "zs1"),
                                                                    (MLet (
                                                                    (App
                                                                    [(Id (
                                                                    "send1",
                                                                    I));
                                                                    (Id (
                                                                    "refl", I
                                                                    ));
                                                                    (Id ("c",
                                                                    I));
                                                                    (Id (
                                                                    "zs1", I
                                                                    ))]),
                                                                    (Binder (
                                                                    (PId "c"),
                                                                    (MLet (
                                                                    (App
                                                                    [(Id (
                                                                    "close",
                                                                    I));
                                                                    (Id (
                                                                    "c1", I))
                                                                    ]),
                                                                    (Binder (
                                                                    (PId "_"),
                                                                    (MLet (
                                                                    (App
                                                                    [(Id (
                                                                    "close",
                                                                    I));
                                                                    (Id (
                                                                    "c2", I))
                                                                    ]),
                                                                    (Binder (
                                                                    (PId "_"),
                                                                    (MLet (
                                                                    (App
                                                                    [(Id (
                                                                    "close",
                                                                    I));
                                                                    (Id ("c",
                                                                    I))]),
                                                                    (Binder (
                                                                    (PId "_"),
                                                                    (Return
                                                                    (Id (
                                                                    "tt", I)))
                                                                    ))))))))
                                                                    ))))))))
                                                                    ))))))
                                                                 ))))
                                                               ]
                                                             ))
                                                          ))
                                                       ))
                                                    ))
                                                 ))
                                              ))
                                           ))
                                        ))
                                     ))))
                            ]
                          ))))
                ]
              )),
           [])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("_",
              (Pi (R, U,
                 (App
                    [(Inst ("list", [(SId "_"); (SId "t")], I));
                      (Id ("nat", I))]),
                 (Binder ("zs",
                    (Pi (R, L,
                       (App
                          [(Inst ("cmsort_ch", [(SId "t")], I));
                            (Id ("zs", I))]),
                       (Binder ("_", (IO (Id ("unit", I)))))))
                    ))
                 ))
              ))
           )))
       ));
    view = []}
  ]

-----------------------------------------

#[logical]
inductive eq_1‹s_383› (A_384 : Type‹s_383›) (m_385 : A_384):
  A_384 -> U
where
| refl_1 : (eq_1‹??_1› ?_1[0;0] m_385 m_385)

#[program]
def rwl_1‹s_387,r_388› :
  ∀ {A_389 : Type‹s_387›} ->
    ∀ {m_390 : A_389} ->
      ∀ {n_391 : A_389} ->
        ∀ {B_392 : A_389 -> Type‹r_388›} ->
          {(eq_1‹??_3› ?_3[0;0] m_390 n_391)} ->
            ((B_392) m_390) -> ((B_392) n_391)
:=
  function rwl_396 :
    ∀ {A_397 : Type‹s_387›} ->
      ∀ {m_398 : A_397} ->
        ∀ {n_399 : A_397} ->
          ∀ {B_400 : A_397 -> Type‹r_388›} ->
            {(eq_1‹??_2› ?_2[0;0] m_398 n_399)} ->
              ((B_400) m_398) -> ((B_400) n_399)
  | A_404 m_405 n_406 B_407 refl_1 x_408 => x_408

#[program]
def rwr_2‹s_409,r_410› :
  ∀ {A_411 : Type‹s_409›} ->
    ∀ {m_412 : A_411} ->
      ∀ {n_413 : A_411} ->
        ∀ {B_414 : A_411 -> Type‹r_410›} ->
          {(eq_1‹??_5› ?_5[0;0] m_412 n_413)} ->
            ((B_414) n_413) -> ((B_414) m_412)
:=
  function rwr_418 :
    ∀ {A_419 : Type‹s_409›} ->
      ∀ {m_420 : A_419} ->
        ∀ {n_421 : A_419} ->
          ∀ {B_422 : A_419 -> Type‹r_410›} ->
            {(eq_1‹??_4› ?_4[0;0] m_420 n_421)} ->
              ((B_422) n_421) -> ((B_422) m_420)
  | A_426 m_427 n_428 B_429 refl_1 x_430 => x_430

#[program]
inductive sing_2‹s_431› (A_432 : Type‹s_431›):
  A_432 -> Type‹s_431›
where
| just_2 (m_434 : A_432) : (sing_2‹??_6› ?_6[0;0] m_434)

#[program]
inductive unit_3‹› : U where
| tt_3 : unit_3

#[program]
inductive bool_4‹› : U where
| true_4 : bool_4
| false_5 : bool_4

#[program]
inductive nat_5‹› : U where
| zero_6 : nat_5
| succ_7 (n_435 : nat_5) : nat_5

#[program]
inductive list_6‹s_436,t_437› (A_438 : Type‹s_436›): Type‹t_437›
where
| nil_8 : (list_6‹??_7,??_8› A_438)
| cons_9
    (hd_439 : A_438) (tl_440 : (list_6‹??_9,t_437› A_438))
    : (list_6‹??_10,??_11› A_438)

#[program]
inductive exists0_7‹s_441,r_442› (A_443 : Type‹s_441›) (B_444 : 
A_443 -> Type‹r_442›): L where
| ex0_10
    {m_446 : A_443} (n_447 : ((B_444) m_446))
    : (exists0_7‹??_12,??_13› A_443 B_444)

#[program]
inductive exists1_8‹s_448,r_449› (A_450 : Type‹s_448›) (B_451 : 
A_450 -> Type‹r_449›): L where
| ex1_11
    (m_453 : A_450) (n_454 : ((B_451) m_453))
    : (exists1_8‹??_14,??_15› A_450 B_451)

#[logical]
def prod0_3‹s_455,r_456› :
  Type‹s_455› -> Type‹r_456› -> ?_10[0;0]
:=
  function prod0_459 : Type‹s_455› -> Type‹r_456› -> ?_7[0;0]
  | A_462 B_463 =>
    (exists0_7‹??_16,??_17›
      A_462 function _464 : ?_8[0;0] -> ?_9[0;0]
            | _466 => B_463)

#[logical]
def prod1_4‹s_467,r_468› :
  Type‹s_467› -> Type‹r_468› -> ?_14[0;0]
:=
  function prod1_471 : Type‹s_467› -> Type‹r_468› -> ?_11[0;0]
  | A_474 B_475 =>
    (exists1_8‹??_18,??_19›
      A_474 function _476 : ?_12[0;0] -> ?_13[0;0]
            | _478 => B_475)

#[program]
def not_5‹› : bool_4 -> bool_4 :=
  function not_480 : bool_4 -> bool_4
  | true_4 => false_5
  | false_5 => true_4

#[program]
def and_6‹› : bool_4 -> bool_4 -> bool_4 :=
  function and_484 : bool_4 -> bool_4 -> bool_4
  | true_4 true_4 => true_4
  | _487 _488 => false_5

#[program]
def or_7‹› : bool_4 -> bool_4 -> bool_4 :=
  function or_491 : bool_4 -> bool_4 -> bool_4
  | false_5 false_5 => false_5
  | _494 _495 => true_4

#[program]
def xor_8‹› : bool_4 -> bool_4 -o bool_4 :=
  function xor_498 : bool_4 -> bool_4 -o bool_4
  | true_4 true_4 => false_5
  | false_5 false_5 => false_5
  | _501 _502 => true_4

#[program]
def lte_9‹› : nat_5 -> nat_5 -> bool_4 :=
  function lte_505 : nat_5 -> nat_5 -> bool_4
  | zero_6 _508 => true_4
  | _509 zero_6 => false_5
  | (succ_7 x_510) (succ_7 y_511) => ((lte_505) x_510 y_511)

#[program]
def lt_10‹› : nat_5 -> nat_5 -> bool_4 :=
  function lt_514 : nat_5 -> nat_5 -> bool_4
  | x_517 y_518 => ((lte_9) (succ_7‹› x_517) y_518)

#[program]
def pred_11‹› : nat_5 -> nat_5 :=
  function pred_520 : nat_5 -> nat_5
  | zero_6 => zero_6
  | (succ_7 x_522) => x_522

#[program]
def add_12‹› : nat_5 -> nat_5 -> nat_5 :=
  function add_525 : nat_5 -> nat_5 -> nat_5
  | zero_6 y_528 => y_528
  | (succ_7 x_529) y_530 => (succ_7‹› ((add_525) x_529 y_530))

#[program]
def sub_13‹› : nat_5 -> nat_5 -> nat_5 :=
  function sub_533 : nat_5 -> nat_5 -> nat_5
  | x_536 zero_6 => x_536
  | x_537 (succ_7 y_538) => ((sub_533) ((pred_11) x_537) y_538)

#[program]
def mul_14‹› : nat_5 -> nat_5 -> nat_5 :=
  function mul_541 : nat_5 -> nat_5 -> nat_5
  | zero_6 _544 => zero_6
  | (succ_7 x_545) y_546 => ((add_12) y_546 ((mul_541) x_545 y_546))

#[program]
def div_15‹› : nat_5 -> nat_5 -> ?_18[0;0] :=
  function div_549 : nat_5 -> nat_5 -> ?_15[0;0]
  | x_552 y_553 =>
    match ((lt_10) x_552 y_553) in ?_16[0;0] -o ?_17[0;0] with
    | true_4 => zero_6
    | false_5 => (succ_7‹› ((div_549) ((sub_13) x_552 y_553) y_553))

#[program]
def rem_16‹› : nat_5 -> nat_5 -> ?_20[0;0] :=
  function rem_557 : nat_5 -> nat_5 -> ?_19[0;0]
  | x_560 y_561 => ((sub_13) x_560 ((mul_14) ((div_15) x_560 y_561) y_561))

#[program]
def pow_17‹› : nat_5 -> nat_5 -> nat_5 :=
  function pow_564 : nat_5 -> nat_5 -> nat_5
  | _567 zero_6 => (succ_7‹› zero_6)
  | x_568 (succ_7 y_569) => ((mul_14) x_568 ((pow_564) x_568 y_569))

#[logical]
extern proto_18‹› : U

#[logical]
extern act0_19‹s_570› :
  bool_4 -> ∀ (A_572 : Type‹s_570›) -> A_572 -> proto_18 -> proto_18

#[logical]
extern act1_20‹s_575› :
  bool_4 -> ∀ (A_577 : Type‹s_575›) -> A_577 -> proto_18 -> proto_18

#[logical]
extern endp_21‹› : proto_18

#[logical]
extern ch_22‹› : bool_4 -> proto_18 -> L

#[program]
extern close_23‹› :
  ∀ {b_582 : bool_4} -> ((ch_22) b_582 endp_21) -> IO unit_3

#[program]
extern send0_24‹s_584› :
  ∀ {b1_585 : bool_4} ->
    ∀ {b2_586 : bool_4} ->
      ∀ {A_587 : Type‹s_584›} ->
        ∀ {B_588 : A_587 -> proto_18} ->
          {(eq_1‹??_20› ?_21[0;0] ((xor_8) b1_585 b2_586) false_5)} ->
            ((ch_22) b1_585 ((act0_19‹??_21›) b2_586 ?_22[0;0] B_588)) ->
              ∀ {x_592 : A_587} -o IO ((ch_22) b1_585 ((B_588) x_592))

#[program]
extern send1_25‹s_593› :
  ∀ {b1_594 : bool_4} ->
    ∀ {b2_595 : bool_4} ->
      ∀ {A_596 : Type‹s_593›} ->
        ∀ {B_597 : A_596 -> proto_18} ->
          {(eq_1‹??_22› ?_23[0;0] ((xor_8) b1_594 b2_595) false_5)} ->
            ((ch_22) b1_594 ((act1_20‹??_23›) b2_595 ?_24[0;0] B_597)) ->
              ∀ (x_601 : A_596) -o IO ((ch_22) b1_594 ((B_597) x_601))

#[program]
extern recv0_26‹s_602› :
  ∀ {b1_603 : bool_4} ->
    ∀ {b2_604 : bool_4} ->
      ∀ {A_605 : Type‹s_602›} ->
        ∀ {B_606 : A_605 -> proto_18} ->
          {(eq_1‹??_24› ?_25[0;0] ((xor_8) b1_603 b2_604) true_4)} ->
            ((ch_22) b1_603 ((act0_19‹??_25›) b2_604 ?_26[0;0] B_606)) ->
              IO (exists0_7‹??_26,??_27›
                   ?_28[0;0]
                   function _610 : A_605 -> ?_27[0;0]
                   | x_612 => ((ch_22) b1_603 ((B_606) x_612)))

#[program]
extern recv1_27‹s_613› :
  ∀ {b1_614 : bool_4} ->
    ∀ {b2_615 : bool_4} ->
      ∀ {A_616 : Type‹s_613›} ->
        ∀ {B_617 : A_616 -> proto_18} ->
          {(eq_1‹??_28› ?_29[0;0] ((xor_8) b1_614 b2_615) true_4)} ->
            ((ch_22) b1_614 ((act1_20‹??_29›) b2_615 ?_30[0;0] B_617)) ->
              IO (exists1_8‹??_30,??_31›
                   ?_32[0;0]
                   function _621 : A_616 -> ?_31[0;0]
                   | x_623 => ((ch_22) b1_614 ((B_617) x_623)))

#[program]
extern fork_28‹› :
  ∀ {b_624 : bool_4} ->
    ∀ {P_625 : proto_18} ->
      ((ch_22) b_624 P_625) -o IO unit_3 ->
        IO ((ch_22) ((not_5) b_624) P_625)

#[program]
def split_29‹t_628› :
  (list_6‹??_57,t_628› nat_5) ->
    ((prod1_4‹??_60,??_61›)
      (list_6‹??_58,t_628› nat_5) (list_6‹??_59,t_628› nat_5))
:=
  function split_630 :
    (list_6‹??_32,t_628› nat_5) ->
      ((prod1_4‹??_35,??_36›)
        (list_6‹??_33,t_628› nat_5) (list_6‹??_34,t_628› nat_5))
  | nil_8 =>
    (ex1_11‹??_41,??_42›
      ?_35[0;0] ?_36[0;0] (nil_8‹??_37,??_38› ?_33[0;0])
      (nil_8‹??_39,??_40› ?_34[0;0]))
  | (cons_9 x_632 nil_8) =>
    (ex1_11‹??_49,??_50›
      ?_40[0;0] ?_41[0;0]
      (cons_9‹??_45,??_46›
        ?_38[0;0] x_632 (nil_8‹??_43,??_44› ?_37[0;0]))
      (nil_8‹??_47,??_48› ?_39[0;0]))
  | (cons_9 x_633 (cons_9 y_634 zs_635)) =>
    match ((split_630) zs_635) in ?_42[0;0] -o ?_43[0;0] with
    | (ex1_11 xs_637 ys_638) =>
      (ex1_11‹??_55,??_56›
        ?_46[0;0] ?_47[0;0] (cons_9‹??_51,??_52› ?_44[0;0] x_633 xs_637)
        (cons_9‹??_53,??_54› ?_45[0;0] y_634 ys_638))

#[program]
def merge_30‹t_639› :
  (list_6‹??_73,t_639› nat_5) ->
    (list_6‹??_74,t_639› nat_5) -o (list_6‹??_75,t_639› nat_5)
:=
  function merge_642 :
    (list_6‹??_62,t_639› nat_5) ->
      (list_6‹??_63,t_639› nat_5) -o (list_6‹??_64,t_639› nat_5)
  | nil_8 ys_645 => ys_645
  | xs_646 nil_8 => xs_646
  | (cons_9 x_647 xs_648) (cons_9 y_649 ys_650) =>
    match ((lte_9) x_647 y_649) in ?_48[0;0] -o ?_49[0;0] with
    | true_4 =>
      (cons_9‹??_67,??_68›
        ?_51[0;0] x_647
        ((merge_642) xs_648 (cons_9‹??_65,??_66› ?_50[0;0] y_649 ys_650)))
    | false_5 =>
      (cons_9‹??_71,??_72›
        ?_53[0;0] y_649
        ((merge_642) (cons_9‹??_69,??_70› ?_52[0;0] x_647 xs_648) ys_650))

#[program]
def msort_31‹t_652› :
  (list_6‹??_86,t_652› nat_5) -> (list_6‹??_87,t_652› nat_5)
:=
  function msort_654 :
    (list_6‹??_76,t_652› nat_5) -> (list_6‹??_77,t_652› nat_5)
  | nil_8 => (nil_8‹??_78,??_79› ?_54[0;0])
  | (cons_9 z_656 nil_8) =>
    (cons_9‹??_82,??_83›
      ?_56[0;0] z_656 (nil_8‹??_80,??_81› ?_55[0;0]))
  | zs_657 =>
    let _658 := ((split_29‹??_84›) zs_657) in
    match _658 in ?_58[0;0] -o ?_57[0;0] with
    | (ex1_11 xs_660 ys_661) =>
      ((merge_30‹??_85›) ((msort_654) xs_660) ((msort_654) ys_661))

#[logical]
def cmsort_ch_32‹t_662› : (list_6‹??_92,t_662› nat_5) -> L :=
  function cmsort_ch_664 : (list_6‹??_88,t_662› nat_5) -> L
  | xs_666 =>
    ((ch_22)
      true_4
      ((act1_20‹??_91›)
        true_4 ?_61[0;0]
        function _667 :
          (sing_2‹??_90› ?_59[0;0] ((msort_31‹??_89›) xs_666)) ->
            ?_60[0;0]
        | _669 => endp_21))

#[program]
def cmsort_worker_33‹t_670› :
  nat_5 ->
    ∀ (zs_672 : (list_6‹??_137,t_670› nat_5)) ->
      ((cmsort_ch_32‹t_670›) zs_672) -o IO unit_3
:=
  function cmsort_worker_674 :
    nat_5 ->
      ∀ (zs_676 : (list_6‹??_93,t_670› nat_5)) ->
        ((cmsort_ch_32‹t_670›) zs_676) -o IO unit_3
  | zero_6 zs_678 c_679 =>
    let* c_680 :=
      ((send1_25‹??_97›)
        ?_68[0;0] ?_67[0;0] ?_66[0;0] ?_65[0;0]
        (refl_1‹??_94› ?_62[0;0] ?_63[0;0]) c_679
        (just_2‹??_96› ?_64[0;0] ((msort_31‹??_95›) zs_678)))
    in ((close_23) ?_69[0;0] c_680)
  | (succ_7 n_681) nil_8 c_682 =>
    let* c_683 :=
      ((send1_25‹??_102›)
        ?_77[0;0] ?_76[0;0] ?_75[0;0] ?_74[0;0]
        (refl_1‹??_98› ?_70[0;0] ?_71[0;0]) c_682
        (just_2‹??_101› ?_73[0;0] (nil_8‹??_99,??_100› ?_72[0;0])))
    in ((close_23) ?_78[0;0] c_683)
  | (succ_7 n_684) (cons_9 z_685 nil_8) c_686 =>
    let* c_687 :=
      ((send1_25‹??_109›)
        ?_87[0;0] ?_86[0;0] ?_85[0;0] ?_84[0;0]
        (refl_1‹??_103› ?_79[0;0] ?_80[0;0]) c_686
        (just_2‹??_108›
          ?_83[0;0]
          (cons_9‹??_106,??_107›
            ?_82[0;0] z_685 (nil_8‹??_104,??_105› ?_81[0;0]))))
    in ((close_23) ?_88[0;0] c_687)
  | (succ_7 n_688) zs_689 c_690 =>
    match ((split_29‹??_110›) zs_689),
    (refl_1‹??_111› ?_89[0;0] ?_90[0;0]) in
      ∀ (h1_691 : ?_91[0;0]) -o
        {(eq_1‹??_119›
           ?_96[0;0]
           match h1_691 in ?_92[0;0] -o ?_93[0;0] with
           | (ex1_11 xs_694 ys_695) =>
             ((merge_30‹??_114›)
               ((msort_31‹??_112›) xs_694)
               ((msort_31‹??_113›) ys_695))
           match ((split_29‹??_115›) zs_689) in ?_94[0;0] -o ?_95[0;0]
           with
           | (ex1_11 xs_697 ys_698) =>
             ((merge_30‹??_118›)
               ((msort_31‹??_116›) xs_697)
               ((msort_31‹??_117›) ys_698)))} -o
          ?_97[0;0]
    with
    | (ex1_11 xs0_699 ys0_700), pf_701 =>
      let* r1_702 :=
        ((fork_28)
          ?_101[0;0] ?_98[0;0]
          function _703 : ?_99[0;0] -o ?_100[0;0]
          | c1_705 => ((cmsort_worker_674) n_688 xs0_699 c1_705))
      in
      let* r2_706 :=
        ((fork_28)
          ?_105[0;0] ?_102[0;0]
          function _707 : ?_103[0;0] -o ?_104[0;0]
          | c2_709 => ((cmsort_worker_674) n_688 ys0_700 c2_709))
      in
      let* _710 :=
        ((recv1_27‹??_121›)
          ?_111[0;0] ?_110[0;0] ?_109[0;0] ?_108[0;0]
          (refl_1‹??_120› ?_106[0;0] ?_107[0;0]) r1_702)
      in
      match _710 in ?_142[0;0] -o ?_141[0;0] with
      | (ex1_11 xs1_712 c1_713) =>
        let* _714 :=
          ((recv1_27‹??_123›)
            ?_117[0;0] ?_116[0;0] ?_115[0;0] ?_114[0;0]
            (refl_1‹??_122› ?_112[0;0] ?_113[0;0]) r2_706)
        in
        match _714 in ?_140[0;0] -o ?_139[0;0] with
        | (ex1_11 ys1_716 c2_717) =>
          match xs1_712, ys1_716 in ?_118[0;0] -o ?_119[0;0] -o ?_120[0;0]
          with
          | (just_2 xs1_720), (just_2 ys1_721) =>
            let zs1_722 :=
              ((just_2‹??_125›
                 ?_121[0;0] ((merge_30‹??_124›) xs1_720 ys1_721))
                : (sing_2‹??_129›
                    ?_122[0;0]
                    ((merge_30‹??_128›)
                      ((msort_31‹??_126›) xs0_699)
                      ((msort_31‹??_127›) ys0_700))))
            in
            let zs1_723 :=
              (((rwl_1‹??_131,??_132›)
                 ?_128[0;0] ?_127[0;0] ?_126[0;0]
                 function _724 : ?_123[0;0] -> ?_124[0;0]
                 | x_726 => (sing_2‹??_130› ?_125[0;0] x_726) pf_701
                 zs1_722)
                : (sing_2‹??_134›
                    ?_129[0;0] ((msort_31‹??_133›) zs_689)))
            in
            let* c_727 :=
              ((send1_25‹??_136›)
                ?_135[0;0] ?_134[0;0] ?_133[0;0] ?_132[0;0]
                (refl_1‹??_135› ?_130[0;0] ?_131[0;0]) c_690 zs1_723)
            in
            let* __728 := ((close_23) ?_136[0;0] c1_713) in
            let* __729 := ((close_23) ?_137[0;0] c2_717) in
            let* __730 := ((close_23) ?_138[0;0] c_727) in return tt_3

-----------------------------------------

#[logical]
inductive eq_1‹s_19260› (A_19261 : Type‹s_19260›) (m_19262 : A_19261):
  A_19261 -> U
where
| refl_1 : (eq_1‹s_19260› A_19261 m_19262 m_19262)

#[program]
def rwl_1‹s_19264,r_19265› :
  ∀ {A_19266 : Type‹s_19264›} ->
    ∀ {m_19267 : A_19266} ->
      ∀ {n_19268 : A_19266} ->
        ∀ {B_19269 : A_19266 -> Type‹r_19265›} ->
          {(eq_1‹s_19264› A_19266 m_19267 n_19268)} ->
            ((B_19269) m_19267) -> ((B_19269) n_19268)
:=
  function rwl_19273 :
    ∀ {A_19274 : Type‹s_19264›} ->
      ∀ {m_19275 : A_19274} ->
        ∀ {n_19276 : A_19274} ->
          ∀ {B_19277 : A_19274 -> Type‹r_19265›} ->
            {(eq_1‹s_19264› A_19274 m_19275 n_19276)} ->
              ((B_19277) m_19275) -> ((B_19277) n_19276)
  | A_19281 m_19282 n_19283 B_19284 refl_1 __19285 => __19285

#[program]
def rwr_2‹s_19286,r_19287› :
  ∀ {A_19288 : Type‹s_19286›} ->
    ∀ {m_19289 : A_19288} ->
      ∀ {n_19290 : A_19288} ->
        ∀ {B_19291 : A_19288 -> Type‹r_19287›} ->
          {(eq_1‹s_19286› A_19288 m_19289 n_19290)} ->
            ((B_19291) n_19290) -> ((B_19291) m_19289)
:=
  function rwr_19295 :
    ∀ {A_19296 : Type‹s_19286›} ->
      ∀ {m_19297 : A_19296} ->
        ∀ {n_19298 : A_19296} ->
          ∀ {B_19299 : A_19296 -> Type‹r_19287›} ->
            {(eq_1‹s_19286› A_19296 m_19297 n_19298)} ->
              ((B_19299) n_19298) -> ((B_19299) m_19297)
  | A_19303 m_19304 n_19305 B_19306 refl_1 __19307 => __19307

#[program]
inductive sing_2‹s_19308› (A_19309 : Type‹s_19308›):
  A_19309 -> Type‹s_19308›
where
| just_2 (m_19311 : A_19309) : (sing_2‹s_19308› A_19309 m_19311)

#[program]
inductive unit_3‹› : U where
| tt_3 : unit_3

#[program]
inductive bool_4‹› : U where
| true_4 : bool_4
| false_5 : bool_4

#[program]
inductive nat_5‹› : U where
| zero_6 : nat_5
| succ_7 (n_19312 : nat_5) : nat_5

#[program]
inductive list_6‹s_19313,t_19314› (A_19315 : Type‹s_19313›):
  Type‹t_19314›
where
| nil_8 : (list_6‹s_19313,t_19314› A_19315)
| cons_9
    (hd_19316 : A_19315) (tl_19317 : (list_6‹s_19313,t_19314› A_19315))
    : (list_6‹s_19313,t_19314› A_19315)

#[program]
inductive exists0_7‹s_19318,r_19319› (A_19320 : Type‹s_19318›) (B_19321 : 
A_19320 -> Type‹r_19319›): L where
| ex0_10
    {m_19323 : A_19320} (n_19324 : ((B_19321) m_19323))
    : (exists0_7‹s_19318,r_19319› A_19320 B_19321)

#[program]
inductive exists1_8‹s_19325,r_19326› (A_19327 : Type‹s_19325›) (B_19328 : 
A_19327 -> Type‹r_19326›): L where
| ex1_11
    (m_19330 : A_19327) (n_19331 : ((B_19328) m_19330))
    : (exists1_8‹s_19325,r_19326› A_19327 B_19328)

#[logical]
def prod0_3‹s_19332,r_19333› :
  Type‹s_19332› -> Type‹r_19333› -> L
:=
  function prod0_19336 : Type‹s_19332› -> Type‹r_19333› -> L
  | A_19339 B_19340 =>
    (exists0_7‹s_19332,r_19333›
      A_19339
      function _19341 : A_19339 -> Type‹r_19333›
      | __19343 => B_19340)

#[logical]
def prod1_4‹s_19344,r_19345› :
  Type‹s_19344› -> Type‹r_19345› -> L
:=
  function prod1_19348 : Type‹s_19344› -> Type‹r_19345› -> L
  | A_19351 B_19352 =>
    (exists1_8‹s_19344,r_19345›
      A_19351
      function _19353 : A_19351 -> Type‹r_19345›
      | __19355 => B_19352)

#[program]
def not_5‹› : bool_4 -> bool_4 :=
  function not_19357 : bool_4 -> bool_4
  | true_4 => false_5
  | false_5 => true_4

#[program]
def and_6‹› : bool_4 -> bool_4 -> bool_4 :=
  function and_19361 : bool_4 -> bool_4 -> bool_4
  | true_4 true_4 => true_4
  | true_4 false_5 => false_5
  | false_5 __19364 => false_5

#[program]
def or_7‹› : bool_4 -> bool_4 -> bool_4 :=
  function or_19367 : bool_4 -> bool_4 -> bool_4
  | true_4 __19370 => true_4
  | false_5 true_4 => true_4
  | false_5 false_5 => false_5

#[program]
def xor_8‹› : bool_4 -> bool_4 -o bool_4 :=
  function xor_19373 : bool_4 -> bool_4 -o bool_4
  | true_4 true_4 => false_5
  | true_4 false_5 => true_4
  | false_5 true_4 => true_4
  | false_5 false_5 => false_5

#[program]
def lte_9‹› : nat_5 -> nat_5 -> bool_4 :=
  function lte_19378 : nat_5 -> nat_5 -> bool_4
  | zero_6 __19381 => true_4
  | (succ_7 n_19382) zero_6 => false_5
  | (succ_7 n_19383) (succ_7 n_19384) => ((lte_19378) n_19383 n_19384)

#[program]
def lt_10‹› : nat_5 -> nat_5 -> bool_4 :=
  function lt_19387 : nat_5 -> nat_5 -> bool_4
  | x_19390 y_19391 => ((lte_9) (succ_7‹› x_19390) y_19391)

#[program]
def pred_11‹› : nat_5 -> nat_5 :=
  function pred_19393 : nat_5 -> nat_5
  | zero_6 => zero_6
  | (succ_7 n_19395) => n_19395

#[program]
def add_12‹› : nat_5 -> nat_5 -> nat_5 :=
  function add_19398 : nat_5 -> nat_5 -> nat_5
  | zero_6 __19401 => __19401
  | (succ_7 n_19402) __19403 => (succ_7‹› ((add_19398) n_19402 __19403))

#[program]
def sub_13‹› : nat_5 -> nat_5 -> nat_5 :=
  function sub_19406 : nat_5 -> nat_5 -> nat_5
  | __19409 zero_6 => __19409
  | __19410 (succ_7 n_19411) => ((sub_19406) ((pred_11) __19410) n_19411)

#[program]
def mul_14‹› : nat_5 -> nat_5 -> nat_5 :=
  function mul_19414 : nat_5 -> nat_5 -> nat_5
  | zero_6 __19417 => zero_6
  | (succ_7 n_19418) __19419 =>
    ((add_12) __19419 ((mul_19414) n_19418 __19419))

#[program]
def div_15‹› : nat_5 -> nat_5 -> nat_5 :=
  function div_19422 : nat_5 -> nat_5 -> nat_5
  | x_19425 y_19426 =>
    match ((lt_10) x_19425 y_19426) in bool_4 -o nat_5 with
    | true_4 => zero_6
    | false_5 =>
      (succ_7‹› ((div_19422) ((sub_13) x_19425 y_19426) y_19426))

#[program]
def rem_16‹› : nat_5 -> nat_5 -> nat_5 :=
  function rem_19430 : nat_5 -> nat_5 -> nat_5
  | x_19433 y_19434 =>
    ((sub_13) x_19433 ((mul_14) ((div_15) x_19433 y_19434) y_19434))

#[program]
def pow_17‹› : nat_5 -> nat_5 -> nat_5 :=
  function pow_19437 : nat_5 -> nat_5 -> nat_5
  | __19440 zero_6 => (succ_7‹› zero_6)
  | __19441 (succ_7 n_19442) =>
    ((mul_14) __19441 ((pow_19437) __19441 n_19442))

#[logical]
extern proto_18‹› : U

#[logical]
extern act0_19‹s_19443› :
  bool_4 ->
    ∀ (A_19445 : Type‹s_19443›) -> A_19445 -> proto_18 -> proto_18

#[logical]
extern act1_20‹s_19448› :
  bool_4 ->
    ∀ (A_19450 : Type‹s_19448›) -> A_19450 -> proto_18 -> proto_18

#[logical]
extern endp_21‹› : proto_18

#[logical]
extern ch_22‹› : bool_4 -> proto_18 -> L

#[program]
extern close_23‹› :
  ∀ {b_19455 : bool_4} -> ((ch_22) b_19455 endp_21) -> IO unit_3

#[program]
extern send0_24‹s_19457› :
  ∀ {b1_19458 : bool_4} ->
    ∀ {b2_19459 : bool_4} ->
      ∀ {A_19460 : Type‹s_19457›} ->
        ∀ {B_19461 : A_19460 -> proto_18} ->
          {(eq_1‹U› bool_4 ((xor_8) b1_19458 b2_19459) false_5)} ->
            ((ch_22)
              b1_19458 ((act0_19‹s_19457›) b2_19459 A_19460 B_19461)) ->
              ∀ {x_19465 : A_19460} -o
                IO ((ch_22) b1_19458 ((B_19461) x_19465))

#[program]
extern send1_25‹s_19466› :
  ∀ {b1_19467 : bool_4} ->
    ∀ {b2_19468 : bool_4} ->
      ∀ {A_19469 : Type‹s_19466›} ->
        ∀ {B_19470 : A_19469 -> proto_18} ->
          {(eq_1‹U› bool_4 ((xor_8) b1_19467 b2_19468) false_5)} ->
            ((ch_22)
              b1_19467 ((act1_20‹s_19466›) b2_19468 A_19469 B_19470)) ->
              ∀ (x_19474 : A_19469) -o
                IO ((ch_22) b1_19467 ((B_19470) x_19474))

#[program]
extern recv0_26‹s_19475› :
  ∀ {b1_19476 : bool_4} ->
    ∀ {b2_19477 : bool_4} ->
      ∀ {A_19478 : Type‹s_19475›} ->
        ∀ {B_19479 : A_19478 -> proto_18} ->
          {(eq_1‹U› bool_4 ((xor_8) b1_19476 b2_19477) true_4)} ->
            ((ch_22)
              b1_19476 ((act0_19‹s_19475›) b2_19477 A_19478 B_19479)) ->
              IO (exists0_7‹s_19475,L›
                   A_19478
                   function _19483 : A_19478 -> L
                   | __19485 => ((ch_22) b1_19476 ((B_19479) __19485)))

#[program]
extern recv1_27‹s_19486› :
  ∀ {b1_19487 : bool_4} ->
    ∀ {b2_19488 : bool_4} ->
      ∀ {A_19489 : Type‹s_19486›} ->
        ∀ {B_19490 : A_19489 -> proto_18} ->
          {(eq_1‹U› bool_4 ((xor_8) b1_19487 b2_19488) true_4)} ->
            ((ch_22)
              b1_19487 ((act1_20‹s_19486›) b2_19488 A_19489 B_19490)) ->
              IO (exists1_8‹s_19486,L›
                   A_19489
                   function _19494 : A_19489 -> L
                   | __19496 => ((ch_22) b1_19487 ((B_19490) __19496)))

#[program]
extern fork_28‹› :
  ∀ {b_19497 : bool_4} ->
    ∀ {P_19498 : proto_18} ->
      ((ch_22) b_19497 P_19498) -o IO unit_3 ->
        IO ((ch_22) ((not_5) b_19497) P_19498)

#[program]
def split_29‹t_19501› :
  (list_6‹U,t_19501› nat_5) ->
    ((prod1_4‹t_19501,t_19501›)
      (list_6‹U,t_19501› nat_5) (list_6‹U,t_19501› nat_5))
:=
  function split_19503 :
    (list_6‹U,t_19501› nat_5) ->
      ((prod1_4‹t_19501,t_19501›)
        (list_6‹U,t_19501› nat_5) (list_6‹U,t_19501› nat_5))
  | nil_8 =>
    (ex1_11‹t_19501,t_19501›
      (list_6‹U,t_19501› nat_5)
      function _19505 : (list_6‹U,t_19501› nat_5) -> Type‹t_19501›
      | __19507 => (list_6‹U,t_19501› nat_5) (nil_8‹U,t_19501› nat_5)
      (nil_8‹U,t_19501› nat_5))
  | (cons_9 hd_19508 nil_8) =>
    (ex1_11‹t_19501,t_19501›
      (list_6‹U,t_19501› nat_5)
      function _19509 : (list_6‹U,t_19501› nat_5) -> Type‹t_19501›
      | __19511 => (list_6‹U,t_19501› nat_5)
      (cons_9‹U,t_19501› nat_5 hd_19508 (nil_8‹U,t_19501› nat_5))
      (nil_8‹U,t_19501› nat_5))
  | (cons_9 hd_19512 (cons_9 hd_19513 tl_19514)) =>
    match ((split_19503) tl_19514) in
      ((prod1_4‹t_19501,t_19501›)
        (list_6‹U,t_19501› nat_5) (list_6‹U,t_19501› nat_5)) -o
        ((prod1_4‹t_19501,t_19501›)
          (list_6‹U,t_19501› nat_5) (list_6‹U,t_19501› nat_5))
    with
    | (ex1_11 m_19516 n_19517) =>
      (ex1_11‹t_19501,t_19501›
        (list_6‹U,t_19501› nat_5)
        function _19518 : (list_6‹U,t_19501› nat_5) -> Type‹t_19501›
        | __19520 => (list_6‹U,t_19501› nat_5)
        (cons_9‹U,t_19501› nat_5 hd_19512 m_19516)
        (cons_9‹U,t_19501› nat_5 hd_19513 n_19517))

#[program]
def merge_30‹t_19521› :
  (list_6‹U,t_19521› nat_5) ->
    (list_6‹U,t_19521› nat_5) -o (list_6‹U,t_19521› nat_5)
:=
  function merge_19524 :
    (list_6‹U,t_19521› nat_5) ->
      (list_6‹U,t_19521› nat_5) -o (list_6‹U,t_19521› nat_5)
  | nil_8 __19527 => __19527
  | (cons_9 hd_19528 tl_19529) nil_8 =>
    (cons_9‹U,t_19521› nat_5 hd_19528 tl_19529)
  | (cons_9 hd_19530 tl_19531) (cons_9 hd_19532 tl_19533) =>
    match ((lte_9) hd_19530 hd_19532) in
      bool_4 -o (list_6‹U,t_19521› nat_5)
    with
    | true_4 =>
      (cons_9‹U,t_19521›
        nat_5 hd_19530
        ((merge_19524)
          tl_19531 (cons_9‹U,t_19521› nat_5 hd_19532 tl_19533)))
    | false_5 =>
      (cons_9‹U,t_19521›
        nat_5 hd_19532
        ((merge_19524)
          (cons_9‹U,t_19521› nat_5 hd_19530 tl_19531) tl_19533))

#[program]
def msort_31‹t_19535› :
  (list_6‹U,t_19535› nat_5) -> (list_6‹U,t_19535› nat_5)
:=
  function msort_19537 :
    (list_6‹U,t_19535› nat_5) -> (list_6‹U,t_19535› nat_5)
  | nil_8 => (nil_8‹U,t_19535› nat_5)
  | (cons_9 hd_19539 nil_8) =>
    (cons_9‹U,t_19535› nat_5 hd_19539 (nil_8‹U,t_19535› nat_5))
  | (cons_9 hd_19540 (cons_9 hd_19541 tl_19542)) =>
    let _19543 :=
      ((split_29‹t_19535›)
        (cons_9‹U,t_19535›
          nat_5 hd_19540 (cons_9‹U,t_19535› nat_5 hd_19541 tl_19542)))
    in
    match _19543 in
      ((prod1_4‹t_19535,t_19535›)
        (list_6‹U,t_19535› nat_5) (list_6‹U,t_19535› nat_5)) -o
        (list_6‹U,t_19535› nat_5)
    with
    | (ex1_11 m_19545 n_19546) =>
      ((merge_30‹t_19535›)
        ((msort_19537) m_19545) ((msort_19537) n_19546))

#[logical]
def cmsort_ch_32‹t_19547› : (list_6‹U,t_19547› nat_5) -> L :=
  function cmsort_ch_19549 : (list_6‹U,t_19547› nat_5) -> L
  | xs_19551 =>
    ((ch_22)
      true_4
      ((act1_20‹t_19547›)
        true_4
        (sing_2‹t_19547›
          (list_6‹U,t_19547› nat_5) ((msort_31‹t_19547›) xs_19551))
        function _19552 :
          (sing_2‹t_19547›
            (list_6‹U,t_19547› nat_5) ((msort_31‹t_19547›) xs_19551)) ->
            proto_18
        | __19554 => endp_21))

#[program]
def cmsort_worker_33‹t_19555› :
  nat_5 ->
    ∀ (zs_19557 : (list_6‹U,t_19555› nat_5)) ->
      ((cmsort_ch_32‹t_19555›) zs_19557) -o IO unit_3
:=
  function cmsort_worker_19559 :
    nat_5 ->
      ∀ (zs_19561 : (list_6‹U,t_19555› nat_5)) ->
        ((cmsort_ch_32‹t_19555›) zs_19561) -o IO unit_3
  | zero_6 zs_19563 __19564 =>
    let* c_19565 :=
      ((send1_25‹t_19555›)
        true_4 true_4
        (sing_2‹t_19555›
          (list_6‹U,t_19555› nat_5) ((msort_31‹t_19555›) zs_19563))
        function _19566 :
          (sing_2‹t_19555›
            (list_6‹U,t_19555› nat_5) ((msort_31‹t_19555›) zs_19563)) ->
            proto_18
        | __19568 => endp_21 (refl_1‹U› bool_4 ((xor_8) true_4 true_4))
        __19564
        (just_2‹t_19555›
          (list_6‹U,t_19555› nat_5) ((msort_31‹t_19555›) zs_19563)))
    in ((close_23) true_4 c_19565)
  | (succ_7 n_19569) nil_8 __19570 =>
    let* c_19571 :=
      ((send1_25‹t_19555›)
        true_4 true_4
        (sing_2‹t_19555›
          (list_6‹U,t_19555› nat_5)
          ((msort_31‹t_19555›) (nil_8‹U,t_19555› nat_5)))
        function _19572 :
          (sing_2‹t_19555›
            (list_6‹U,t_19555› nat_5)
            ((msort_31‹t_19555›) (nil_8‹U,t_19555› nat_5))) ->
            proto_18
        | __19574 => endp_21 (refl_1‹U› bool_4 ((xor_8) true_4 true_4))
        __19570
        (just_2‹t_19555›
          (list_6‹U,t_19555› nat_5) (nil_8‹U,t_19555› nat_5)))
    in ((close_23) true_4 c_19571)
  | (succ_7 n_19575) (cons_9 hd_19576 nil_8) __19577 =>
    let* c_19578 :=
      ((send1_25‹t_19555›)
        true_4 true_4
        (sing_2‹t_19555›
          (list_6‹U,t_19555› nat_5)
          ((msort_31‹t_19555›)
            (cons_9‹U,t_19555›
              nat_5 hd_19576 (nil_8‹U,t_19555› nat_5))))
        function _19579 :
          (sing_2‹t_19555›
            (list_6‹U,t_19555› nat_5)
            ((msort_31‹t_19555›)
              (cons_9‹U,t_19555›
                nat_5 hd_19576 (nil_8‹U,t_19555› nat_5)))) ->
            proto_18
        | __19581 => endp_21 (refl_1‹U› bool_4 ((xor_8) true_4 true_4))
        __19577
        (just_2‹t_19555›
          (list_6‹U,t_19555› nat_5)
          (cons_9‹U,t_19555› nat_5 hd_19576 (nil_8‹U,t_19555› nat_5))))
    in ((close_23) true_4 c_19578)
  | (succ_7 n_19582) (cons_9 hd_19583 (cons_9 hd_19584 tl_19585)) __19586 =>
    match ((split_29‹t_19555›)
            (cons_9‹U,t_19555›
              nat_5 hd_19583 (cons_9‹U,t_19555› nat_5 hd_19584 tl_19585))),
    (refl_1‹t_19555›
      (list_6‹U,t_19555› nat_5)
      match ((split_29‹t_19555›)
              (cons_9‹U,t_19555›
                nat_5 hd_19583
                (cons_9‹U,t_19555› nat_5 hd_19584 tl_19585))) in
        ((prod1_4‹t_19555,t_19555›)
          (list_6‹U,t_19555› nat_5) (list_6‹U,t_19555› nat_5)) -o
          (list_6‹U,t_19555› nat_5)
      with
      | (ex1_11 m_19588 n_19589) =>
        ((merge_30‹t_19555›)
          ((msort_31‹t_19555›) m_19588) ((msort_31‹t_19555›) n_19589))) in
      ∀ (h1_19590 :
        ((prod1_4‹t_19555,t_19555›)
          (list_6‹U,t_19555› nat_5) (list_6‹U,t_19555› nat_5))) -o
        {(eq_1‹t_19555›
           (list_6‹U,t_19555› nat_5)
           match h1_19590 in
             ((prod1_4‹t_19555,t_19555›)
               (list_6‹U,t_19555› nat_5) (list_6‹U,t_19555› nat_5)) -o
               (list_6‹U,t_19555› nat_5)
           with
           | (ex1_11 m_19593 n_19594) =>
             ((merge_30‹t_19555›)
               ((msort_31‹t_19555›) m_19593)
               ((msort_31‹t_19555›) n_19594))
           match ((split_29‹t_19555›)
                   (cons_9‹U,t_19555›
                     nat_5 hd_19583
                     (cons_9‹U,t_19555› nat_5 hd_19584 tl_19585))) in
             ((prod1_4‹t_19555,t_19555›)
               (list_6‹U,t_19555› nat_5) (list_6‹U,t_19555› nat_5)) -o
               (list_6‹U,t_19555› nat_5)
           with
           | (ex1_11 m_19596 n_19597) =>
             ((merge_30‹t_19555›)
               ((msort_31‹t_19555›) m_19596)
               ((msort_31‹t_19555›) n_19597)))} -o
          IO unit_3
    with
    | (ex1_11 m_19598 n_19599), __19600 =>
      let* r1_19601 :=
        ((fork_28)
          true_4
          ((act1_20‹t_19555›)
            true_4
            (sing_2‹t_19555›
              (list_6‹U,t_19555› nat_5) ((msort_31‹t_19555›) m_19598))
            function _19602 :
              (sing_2‹t_19555›
                (list_6‹U,t_19555› nat_5)
                ((msort_31‹t_19555›) m_19598)) -> proto_18
            | __19604 => endp_21)
          function _19605 :
            ((ch_22)
              true_4
              ((act1_20‹t_19555›)
                true_4
                (sing_2‹t_19555›
                  (list_6‹U,t_19555› nat_5)
                  ((msort_31‹t_19555›) m_19598))
                function _19607 :
                  (sing_2‹t_19555›
                    (list_6‹U,t_19555› nat_5)
                    ((msort_31‹t_19555›) m_19598)) -> proto_18
                | __19609 => endp_21)) -o
              IO unit_3
          | __19610 => ((cmsort_worker_19559) n_19582 m_19598 __19610))
      in
      let* r2_19611 :=
        ((fork_28)
          true_4
          ((act1_20‹t_19555›)
            true_4
            (sing_2‹t_19555›
              (list_6‹U,t_19555› nat_5) ((msort_31‹t_19555›) n_19599))
            function _19612 :
              (sing_2‹t_19555›
                (list_6‹U,t_19555› nat_5)
                ((msort_31‹t_19555›) n_19599)) -> proto_18
            | __19614 => endp_21)
          function _19615 :
            ((ch_22)
              true_4
              ((act1_20‹t_19555›)
                true_4
                (sing_2‹t_19555›
                  (list_6‹U,t_19555› nat_5)
                  ((msort_31‹t_19555›) n_19599))
                function _19617 :
                  (sing_2‹t_19555›
                    (list_6‹U,t_19555› nat_5)
                    ((msort_31‹t_19555›) n_19599)) -> proto_18
                | __19619 => endp_21)) -o
              IO unit_3
          | __19620 => ((cmsort_worker_19559) n_19582 n_19599 __19620))
      in
      let* _19621 :=
        ((recv1_27‹t_19555›)
          ((not_5) true_4) true_4
          (sing_2‹t_19555›
            (list_6‹U,t_19555› nat_5) ((msort_31‹t_19555›) m_19598))
          function _19622 :
            (sing_2‹t_19555›
              (list_6‹U,t_19555› nat_5) ((msort_31‹t_19555›) m_19598)) ->
              proto_18
          | __19624 => endp_21
          (refl_1‹U› bool_4 ((xor_8) ((not_5) true_4) true_4)) r1_19601)
      in
      match _19621 in
        (exists1_8‹t_19555,L›
          (sing_2‹t_19555›
            (list_6‹U,t_19555› nat_5) ((msort_31‹t_19555›) m_19598))
          function _19626 :
            (sing_2‹t_19555›
              (list_6‹U,t_19555› nat_5) ((msort_31‹t_19555›) m_19598)) ->
              L
          | __19628 =>
            ((ch_22)
              ((not_5) true_4)
              ((function _19629 :
                  (sing_2‹t_19555›
                    (list_6‹U,t_19555› nat_5)
                    ((msort_31‹t_19555›) m_19598)) -> proto_18
                | __19631 => endp_21) __19628))) -o
          IO unit_3
      with
      | (ex1_11 m_19632 n_19633) =>
        let* _19634 :=
          ((recv1_27‹t_19555›)
            ((not_5) true_4) true_4
            (sing_2‹t_19555›
              (list_6‹U,t_19555› nat_5) ((msort_31‹t_19555›) n_19599))
            function _19635 :
              (sing_2‹t_19555›
                (list_6‹U,t_19555› nat_5)
                ((msort_31‹t_19555›) n_19599)) -> proto_18
            | __19637 => endp_21
            (refl_1‹U› bool_4 ((xor_8) ((not_5) true_4) true_4)) r2_19611)
        in
        match _19634 in
          (exists1_8‹t_19555,L›
            (sing_2‹t_19555›
              (list_6‹U,t_19555› nat_5) ((msort_31‹t_19555›) n_19599))
            function _19639 :
              (sing_2‹t_19555›
                (list_6‹U,t_19555› nat_5)
                ((msort_31‹t_19555›) n_19599)) -> L
            | __19641 =>
              ((ch_22)
                ((not_5) true_4)
                ((function _19642 :
                    (sing_2‹t_19555›
                      (list_6‹U,t_19555› nat_5)
                      ((msort_31‹t_19555›) n_19599)) -> proto_18
                  | __19644 => endp_21) __19641))) -o
            IO unit_3
        with
        | (ex1_11 m_19645 n_19646) =>
          match m_19632, m_19645 in
            (sing_2‹t_19555›
              (list_6‹U,t_19555› nat_5) ((msort_31‹t_19555›) m_19598)) -o
              (sing_2‹t_19555›
                (list_6‹U,t_19555› nat_5)
                ((msort_31‹t_19555›) n_19599)) -o IO unit_3
          with
          | (just_2 m_19649), (just_2 m_19650) =>
            let zs1_19651 :=
              ((just_2‹t_19555›
                 (list_6‹U,t_19555› nat_5)
                 ((merge_30‹t_19555›) m_19649 m_19650))
                : (sing_2‹t_19555›
                    (list_6‹U,t_19555› nat_5)
                    ((merge_30‹t_19555›)
                      ((msort_31‹t_19555›) m_19598)
                      ((msort_31‹t_19555›) n_19599))))
            in
            let zs1_19652 :=
              (((rwl_1‹t_19555,t_19555›)
                 (list_6‹U,t_19555› nat_5)
                 ((merge_30‹t_19555›)
                   ((msort_31‹t_19555›) m_19598)
                   ((msort_31‹t_19555›) n_19599))
                 match ((split_29‹t_19555›)
                         (cons_9‹U,t_19555›
                           nat_5 hd_19583
                           (cons_9‹U,t_19555› nat_5 hd_19584 tl_19585))) in
                   ((prod1_4‹t_19555,t_19555›)
                     (list_6‹U,t_19555› nat_5)
                     (list_6‹U,t_19555› nat_5)) -o
                     (list_6‹U,t_19555› nat_5)
                 with
                 | (ex1_11 m_19654 n_19655) =>
                   ((merge_30‹t_19555›)
                     ((msort_31‹t_19555›) m_19654)
                     ((msort_31‹t_19555›) n_19655))
                 function _19656 :
                   (list_6‹U,t_19555› nat_5) -> Type‹t_19555›
                 | __19658 =>
                   (sing_2‹t_19555›
                     (list_6‹U,t_19555› nat_5) __19658)
                 __19600 zs1_19651)
                : (sing_2‹t_19555›
                    (list_6‹U,t_19555› nat_5)
                    ((msort_31‹t_19555›)
                      (cons_9‹U,t_19555›
                        nat_5 hd_19583
                        (cons_9‹U,t_19555› nat_5 hd_19584 tl_19585)))))
            in
            let* c_19659 :=
              ((send1_25‹t_19555›)
                true_4 true_4
                (sing_2‹t_19555›
                  (list_6‹U,t_19555› nat_5)
                  ((msort_31‹t_19555›)
                    (cons_9‹U,t_19555›
                      nat_5 hd_19583
                      (cons_9‹U,t_19555› nat_5 hd_19584 tl_19585))))
                function _19660 :
                  (sing_2‹t_19555›
                    (list_6‹U,t_19555› nat_5)
                    ((msort_31‹t_19555›)
                      (cons_9‹U,t_19555›
                        nat_5 hd_19583
                        (cons_9‹U,t_19555› nat_5 hd_19584 tl_19585)))) ->
                    proto_18
                | __19662 => endp_21
                (refl_1‹U› bool_4 ((xor_8) true_4 true_4)) __19586
                zs1_19652)
            in
            let* __19663 := ((close_23) ((not_5) true_4) n_19633) in
            let* __19664 := ((close_23) ((not_5) true_4) n_19646) in
            let* __19665 := ((close_23) true_4 c_19659) in return tt_3

-----------------------------------------

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
def rwlUU_37 :=
  fun rwl_31307 {A_31308} -> {m_31309} -> {n_31310} -> {B_31311} ->
  {__31312} -> (__31313) -> match {NULL} with
                            | reflU_13  => __31313
                            end

#[program]
def rwlUL_36 :=
  fun rwl_31314 {A_31315} -> {m_31316} -> {n_31317} -> {B_31318} ->
  {__31319} -> (__31320) -> match {NULL} with
                            | reflU_13  => __31320
                            end

#[program]
def rwlLU_35 :=
  fun rwl_31321 {A_31322} -> {m_31323} -> {n_31324} -> {B_31325} ->
  {__31326} -> (__31327) -> match {NULL} with
                            | reflL_12  => __31327
                            end

#[program]
def rwlLL_34 :=
  fun rwl_31328 {A_31329} -> {m_31330} -> {n_31331} -> {B_31332} ->
  {__31333} -> (__31334) -> match {NULL} with
                            | reflL_12  => __31334
                            end

#[program]
def rwrUU_41 :=
  fun rwr_31335 {A_31336} -> {m_31337} -> {n_31338} -> {B_31339} ->
  {__31340} -> (__31341) -> match {NULL} with
                            | reflU_13  => __31341
                            end

#[program]
def rwrUL_40 :=
  fun rwr_31342 {A_31343} -> {m_31344} -> {n_31345} -> {B_31346} ->
  {__31347} -> (__31348) -> match {NULL} with
                            | reflU_13  => __31348
                            end

#[program]
def rwrLU_39 :=
  fun rwr_31349 {A_31350} -> {m_31351} -> {n_31352} -> {B_31353} ->
  {__31354} -> (__31355) -> match {NULL} with
                            | reflL_12  => __31355
                            end

#[program]
def rwrLL_38 :=
  fun rwr_31356 {A_31357} -> {m_31358} -> {n_31359} -> {B_31360} ->
  {__31361} -> (__31362) -> match {NULL} with
                            | reflL_12  => __31362
                            end

#[program]
inductive singU_12 where
| justU_15 of layout[R]

#[program]
inductive singL_11 where
| justL_14 of layout[R]

#[program]
inductive unit_3 where
| tt_3 of layout[]

#[program]
inductive bool_4 where
| true_4 of layout[]
| false_5 of layout[]

#[program]
inductive nat_5 where
| zero_6 of layout[]
| succ_7 of layout[R]

#[program]
inductive listUU_16 where
| nilUU_22 of layout[]
| consUU_23 of layout[R, R]

#[program]
inductive listUL_15 where
| nilUL_20 of layout[]
| consUL_21 of layout[R, R]

#[program]
inductive listLU_14 where
| nilLU_18 of layout[]

#[program]
inductive listLL_13 where
| nilLL_16 of layout[]
| consLL_17 of layout[R, R]

#[program]
inductive exists0UU_20 where
| ex0UU_27 of layout[N, R]

#[program]
inductive exists0UL_19 where
| ex0UL_26 of layout[N, R]

#[program]
inductive exists0LU_18 where
| ex0LU_25 of layout[N, R]

#[program]
inductive exists0LL_17 where
| ex0LL_24 of layout[N, R]

#[program]
inductive exists1UU_24 where
| ex1UU_31 of layout[R, R]

#[program]
inductive exists1UL_23 where
| ex1UL_30 of layout[R, R]

#[program]
inductive exists1LU_22 where
| ex1LU_29 of layout[R, R]

#[program]
inductive exists1LL_21 where
| ex1LL_28 of layout[R, R]

#[logical]
def prod0UU_45 := NULL

#[logical]
def prod0UL_44 := NULL

#[logical]
def prod0LU_43 := NULL

#[logical]
def prod0LL_42 := NULL

#[logical]
def prod1UU_49 := NULL

#[logical]
def prod1UL_48 := NULL

#[logical]
def prod1LU_47 := NULL

#[logical]
def prod1LL_46 := NULL

#[program]
def not_5 :=
  fun not_31363 (__31364) ->
    match __31364 with
    | true_4  => false_5 | false_5  => true_4
    end

#[program]
def and_6 :=
  fun and_31365 (__31366) -> (__31367) ->
    match __31366 with
    | true_4  =>
      match __31367 with
      | true_4  => true_4 | false_5  => false_5
      end
    | false_5  => false_5
    end

#[program]
def or_7 :=
  fun or_31368 (__31369) -> (__31370) ->
    match __31369 with
    | true_4  => true_4
    | false_5  =>
      match __31370 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def xor_8 :=
  fun xor_31371 (__31372) -> (__31373) -o
    match __31372 with
    | true_4  =>
      match __31373 with
      | true_4  => false_5 | false_5  => true_4
      end
    | false_5  =>
      match __31373 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def lte_9 :=
  fun lte_31374 (__31375) -> (__31376) ->
    match __31375 with
    | zero_6  => true_4
    | succ_7 n_31377 =>
      match __31376 with
      | zero_6  => false_5 | succ_7 n_31378 => ((lte_31374) n_31377 n_31378)
      end
    end

#[program]
def lt_10 :=
  fun lt_31379 (x_31380) -> (y_31381) -> ((lte_9) (succ_7 x_31380) y_31381)

#[program]
def pred_11 :=
  fun pred_31382 (__31383) ->
    match __31383 with
    | zero_6  => zero_6 | succ_7 n_31384 => n_31384
    end

#[program]
def add_12 :=
  fun add_31385 (__31386) -> (__31387) ->
    match __31386 with
    | zero_6  => __31387
    | succ_7 n_31388 => (succ_7 ((add_31385) n_31388 __31387))
    end

#[program]
def sub_13 :=
  fun sub_31389 (__31390) -> (__31391) ->
    match __31391 with
    | zero_6  => __31390
    | succ_7 n_31392 => ((sub_31389) ((pred_11) __31390) n_31392)
    end

#[program]
def mul_14 :=
  fun mul_31393 (__31394) -> (__31395) ->
    match __31394 with
    | zero_6  => zero_6
    | succ_7 n_31396 => ((add_12) __31395 ((mul_31393) n_31396 __31395))
    end

#[program]
def div_15 :=
  fun div_31397 (x_31398) -> (y_31399) ->
    match ((lt_10) x_31398 y_31399) with
    | true_4  => zero_6
    | false_5  => (succ_7 ((div_31397) ((sub_13) x_31398 y_31399) y_31399))
    end

#[program]
def rem_16 :=
  fun rem_31400 (x_31401) -> (y_31402) ->
    ((sub_13) x_31401 ((mul_14) ((div_15) x_31401 y_31402) y_31402))

#[program]
def pow_17 :=
  fun pow_31403 (__31404) -> (__31405) ->
    match __31405 with
    | zero_6  => (succ_7 zero_6)
    | succ_7 n_31406 => ((mul_14) __31404 ((pow_31403) __31404 n_31406))
    end

#[logical]
extern proto_18

#[logical]
extern act0U_51

#[logical]
extern act0L_50

#[logical]
extern act1U_53

#[logical]
extern act1L_52

#[logical]
extern endp_21

#[logical]
extern ch_22

#[program]
extern close_23

#[program]
extern send0U_55

#[program]
extern send0L_54

#[program]
extern send1U_57

#[program]
extern send1L_56

#[program]
extern recv0U_59

#[program]
extern recv0L_58

#[program]
extern recv1U_61

#[program]
extern recv1L_60

#[program]
extern fork_28

#[program]
def splitU_63 :=
  fun split_31407 (__31408) ->
    match __31408 with
    | nilUU_22  => (ex1UU_31 nilUU_22 nilUU_22)
    | consUU_23 hd_31409 tl_31410 =>
      match tl_31410 with
      | nilUU_22  => (ex1UU_31 (consUU_23 hd_31409 nilUU_22) nilUU_22)
      | consUU_23 hd_31411 tl_31412 =>
        match ((split_31407) tl_31412) with
        | ex1UU_31 m_31413 n_31414 =>
          (ex1UU_31
            (consUU_23 hd_31409 m_31413) (consUU_23 hd_31411 n_31414))
        end
      end
    end

#[program]
def splitL_62 :=
  fun split_31415 (__31416) ->
    match __31416 with
    | nilUL_20  => (ex1LL_28 nilUL_20 nilUL_20)
    | consUL_21 hd_31417 tl_31418 =>
      match tl_31418 with
      | nilUL_20  => (ex1LL_28 (consUL_21 hd_31417 nilUL_20) nilUL_20)
      | consUL_21 hd_31419 tl_31420 =>
        match ((split_31415) tl_31420) with
        | ex1LL_28 m_31421 n_31422 =>
          (ex1LL_28
            (consUL_21 hd_31417 m_31421) (consUL_21 hd_31419 n_31422))
        end
      end
    end

#[program]
def mergeU_65 :=
  fun merge_31423 (__31424) -> (__31425) -o
    match __31424 with
    | nilUU_22  => __31425
    | consUU_23 hd_31426 tl_31427 =>
      match __31425 with
      | nilUU_22  => (consUU_23 hd_31426 tl_31427)
      | consUU_23 hd_31428 tl_31429 =>
        match ((lte_9) hd_31426 hd_31428) with
        | true_4  =>
          (consUU_23
            hd_31426 ((merge_31423) tl_31427 (consUU_23 hd_31428 tl_31429)))
        | false_5  =>
          (consUU_23
            hd_31428 ((merge_31423) (consUU_23 hd_31426 tl_31427) tl_31429))
        end
      end
    end

#[program]
def mergeL_64 :=
  fun merge_31430 (__31431) -> (__31432) -o
    match __31431 with
    | nilUL_20  => __31432
    | consUL_21 hd_31433 tl_31434 =>
      match __31432 with
      | nilUL_20  => (consUL_21 hd_31433 tl_31434)
      | consUL_21 hd_31435 tl_31436 =>
        match ((lte_9) hd_31433 hd_31435) with
        | true_4  =>
          (consUL_21
            hd_31433 ((merge_31430) tl_31434 (consUL_21 hd_31435 tl_31436)))
        | false_5  =>
          (consUL_21
            hd_31435 ((merge_31430) (consUL_21 hd_31433 tl_31434) tl_31436))
        end
      end
    end

#[program]
def msortU_67 :=
  fun msort_31437 (__31438) ->
    match __31438 with
    | nilUU_22  => nilUU_22
    | consUU_23 hd_31439 tl_31440 =>
      match tl_31440 with
      | nilUU_22  => (consUU_23 hd_31439 nilUU_22)
      | consUU_23 hd_31441 tl_31442 =>
        let _31443 :=
          ((splitU_63) (consUU_23 hd_31439 (consUU_23 hd_31441 tl_31442)))
        in
        match _31443 with
        | ex1UU_31 m_31444 n_31445 =>
          ((mergeU_65) ((msort_31437) m_31444) ((msort_31437) n_31445))
        end
      end
    end

#[program]
def msortL_66 :=
  fun msort_31446 (__31447) ->
    match __31447 with
    | nilUL_20  => nilUL_20
    | consUL_21 hd_31448 tl_31449 =>
      match tl_31449 with
      | nilUL_20  => (consUL_21 hd_31448 nilUL_20)
      | consUL_21 hd_31450 tl_31451 =>
        let _31452 :=
          ((splitL_62) (consUL_21 hd_31448 (consUL_21 hd_31450 tl_31451)))
        in
        match _31452 with
        | ex1LL_28 m_31453 n_31454 =>
          ((mergeL_64) ((msort_31446) m_31453) ((msort_31446) n_31454))
        end
      end
    end

#[logical]
def cmsort_chU_69 := NULL

#[logical]
def cmsort_chL_68 := NULL

#[program]
def cmsort_workerU_71 :=
  fun cmsort_worker_31455 (__31456) -> (zs_31457) -> (__31458) -o
    match __31456 with
    | zero_6  =>
      let* c_31459 :=
        ((send1U_57)
          NULL NULL NULL NULL NULL __31458 (justU_15 ((msortU_67) zs_31457)))
      in ((close_23) NULL c_31459)
    | succ_7 n_31460 =>
      match zs_31457 with
      | nilUU_22  =>
        let* c_31461 :=
          ((send1U_57) NULL NULL NULL NULL NULL __31458 (justU_15 nilUU_22))
        in ((close_23) NULL c_31461)
      | consUU_23 hd_31462 tl_31463 =>
        match tl_31463 with
        | nilUU_22  =>
          let* c_31464 :=
            ((send1U_57)
              NULL NULL NULL NULL NULL __31458
              (justU_15 (consUU_23 hd_31462 nilUU_22)))
          in ((close_23) NULL c_31464)
        | consUU_23 hd_31465 tl_31466 =>
          match ((splitU_63)
                  (consUU_23 hd_31462 (consUU_23 hd_31465 tl_31466))) with
          | ex1UU_31 m_31467 n_31468 =>
            let* r1_31469 :=
              ((fork_28)
                NULL NULL
                fun _31470 (c1_31471) -o
                  ((cmsort_worker_31455) n_31460 m_31467 c1_31471))
              in
            let* r2_31472 :=
              ((fork_28)
                NULL NULL
                fun _31473 (c2_31474) -o
                  ((cmsort_worker_31455) n_31460 n_31468 c2_31474))
              in
            let* _31475 := ((recv1U_61) NULL NULL NULL NULL NULL r1_31469) in
            match _31475 with
            | ex1UL_30 m_31476 n_31477 =>
              let* _31478 := ((recv1U_61) NULL NULL NULL NULL NULL r2_31472)
              in
              match _31478 with
              | ex1UL_30 m_31479 n_31480 =>
                match m_31476 with
                | justU_15 m_31481 =>
                  match m_31479 with
                  | justU_15 m_31482 =>
                    let zs1_31483 := (justU_15 ((mergeU_65) m_31481 m_31482))
                    in
                    let zs1_31484 :=
                      ((rwlUU_37) NULL NULL NULL NULL NULL zs1_31483)
                    in
                    let* c_31485 :=
                      ((send1U_57)
                        NULL NULL NULL NULL NULL __31458 zs1_31484)
                    in
                    let* __31486 := ((close_23) NULL n_31477) in
                    let* __31487 := ((close_23) NULL n_31480) in
                    let* __31488 := ((close_23) NULL c_31485) in return tt_3
                  end
                end
              end
            end end
          end
        end
      end

#[program]
def cmsort_workerL_70 :=
  fun cmsort_worker_31489 (__31490) -> (zs_31491) -> (__31492) -o
    match __31490 with
    | zero_6  =>
      let* c_31493 :=
        ((send1L_56)
          NULL NULL NULL NULL NULL __31492 (justL_14 ((msortL_66) zs_31491)))
      in ((close_23) NULL c_31493)
    | succ_7 n_31494 =>
      match zs_31491 with
      | nilUL_20  =>
        let* c_31495 :=
          ((send1L_56) NULL NULL NULL NULL NULL __31492 (justL_14 nilUL_20))
        in ((close_23) NULL c_31495)
      | consUL_21 hd_31496 tl_31497 =>
        match tl_31497 with
        | nilUL_20  =>
          let* c_31498 :=
            ((send1L_56)
              NULL NULL NULL NULL NULL __31492
              (justL_14 (consUL_21 hd_31496 nilUL_20)))
          in ((close_23) NULL c_31498)
        | consUL_21 hd_31499 tl_31500 =>
          match ((splitL_62)
                  (consUL_21 hd_31496 (consUL_21 hd_31499 tl_31500))) with
          | ex1LL_28 m_31501 n_31502 =>
            let* r1_31503 :=
              ((fork_28)
                NULL NULL
                fun _31504 (c1_31505) -o
                  ((cmsort_worker_31489) n_31494 m_31501 c1_31505))
              in
            let* r2_31506 :=
              ((fork_28)
                NULL NULL
                fun _31507 (c2_31508) -o
                  ((cmsort_worker_31489) n_31494 n_31502 c2_31508))
              in
            let* _31509 := ((recv1L_60) NULL NULL NULL NULL NULL r1_31503) in
            match _31509 with
            | ex1LL_28 m_31510 n_31511 =>
              let* _31512 := ((recv1L_60) NULL NULL NULL NULL NULL r2_31506)
              in
              match _31512 with
              | ex1LL_28 m_31513 n_31514 =>
                match m_31510 with
                | justL_14 m_31515 =>
                  match m_31513 with
                  | justL_14 m_31516 =>
                    let zs1_31517 := (justL_14 ((mergeL_64) m_31515 m_31516))
                    in
                    let zs1_31518 :=
                      ((rwlLL_34) NULL NULL NULL NULL NULL zs1_31517)
                    in
                    let* c_31519 :=
                      ((send1L_56)
                        NULL NULL NULL NULL NULL __31492 zs1_31518)
                    in
                    let* __31520 := ((close_23) NULL n_31511) in
                    let* __31521 := ((close_23) NULL n_31514) in
                    let* __31522 := ((close_23) NULL c_31519) in return tt_3
                  end
                end
              end
            end end
          end
        end
      end

-----------------------------------------

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
def rwlUU_37 :=
  fun rwl_31739 {A_31740} -> {m_31741} -> {n_31742} -> {B_31743} ->
  {__31744} -> (__31745) -> __31745

#[program]
def rwlUL_36 :=
  fun rwl_31746 {A_31747} -> {m_31748} -> {n_31749} -> {B_31750} ->
  {__31751} -> (__31752) -> __31752

#[program]
def rwlLU_35 :=
  fun rwl_31753 {A_31754} -> {m_31755} -> {n_31756} -> {B_31757} ->
  {__31758} -> (__31759) -> __31759

#[program]
def rwlLL_34 :=
  fun rwl_31760 {A_31761} -> {m_31762} -> {n_31763} -> {B_31764} ->
  {__31765} -> (__31766) -> __31766

#[program]
def rwrUU_41 :=
  fun rwr_31767 {A_31768} -> {m_31769} -> {n_31770} -> {B_31771} ->
  {__31772} -> (__31773) -> __31773

#[program]
def rwrUL_40 :=
  fun rwr_31774 {A_31775} -> {m_31776} -> {n_31777} -> {B_31778} ->
  {__31779} -> (__31780) -> __31780

#[program]
def rwrLU_39 :=
  fun rwr_31781 {A_31782} -> {m_31783} -> {n_31784} -> {B_31785} ->
  {__31786} -> (__31787) -> __31787

#[program]
def rwrLL_38 :=
  fun rwr_31788 {A_31789} -> {m_31790} -> {n_31791} -> {B_31792} ->
  {__31793} -> (__31794) -> __31794

#[program]
inductive singU_12 where
| justU_15 of layout[R]

#[program]
inductive singL_11 where
| justL_14 of layout[R]

#[program]
inductive unit_3 where
| tt_3 of layout[]

#[program]
inductive bool_4 where
| true_4 of layout[]
| false_5 of layout[]

#[program]
inductive nat_5 where
| zero_6 of layout[]
| succ_7 of layout[R]

#[program]
inductive listUU_16 where
| nilUU_22 of layout[]
| consUU_23 of layout[R, R]

#[program]
inductive listUL_15 where
| nilUL_20 of layout[]
| consUL_21 of layout[R, R]

#[program]
inductive listLU_14 where
| nilLU_18 of layout[]

#[program]
inductive listLL_13 where
| nilLL_16 of layout[]
| consLL_17 of layout[R, R]

#[program]
inductive exists0UU_20 where
| ex0UU_27 of layout[N, R]

#[program]
inductive exists0UL_19 where
| ex0UL_26 of layout[N, R]

#[program]
inductive exists0LU_18 where
| ex0LU_25 of layout[N, R]

#[program]
inductive exists0LL_17 where
| ex0LL_24 of layout[N, R]

#[program]
inductive exists1UU_24 where
| ex1UU_31 of layout[R, R]

#[program]
inductive exists1UL_23 where
| ex1UL_30 of layout[R, R]

#[program]
inductive exists1LU_22 where
| ex1LU_29 of layout[R, R]

#[program]
inductive exists1LL_21 where
| ex1LL_28 of layout[R, R]

#[logical]
def prod0UU_45 := NULL

#[logical]
def prod0UL_44 := NULL

#[logical]
def prod0LU_43 := NULL

#[logical]
def prod0LL_42 := NULL

#[logical]
def prod1UU_49 := NULL

#[logical]
def prod1UL_48 := NULL

#[logical]
def prod1LU_47 := NULL

#[logical]
def prod1LL_46 := NULL

#[program]
def not_5 :=
  fun not_31795 (__31796) ->
    match __31796 with
    | true_4  => false_5 | false_5  => true_4
    end

#[program]
def and_6 :=
  fun and_31797 (__31798) -> (__31799) ->
    match __31798 with
    | true_4  =>
      match __31799 with
      | true_4  => true_4 | false_5  => false_5
      end
    | false_5  => false_5
    end

#[program]
def or_7 :=
  fun or_31800 (__31801) -> (__31802) ->
    match __31801 with
    | true_4  => true_4
    | false_5  =>
      match __31802 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def xor_8 :=
  fun xor_31803 (__31804) -> (__31805) -o
    match __31804 with
    | true_4  =>
      match __31805 with
      | true_4  => false_5 | false_5  => true_4
      end
    | false_5  =>
      match __31805 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def lte_9 :=
  fun lte_31806 (__31807) -> (__31808) ->
    match __31807 with
    | zero_6  => true_4
    | succ_7 n_31809 =>
      match __31808 with
      | zero_6  => false_5 | succ_7 n_31810 => ((lte_31806) n_31809 n_31810)
      end
    end

#[program]
def lt_10 :=
  fun lt_31811 (x_31812) -> (y_31813) -> ((lte_9) (succ_7 x_31812) y_31813)

#[program]
def pred_11 :=
  fun pred_31814 (__31815) ->
    match __31815 with
    | zero_6  => zero_6 | succ_7 n_31816 => n_31816
    end

#[program]
def add_12 :=
  fun add_31817 (__31818) -> (__31819) ->
    match __31818 with
    | zero_6  => __31819
    | succ_7 n_31820 => (succ_7 ((add_31817) n_31820 __31819))
    end

#[program]
def sub_13 :=
  fun sub_31821 (__31822) -> (__31823) ->
    match __31823 with
    | zero_6  => __31822
    | succ_7 n_31824 => ((sub_31821) ((pred_11) __31822) n_31824)
    end

#[program]
def mul_14 :=
  fun mul_31825 (__31826) -> (__31827) ->
    match __31826 with
    | zero_6  => zero_6
    | succ_7 n_31828 => ((add_12) __31827 ((mul_31825) n_31828 __31827))
    end

#[program]
def div_15 :=
  fun div_31829 (x_31830) -> (y_31831) ->
    match ((lt_10) x_31830 y_31831) with
    | true_4  => zero_6
    | false_5  => (succ_7 ((div_31829) ((sub_13) x_31830 y_31831) y_31831))
    end

#[program]
def rem_16 :=
  fun rem_31832 (x_31833) -> (y_31834) ->
    ((sub_13) x_31833 ((mul_14) ((div_15) x_31833 y_31834) y_31834))

#[program]
def pow_17 :=
  fun pow_31835 (__31836) -> (__31837) ->
    match __31837 with
    | zero_6  => (succ_7 zero_6)
    | succ_7 n_31838 => ((mul_14) __31836 ((pow_31835) __31836 n_31838))
    end

#[logical]
extern proto_18

#[logical]
extern act0U_51

#[logical]
extern act0L_50

#[logical]
extern act1U_53

#[logical]
extern act1L_52

#[logical]
extern endp_21

#[logical]
extern ch_22

#[program]
extern close_23

#[program]
extern send0U_55

#[program]
extern send0L_54

#[program]
extern send1U_57

#[program]
extern send1L_56

#[program]
extern recv0U_59

#[program]
extern recv0L_58

#[program]
extern recv1U_61

#[program]
extern recv1L_60

#[program]
extern fork_28

#[program]
def splitU_63 :=
  fun split_31839 (__31840) ->
    match __31840 with
    | nilUU_22  => (ex1UU_31 nilUU_22 nilUU_22)
    | consUU_23 hd_31841 tl_31842 =>
      match tl_31842 with
      | nilUU_22  => (ex1UU_31 (consUU_23 hd_31841 nilUU_22) nilUU_22)
      | consUU_23 hd_31843 tl_31844 =>
        match ((split_31839) tl_31844) with
        | ex1UU_31 m_31845 n_31846 =>
          (ex1UU_31
            (consUU_23 hd_31841 m_31845) (consUU_23 hd_31843 n_31846))
        end
      end
    end

#[program]
def splitL_62 :=
  fun split_31847 (__31848) ->
    match __31848 with
    | nilUL_20  => (ex1LL_28 nilUL_20 nilUL_20)
    | consUL_21 hd_31849 tl_31850 =>
      match tl_31850 with
      | nilUL_20  => (ex1LL_28 (consUL_21 hd_31849 nilUL_20) nilUL_20)
      | consUL_21 hd_31851 tl_31852 =>
        match ((split_31847) tl_31852) with
        | ex1LL_28 m_31853 n_31854 =>
          (ex1LL_28
            (consUL_21 hd_31849 m_31853) (consUL_21 hd_31851 n_31854))
        end
      end
    end

#[program]
def mergeU_65 :=
  fun merge_31855 (__31856) -> (__31857) -o
    match __31856 with
    | nilUU_22  => __31857
    | consUU_23 hd_31858 tl_31859 =>
      match __31857 with
      | nilUU_22  => (consUU_23 hd_31858 tl_31859)
      | consUU_23 hd_31860 tl_31861 =>
        match ((lte_9) hd_31858 hd_31860) with
        | true_4  =>
          (consUU_23
            hd_31858 ((merge_31855) tl_31859 (consUU_23 hd_31860 tl_31861)))
        | false_5  =>
          (consUU_23
            hd_31860 ((merge_31855) (consUU_23 hd_31858 tl_31859) tl_31861))
        end
      end
    end

#[program]
def mergeL_64 :=
  fun merge_31862 (__31863) -> (__31864) -o
    match __31863 with
    | nilUL_20  => __31864
    | consUL_21 hd_31865 tl_31866 =>
      match __31864 with
      | nilUL_20  => (consUL_21 hd_31865 tl_31866)
      | consUL_21 hd_31867 tl_31868 =>
        match ((lte_9) hd_31865 hd_31867) with
        | true_4  =>
          (consUL_21
            hd_31865 ((merge_31862) tl_31866 (consUL_21 hd_31867 tl_31868)))
        | false_5  =>
          (consUL_21
            hd_31867 ((merge_31862) (consUL_21 hd_31865 tl_31866) tl_31868))
        end
      end
    end

#[program]
def msortU_67 :=
  fun msort_31869 (__31870) ->
    match __31870 with
    | nilUU_22  => nilUU_22
    | consUU_23 hd_31871 tl_31872 =>
      match tl_31872 with
      | nilUU_22  => (consUU_23 hd_31871 nilUU_22)
      | consUU_23 hd_31873 tl_31874 =>
        let _31875 :=
          ((splitU_63) (consUU_23 hd_31871 (consUU_23 hd_31873 tl_31874)))
        in
        match _31875 with
        | ex1UU_31 m_31876 n_31877 =>
          ((mergeU_65) ((msort_31869) m_31876) ((msort_31869) n_31877))
        end
      end
    end

#[program]
def msortL_66 :=
  fun msort_31878 (__31879) ->
    match __31879 with
    | nilUL_20  => nilUL_20
    | consUL_21 hd_31880 tl_31881 =>
      match tl_31881 with
      | nilUL_20  => (consUL_21 hd_31880 nilUL_20)
      | consUL_21 hd_31882 tl_31883 =>
        let _31884 :=
          ((splitL_62) (consUL_21 hd_31880 (consUL_21 hd_31882 tl_31883)))
        in
        match _31884 with
        | ex1LL_28 m_31885 n_31886 =>
          ((mergeL_64) ((msort_31878) m_31885) ((msort_31878) n_31886))
        end
      end
    end

#[logical]
def cmsort_chU_69 := NULL

#[logical]
def cmsort_chL_68 := NULL

#[program]
def cmsort_workerU_71 :=
  fun cmsort_worker_31887 (__31888) -> (zs_31889) -> (__31890) -o
    match __31888 with
    | zero_6  =>
      let* c_31891 :=
        ((send1U_57)
          NULL NULL NULL NULL NULL __31890 (justU_15 ((msortU_67) zs_31889)))
      in ((close_23) NULL c_31891)
    | succ_7 n_31892 =>
      match zs_31889 with
      | nilUU_22  =>
        let* c_31893 :=
          ((send1U_57) NULL NULL NULL NULL NULL __31890 (justU_15 nilUU_22))
        in ((close_23) NULL c_31893)
      | consUU_23 hd_31894 tl_31895 =>
        match tl_31895 with
        | nilUU_22  =>
          let* c_31896 :=
            ((send1U_57)
              NULL NULL NULL NULL NULL __31890
              (justU_15 (consUU_23 hd_31894 nilUU_22)))
          in ((close_23) NULL c_31896)
        | consUU_23 hd_31897 tl_31898 =>
          match ((splitU_63)
                  (consUU_23 hd_31894 (consUU_23 hd_31897 tl_31898))) with
          | ex1UU_31 m_31899 n_31900 =>
            let* r1_31901 :=
              ((fork_28)
                NULL NULL
                fun _31902 (c1_31903) -o
                  ((cmsort_worker_31887) n_31892 m_31899 c1_31903))
              in
            let* r2_31904 :=
              ((fork_28)
                NULL NULL
                fun _31905 (c2_31906) -o
                  ((cmsort_worker_31887) n_31892 n_31900 c2_31906))
              in
            let* _31907 := ((recv1U_61) NULL NULL NULL NULL NULL r1_31901) in
            match _31907 with
            | ex1UL_30 m_31908 n_31909 =>
              let* _31910 := ((recv1U_61) NULL NULL NULL NULL NULL r2_31904)
              in
              match _31910 with
              | ex1UL_30 m_31911 n_31912 =>
                match m_31908 with
                | justU_15 m_31913 =>
                  match m_31911 with
                  | justU_15 m_31914 =>
                    let zs1_31915 := (justU_15 ((mergeU_65) m_31913 m_31914))
                    in
                    let zs1_31916 :=
                      ((rwlUU_37) NULL NULL NULL NULL NULL zs1_31915)
                    in
                    let* c_31917 :=
                      ((send1U_57)
                        NULL NULL NULL NULL NULL __31890 zs1_31916)
                    in
                    let* __31918 := ((close_23) NULL n_31909) in
                    let* __31919 := ((close_23) NULL n_31912) in
                    let* __31920 := ((close_23) NULL c_31917) in return tt_3
                  end
                end
              end
            end end
          end
        end
      end

#[program]
def cmsort_workerL_70 :=
  fun cmsort_worker_31921 (__31922) -> (zs_31923) -> (__31924) -o
    match __31922 with
    | zero_6  =>
      let* c_31925 :=
        ((send1L_56)
          NULL NULL NULL NULL NULL __31924 (justL_14 ((msortL_66) zs_31923)))
      in ((close_23) NULL c_31925)
    | succ_7 n_31926 =>
      match zs_31923 with
      | nilUL_20  =>
        let* c_31927 :=
          ((send1L_56) NULL NULL NULL NULL NULL __31924 (justL_14 nilUL_20))
        in ((close_23) NULL c_31927)
      | consUL_21 hd_31928 tl_31929 =>
        match tl_31929 with
        | nilUL_20  =>
          let* c_31930 :=
            ((send1L_56)
              NULL NULL NULL NULL NULL __31924
              (justL_14 (consUL_21 hd_31928 nilUL_20)))
          in ((close_23) NULL c_31930)
        | consUL_21 hd_31931 tl_31932 =>
          match ((splitL_62)
                  (consUL_21 hd_31928 (consUL_21 hd_31931 tl_31932))) with
          | ex1LL_28 m_31933 n_31934 =>
            let* r1_31935 :=
              ((fork_28)
                NULL NULL
                fun _31936 (c1_31937) -o
                  ((cmsort_worker_31921) n_31926 m_31933 c1_31937))
              in
            let* r2_31938 :=
              ((fork_28)
                NULL NULL
                fun _31939 (c2_31940) -o
                  ((cmsort_worker_31921) n_31926 n_31934 c2_31940))
              in
            let* _31941 := ((recv1L_60) NULL NULL NULL NULL NULL r1_31935) in
            match _31941 with
            | ex1LL_28 m_31942 n_31943 =>
              let* _31944 := ((recv1L_60) NULL NULL NULL NULL NULL r2_31938)
              in
              match _31944 with
              | ex1LL_28 m_31945 n_31946 =>
                match m_31942 with
                | justL_14 m_31947 =>
                  match m_31945 with
                  | justL_14 m_31948 =>
                    let zs1_31949 := (justL_14 ((mergeL_64) m_31947 m_31948))
                    in
                    let zs1_31950 :=
                      ((rwlLL_34) NULL NULL NULL NULL NULL zs1_31949)
                    in
                    let* c_31951 :=
                      ((send1L_56)
                        NULL NULL NULL NULL NULL __31924 zs1_31950)
                    in
                    let* __31952 := ((close_23) NULL n_31943) in
                    let* __31953 := ((close_23) NULL n_31946) in
                    let* __31954 := ((close_23) NULL c_31951) in return tt_3
                  end
                end
              end
            end end
          end
        end
      end

-----------------------------------------

