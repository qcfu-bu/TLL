[Inductive {name = "eq"; relv = N;
   body =
   (Binder (["s"],
      (PBind ((Type (SId "s")),
         (Binder ("A",
            (PBind ((Id ("A", I)),
               (Binder ("m",
                  (PBase
                     ((TBind (R, (Id ("A", I)),
                         (Binder ("_", (TBase (Type U)))))),
                      [(DConstr ("refl",
                          (TBase
                             (App
                                [(Id ("eq", I)); (Id ("m", I)); (Id ("m", I))
                                  ])),
                          []))
                        ]))
                  ))
               ))
            ))
         ))
      ));
   view = [I; E]};
  Inductive {name = "unit"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)), [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
       ));
    view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "list"; relv = R;
    body =
    (Binder (["s"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type (SId "t"))),
                 [(DConstr ("nil",
                     (TBase (App [(Id ("list", I)); (Id ("A", I))])), 
                     []));
                   (DConstr ("cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (App [(Id ("list", I)); (Id ("A", I))]),
                               (Binder ("tl",
                                  (TBase
                                     (App [(Id ("list", I)); (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Inductive {name = "exists0"; relv = R;
    body =
    (Binder (["s"; "r"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("ex0",
                           (TBind (N, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("exists0", E));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "exists1"; relv = R;
    body =
    (Binder (["s"; "r"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type L)),
                       [(DConstr ("ex1",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("exists1", E));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Definition {name = "xor"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("bool", I)),
              (Binder ("_",
                 (Pi (R, L, (Id ("bool", I)),
                    (Binder ("_", (Id ("bool", I))))))
                 ))
              )),
           (Binder ((Some "xor"),
              [([(PId "true"); (PId "true")], (Some (Id ("false", I))));
                ([(PId "false"); (PId "false")], (Some (Id ("false", I))));
                ([(PId "_"); (PId "_")], (Some (Id ("true", I))))]
              )),
           [])),
        (Pi (R, U, (Id ("bool", I)),
           (Binder ("_",
              (Pi (R, L, (Id ("bool", I)), (Binder ("_", (Id ("bool", I))))))
              ))
           )))
       ));
    view = []};
  Extern {name = "proto"; relv = N; body = (Binder ([], (Type U))); view = []};
  Extern {name = "act0"; relv = N;
    body =
    (Binder (["s"],
       (Pi (R, U, (Id ("bool", I)),
          (Binder ("b",
             (Pi (R, U, (Type (SId "s")),
                (Binder ("A",
                   (Pi (R, U,
                      (Pi (R, U, (Id ("A", I)),
                         (Binder ("_", (Id ("proto", I)))))),
                      (Binder ("B", (Id ("proto", I))))))
                   ))
                ))
             ))
          ))
       ));
    view = [E; I; E]};
  Extern {name = "act1"; relv = N;
    body =
    (Binder (["s"],
       (Pi (R, U, (Id ("bool", I)),
          (Binder ("b",
             (Pi (R, U, (Type (SId "s")),
                (Binder ("A",
                   (Pi (R, U,
                      (Pi (R, U, (Id ("A", I)),
                         (Binder ("_", (Id ("proto", I)))))),
                      (Binder ("B", (Id ("proto", I))))))
                   ))
                ))
             ))
          ))
       ));
    view = [E; I; E]};
  Extern {name = "endp"; relv = N; body = (Binder ([], (Id ("proto", I))));
    view = []};
  Extern {name = "ch"; relv = N;
    body =
    (Binder ([],
       (Pi (R, U, (Id ("bool", I)),
          (Binder ("_",
             (Pi (R, U, (Id ("proto", I)), (Binder ("_", (Type L)))))))
          ))
       ));
    view = []};
  Extern {name = "close"; relv = R;
    body =
    (Binder ([],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b",
             (Pi (R, U,
                (App [(Id ("ch", I)); (Id ("b", I)); (Id ("endp", I))]),
                (Binder ("_", (IO (Id ("unit", I)))))))
             ))
          ))
       ));
    view = [I]};
  Extern {name = "send0"; relv = R;
    body =
    (Binder (["s"],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b1",
             (Pi (N, U, (Id ("bool", I)),
                (Binder ("b2",
                   (Pi (N, U, (Type (SId "s")),
                      (Binder ("A",
                         (Pi (N, U,
                            (Pi (R, U, (Id ("A", I)),
                               (Binder ("_", (Id ("proto", I)))))),
                            (Binder ("B",
                               (Pi (N, U,
                                  (App
                                     [(Id ("eq", I));
                                       (App
                                          [(Id ("xor", I)); (Id ("b1", I));
                                            (Id ("b2", I))]);
                                       (Id ("false", I))]),
                                  (Binder ("_",
                                     (Pi (R, U,
                                        (App
                                           [(Id ("ch", I)); (Id ("b1", I));
                                             (App
                                                [(Id ("act0", I));
                                                  (Id ("b2", I));
                                                  (Id ("B", I))])
                                             ]),
                                        (Binder ("_",
                                           (Pi (N, L, (Id ("A", I)),
                                              (Binder ("x",
                                                 (IO
                                                    (App
                                                       [(Id ("ch", I));
                                                         (Id ("b1", I));
                                                         (App
                                                            [(Id ("B", I));
                                                              (Id ("x", I))])
                                                         ]))
                                                 ))
                                              ))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))
                      ))
                   ))
                ))
             ))
          ))
       ));
    view = [I; I; I; I]};
  Extern {name = "send1"; relv = R;
    body =
    (Binder (["s"],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b1",
             (Pi (N, U, (Id ("bool", I)),
                (Binder ("b2",
                   (Pi (N, U, (Type (SId "s")),
                      (Binder ("A",
                         (Pi (N, U,
                            (Pi (R, U, (Id ("A", I)),
                               (Binder ("_", (Id ("proto", I)))))),
                            (Binder ("B",
                               (Pi (N, U,
                                  (App
                                     [(Id ("eq", I));
                                       (App
                                          [(Id ("xor", I)); (Id ("b1", I));
                                            (Id ("b2", I))]);
                                       (Id ("false", I))]),
                                  (Binder ("_",
                                     (Pi (R, U,
                                        (App
                                           [(Id ("ch", I)); (Id ("b1", I));
                                             (App
                                                [(Id ("act1", I));
                                                  (Id ("b2", I));
                                                  (Id ("B", I))])
                                             ]),
                                        (Binder ("_",
                                           (Pi (R, L, (Id ("A", I)),
                                              (Binder ("x",
                                                 (IO
                                                    (App
                                                       [(Id ("ch", I));
                                                         (Id ("b1", I));
                                                         (App
                                                            [(Id ("B", I));
                                                              (Id ("x", I))])
                                                         ]))
                                                 ))
                                              ))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))
                      ))
                   ))
                ))
             ))
          ))
       ));
    view = [I; I; I; I]};
  Extern {name = "recv0"; relv = R;
    body =
    (Binder (["s"],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b1",
             (Pi (N, U, (Id ("bool", I)),
                (Binder ("b2",
                   (Pi (N, U, (Type (SId "s")),
                      (Binder ("A",
                         (Pi (N, U,
                            (Pi (R, U, (Id ("A", I)),
                               (Binder ("_", (Id ("proto", I)))))),
                            (Binder ("B",
                               (Pi (N, U,
                                  (App
                                     [(Id ("eq", I));
                                       (App
                                          [(Id ("xor", I)); (Id ("b1", I));
                                            (Id ("b2", I))]);
                                       (Id ("false", I))]),
                                  (Binder ("_",
                                     (Pi (R, U,
                                        (App
                                           [(Id ("ch", I)); (Id ("b1", I));
                                             (App
                                                [(Id ("act0", I));
                                                  (Id ("b2", I));
                                                  (Id ("B", I))])
                                             ]),
                                        (Binder ("_",
                                           (IO
                                              (App
                                                 [(Id ("exists0", I));
                                                   (Fun (
                                                      (Pi (R, U,
                                                         (Id ("A", I)),
                                                         (Binder ("x", IMeta
                                                            ))
                                                         )),
                                                      (Binder (None,
                                                         [([(PId "x")],
                                                           (Some (App
                                                                    [(Id (
                                                                    "ch", I));
                                                                    (Id (
                                                                    "b1", I));
                                                                    (App
                                                                    [(Id (
                                                                    "B", I));
                                                                    (Id ("x",
                                                                    I))])])))
                                                           ]
                                                         )),
                                                      []))
                                                   ]))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))
                      ))
                   ))
                ))
             ))
          ))
       ));
    view = [I; I; I; I]};
  Extern {name = "recv1"; relv = R;
    body =
    (Binder (["s"],
       (Pi (N, U, (Id ("bool", I)),
          (Binder ("b1",
             (Pi (N, U, (Id ("bool", I)),
                (Binder ("b2",
                   (Pi (N, U, (Type (SId "s")),
                      (Binder ("A",
                         (Pi (N, U,
                            (Pi (R, U, (Id ("A", I)),
                               (Binder ("_", (Id ("proto", I)))))),
                            (Binder ("B",
                               (Pi (N, U,
                                  (App
                                     [(Id ("eq", I));
                                       (App
                                          [(Id ("xor", I)); (Id ("b1", I));
                                            (Id ("b2", I))]);
                                       (Id ("false", I))]),
                                  (Binder ("_",
                                     (Pi (R, U,
                                        (App
                                           [(Id ("ch", I)); (Id ("b1", I));
                                             (App
                                                [(Id ("act1", I));
                                                  (Id ("b2", I));
                                                  (Id ("B", I))])
                                             ]),
                                        (Binder ("_",
                                           (IO
                                              (App
                                                 [(Id ("exists1", I));
                                                   (Fun (
                                                      (Pi (R, U,
                                                         (Id ("A", I)),
                                                         (Binder ("x", IMeta
                                                            ))
                                                         )),
                                                      (Binder (None,
                                                         [([(PId "x")],
                                                           (Some (App
                                                                    [(Id (
                                                                    "ch", I));
                                                                    (Id (
                                                                    "b1", I));
                                                                    (App
                                                                    [(Id (
                                                                    "B", I));
                                                                    (Id ("x",
                                                                    I))])])))
                                                           ]
                                                         )),
                                                      []))
                                                   ]))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))
                      ))
                   ))
                ))
             ))
          ))
       ));
    view = [I; I; I; I]};
  Extern {name = "c"; relv = R;
    body =
    (Binder ([],
       (App
          [(Id ("ch", I)); (Id ("true", I));
            (App
               [(Id ("act1", I)); (Id ("true", I));
                 (Fun ((Pi (R, U, (Id ("nat", I)), (Binder ("x", IMeta)))),
                    (Binder (None, [([(PId "x")], (Some (Id ("endp", I))))])),
                    []))
                 ])
            ])
       ));
    view = []};
  Definition {name = "main"; relv = R;
    body =
    (Binder ([],
       ((MLet (
           (App
              [(Id ("send1", I)); (Id ("refl", I)); (Id ("c", I));
                (Id ("zero", I))]),
           (Binder ("c", (App [(Id ("close", I)); (Id ("c", I))]))))),
        (IO (Id ("unit", I))))
       ));
    view = []}
  ]

-----------------------------------------

#[logical]
inductive eq_1‹s_108› (A_109 : Type‹s_108›) (m_110 : A_109):
  A_109 -> U
where
| refl_1 : (eq_1‹??_1› ?_1 m_110 m_110)

#[program]
inductive unit_2‹› : U where
| tt_2 : unit_2

#[program]
inductive bool_3‹› : U where
| true_3 : bool_3
| false_4 : bool_3

#[program]
inductive nat_4‹› : U where
| zero_5 : nat_4
| succ_6 (pred_112 : nat_4) : nat_4

#[program]
inductive list_5‹s_113,t_114› (A_115 : Type‹s_113›): Type‹t_114›
where
| nil_7 : (list_5‹??_2,??_3› A_115)
| cons_8
    (hd_116 : A_115) (tl_117 : (list_5‹??_4,??_5› A_115))
    : (list_5‹??_6,??_7› A_115)

#[program]
inductive exists0_6‹s_118,r_119› (A_120 : Type‹s_118›) (B_121 : 
A_120 -> Type‹r_119›): L where
| ex0_9
    {m_123 : A_120} (n_124 : ((B_121) m_123))
    : (exists0_6‹??_8,??_9› A_120 B_121)

#[program]
inductive exists1_7‹s_125,r_126› (A_127 : Type‹s_125›) (B_128 : 
A_127 -> Type‹r_126›): L where
| ex1_10
    (m_130 : A_127) (n_131 : ((B_128) m_130))
    : (exists1_7‹??_10,??_11› A_127 B_128)

#[program]
def xor_1‹› : bool_3 -> bool_3 -o bool_3 :=
  function xor_134 : bool_3 -> bool_3 -o bool_3
  | true_3 true_3 => false_4
  | false_4 false_4 => false_4
  | _137 _138 => true_3

#[logical]
extern proto_2‹› : U

#[logical]
extern act0_3‹s_139› :
  bool_3 -> ∀ (A_141 : Type‹s_139›) -> A_141 -> proto_2 -> proto_2

#[logical]
extern act1_4‹s_144› :
  bool_3 -> ∀ (A_146 : Type‹s_144›) -> A_146 -> proto_2 -> proto_2

#[logical]
extern endp_5‹› : proto_2

#[logical]
extern ch_6‹› : bool_3 -> proto_2 -> L

#[program]
extern close_7‹› :
  ∀ {b_151 : bool_3} -> ((ch_6) b_151 endp_5) -> IO unit_2

#[program]
extern send0_8‹s_153› :
  ∀ {b1_154 : bool_3} ->
    ∀ {b2_155 : bool_3} ->
      ∀ {A_156 : Type‹s_153›} ->
        ∀ {B_157 : A_156 -> proto_2} ->
          ∀ {__159 :
            (eq_1‹??_12› ?_2 ((xor_1) b1_154 b2_155) false_4)} ->
            ((ch_6) b1_154 ((act0_3‹??_13›) b2_155 ?_3 B_157)) ->
              ∀ {x_161 : A_156} -o IO ((ch_6) b1_154 ((B_157) x_161))

#[program]
extern send1_9‹s_162› :
  ∀ {b1_163 : bool_3} ->
    ∀ {b2_164 : bool_3} ->
      ∀ {A_165 : Type‹s_162›} ->
        ∀ {B_166 : A_165 -> proto_2} ->
          ∀ {__168 :
            (eq_1‹??_14› ?_4 ((xor_1) b1_163 b2_164) false_4)} ->
            ((ch_6) b1_163 ((act1_4‹??_15›) b2_164 ?_5 B_166)) ->
              ∀ (x_170 : A_165) -o IO ((ch_6) b1_163 ((B_166) x_170))

#[program]
extern recv0_10‹s_171› :
  ∀ {b1_172 : bool_3} ->
    ∀ {b2_173 : bool_3} ->
      ∀ {A_174 : Type‹s_171›} ->
        ∀ {B_175 : A_174 -> proto_2} ->
          ∀ {__177 :
            (eq_1‹??_16› ?_6 ((xor_1) b1_172 b2_173) false_4)} ->
            ∀ (__178 :
              ((ch_6) b1_172 ((act0_3‹??_17›) b2_173 ?_7 B_175))) ->
              IO (exists0_6‹??_18,??_19›
                   ?_9
                   function _179 : ∀ (x_180 : A_174) -> ?_8
                   | x_181 => ((ch_6) b1_172 ((B_175) x_181)))

#[program]
extern recv1_11‹s_182› :
  ∀ {b1_183 : bool_3} ->
    ∀ {b2_184 : bool_3} ->
      ∀ {A_185 : Type‹s_182›} ->
        ∀ {B_186 : A_185 -> proto_2} ->
          ∀ {__188 :
            (eq_1‹??_20› ?_10 ((xor_1) b1_183 b2_184) false_4)} ->
            ∀ (__189 :
              ((ch_6) b1_183 ((act1_4‹??_21›) b2_184 ?_11 B_186))) ->
              IO (exists1_7‹??_22,??_23›
                   ?_13
                   function _190 : ∀ (x_191 : A_185) -> ?_12
                   | x_192 => ((ch_6) b1_183 ((B_186) x_192)))

#[program]
extern c_12‹› :
  ((ch_6)
    true_3
    ((act1_4‹??_24›)
      true_3 ?_15
      function _193 : ∀ (x_194 : nat_4) -> ?_14
      | x_195 => endp_5))

#[program]
def main_13‹› : IO unit_2 :=
  let* c_196 :=
    ((send1_9‹??_26›) ?_21 ?_20 ?_19 ?_18 refl_1‹??_25› c_12 zero_5)
  in ((close_7) ?_22 c_196)

-----------------------------------------

#[logical]
inductive eq_1‹s_1176› (A_1177 : Type‹s_1176›) (m_1178 : A_1177):
  A_1177 -> U
where
| refl_1 : (eq_1‹s_1176› A_1177 m_1178 m_1178)

#[program]
inductive unit_2‹› : U where
| tt_2 : unit_2

#[program]
inductive bool_3‹› : U where
| true_3 : bool_3
| false_4 : bool_3

#[program]
inductive nat_4‹› : U where
| zero_5 : nat_4
| succ_6 (pred_1180 : nat_4) : nat_4

#[program]
inductive list_5‹s_1181,t_1182› (A_1183 : Type‹s_1181›):
  Type‹t_1182›
where
| nil_7 : (list_5‹s_1181,t_1182› A_1183)
| cons_8
    (hd_1184 : A_1183) (tl_1185 : (list_5‹s_1181,??_5› A_1183))
    : (list_5‹s_1181,t_1182› A_1183)

#[program]
inductive exists0_6‹s_1186,r_1187› (A_1188 : Type‹s_1186›) (B_1189 : 
A_1188 -> Type‹r_1187›): L where
| ex0_9
    {m_1191 : A_1188} (n_1192 : ((B_1189) m_1191))
    : (exists0_6‹s_1186,r_1187› A_1188 B_1189)

#[program]
inductive exists1_7‹s_1193,r_1194› (A_1195 : Type‹s_1193›) (B_1196 : 
A_1195 -> Type‹r_1194›): L where
| ex1_10
    (m_1198 : A_1195) (n_1199 : ((B_1196) m_1198))
    : (exists1_7‹s_1193,r_1194› A_1195 B_1196)

#[program]
def xor_1‹› : bool_3 -> bool_3 -o bool_3 :=
  function xor_1202 : bool_3 -> bool_3 -o bool_3
  | true_3 true_3 => false_4
  | false_4 false_4 => false_4
  | _1205 _1206 => true_3

#[logical]
extern proto_2‹› : U

#[logical]
extern act0_3‹s_1207› :
  bool_3 -> ∀ (A_1209 : Type‹s_1207›) -> A_1209 -> proto_2 -> proto_2

#[logical]
extern act1_4‹s_1212› :
  bool_3 -> ∀ (A_1214 : Type‹s_1212›) -> A_1214 -> proto_2 -> proto_2

#[logical]
extern endp_5‹› : proto_2

#[logical]
extern ch_6‹› : bool_3 -> proto_2 -> L

#[program]
extern close_7‹› :
  ∀ {b_1219 : bool_3} -> ((ch_6) b_1219 endp_5) -> IO unit_2

#[program]
extern send0_8‹s_1221› :
  ∀ {b1_1222 : bool_3} ->
    ∀ {b2_1223 : bool_3} ->
      ∀ {A_1224 : Type‹s_1221›} ->
        ∀ {B_1225 : A_1224 -> proto_2} ->
          {(eq_1‹U› bool_3 ((xor_1) b1_1222 b2_1223) false_4)} ->
            ((ch_6) b1_1222 ((act0_3‹s_1221›) b2_1223 A_1224 B_1225)) ->
              ∀ {x_1229 : A_1224} -o IO ((ch_6) b1_1222 ((B_1225) x_1229))

#[program]
extern send1_9‹s_1230› :
  ∀ {b1_1231 : bool_3} ->
    ∀ {b2_1232 : bool_3} ->
      ∀ {A_1233 : Type‹s_1230›} ->
        ∀ {B_1234 : A_1233 -> proto_2} ->
          {(eq_1‹U› bool_3 ((xor_1) b1_1231 b2_1232) false_4)} ->
            ((ch_6) b1_1231 ((act1_4‹s_1230›) b2_1232 A_1233 B_1234)) ->
              ∀ (x_1238 : A_1233) -o IO ((ch_6) b1_1231 ((B_1234) x_1238))

#[program]
extern recv0_10‹s_1239› :
  ∀ {b1_1240 : bool_3} ->
    ∀ {b2_1241 : bool_3} ->
      ∀ {A_1242 : Type‹s_1239›} ->
        ∀ {B_1243 : A_1242 -> proto_2} ->
          {(eq_1‹U› bool_3 ((xor_1) b1_1240 b2_1241) false_4)} ->
            ((ch_6) b1_1240 ((act0_3‹s_1239›) b2_1241 A_1242 B_1243)) ->
              IO (exists0_6‹s_1239,L›
                   A_1242
                   function _1247 : A_1242 -> L
                   | x_1249 => ((ch_6) b1_1240 ((B_1243) x_1249)))

#[program]
extern recv1_11‹s_1250› :
  ∀ {b1_1251 : bool_3} ->
    ∀ {b2_1252 : bool_3} ->
      ∀ {A_1253 : Type‹s_1250›} ->
        ∀ {B_1254 : A_1253 -> proto_2} ->
          {(eq_1‹U› bool_3 ((xor_1) b1_1251 b2_1252) false_4)} ->
            ((ch_6) b1_1251 ((act1_4‹s_1250›) b2_1252 A_1253 B_1254)) ->
              IO (exists1_7‹s_1250,L›
                   A_1253
                   function _1258 : A_1253 -> L
                   | x_1260 => ((ch_6) b1_1251 ((B_1254) x_1260)))

#[program]
extern c_12‹› :
  ((ch_6)
    true_3
    ((act1_4‹U›)
      true_3 nat_4 function _1261 : nat_4 -> proto_2
                   | x_1263 => endp_5))

#[program]
def main_13‹› : IO unit_2 :=
  let* c_1264 :=
    ((send1_9‹U›)
      true_3 true_3 nat_4
      function _1265 : nat_4 -> proto_2
      | x_1267 => endp_5 refl_1‹U› c_12 zero_5)
  in ((close_7) true_3 c_1264)

-----------------------------------------

  warning - pruned constructor consLL_14 trans12.Logical.assert_sort
  warning - pruned constructor consLU_16 trans12.Logical.assert_sort
  warning - pruned constructor consUL_18 trans12.Logical.assert_sort
  warning - pruned constructor consUU_20 trans12.Logical.assert_sort
#[logical]
inductive eqU_9 where
| reflU_12 of layout[]

#[logical]
inductive eqL_8 where
| reflL_11 of layout[]

#[program]
inductive unit_2 where
| tt_2 of layout[]

#[program]
inductive bool_3 where
| true_3 of layout[]
| false_4 of layout[]

#[program]
inductive nat_4 where
| zero_5 of layout[]
| succ_6 of layout[R]

#[program]
inductive listUU_13 where
| nilUU_19 of layout[]

#[program]
inductive listUL_12 where
| nilUL_17 of layout[]

#[program]
inductive listLU_11 where
| nilLU_15 of layout[]

#[program]
inductive listLL_10 where
| nilLL_13 of layout[]

#[program]
inductive exists0UU_17 where
| ex0UU_24 of layout[N, R]

#[program]
inductive exists0UL_16 where
| ex0UL_23 of layout[N, R]

#[program]
inductive exists0LU_15 where
| ex0LU_22 of layout[N, R]

#[program]
inductive exists0LL_14 where
| ex0LL_21 of layout[N, R]

#[program]
inductive exists1UU_21 where
| ex1UU_28 of layout[R, R]

#[program]
inductive exists1UL_20 where
| ex1UL_27 of layout[R, R]

#[program]
inductive exists1LU_19 where
| ex1LU_26 of layout[R, R]

#[program]
inductive exists1LL_18 where
| ex1LL_25 of layout[R, R]

#[program]
def xor_1 :=
  fun xor_1560 (__1561, __1562) =>
    match __1561 with
    | true_3  =>
      match __1562 with
      | true_3  => false_4 | false_4  => true_3
      end
    | false_4  =>
      match __1562 with
      | true_3  => true_3 | false_4  => false_4
      end
    end

#[logical]
extern proto_2

#[logical]
extern act0U_15

#[logical]
extern act0L_14

#[logical]
extern act1U_17

#[logical]
extern act1L_16

#[logical]
extern endp_5

#[logical]
extern ch_6

#[program]
extern close_7

#[program]
extern send0U_19

#[program]
extern send0L_18

#[program]
extern send1U_21

#[program]
extern send1L_20

#[program]
extern recv0U_23

#[program]
extern recv0L_22

#[program]
extern recv1U_25

#[program]
extern recv1L_24

#[program]
extern c_12

#[program]
def main :=
  let* c_1563 := ((send1U_21) NULL NULL NULL NULL NULL c_12 zero_5) in
  ((close_7) NULL c_1563)

-----------------------------------------

#[logical]
inductive eqU_9 where
| reflU_12 of layout[]

#[logical]
inductive eqL_8 where
| reflL_11 of layout[]

#[program]
inductive unit_2 where
| tt_2 of layout[]

#[program]
inductive bool_3 where
| true_3 of layout[]
| false_4 of layout[]

#[program]
inductive nat_4 where
| zero_5 of layout[]
| succ_6 of layout[R]

#[program]
inductive listUU_13 where
| nilUU_19 of layout[]

#[program]
inductive listUL_12 where
| nilUL_17 of layout[]

#[program]
inductive listLU_11 where
| nilLU_15 of layout[]

#[program]
inductive listLL_10 where
| nilLL_13 of layout[]

#[program]
inductive exists0UU_17 where
| ex0UU_24 of layout[N, R]

#[program]
inductive exists0UL_16 where
| ex0UL_23 of layout[N, R]

#[program]
inductive exists0LU_15 where
| ex0LU_22 of layout[N, R]

#[program]
inductive exists0LL_14 where
| ex0LL_21 of layout[N, R]

#[program]
inductive exists1UU_21 where
| ex1UU_28 of layout[R, R]

#[program]
inductive exists1UL_20 where
| ex1UL_27 of layout[R, R]

#[program]
inductive exists1LU_19 where
| ex1LU_26 of layout[R, R]

#[program]
inductive exists1LL_18 where
| ex1LL_25 of layout[R, R]

#[program]
def xor_1 :=
  fun xor_1568 (__1569, __1570) =>
    match __1569 with
    | true_3  =>
      match __1570 with
      | true_3  => false_4 | false_4  => true_3
      end
    | false_4  =>
      match __1570 with
      | true_3  => true_3 | false_4  => false_4
      end
    end

#[logical]
extern proto_2

#[logical]
extern act0U_15

#[logical]
extern act0L_14

#[logical]
extern act1U_17

#[logical]
extern act1L_16

#[logical]
extern endp_5

#[logical]
extern ch_6

#[program]
extern close_7

#[program]
extern send0U_19

#[program]
extern send0L_18

#[program]
extern send1U_21

#[program]
extern send1L_20

#[program]
extern recv0U_23

#[program]
extern recv0L_22

#[program]
extern recv1U_25

#[program]
extern recv1L_24

#[program]
extern c_12

#[program]
def main :=
  let* c_1571 := ((send1U_21) NULL NULL NULL NULL NULL c_12 zero_5) in
  ((close_7) NULL c_1571)

-----------------------------------------

