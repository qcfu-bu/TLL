[Inductive {name = "unit"; relv = R;
   body =
   (Binder (["s"],
      (PBase
         ((TBase (Type (SId "s"))),
          [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
      ));
   view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "stream_node"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type L)),
                 [(DConstr ("stream_nil",
                     (TBase (App [(Id ("stream_node", I)); (Id ("A", I))])),
                     []));
                   (DConstr ("stream_cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (Pi (R, L, (Id ("bool", I)),
                                  (Binder ("b",
                                     (Match ([(R, (Id ("b", I)), None)],
                                        None,
                                        [([(PId "true")],
                                          (Some (App
                                                   [(Id ("stream_node", I));
                                                     (Id ("A", I))])));
                                          ([(PId "false")],
                                           (Some (Id ("unit", I))))
                                          ]
                                        ))
                                     ))
                                  )),
                               (Binder ("tl",
                                  (TBase
                                     (App
                                        [(Id ("stream_node", I));
                                          (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Definition {name = "stream"; relv = N;
    body =
    (Binder (["s"],
       ((Fun ((Pi (R, U, (Type (SId "s")), (Binder ("A", IMeta)))),
           (Binder ((Some "stream"),
              [([(PId "A")],
                (Some (Pi (R, L, (Id ("bool", I)),
                         (Binder ("b",
                            (Match ([(R, (Id ("b", I)), None)], None,
                               [([(PId "true")],
                                 (Some (App
                                          [(Id ("stream_node", I));
                                            (Id ("A", I))])));
                                 ([(PId "false")], (Some (Id ("unit", I))))]
                               ))
                            ))
                         ))))
                ]
              )),
           [E])),
        (Pi (R, U, (Type (SId "s")), (Binder ("A", IMeta)))))
       ));
    view = [E]};
  Definition {name = "free_stream"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (App [(Id ("stream", I)); (Id ("A", I))]),
                    (Binder ("st", (Inst ("unit", [U], I))))))
                 ))
              )),
           (Binder ((Some "free_stream"),
              [([(PId "A"); (PId "st")],
                (Some (Match (
                         [(R, (App [(Id ("st", I)); (Id ("false", I))]), None)
                           ],
                         None, [([(PId "tt")], (Some (Id ("tt", I))))]))))
                ]
              )),
           [I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (R, U, (App [(Id ("stream", I)); (Id ("A", I))]),
                 (Binder ("st", (Inst ("unit", [U], I))))))
              ))
           )))
       ));
    view = [I; E]};
  Definition {name = "stream_succ"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (App [(Id ("stream", I)); (Id ("nat", I))]),
              (Binder ("xs", (App [(Id ("stream", I)); (Id ("nat", I))]))))),
           (Binder ((Some "stream_succ"),
              [([(PId "xs")],
                (Some (Fun (IMeta,
                         (Binder (None,
                            [([(PId "true")],
                              (Some (Match (
                                       [(R,
                                         (App
                                            [(Id ("xs", I)); (Id ("true", I))
                                              ]),
                                         None)],
                                       None,
                                       [([(PId "stream_nil")],
                                         (Some (Id ("stream_nil", I))));
                                         ([(PConstr ("stream_cons",
                                              [(PId "hd"); (PId "tl")]))
                                            ],
                                          (Some (App
                                                   [(Id ("stream_cons", I));
                                                     (App
                                                        [(Id ("succ", I));
                                                          (Id ("hd", I))]);
                                                     (App
                                                        [(Id ("stream_succ",
                                                            I));
                                                          (Id ("tl", I))])
                                                     ])))
                                         ]
                                       ))));
                              ([(PId "false")],
                               (Some (App [(Id ("xs", I)); (Id ("false", I))])))
                              ]
                            )),
                         []))))
                ]
              )),
           [E])),
        (Pi (R, U, (App [(Id ("stream", I)); (Id ("nat", I))]),
           (Binder ("xs", (App [(Id ("stream", I)); (Id ("nat", I))]))))))
       ));
    view = [E]};
  Definition {name = "nat_make"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("n", (App [(Id ("stream", I)); (Id ("nat", I))]))))),
           (Binder ((Some "nat_make"),
              [([(PId "n")],
                (Some (Fun (IMeta,
                         (Binder (None,
                            [([(PId "true")],
                              (Some (App
                                       [(Id ("stream_cons", I));
                                         (Id ("n", I));
                                         (App
                                            [(Id ("nat_make", I));
                                              (App
                                                 [(Id ("succ", I));
                                                   (Id ("n", I))])
                                              ])
                                         ])));
                              ([(PId "false")], (Some (Id ("tt", I))))]
                            )),
                         []))))
                ]
              )),
           [E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("n", (App [(Id ("stream", I)); (Id ("nat", I))]))))))
       ));
    view = [E]};
  Definition {name = "nat_stream"; relv = R;
    body =
    (Binder ([], ((App [(Id ("nat_make", I)); (Id ("zero", I))]), IMeta)));
    view = []};
  Definition {name = "snat_stream"; relv = R;
    body =
    (Binder ([],
       ((App [(Id ("stream_succ", I)); (Id ("nat_stream", I))]), IMeta)));
    view = []};
  Definition {name = "_"; relv = R;
    body =
    (Binder ([],
       ((App [(Id ("free_stream", I)); (Id ("snat_stream", I))]), IMeta)));
    view = []}
  ]

-----------------------------------------

#[program]
inductive unit_1‹s_42› : Type‹s_42› where
| tt_1 : unit_1‹??_1›

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_43 : nat_3) : nat_3

#[program]
inductive stream_node_4‹s_44› (A_45 : Type‹s_44›): L where
| stream_nil_6 : (stream_node_4‹??_2› A_45)
| stream_cons_7
    (hd_46 : A_45)
    (tl_47 : ∀ (b_48 : bool_2) -o
               match b_48 in ∀ (_49 : ?_1) -o ?_2 with
               | true_2 => (stream_node_4‹??_3› A_45)
               | false_3 => unit_1‹??_4›)
    : (stream_node_4‹??_5› A_45)

#[logical]
def stream_1‹s_50› : ∀ (A_51 : Type‹s_50›) -> ?_6 :=
  function stream_52 : ∀ (A_53 : Type‹s_50›) -> ?_3
  | A_54 =>
    ∀ (b_55 : bool_2) -o
      match b_55 in ∀ (_56 : ?_4) -o ?_5 with
      | true_2 => (stream_node_4‹??_6› A_54)
      | false_3 => unit_1‹??_7›

#[program]
def free_stream_2‹s_57› :
  ∀ {A_58 : Type‹s_57›} ->
    ((stream_1‹??_10›) A_58) -> unit_1‹U›
:=
  function free_stream_60 :
    ∀ {A_61 : Type‹s_57›} ->
      ((stream_1‹??_8›) A_61) -> unit_1‹U›
  | A_63 st_64 =>
    match ((st_64) false_3) in ∀ (_65 : ?_7) -o ?_8 with
    | tt_1 => tt_1‹??_9›

#[program]
def stream_succ_3‹› :
  ((stream_1‹??_15›) nat_3) -> ((stream_1‹??_16›) nat_3)
:=
  function stream_succ_67 :
    ((stream_1‹??_11›) nat_3) -> ((stream_1‹??_12›) nat_3)
  | xs_69 =>
    function _70 : ?_9
    | true_2 =>
      match ((xs_69) true_2) in ∀ (_71 : ?_10) -o ?_11 with
      | stream_nil_6 => stream_nil_6‹??_13›
      | (stream_cons_7 hd_72 tl_73) =>
        (stream_cons_7‹??_14›
          (succ_5‹› hd_72) ((stream_succ_67) tl_73))
    | false_3 => ((xs_69) false_3)

#[program]
def nat_make_4‹› : nat_3 -> ((stream_1‹??_20›) nat_3) :=
  function nat_make_75 : nat_3 -> ((stream_1‹??_17›) nat_3)
  | n_77 =>
    function _78 : ?_14
    | true_2 =>
      (stream_cons_7‹??_18› n_77 ((nat_make_75) (succ_5‹› n_77)))
    | false_3 => tt_1‹??_19›

#[program]
def nat_stream_5‹› : ?_16 := ((nat_make_4) zero_4)

#[program]
def snat_stream_6‹› : ?_17 := ((stream_succ_3) nat_stream_5)

#[program]
def __7‹› : ?_19 := ((free_stream_2‹??_21›) ?_18 snat_stream_6)

-----------------------------------------

inductive-------------------------
infer_tm(unit_1‹??_1›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_81
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(bool_2)
infer_tm(bool_2)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_84
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(nat_3)
infer_tm(nat_3)
infer_tm(nat_3)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_86
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(Type‹s_88›)
infer_tm(Type‹s_90›)
assert_equal1( A_91, A_91)
assert_equal1_ok( A_91, A_91)
infer_tm((stream_node_4‹??_2› A_91))
check_tm( A_91, Type‹??_2›)
infer_tm(A_91)
assert_equal1( Type‹??_2›, Type‹s_90›)
assert_equal1_extend( Type‹??_2›, Type‹s_90›)
simpl_tm ~expand:false( Type‹??_2›, Type‹s_90›)
infer_tm(Type‹s_92›)
infer_tm(A_93)
infer_tm(∀ (b_96 : bool_2) -o
           match b_96 in ∀ (_97 : ?_1) -o ?_2 with
           | true_2 => (stream_node_4‹??_3› A_93)
           | false_3 => unit_1‹??_4›)
infer_tm(bool_2)
infer_tm(match b_98 in ∀ (_99 : ?_1) -o ?_2 with
         | true_2 => (stream_node_4‹??_3› A_93)
         | false_3 => unit_1‹??_4›)
infer_motive(b_98 : ?_1)
infer_tm(?_1)
delay_assert(?_20, ??_22)
check_tm( b_98, ?_1)
infer_tm(b_98)
assert_equal1( ?_1, bool_2)
assert_equal1_extend( ?_1, bool_2)
infer_tm(?_2)
simpl_tm ~expand:false( ?_1, bool_2)
simpl_tm ~expand:false( ?_20, Type‹??_22›)
delay_assert(?_21, ??_23)
simpl_tm ~expand:false( ?_21, Type‹??_23›)
check_cls {|
  prblm {| ;
    {|  ::: [true_2] =>? (stream_node_4‹??_3› A_93) |}
    {|  ::: [false_3] =>? unit_1‹??_4› |}
  |}
  a := ∀ (_101 : bool_2) -o ?_2
|}
case_intro
case_introed(_102 : bool_2)
case_splitting
splitting_on(true_2)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2);
    {|  ::: [] =>? (stream_node_4‹??_3› A_93) |}
  |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( (stream_node_4‹??_3› A_93), ?_2)
check_tm( (stream_node_4‹??_3› A_93), ?_2)
infer_tm((stream_node_4‹??_3› A_93))
check_tm( A_93, Type‹??_3›)
infer_tm(A_93)
assert_equal1( Type‹??_3›, Type‹s_92›)
assert_equal1_extend( Type‹??_3›, Type‹s_92›)
assert_equal1( ?_2, L)
assert_equal1_extend( ?_2, L)
splitting_on(false_3)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2); {|  ::: [] =>? unit_1‹??_4› |} |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( unit_1‹??_4›, ?_2)
check_tm( unit_1‹??_4›, ?_2)
infer_tm(unit_1‹??_4›)
assert_equal1( ?_2, Type‹??_4›)
assert_equal1_extend( ?_2, Type‹??_4›)
simpl_tm ~expand:false( ?_2, Type‹??_4›)
simpl_tm ~expand:false( Type‹??_4›, L)
simpl_tm ~expand:false( Type‹??_3›, Type‹s_92›)
assert_equal1( A_93, A_93)
assert_equal1_ok( A_93, A_93)
infer_tm((stream_node_4‹??_5› A_93))
check_tm( A_93, Type‹??_5›)
infer_tm(A_93)
assert_equal1( Type‹??_5›, Type‹s_92›)
assert_equal1_extend( Type‹??_5›, Type‹s_92›)
simpl_tm ~expand:false( Type‹??_5›, Type‹s_92›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_104
    ??_2 <= s_105
    ??_3 <= s_106
    ??_4 <= L
    ??_5 <= s_108
    
  |}
  imeta_meta {|
    ?_1 <= bool_2
    ?_2 <= Type‹??_4›
    ?_20 <= Type‹??_22›
    ?_21 <= Type‹??_23›
    
  |}
  eqns {|
    
  |}
end_dump
infer_tm(Type‹??_22›)
check_tm( bool_2, Type‹??_22›)
infer_tm(bool_2)
assert_equal1( Type‹??_22›, U)
assert_equal1_extend( Type‹??_22›, U)
simpl_tm ~expand:false( Type‹??_22›, U)
infer_tm(Type‹??_23›)
check_tm( L, Type‹??_23›)
infer_tm(L)
assert_equal1( Type‹??_23›, U)
assert_equal1_extend( Type‹??_23›, U)
simpl_tm ~expand:false( Type‹??_23›, U)
----------------------------------

definition-------------------------
infer_tm(∀ (A_145 : Type‹s_144›) -> ?_6)
infer_tm(Type‹s_144›)
infer_tm(?_6)
delay_assert(?_22, ??_24)
simpl_tm ~expand:false( ?_22, Type‹??_24›)
check_tm(
  function stream_147 : ∀ (A_148 : Type‹s_144›) -> ?_3
  | A_149 =>
    ∀ (b_150 : bool_2) -o
      match b_150 in ∀ (_151 : ?_4) -o ?_5 with
      | true_2 => (stream_node_4‹??_6› A_149)
      | false_3 => unit_1‹??_7›,
  ∀ (A_152 : Type‹s_144›) -> ?_6)
infer_tm(∀ (A_154 : Type‹s_144›) -> ?_3)
infer_tm(Type‹s_144›)
infer_tm(?_3)
delay_assert(?_23, ??_25)
simpl_tm ~expand:false( ?_23, Type‹??_25›)
assert_equal1( ∀ (A_156 : Type‹s_144›) -> ?_6,
  ∀ (A_157 : Type‹s_144›) -> ?_3)
assert_equal1_extend( ∀ (A_162 : Type‹s_144›) -> ?_6,
  ∀ (A_163 : Type‹s_144›) -> ?_3)
simpl_tm ~expand:false( ∀ (A_167 : Type‹s_144›) -> ?_6,
  ∀ (A_168 : Type‹s_144›) -> ?_3)
simpl_tm ~expand:false( Type‹s_144›, Type‹s_144›)
simpl_tm ~expand:false( ?_6, ?_3)
check_cls {|
  prblm {| ;
    {|  ::: [A_164] =>?
         ∀ (b_171 : bool_2) -o
           match b_171 in ∀ (_172 : ?_4) -o ?_5 with
           | true_2 => (stream_node_4‹??_6› #A_164)
           | false_3 => unit_1‹??_7›
    |}
  |}
  a := ∀ (A_173 : Type‹s_144›) -> ?_3
|}
case_intro
case_introed(A_174 : Type‹s_144›)
case_coverage{|
  prblm {| ;
    {| eq_pat?( #A_174, A_164 : Type‹s_144›) ::: [] =>?
         ∀ (b_175 : bool_2) -o
           match b_175 in ∀ (_176 : ?_4) -o ?_5 with
           | true_2 => (stream_node_4‹??_6› #A_164)
           | false_3 => unit_1‹??_7›
    |}
  |}
|}
unify_local( eq_pat?( #A_174, A_164 : Type‹s_144›) )
unify_global(  )
simpl_pprbm ~expand:false( #A_174, #A_164)
case_coverage_ok(
  ∀ (b_181 : bool_2) -o
    match b_181 in ∀ (_182 : ?_4) -o ?_5 with
    | true_2 => (stream_node_4‹??_6› A_174)
    | false_3 => unit_1‹??_7›,
  ?_3)
check_tm(
  ∀ (b_183 : bool_2) -o
    match b_183 in ∀ (_184 : ?_4) -o ?_5 with
    | true_2 => (stream_node_4‹??_6› A_174)
    | false_3 => unit_1‹??_7›,
  ?_3)
infer_tm(∀ (b_185 : bool_2) -o
           match b_185 in ∀ (_186 : ?_4) -o ?_5 with
           | true_2 => (stream_node_4‹??_6› A_174)
           | false_3 => unit_1‹??_7›)
infer_tm(bool_2)
infer_tm(match b_187 in ∀ (_188 : ?_4) -o ?_5 with
         | true_2 => (stream_node_4‹??_6› A_174)
         | false_3 => unit_1‹??_7›)
infer_motive(b_187 : ?_4)
infer_tm(?_4)
delay_assert(?_24, ??_26)
check_tm( b_187, ?_4)
infer_tm(b_187)
assert_equal1( ?_4, bool_2)
assert_equal1_extend( ?_4, bool_2)
infer_tm(?_5)
simpl_tm ~expand:false( ?_4, bool_2)
simpl_tm ~expand:false( ?_24, Type‹??_26›)
delay_assert(?_25, ??_27)
simpl_tm ~expand:false( ?_25, Type‹??_27›)
check_cls {|
  prblm {| ;
    {|  ::: [true_2] =>? (stream_node_4‹??_6› A_174) |}
    {|  ::: [false_3] =>? unit_1‹??_7› |}
  |}
  a := ∀ (_190 : bool_2) -o ?_5
|}
case_intro
case_introed(_191 : bool_2)
case_splitting
splitting_on(true_2)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2);
    {|  ::: [] =>? (stream_node_4‹??_6› A_174) |}
  |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( (stream_node_4‹??_6› A_174), ?_5)
check_tm( (stream_node_4‹??_6› A_174), ?_5)
infer_tm((stream_node_4‹??_6› A_174))
check_tm( A_174, Type‹??_6›)
infer_tm(A_174)
assert_equal1( Type‹??_6›, Type‹s_144›)
assert_equal1_extend( Type‹??_6›, Type‹s_144›)
assert_equal1( ?_5, L)
assert_equal1_extend( ?_5, L)
splitting_on(false_3)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2); {|  ::: [] =>? unit_1‹??_7› |} |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( unit_1‹??_7›, ?_5)
check_tm( unit_1‹??_7›, ?_5)
infer_tm(unit_1‹??_7›)
assert_equal1( ?_5, Type‹??_7›)
assert_equal1_extend( ?_5, Type‹??_7›)
simpl_tm ~expand:false( ?_5, Type‹??_7›)
simpl_tm ~expand:false( Type‹??_7›, L)
simpl_tm ~expand:false( Type‹??_6›, Type‹s_144›)
assert_equal1( ?_3, L)
assert_equal1_extend( ?_3, L)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_197
    ??_2 <= s_198
    ??_3 <= s_199
    ??_4 <= L
    ??_5 <= s_201
    ??_6 <= s_202
    ??_7 <= L
    ??_22 <= U
    ??_23 <= U
    
  |}
  imeta_meta {|
    ?_1 <= bool_2
    ?_2 <= Type‹??_4›
    ?_4 <= bool_2
    ?_5 <= Type‹??_7›
    ?_6 <= ?_3
    ?_20 <= Type‹??_22›
    ?_21 <= Type‹??_23›
    ?_22 <= Type‹??_24›
    ?_23 <= Type‹??_25›
    ?_24 <= Type‹??_26›
    ?_25 <= Type‹??_27›
    
  |}
  eqns {|
    equal_tm? (?_3, L)
  |}
end_dump
simpl_tm ~expand:false( ?_3, L)
infer_tm(Type‹??_25›)
check_tm( L, Type‹??_25›)
infer_tm(L)
assert_equal1( Type‹??_25›, U)
assert_equal1_extend( Type‹??_25›, U)
simpl_tm ~expand:false( Type‹??_25›, U)
infer_tm(Type‹??_26›)
check_tm( bool_2, Type‹??_26›)
infer_tm(bool_2)
assert_equal1( Type‹??_26›, U)
assert_equal1_extend( Type‹??_26›, U)
simpl_tm ~expand:false( Type‹??_26›, U)
infer_tm(Type‹??_27›)
check_tm( L, Type‹??_27›)
infer_tm(L)
assert_equal1( Type‹??_27›, U)
assert_equal1_extend( Type‹??_27›, U)
simpl_tm ~expand:false( Type‹??_27›, U)
infer_tm(Type‹??_24›)
check_tm( L, Type‹??_24›)
infer_tm(L)
assert_equal1( Type‹??_24›, U)
assert_equal1_extend( Type‹??_24›, U)
simpl_tm ~expand:false( Type‹??_24›, U)
----------------------------------

definition-------------------------
infer_tm(∀ {A_255 : Type‹s_254›} ->
           ((stream_1‹??_10›) A_255) -> unit_1‹U›)
infer_tm(Type‹s_254›)
infer_tm(((stream_1‹??_10›) A_257) -> unit_1‹U›)
infer_tm(((stream_1‹??_10›) A_257))
infer_tm(stream_1‹??_10›)
check_tm( A_257, Type‹??_10›)
infer_tm(A_257)
assert_equal1( Type‹??_10›, Type‹s_254›)
assert_equal1_extend( Type‹??_10›, Type‹s_254›)
simpl_tm ~expand:false( Type‹??_10›, Type‹s_254›)
infer_tm(unit_1‹U›)
check_tm(
  function free_stream_261 :
    ∀ {A_262 : Type‹s_254›} ->
      ((stream_1‹??_8›) A_262) -> unit_1‹U›
  | A_264 st_265 =>
    match ((st_265) false_3) in ∀ (_266 : ?_7) -o ?_8 with
    | tt_1 => tt_1‹??_9›,
  ∀ {A_267 : Type‹s_254›} ->
    ((stream_1‹??_10›) A_267) -> unit_1‹U›)
infer_tm(∀ {A_270 : Type‹s_254›} ->
           ((stream_1‹??_8›) A_270) -> unit_1‹U›)
infer_tm(Type‹s_254›)
infer_tm(((stream_1‹??_8›) A_272) -> unit_1‹U›)
infer_tm(((stream_1‹??_8›) A_272))
infer_tm(stream_1‹??_8›)
check_tm( A_272, Type‹??_8›)
infer_tm(A_272)
assert_equal1( Type‹??_8›, Type‹s_254›)
assert_equal1_extend( Type‹??_8›, Type‹s_254›)
simpl_tm ~expand:false( Type‹??_8›, Type‹s_254›)
infer_tm(unit_1‹U›)
assert_equal1(
  ∀ {A_276 : Type‹s_254›} ->
    ((stream_1‹??_10›) A_276) -> unit_1‹U›,
  ∀ {A_278 : Type‹s_254›} ->
    ((stream_1‹??_8›) A_278) -> unit_1‹U›)
assert_equal1_extend(
  ∀ {A_285 : Type‹s_254›} ->
    ((stream_1‹??_10›) A_285) -> unit_1‹U›,
  ∀ {A_287 : Type‹s_254›} ->
    ((stream_1‹??_8›) A_287) -> unit_1‹U›)
simpl_tm ~expand:false(
  ∀ {A_295 : Type‹s_254›} ->
    ((stream_1‹s_254›) A_295) -> unit_1‹U›,
  ∀ {A_297 : Type‹s_254›} ->
    ((stream_1‹s_254›) A_297) -> unit_1‹U›)
simpl_tm ~expand:false( Type‹s_254›, Type‹s_254›)
simpl_tm ~expand:false( ((stream_1‹s_254›) A_299) -> unit_1‹U›,
  ((stream_1‹s_254›) A_299) -> unit_1‹U›)
simpl_tm ~expand:false( ((stream_1‹s_254›) A_299),
  ((stream_1‹s_254›) A_299))
simpl_tm ~expand:false( stream_1‹s_254›, stream_1‹s_254›)
simpl_tm ~expand:false( A_299, A_299)
simpl_tm ~expand:false( unit_1‹U›, unit_1‹U›)
check_cls {|
  prblm {| ;
    {|  ::: [A_289, st_290] =>?
         match ((#st_290) false_3) in ∀ (_305 : ?_7) -o ?_8 with
         | tt_1 => tt_1‹??_9›
    |}
  |}
  a := ∀ {A_306 : Type‹s_254›} ->
         ((stream_1‹s_254›) A_306) -> unit_1‹U›
|}
case_intro
case_introed(A_308 : Type‹s_254›)
case_intro
case_introed(st_309 : ((stream_1‹s_254›) #A_308))
case_coverage{|
  prblm {| ;
    {| eq_pat?( #A_308, A_289 : Type‹s_254›)
       eq_pat?( #st_309, st_290 : ((stream_1‹s_254›) #A_308)) ::: [] =>?
         match ((#st_290) false_3) in ∀ (_310 : ?_7) -o ?_8 with
         | tt_1 => tt_1‹??_9›
    |}
  |}
|}
unify_local(
  eq_pat?( #A_308, A_289 : Type‹s_254›)
  eq_pat?( #st_309, st_290 : ((stream_1‹s_254›) #A_308))
)
unify_global(  )
simpl_pprbm ~expand:false( #A_308, #A_289)
simpl_pprbm ~expand:false( #st_309, #st_290)
case_coverage_ok(
  match ((st_309) false_3) in ∀ (_314 : ?_7) -o ?_8 with
  | tt_1 => tt_1‹??_9›, unit_1‹U›)
check_tm(
  match ((st_309) false_3) in ∀ (_315 : ?_7) -o ?_8 with
  | tt_1 => tt_1‹??_9›, unit_1‹U›)
infer_tm(match ((st_309) false_3) in ∀ (_316 : ?_7) -o ?_8 with
         | tt_1 => tt_1‹??_9›)
infer_motive(((st_309) false_3) : ?_7)
infer_tm(?_7)
delay_assert(?_26, ??_28)
check_tm( ((st_309) false_3), ?_7)
infer_tm(((st_309) false_3))
infer_tm(st_309)
simpl_tm ~expand:false( ?_26, Type‹??_28›)
check_tm( false_3, bool_2)
infer_tm(false_3)
assert_equal1( bool_2, bool_2)
assert_equal1_ok( bool_2, bool_2)
assert_equal1( ?_7,
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹s_254› A_308)
  | false_3 => unit_1‹L›)
assert_equal1_extend( ?_7,
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹s_254› A_308)
  | false_3 => unit_1‹L›)
infer_tm(?_8)
simpl_tm ~expand:false( ?_7, unit_1‹L›)
delay_assert(?_27, ??_29)
simpl_tm ~expand:false( ?_27, Type‹??_29›)
check_cls {|
  prblm {| ; {|  ::: [tt_1] =>? tt_1‹??_9› |} |}
  a := ∀ (_321 : unit_1‹L›) -o ?_8
|}
case_intro
case_introed(_322 : unit_1‹L›)
case_splitting
splitting_on(tt_1)
case_coverage{|
  prblm {| eq_term?( unit_1‹L›, unit_1‹L›);
    {|  ::: [] =>? tt_1‹??_9› |}
  |}
|}
unify_local(  )
unify_global( eq_term?( unit_1‹L›, unit_1‹L›) )
simpl_pprbm ~expand:false( unit_1‹L›, unit_1‹L›)
case_coverage_ok( tt_1‹??_9›, ?_8)
check_tm( tt_1‹??_9›, ?_8)
infer_tm(tt_1‹??_9›)
assert_equal1( ?_8, unit_1‹??_9›)
assert_equal1_extend( ?_8, unit_1‹??_9›)
assert_equal1( unit_1‹U›, ?_8)
assert_equal1_extend( unit_1‹U›, ?_8)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_327
    ??_2 <= s_328
    ??_3 <= s_329
    ??_4 <= L
    ??_5 <= s_331
    ??_6 <= s_332
    ??_7 <= L
    ??_8 <= s_334
    ??_10 <= s_335
    ??_22 <= U
    ??_23 <= U
    ??_24 <= U
    ??_25 <= U
    ??_26 <= U
    ??_27 <= U
    
  |}
  imeta_meta {|
    ?_1 <= bool_2
    ?_2 <= Type‹??_4›
    ?_3 <= L
    ?_4 <= bool_2
    ?_5 <= Type‹??_7›
    ?_6 <= ?_3
    ?_7 <= unit_1‹L›
    ?_20 <= Type‹??_22›
    ?_21 <= Type‹??_23›
    ?_22 <= Type‹??_24›
    ?_23 <= Type‹??_25›
    ?_24 <= Type‹??_26›
    ?_25 <= Type‹??_27›
    ?_26 <= Type‹??_28›
    ?_27 <= Type‹??_29›
    
  |}
  eqns {|
    equal_tm? (unit_1‹U›, ?_8);
    equal_tm? (?_8, unit_1‹??_9›)
  |}
end_dump
simpl_tm ~expand:false( unit_1‹U›, ?_8)
simpl_tm ~expand:false( unit_1‹U›, unit_1‹??_9›)
infer_tm(Type‹??_28›)
check_tm( unit_1‹L›, Type‹??_28›)
infer_tm(unit_1‹L›)
assert_equal1( Type‹??_28›, L)
assert_equal1_extend( Type‹??_28›, L)
simpl_tm ~expand:false( Type‹??_28›, L)
infer_tm(Type‹??_29›)
check_tm( unit_1‹U›, Type‹??_29›)
infer_tm(unit_1‹U›)
assert_equal1( Type‹??_29›, U)
assert_equal1_extend( Type‹??_29›, U)
simpl_tm ~expand:false( Type‹??_29›, U)
----------------------------------

definition-------------------------
infer_tm(((stream_1‹??_15›) nat_3) -> ((stream_1‹??_16›) nat_3))
infer_tm(((stream_1‹??_15›) nat_3))
infer_tm(stream_1‹??_15›)
check_tm( nat_3, Type‹??_15›)
infer_tm(nat_3)
assert_equal1( Type‹??_15›, U)
assert_equal1_extend( Type‹??_15›, U)
simpl_tm ~expand:false( Type‹??_15›, U)
infer_tm(((stream_1‹??_16›) nat_3))
infer_tm(stream_1‹??_16›)
check_tm( nat_3, Type‹??_16›)
infer_tm(nat_3)
assert_equal1( Type‹??_16›, U)
assert_equal1_extend( Type‹??_16›, U)
simpl_tm ~expand:false( Type‹??_16›, U)
check_tm(
  function stream_succ_411 :
    ((stream_1‹??_11›) nat_3) -> ((stream_1‹??_12›) nat_3)
  | xs_413 =>
    function _414 : ?_9
    | true_2 =>
      match ((xs_413) true_2) in ∀ (_415 : ?_10) -o ?_11 with
      | stream_nil_6 => stream_nil_6‹??_13›
      | (stream_cons_7 hd_416 tl_417) =>
        (stream_cons_7‹??_14›
          (succ_5‹› hd_416) ((stream_succ_411) tl_417))
    | false_3 => ((xs_413) false_3),
  ((stream_1‹??_15›) nat_3) -> ((stream_1‹??_16›) nat_3))
infer_tm(((stream_1‹??_11›) nat_3) -> ((stream_1‹??_12›) nat_3))
infer_tm(((stream_1‹??_11›) nat_3))
infer_tm(stream_1‹??_11›)
check_tm( nat_3, Type‹??_11›)
infer_tm(nat_3)
assert_equal1( Type‹??_11›, U)
assert_equal1_extend( Type‹??_11›, U)
simpl_tm ~expand:false( Type‹??_11›, U)
infer_tm(((stream_1‹??_12›) nat_3))
infer_tm(stream_1‹??_12›)
check_tm( nat_3, Type‹??_12›)
infer_tm(nat_3)
assert_equal1( Type‹??_12›, U)
assert_equal1_extend( Type‹??_12›, U)
simpl_tm ~expand:false( Type‹??_12›, U)
assert_equal1(
  ((stream_1‹??_15›) nat_3) -> ((stream_1‹??_16›) nat_3),
  ((stream_1‹??_11›) nat_3) -> ((stream_1‹??_12›) nat_3))
assert_equal1_extend(
  ((stream_1‹??_15›) nat_3) -> ((stream_1‹??_16›) nat_3),
  ((stream_1‹??_11›) nat_3) -> ((stream_1‹??_12›) nat_3))
simpl_tm ~expand:false(
  ((stream_1‹U›) nat_3) -> ((stream_1‹U›) nat_3),
  ((stream_1‹U›) nat_3) -> ((stream_1‹U›) nat_3))
simpl_tm ~expand:false( ((stream_1‹U›) nat_3), ((stream_1‹U›) nat_3))
simpl_tm ~expand:false( stream_1‹U›, stream_1‹U›)
simpl_tm ~expand:false( nat_3, nat_3)
simpl_tm ~expand:false( ((stream_1‹U›) nat_3), ((stream_1‹U›) nat_3))
simpl_tm ~expand:false( stream_1‹U›, stream_1‹U›)
simpl_tm ~expand:false( nat_3, nat_3)
check_cls {|
  prblm {| ;
    {|  ::: [xs_429] =>?
         function _436 : ?_9
         | true_2 =>
           match ((#xs_429) true_2) in ∀ (_437 : ?_10) -o ?_11 with
           | stream_nil_6 => stream_nil_6‹??_13›
           | (stream_cons_7 hd_438 tl_439) =>
             (stream_cons_7‹??_14›
               (succ_5‹› hd_438) ((stream_succ_419) tl_439))
         | false_3 => ((#xs_429) false_3)
    |}
  |}
  a := ((stream_1‹U›) nat_3) -> ((stream_1‹U›) nat_3)
|}
case_intro
case_introed(xs_441 : ((stream_1‹U›) nat_3))
case_coverage{|
  prblm {| ;
    {| eq_pat?( #xs_441, xs_429 : ((stream_1‹U›) nat_3)) ::: [] =>?
         function _442 : ?_9
         | true_2 =>
           match ((#xs_429) true_2) in ∀ (_443 : ?_10) -o ?_11 with
           | stream_nil_6 => stream_nil_6‹??_13›
           | (stream_cons_7 hd_444 tl_445) =>
             (stream_cons_7‹??_14›
               (succ_5‹› hd_444) ((stream_succ_419) tl_445))
         | false_3 => ((#xs_429) false_3)
    |}
  |}
|}
unify_local( eq_pat?( #xs_441, xs_429 : ((stream_1‹U›) nat_3)) )
unify_global(  )
simpl_pprbm ~expand:false( #xs_441, #xs_429)
case_coverage_ok(
  function _454 : ?_9
  | true_2 =>
    match ((xs_441) true_2) in ∀ (_455 : ?_10) -o ?_11 with
    | stream_nil_6 => stream_nil_6‹??_13›
    | (stream_cons_7 hd_456 tl_457) =>
      (stream_cons_7‹??_14›
        (succ_5‹› hd_456) ((stream_succ_419) tl_457))
  | false_3 => ((xs_441) false_3), ((stream_1‹U›) nat_3))
check_tm(
  function _458 : ?_9
  | true_2 =>
    match ((xs_441) true_2) in ∀ (_459 : ?_10) -o ?_11 with
    | stream_nil_6 => stream_nil_6‹??_13›
    | (stream_cons_7 hd_460 tl_461) =>
      (stream_cons_7‹??_14›
        (succ_5‹› hd_460) ((stream_succ_419) tl_461))
  | false_3 => ((xs_441) false_3), ((stream_1‹U›) nat_3))
infer_tm(?_9)
delay_assert(?_28, ??_30)
assert_equal1( ((stream_1‹U›) nat_3), ?_9)
assert_equal1_extend( ((stream_1‹U›) nat_3), ?_9)
simpl_tm ~expand:false( ((stream_1‹U›) nat_3), ?_9)
simpl_tm ~expand:false( ?_28, Type‹??_30›)
check_cls {|
  prblm {| ;
    {|  ::: [true_2] =>?
         match ((xs_441) true_2) in ∀ (_463 : ?_10) -o ?_11 with
         | stream_nil_6 => stream_nil_6‹??_13›
         | (stream_cons_7 hd_464 tl_465) =>
           (stream_cons_7‹??_14›
             (succ_5‹› hd_464) ((stream_succ_419) tl_465))
    |} {|  ::: [false_3] =>? ((xs_441) false_3) |}
  |}
  a := ((stream_1‹U›) nat_3)
|}
case_intro
case_introed(b_466 : bool_2)
case_splitting
splitting_on(true_2)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2);
    {|  ::: [] =>?
         match ((xs_441) true_2) in ∀ (_469 : ?_10) -o ?_11 with
         | stream_nil_6 => stream_nil_6‹??_13›
         | (stream_cons_7 hd_470 tl_471) =>
           (stream_cons_7‹??_14›
             (succ_5‹› hd_470) ((stream_succ_419) tl_471))
    |}
  |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok(
  match ((xs_441) true_2) in ∀ (_477 : ?_10) -o ?_11 with
  | stream_nil_6 => stream_nil_6‹??_13›
  | (stream_cons_7 hd_478 tl_479) =>
    (stream_cons_7‹??_14›
      (succ_5‹› hd_478) ((stream_succ_419) tl_479)),
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
check_tm(
  match ((xs_441) true_2) in ∀ (_481 : ?_10) -o ?_11 with
  | stream_nil_6 => stream_nil_6‹??_13›
  | (stream_cons_7 hd_482 tl_483) =>
    (stream_cons_7‹??_14›
      (succ_5‹› hd_482) ((stream_succ_419) tl_483)),
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
infer_tm(match ((xs_441) true_2) in ∀ (_485 : ?_10) -o ?_11 with
         | stream_nil_6 => stream_nil_6‹??_13›
         | (stream_cons_7 hd_486 tl_487) =>
           (stream_cons_7‹??_14›
             (succ_5‹› hd_486) ((stream_succ_419) tl_487)))
infer_motive(((xs_441) true_2) : ?_10)
infer_tm(?_10)
delay_assert(?_29, ??_31)
check_tm( ((xs_441) true_2), ?_10)
infer_tm(((xs_441) true_2))
infer_tm(xs_441)
simpl_tm ~expand:false( ?_29, Type‹??_31›)
check_tm( true_2, bool_2)
infer_tm(true_2)
assert_equal1( bool_2, bool_2)
assert_equal1_ok( bool_2, bool_2)
assert_equal1( ?_10,
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
assert_equal1_extend( ?_10,
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
infer_tm(?_11)
simpl_tm ~expand:false( ?_10, (stream_node_4‹U› nat_3))
delay_assert(?_30, ??_32)
simpl_tm ~expand:false( ?_30, Type‹??_32›)
check_cls {|
  prblm {| ;
    {|  ::: [stream_nil_6] =>? stream_nil_6‹??_13› |}
    {|  ::: [(stream_cons_7 hd_491 tl_492)] =>?
         (stream_cons_7‹??_14›
           (succ_5‹› #hd_491) ((stream_succ_419) #tl_492))
    |}
  |}
  a := ∀ (_494 : (stream_node_4‹U› nat_3)) -o ?_11
|}
case_intro
case_introed(_495 : (stream_node_4‹U› nat_3))
case_splitting
splitting_on(stream_nil_6)
case_coverage{|
  prblm {|
    eq_term?( (stream_node_4‹U› nat_3), (stream_node_4‹U› nat_3));
    {|  ::: [] =>? stream_nil_6‹??_13› |}
  |}
|}
unify_local(  )
unify_global(
  eq_term?( (stream_node_4‹U› nat_3), (stream_node_4‹U› nat_3))
)
simpl_pprbm ~expand:false( (stream_node_4‹U› nat_3),
  (stream_node_4‹U› nat_3))
simpl_pprbm ~expand:false( nat_3, nat_3)
case_coverage_ok( stream_nil_6‹??_13›, ?_11)
check_tm( stream_nil_6‹??_13›, ?_11)
infer_tm(stream_nil_6‹??_13›)
check_tm( ?_12, Type‹??_13›)
assert_equal1( ?_11, (stream_node_4‹??_13› ?_12))
assert_equal1_extend( ?_11, (stream_node_4‹??_13› ?_12))
splitting_on(stream_cons_7)
case_coverage{|
  prblm {|
    eq_term?( (stream_node_4‹U› nat_3), (stream_node_4‹U› nat_3));
    {| eq_pat?( #hd_498, hd_491 : nat_3)
       eq_pat?( #tl_499, tl_492 :
         ∀ (b_503 : bool_2) -o
           match b_503 in bool_2 -o L with
           | true_2 => (stream_node_4‹U› nat_3)
           | false_3 => unit_1‹L›) ::: [] =>?
         (stream_cons_7‹??_14›
           (succ_5‹› #hd_491) ((stream_succ_419) #tl_492))
    |}
  |}
|}
unify_local(
  eq_pat?( #hd_498, hd_491 : nat_3)
  eq_pat?( #tl_499, tl_492 :
    ∀ (b_505 : bool_2) -o
      match b_505 in bool_2 -o L with
      | true_2 => (stream_node_4‹U› nat_3)
      | false_3 => unit_1‹L›)
)
unify_global(
  eq_term?( (stream_node_4‹U› nat_3), (stream_node_4‹U› nat_3))
)
simpl_pprbm ~expand:false( #hd_498, #hd_491)
simpl_pprbm ~expand:false( #tl_499, #tl_492)
simpl_pprbm ~expand:false( (stream_node_4‹U› nat_3),
  (stream_node_4‹U› nat_3))
simpl_pprbm ~expand:false( nat_3, nat_3)
case_coverage_ok(
  (stream_cons_7‹??_14› (succ_5‹› hd_498) ((stream_succ_419) tl_499)),
  ?_11)
check_tm(
  (stream_cons_7‹??_14› (succ_5‹› hd_498) ((stream_succ_419) tl_499)),
  ?_11)
infer_tm((stream_cons_7‹??_14›
           (succ_5‹› hd_498) ((stream_succ_419) tl_499)))
check_tm( ?_13, Type‹??_14›)
check_tm( (succ_5‹› hd_498), ?_13)
infer_tm((succ_5‹› hd_498))
check_tm( hd_498, nat_3)
infer_tm(hd_498)
assert_equal1( nat_3, nat_3)
assert_equal1_ok( nat_3, nat_3)
assert_equal1( ?_13, nat_3)
assert_equal1_extend( ?_13, nat_3)
check_tm( ((stream_succ_419) tl_499),
  ∀ (b_510 : bool_2) -o
    match b_510 in bool_2 -o L with
    | true_2 => (stream_node_4‹??_14› ?_13)
    | false_3 => unit_1‹L›)
infer_tm(((stream_succ_419) tl_499))
infer_tm(stream_succ_419)
simpl_tm ~expand:false( ?_13, nat_3)
simpl_tm ~expand:false( ?_11, (stream_node_4‹??_13› ?_12))
check_tm( tl_499, ((stream_1‹U›) nat_3))
infer_tm(tl_499)
assert_equal1( ((stream_1‹U›) nat_3),
  ∀ (b_514 : bool_2) -o
    match b_514 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›)
assert_equal1_ok( ((stream_1‹U›) nat_3),
  ∀ (b_518 : bool_2) -o
    match b_518 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›)
assert_equal1(
  ∀ (b_520 : bool_2) -o
    match b_520 in bool_2 -o L with
    | true_2 => (stream_node_4‹??_14› ?_13)
    | false_3 => unit_1‹L›,
  ((stream_1‹U›) nat_3))
assert_equal1_extend(
  ∀ (b_525 : bool_2) -o
    match b_525 in bool_2 -o L with
    | true_2 => (stream_node_4‹??_14› ?_13)
    | false_3 => unit_1‹L›,
  ((stream_1‹U›) nat_3))
assert_equal1( ?_11, (stream_node_4‹??_14› ?_13))
assert_equal1_extend( ?_11, (stream_node_4‹??_14› ?_13))
assert_equal1(
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›, ?_11)
assert_equal1_extend(
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›, ?_11)
splitting_on(false_3)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2); {|  ::: [] =>? ((xs_441) false_3) |} |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( ((xs_441) false_3),
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
check_tm( ((xs_441) false_3),
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
infer_tm(((xs_441) false_3))
infer_tm(xs_441)
simpl_tm ~expand:false( (stream_node_4‹U› nat_3),
  (stream_node_4‹??_13› ?_12))
simpl_tm ~expand:false( nat_3, ?_12)
simpl_tm ~expand:false( nat_3, ?_12)
simpl_tm ~expand:false( (stream_node_4‹U› nat_3),
  (stream_node_4‹??_14› nat_3))
simpl_tm ~expand:false( nat_3, nat_3)
simpl_tm ~expand:false(
  ∀ (b_538 : bool_2) -o
    match b_538 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›,
  ((stream_1‹U›) nat_3))
simpl_tm ~expand:false(
  ∀ (b_540 : bool_2) -o
    match b_540 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›,
  stream_1‹U›)
simpl_tm ~expand:true(
  ∀ (b_542 : bool_2) -o
    match b_542 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›,
  function stream_544 : U -> L
  | A_546 =>
    ∀ (b_547 : bool_2) -o
      match b_547 in bool_2 -o L with
      | true_2 => (stream_node_4‹U› A_546)
      | false_3 => unit_1‹L›)
simpl_tm ~expand:true(
  ∀ (b_556 : bool_2) -o
    match b_556 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›,
  ∀ (b_558 : bool_2) -o
    match b_558 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›)
simpl_tm ~expand:false( bool_2, bool_2)
simpl_tm ~expand:false(
  match b_560 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›,
  match b_560 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
simpl_tm ~expand:false( b_560, b_560)
simpl_tm ~expand:false( bool_2 -o L, bool_2 -o L)
simpl_tm ~expand:false( bool_2, bool_2)
simpl_tm ~expand:false( L, L)
simpl_tm ~expand:false( (stream_node_4‹U› nat_3),
  (stream_node_4‹U› nat_3))
simpl_tm ~expand:false( nat_3, nat_3)
simpl_tm ~expand:false( unit_1‹L›, unit_1‹L›)
check_tm( false_3, bool_2)
infer_tm(false_3)
assert_equal1( bool_2, bool_2)
assert_equal1_ok( bool_2, bool_2)
assert_equal1(
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›,
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
assert_equal1_ok(
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›,
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_571
    ??_2 <= s_572
    ??_3 <= s_573
    ??_4 <= L
    ??_5 <= s_575
    ??_6 <= s_576
    ??_7 <= L
    ??_8 <= s_578
    ??_9 <= U
    ??_10 <= s_580
    ??_11 <= U
    ??_12 <= U
    ??_13 <= U
    ??_14 <= U
    ??_15 <= U
    ??_16 <= U
    ??_22 <= U
    ??_23 <= U
    ??_24 <= U
    ??_25 <= U
    ??_26 <= U
    ??_27 <= U
    ??_28 <= L
    ??_29 <= U
    
  |}
  imeta_meta {|
    ?_1 <= bool_2
    ?_2 <= Type‹??_4›
    ?_3 <= L
    ?_4 <= bool_2
    ?_5 <= Type‹??_7›
    ?_6 <= ?_3
    ?_7 <= unit_1‹L›
    ?_8 <= unit_1‹U›
    ?_9 <= ((stream_1‹U›) nat_3)
    ?_10 <= (stream_node_4‹U› nat_3)
    ?_11 <= (stream_node_4‹??_13› ?_12)
    ?_12 <= nat_3
    ?_13 <= nat_3
    ?_20 <= Type‹??_22›
    ?_21 <= Type‹??_23›
    ?_22 <= Type‹??_24›
    ?_23 <= Type‹??_25›
    ?_24 <= Type‹??_26›
    ?_25 <= Type‹??_27›
    ?_26 <= Type‹??_28›
    ?_27 <= Type‹??_29›
    ?_28 <= Type‹??_30›
    ?_29 <= Type‹??_31›
    ?_30 <= Type‹??_32›
    
  |}
  eqns {|
    
  |}
end_dump
infer_tm(Type‹??_30›)
check_tm( ((stream_1‹U›) nat_3), Type‹??_30›)
infer_tm(((stream_1‹U›) nat_3))
infer_tm(stream_1‹U›)
check_tm( nat_3, U)
infer_tm(nat_3)
assert_equal1( U, U)
assert_equal1_ok( U, U)
assert_equal1( Type‹??_30›, L)
assert_equal1_extend( Type‹??_30›, L)
simpl_tm ~expand:false( Type‹??_30›, L)
infer_tm(Type‹??_31›)
check_tm( (stream_node_4‹U› nat_3), Type‹??_31›)
infer_tm((stream_node_4‹U› nat_3))
check_tm( nat_3, U)
infer_tm(nat_3)
assert_equal1( U, U)
assert_equal1_ok( U, U)
assert_equal1( Type‹??_31›, L)
assert_equal1_extend( Type‹??_31›, L)
simpl_tm ~expand:false( Type‹??_31›, L)
infer_tm(Type‹??_32›)
check_tm( (stream_node_4‹U› nat_3), Type‹??_32›)
infer_tm((stream_node_4‹U› nat_3))
check_tm( nat_3, U)
infer_tm(nat_3)
assert_equal1( U, U)
assert_equal1_ok( U, U)
assert_equal1( Type‹??_32›, L)
assert_equal1_extend( Type‹??_32›, L)
simpl_tm ~expand:false( Type‹??_32›, L)
infer_tm(U)
check_tm( nat_3, U)
infer_tm(nat_3)
assert_equal1( U, U)
assert_equal1_ok( U, U)
infer_tm(U)
check_tm( nat_3, U)
infer_tm(nat_3)
assert_equal1( U, U)
assert_equal1_ok( U, U)
----------------------------------

definition-------------------------
infer_tm(nat_3 -> ((stream_1‹??_20›) nat_3))
infer_tm(nat_3)
infer_tm(((stream_1‹??_20›) nat_3))
infer_tm(stream_1‹??_20›)
check_tm( nat_3, Type‹??_20›)
infer_tm(nat_3)
assert_equal1( Type‹??_20›, U)
assert_equal1_extend( Type‹??_20›, U)
simpl_tm ~expand:false( Type‹??_20›, U)
check_tm(
  function nat_make_691 : nat_3 -> ((stream_1‹??_17›) nat_3)
  | n_693 =>
    function _694 : ?_14
    | true_2 =>
      (stream_cons_7‹??_18› n_693 ((nat_make_691) (succ_5‹› n_693)))
    | false_3 => tt_1‹??_19›,
  nat_3 -> ((stream_1‹??_20›) nat_3))
infer_tm(nat_3 -> ((stream_1‹??_17›) nat_3))
infer_tm(nat_3)
infer_tm(((stream_1‹??_17›) nat_3))
infer_tm(stream_1‹??_17›)
check_tm( nat_3, Type‹??_17›)
infer_tm(nat_3)
assert_equal1( Type‹??_17›, U)
assert_equal1_extend( Type‹??_17›, U)
simpl_tm ~expand:false( Type‹??_17›, U)
assert_equal1( nat_3 -> ((stream_1‹??_20›) nat_3),
  nat_3 -> ((stream_1‹??_17›) nat_3))
assert_equal1_extend( nat_3 -> ((stream_1‹??_20›) nat_3),
  nat_3 -> ((stream_1‹??_17›) nat_3))
simpl_tm ~expand:false( nat_3 -> ((stream_1‹U›) nat_3),
  nat_3 -> ((stream_1‹U›) nat_3))
simpl_tm ~expand:false( nat_3, nat_3)
simpl_tm ~expand:false( ((stream_1‹U›) nat_3), ((stream_1‹U›) nat_3))
simpl_tm ~expand:false( stream_1‹U›, stream_1‹U›)
simpl_tm ~expand:false( nat_3, nat_3)
check_cls {|
  prblm {| ;
    {|  ::: [n_709] =>?
         function _716 : ?_14
         | true_2 =>
           (stream_cons_7‹??_18›
             #n_709 ((nat_make_696) (succ_5‹› #n_709)))
         | false_3 => tt_1‹??_19›
    |}
  |}
  a := nat_3 -> ((stream_1‹U›) nat_3)
|}
case_intro
case_introed(n_718 : nat_3)
case_coverage{|
  prblm {| ;
    {| eq_pat?( #n_718, n_709 : nat_3) ::: [] =>?
         function _719 : ?_14
         | true_2 =>
           (stream_cons_7‹??_18›
             #n_709 ((nat_make_696) (succ_5‹› #n_709)))
         | false_3 => tt_1‹??_19›
    |}
  |}
|}
unify_local( eq_pat?( #n_718, n_709 : nat_3) )
unify_global(  )
simpl_pprbm ~expand:false( #n_718, #n_709)
case_coverage_ok(
  function _722 : ?_14
  | true_2 =>
    (stream_cons_7‹??_18› n_718 ((nat_make_696) (succ_5‹› n_718)))
  | false_3 => tt_1‹??_19›, ((stream_1‹U›) nat_3))
check_tm(
  function _723 : ?_14
  | true_2 =>
    (stream_cons_7‹??_18› n_718 ((nat_make_696) (succ_5‹› n_718)))
  | false_3 => tt_1‹??_19›, ((stream_1‹U›) nat_3))
infer_tm(?_14)
delay_assert(?_31, ??_33)
assert_equal1( ((stream_1‹U›) nat_3), ?_14)
assert_equal1_extend( ((stream_1‹U›) nat_3), ?_14)
simpl_tm ~expand:false( ((stream_1‹U›) nat_3), ?_14)
simpl_tm ~expand:false( ?_31, Type‹??_33›)
check_cls {|
  prblm {| ;
    {|  ::: [true_2] =>?
         (stream_cons_7‹??_18›
           n_718 ((nat_make_696) (succ_5‹› n_718)))
    |} {|  ::: [false_3] =>? tt_1‹??_19› |}
  |}
  a := ((stream_1‹U›) nat_3)
|}
case_intro
case_introed(b_725 : bool_2)
case_splitting
splitting_on(true_2)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2);
    {|  ::: [] =>?
         (stream_cons_7‹??_18›
           n_718 ((nat_make_696) (succ_5‹› n_718)))
    |}
  |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok(
  (stream_cons_7‹??_18› n_718 ((nat_make_696) (succ_5‹› n_718))),
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
check_tm(
  (stream_cons_7‹??_18› n_718 ((nat_make_696) (succ_5‹› n_718))),
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
infer_tm((stream_cons_7‹??_18›
           n_718 ((nat_make_696) (succ_5‹› n_718))))
check_tm( ?_15, Type‹??_18›)
check_tm( n_718, ?_15)
infer_tm(n_718)
assert_equal1( ?_15, nat_3)
assert_equal1_extend( ?_15, nat_3)
check_tm( ((nat_make_696) (succ_5‹› n_718)),
  ∀ (b_732 : bool_2) -o
    match b_732 in bool_2 -o L with
    | true_2 => (stream_node_4‹??_18› ?_15)
    | false_3 => unit_1‹L›)
infer_tm(((nat_make_696) (succ_5‹› n_718)))
infer_tm(nat_make_696)
simpl_tm ~expand:false( ?_15, nat_3)
check_tm( (succ_5‹› n_718), nat_3)
infer_tm((succ_5‹› n_718))
check_tm( n_718, nat_3)
infer_tm(n_718)
assert_equal1( nat_3, nat_3)
assert_equal1_ok( nat_3, nat_3)
assert_equal1( nat_3, nat_3)
assert_equal1_ok( nat_3, nat_3)
assert_equal1(
  ∀ (b_735 : bool_2) -o
    match b_735 in bool_2 -o L with
    | true_2 => (stream_node_4‹??_18› ?_15)
    | false_3 => unit_1‹L›,
  ((stream_1‹U›) nat_3))
assert_equal1_extend(
  ∀ (b_740 : bool_2) -o
    match b_740 in bool_2 -o L with
    | true_2 => (stream_node_4‹??_18› ?_15)
    | false_3 => unit_1‹L›,
  ((stream_1‹U›) nat_3))
assert_equal1(
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›, (stream_node_4‹??_18› ?_15))
assert_equal1_extend(
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›, (stream_node_4‹??_18› ?_15))
splitting_on(false_3)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2); {|  ::: [] =>? tt_1‹??_19› |} |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( tt_1‹??_19›,
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
check_tm( tt_1‹??_19›,
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
infer_tm(tt_1‹??_19›)
assert_equal1(
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›, unit_1‹??_19›)
assert_equal1_extend(
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›, unit_1‹??_19›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_752
    ??_2 <= s_753
    ??_3 <= s_754
    ??_4 <= L
    ??_5 <= s_756
    ??_6 <= s_757
    ??_7 <= L
    ??_8 <= s_759
    ??_9 <= U
    ??_10 <= s_761
    ??_11 <= U
    ??_12 <= U
    ??_13 <= U
    ??_14 <= U
    ??_15 <= U
    ??_16 <= U
    ??_17 <= U
    ??_20 <= U
    ??_22 <= U
    ??_23 <= U
    ??_24 <= U
    ??_25 <= U
    ??_26 <= U
    ??_27 <= U
    ??_28 <= L
    ??_29 <= U
    ??_30 <= L
    ??_31 <= L
    ??_32 <= L
    
  |}
  imeta_meta {|
    ?_1 <= bool_2
    ?_2 <= Type‹??_4›
    ?_3 <= L
    ?_4 <= bool_2
    ?_5 <= Type‹??_7›
    ?_6 <= ?_3
    ?_7 <= unit_1‹L›
    ?_8 <= unit_1‹U›
    ?_9 <= ((stream_1‹U›) nat_3)
    ?_10 <= (stream_node_4‹U› nat_3)
    ?_11 <= (stream_node_4‹??_13› ?_12)
    ?_12 <= nat_3
    ?_13 <= nat_3
    ?_14 <= ((stream_1‹U›) nat_3)
    ?_15 <= nat_3
    ?_20 <= Type‹??_22›
    ?_21 <= Type‹??_23›
    ?_22 <= Type‹??_24›
    ?_23 <= Type‹??_25›
    ?_24 <= Type‹??_26›
    ?_25 <= Type‹??_27›
    ?_26 <= Type‹??_28›
    ?_27 <= Type‹??_29›
    ?_28 <= Type‹??_30›
    ?_29 <= Type‹??_31›
    ?_30 <= Type‹??_32›
    ?_31 <= Type‹??_33›
    
  |}
  eqns {|
    equal_tm?
      (match false_3 in bool_2 -o L with
       | true_2 => (stream_node_4‹U› nat_3)
       | false_3 => unit_1‹L›,
      unit_1‹??_19›);
    equal_tm?
      (match true_2 in bool_2 -o L with
       | true_2 => (stream_node_4‹U› nat_3)
       | false_3 => unit_1‹L›,
      (stream_node_4‹??_18› ?_15));
    equal_tm?
      (∀ (b_856 : bool_2) -o
         match b_856 in bool_2 -o L with
         | true_2 => (stream_node_4‹??_18› ?_15)
         | false_3 => unit_1‹L›,
      ((stream_1‹U›) nat_3))
  |}
end_dump
simpl_tm ~expand:false( unit_1‹L›, unit_1‹??_19›)
simpl_tm ~expand:false( (stream_node_4‹U› nat_3),
  (stream_node_4‹??_18› nat_3))
simpl_tm ~expand:false( nat_3, nat_3)
simpl_tm ~expand:false(
  ∀ (b_862 : bool_2) -o
    match b_862 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›,
  ((stream_1‹U›) nat_3))
simpl_tm ~expand:false(
  ∀ (b_864 : bool_2) -o
    match b_864 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›,
  stream_1‹U›)
simpl_tm ~expand:true(
  ∀ (b_866 : bool_2) -o
    match b_866 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›,
  function stream_868 : U -> L
  | A_870 =>
    ∀ (b_871 : bool_2) -o
      match b_871 in bool_2 -o L with
      | true_2 => (stream_node_4‹U› A_870)
      | false_3 => unit_1‹L›)
simpl_tm ~expand:true(
  ∀ (b_880 : bool_2) -o
    match b_880 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›,
  ∀ (b_882 : bool_2) -o
    match b_882 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›)
simpl_tm ~expand:false( bool_2, bool_2)
simpl_tm ~expand:false(
  match b_884 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›,
  match b_884 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
simpl_tm ~expand:false( b_884, b_884)
simpl_tm ~expand:false( bool_2 -o L, bool_2 -o L)
simpl_tm ~expand:false( bool_2, bool_2)
simpl_tm ~expand:false( L, L)
simpl_tm ~expand:false( (stream_node_4‹U› nat_3),
  (stream_node_4‹U› nat_3))
simpl_tm ~expand:false( nat_3, nat_3)
simpl_tm ~expand:false( unit_1‹L›, unit_1‹L›)
infer_tm(Type‹??_33›)
check_tm( ((stream_1‹U›) nat_3), Type‹??_33›)
infer_tm(((stream_1‹U›) nat_3))
infer_tm(stream_1‹U›)
check_tm( nat_3, U)
infer_tm(nat_3)
assert_equal1( U, U)
assert_equal1_ok( U, U)
assert_equal1( Type‹??_33›, L)
assert_equal1_extend( Type‹??_33›, L)
simpl_tm ~expand:false( Type‹??_33›, L)
infer_tm(U)
check_tm( nat_3, U)
infer_tm(nat_3)
assert_equal1( U, U)
assert_equal1_ok( U, U)
----------------------------------

definition-------------------------
infer_tm(?_16)
delay_assert(?_32, ??_34)
check_tm( ((nat_make_4) zero_4), ?_16)
infer_tm(((nat_make_4) zero_4))
infer_tm(nat_make_4)
simpl_tm ~expand:false( ?_32, Type‹??_34›)
check_tm( zero_4, nat_3)
infer_tm(zero_4)
assert_equal1( nat_3, nat_3)
assert_equal1_ok( nat_3, nat_3)
assert_equal1( ?_16, ((stream_1‹U›) nat_3))
assert_equal1_extend( ?_16, ((stream_1‹U›) nat_3))
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_900
    ??_2 <= s_901
    ??_3 <= s_902
    ??_4 <= L
    ??_5 <= s_904
    ??_6 <= s_905
    ??_7 <= L
    ??_8 <= s_907
    ??_9 <= U
    ??_10 <= s_909
    ??_11 <= U
    ??_12 <= U
    ??_13 <= U
    ??_14 <= U
    ??_15 <= U
    ??_16 <= U
    ??_17 <= U
    ??_18 <= U
    ??_19 <= L
    ??_20 <= U
    ??_22 <= U
    ??_23 <= U
    ??_24 <= U
    ??_25 <= U
    ??_26 <= U
    ??_27 <= U
    ??_28 <= L
    ??_29 <= U
    ??_30 <= L
    ??_31 <= L
    ??_32 <= L
    ??_33 <= L
    
  |}
  imeta_meta {|
    ?_1 <= bool_2
    ?_2 <= Type‹??_4›
    ?_3 <= L
    ?_4 <= bool_2
    ?_5 <= Type‹??_7›
    ?_6 <= ?_3
    ?_7 <= unit_1‹L›
    ?_8 <= unit_1‹U›
    ?_9 <= ((stream_1‹U›) nat_3)
    ?_10 <= (stream_node_4‹U› nat_3)
    ?_11 <= (stream_node_4‹??_13› ?_12)
    ?_12 <= nat_3
    ?_13 <= nat_3
    ?_14 <= ((stream_1‹U›) nat_3)
    ?_15 <= nat_3
    ?_20 <= Type‹??_22›
    ?_21 <= Type‹??_23›
    ?_22 <= Type‹??_24›
    ?_23 <= Type‹??_25›
    ?_24 <= Type‹??_26›
    ?_25 <= Type‹??_27›
    ?_26 <= Type‹??_28›
    ?_27 <= Type‹??_29›
    ?_28 <= Type‹??_30›
    ?_29 <= Type‹??_31›
    ?_30 <= Type‹??_32›
    ?_31 <= Type‹??_33›
    ?_32 <= Type‹??_34›
    
  |}
  eqns {|
    equal_tm? (?_16, ((stream_1‹U›) nat_3))
  |}
end_dump
simpl_tm ~expand:false( ?_16, ((stream_1‹U›) nat_3))
infer_tm(Type‹??_34›)
check_tm( ((stream_1‹U›) nat_3), Type‹??_34›)
infer_tm(((stream_1‹U›) nat_3))
infer_tm(stream_1‹U›)
check_tm( nat_3, U)
infer_tm(nat_3)
assert_equal1( U, U)
assert_equal1_ok( U, U)
assert_equal1( Type‹??_34›, L)
assert_equal1_extend( Type‹??_34›, L)
simpl_tm ~expand:false( Type‹??_34›, L)
----------------------------------

definition-------------------------
infer_tm(?_17)
delay_assert(?_33, ??_35)
check_tm( ((stream_succ_3) nat_stream_5), ?_17)
infer_tm(((stream_succ_3) nat_stream_5))
infer_tm(stream_succ_3)
simpl_tm ~expand:false( ?_33, Type‹??_35›)
check_tm( nat_stream_5, ((stream_1‹U›) nat_3))
infer_tm(nat_stream_5)
assert_equal1( ((stream_1‹U›) nat_3), ((stream_1‹U›) nat_3))
assert_equal1_ok( ((stream_1‹U›) nat_3), ((stream_1‹U›) nat_3))
assert_equal1( ?_17, ((stream_1‹U›) nat_3))
assert_equal1_extend( ?_17, ((stream_1‹U›) nat_3))
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_1004
    ??_2 <= s_1005
    ??_3 <= s_1006
    ??_4 <= L
    ??_5 <= s_1008
    ??_6 <= s_1009
    ??_7 <= L
    ??_8 <= s_1011
    ??_9 <= U
    ??_10 <= s_1013
    ??_11 <= U
    ??_12 <= U
    ??_13 <= U
    ??_14 <= U
    ??_15 <= U
    ??_16 <= U
    ??_17 <= U
    ??_18 <= U
    ??_19 <= L
    ??_20 <= U
    ??_22 <= U
    ??_23 <= U
    ??_24 <= U
    ??_25 <= U
    ??_26 <= U
    ??_27 <= U
    ??_28 <= L
    ??_29 <= U
    ??_30 <= L
    ??_31 <= L
    ??_32 <= L
    ??_33 <= L
    ??_34 <= L
    
  |}
  imeta_meta {|
    ?_1 <= bool_2
    ?_2 <= Type‹??_4›
    ?_3 <= L
    ?_4 <= bool_2
    ?_5 <= Type‹??_7›
    ?_6 <= ?_3
    ?_7 <= unit_1‹L›
    ?_8 <= unit_1‹U›
    ?_9 <= ((stream_1‹U›) nat_3)
    ?_10 <= (stream_node_4‹U› nat_3)
    ?_11 <= (stream_node_4‹??_13› ?_12)
    ?_12 <= nat_3
    ?_13 <= nat_3
    ?_14 <= ((stream_1‹U›) nat_3)
    ?_15 <= nat_3
    ?_16 <= ((stream_1‹U›) nat_3)
    ?_20 <= Type‹??_22›
    ?_21 <= Type‹??_23›
    ?_22 <= Type‹??_24›
    ?_23 <= Type‹??_25›
    ?_24 <= Type‹??_26›
    ?_25 <= Type‹??_27›
    ?_26 <= Type‹??_28›
    ?_27 <= Type‹??_29›
    ?_28 <= Type‹??_30›
    ?_29 <= Type‹??_31›
    ?_30 <= Type‹??_32›
    ?_31 <= Type‹??_33›
    ?_32 <= Type‹??_34›
    ?_33 <= Type‹??_35›
    
  |}
  eqns {|
    equal_tm? (?_17, ((stream_1‹U›) nat_3))
  |}
end_dump
simpl_tm ~expand:false( ?_17, ((stream_1‹U›) nat_3))
infer_tm(Type‹??_35›)
check_tm( ((stream_1‹U›) nat_3), Type‹??_35›)
infer_tm(((stream_1‹U›) nat_3))
infer_tm(stream_1‹U›)
check_tm( nat_3, U)
infer_tm(nat_3)
assert_equal1( U, U)
assert_equal1_ok( U, U)
assert_equal1( Type‹??_35›, L)
assert_equal1_extend( Type‹??_35›, L)
simpl_tm ~expand:false( Type‹??_35›, L)
----------------------------------

definition-------------------------
infer_tm(?_19)
delay_assert(?_34, ??_36)
check_tm( ((free_stream_2‹??_21›) ?_18 snat_stream_6), ?_19)
infer_tm(((free_stream_2‹??_21›) ?_18 snat_stream_6))
infer_tm(((free_stream_2‹??_21›) ?_18))
infer_tm(free_stream_2‹??_21›)
simpl_tm ~expand:false( ?_34, Type‹??_36›)
check_tm( ?_18, Type‹??_21›)
check_tm( snat_stream_6, ((stream_1‹??_21›) ?_18))
infer_tm(snat_stream_6)
assert_equal1( ((stream_1‹??_21›) ?_18), ((stream_1‹U›) nat_3))
assert_equal1_extend( ((stream_1‹??_21›) ?_18),
  ((stream_1‹U›) nat_3))
assert_equal1( ?_19, unit_1‹U›)
assert_equal1_extend( ?_19, unit_1‹U›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_1111
    ??_2 <= s_1112
    ??_3 <= s_1113
    ??_4 <= L
    ??_5 <= s_1115
    ??_6 <= s_1116
    ??_7 <= L
    ??_8 <= s_1118
    ??_9 <= U
    ??_10 <= s_1120
    ??_11 <= U
    ??_12 <= U
    ??_13 <= U
    ??_14 <= U
    ??_15 <= U
    ??_16 <= U
    ??_17 <= U
    ??_18 <= U
    ??_19 <= L
    ??_20 <= U
    ??_22 <= U
    ??_23 <= U
    ??_24 <= U
    ??_25 <= U
    ??_26 <= U
    ??_27 <= U
    ??_28 <= L
    ??_29 <= U
    ??_30 <= L
    ??_31 <= L
    ??_32 <= L
    ??_33 <= L
    ??_34 <= L
    ??_35 <= L
    
  |}
  imeta_meta {|
    ?_1 <= bool_2
    ?_2 <= Type‹??_4›
    ?_3 <= L
    ?_4 <= bool_2
    ?_5 <= Type‹??_7›
    ?_6 <= ?_3
    ?_7 <= unit_1‹L›
    ?_8 <= unit_1‹U›
    ?_9 <= ((stream_1‹U›) nat_3)
    ?_10 <= (stream_node_4‹U› nat_3)
    ?_11 <= (stream_node_4‹??_13› ?_12)
    ?_12 <= nat_3
    ?_13 <= nat_3
    ?_14 <= ((stream_1‹U›) nat_3)
    ?_15 <= nat_3
    ?_16 <= ((stream_1‹U›) nat_3)
    ?_17 <= ((stream_1‹U›) nat_3)
    ?_20 <= Type‹??_22›
    ?_21 <= Type‹??_23›
    ?_22 <= Type‹??_24›
    ?_23 <= Type‹??_25›
    ?_24 <= Type‹??_26›
    ?_25 <= Type‹??_27›
    ?_26 <= Type‹??_28›
    ?_27 <= Type‹??_29›
    ?_28 <= Type‹??_30›
    ?_29 <= Type‹??_31›
    ?_30 <= Type‹??_32›
    ?_31 <= Type‹??_33›
    ?_32 <= Type‹??_34›
    ?_33 <= Type‹??_35›
    ?_34 <= Type‹??_36›
    
  |}
  eqns {|
    equal_tm? (?_19, unit_1‹U›);
    equal_tm? (((stream_1‹??_21›) ?_18), ((stream_1‹U›) nat_3))
  |}
end_dump
simpl_tm ~expand:false( ?_19, unit_1‹U›)
simpl_tm ~expand:false( ((stream_1‹??_21›) ?_18),
  ((stream_1‹U›) nat_3))
simpl_tm ~expand:false( stream_1‹??_21›, stream_1‹U›)
simpl_tm ~expand:false( ?_18, nat_3)
simpl_tm ~expand:false( nat_3, ?_18)
infer_tm(U)
check_tm( nat_3, U)
infer_tm(nat_3)
assert_equal1( U, U)
assert_equal1_ok( U, U)
infer_tm(Type‹??_36›)
check_tm( unit_1‹U›, Type‹??_36›)
infer_tm(unit_1‹U›)
assert_equal1( Type‹??_36›, U)
assert_equal1_extend( Type‹??_36›, U)
simpl_tm ~expand:false( Type‹??_36›, U)
----------------------------------

smeta_meta {|
  ??_1 <= s_1213
  ??_2 <= s_1214
  ??_3 <= s_1215
  ??_4 <= L
  ??_5 <= s_1217
  ??_6 <= s_1218
  ??_7 <= L
  ??_8 <= s_1220
  ??_9 <= U
  ??_10 <= s_1222
  ??_11 <= U
  ??_12 <= U
  ??_13 <= U
  ??_14 <= U
  ??_15 <= U
  ??_16 <= U
  ??_17 <= U
  ??_18 <= U
  ??_19 <= L
  ??_20 <= U
  ??_21 <= U
  ??_22 <= U
  ??_23 <= U
  ??_24 <= U
  ??_25 <= U
  ??_26 <= U
  ??_27 <= U
  ??_28 <= L
  ??_29 <= U
  ??_30 <= L
  ??_31 <= L
  ??_32 <= L
  ??_33 <= L
  ??_34 <= L
  ??_35 <= L
  ??_36 <= U
  
|}
imeta_meta {|
  ?_1 <= bool_2
  ?_2 <= Type‹??_4›
  ?_3 <= L
  ?_4 <= bool_2
  ?_5 <= Type‹??_7›
  ?_6 <= ?_3
  ?_7 <= unit_1‹L›
  ?_8 <= unit_1‹U›
  ?_9 <= ((stream_1‹U›) nat_3)
  ?_10 <= (stream_node_4‹U› nat_3)
  ?_11 <= (stream_node_4‹??_13› ?_12)
  ?_12 <= nat_3
  ?_13 <= nat_3
  ?_14 <= ((stream_1‹U›) nat_3)
  ?_15 <= nat_3
  ?_16 <= ((stream_1‹U›) nat_3)
  ?_17 <= ((stream_1‹U›) nat_3)
  ?_18 <= nat_3
  ?_19 <= unit_1‹U›
  ?_20 <= Type‹??_22›
  ?_21 <= Type‹??_23›
  ?_22 <= Type‹??_24›
  ?_23 <= Type‹??_25›
  ?_24 <= Type‹??_26›
  ?_25 <= Type‹??_27›
  ?_26 <= Type‹??_28›
  ?_27 <= Type‹??_29›
  ?_28 <= Type‹??_30›
  ?_29 <= Type‹??_31›
  ?_30 <= Type‹??_32›
  ?_31 <= Type‹??_33›
  ?_32 <= Type‹??_34›
  ?_33 <= Type‹??_35›
  ?_34 <= Type‹??_36›
  
|}
#[program]
inductive unit_1‹s_1379› : Type‹s_1379› where
| tt_1 : unit_1‹s_1379›

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_1380 : nat_3) : nat_3

#[program]
inductive stream_node_4‹s_1381› (A_1382 : Type‹s_1381›): L where
| stream_nil_6 : (stream_node_4‹s_1381› A_1382)
| stream_cons_7
    (hd_1383 : A_1382)
    (tl_1384 : ∀ (b_1385 : bool_2) -o
                 match b_1385 in bool_2 -o L with
                 | true_2 => (stream_node_4‹s_1381› A_1382)
                 | false_3 => unit_1‹L›)
    : (stream_node_4‹s_1381› A_1382)

#[logical]
def stream_1‹s_1387› : Type‹s_1387› -> L :=
  function stream_1389 : Type‹s_1387› -> L
  | A_1391 =>
    ∀ (b_1392 : bool_2) -o
      match b_1392 in bool_2 -o L with
      | true_2 => (stream_node_4‹s_1387› A_1391)
      | false_3 => unit_1‹L›

#[program]
def free_stream_2‹s_1394› :
  ∀ {A_1395 : Type‹s_1394›} ->
    ((stream_1‹s_1394›) A_1395) -> unit_1‹U›
:=
  function free_stream_1397 :
    ∀ {A_1398 : Type‹s_1394›} ->
      ((stream_1‹s_1394›) A_1398) -> unit_1‹U›
  | A_1400 st_1401 =>
    match ((st_1401) false_3) in unit_1‹L› -o unit_1‹U› with
    | tt_1 => tt_1‹U›

#[program]
def stream_succ_3‹› :
  ((stream_1‹U›) nat_3) -> ((stream_1‹U›) nat_3)
:=
  function stream_succ_1404 :
    ((stream_1‹U›) nat_3) -> ((stream_1‹U›) nat_3)
  | xs_1406 =>
    function _1407 : ((stream_1‹U›) nat_3)
    | true_2 =>
      match ((xs_1406) true_2) in
        (stream_node_4‹U› nat_3) -o (stream_node_4‹U› nat_3)
      with
      | stream_nil_6 => stream_nil_6‹U›
      | (stream_cons_7 hd_1409 tl_1410) =>
        (stream_cons_7‹U›
          (succ_5‹› hd_1409) ((stream_succ_1404) tl_1410))
    | false_3 => ((xs_1406) false_3)

#[program]
def nat_make_4‹› : nat_3 -> ((stream_1‹U›) nat_3) :=
  function nat_make_1412 : nat_3 -> ((stream_1‹U›) nat_3)
  | n_1414 =>
    function _1415 : ((stream_1‹U›) nat_3)
    | true_2 =>
      (stream_cons_7‹U› n_1414 ((nat_make_1412) (succ_5‹› n_1414)))
    | false_3 => tt_1‹L›

#[program]
def nat_stream_5‹› : ((stream_1‹U›) nat_3) := ((nat_make_4) zero_4)

#[program]
def snat_stream_6‹› : ((stream_1‹U›) nat_3) :=
  ((stream_succ_3) nat_stream_5)

#[program]
def __7‹› : unit_1‹U› := ((free_stream_2‹U›) nat_3 snat_stream_6)

-----------------------------------------

inductive unitU_6 where
| ttU_9 of size(0)

inductive unitL_5 where
| ttL_8 of size(0)

inductive bool_2 where
| true_2 of size(0) | false_3 of size(0)

inductive nat_3 where
| zero_4 of size(0) | succ_5 of size(1)

inductive stream_nodeU_8 where
| stream_nilU_12 of size(0) | stream_consU_13 of size(2)

inductive stream_nodeL_7 where
| stream_nilL_10 of size(0) | stream_consL_11 of size(2)

def streamU_9 := NULL

def streamL_8 := NULL

def free_streamU_11 :=
  fun free_stream_1604 (A_1605, st_1606) =>
    match ((st_1606) false_3) with
    | ttL_8  => ttU_9
    end

def free_streamL_10 :=
  fun free_stream_1607 (A_1608, st_1609) =>
    match ((st_1609) false_3) with
    | ttL_8  => ttU_9
    end

def stream_succ_3 :=
  fun stream_succ_1610 (xs_1611) =>
    fun _1612 (b_1613) =>
      match b_1613 with
      | true_2  =>
        match ((xs_1611) true_2) with
        | stream_nilU_12  => stream_nilU_12
        | stream_consU_13 hd_1614 tl_1615 =>
          (stream_consU_13 (succ_5 hd_1614) ((stream_succ_1610) tl_1615))
        end
      | false_3  => ((xs_1611) false_3)
      end

def nat_make_4 :=
  fun nat_make_1616 (n_1617) =>
    fun _1618 (b_1619) =>
      match b_1619 with
      | true_2  => (stream_consU_13 n_1617 ((nat_make_1616) (succ_5 n_1617)))
      | false_3  => ttL_8
      end

def nat_stream_5 := ((nat_make_4) zero_4)

def snat_stream_6 := ((stream_succ_3) nat_stream_5)

def __7 := ((free_streamU_11) NULL snat_stream_6)

-----------------------------------------

