[Notation {name = "|>"; body = (App [(Hole 2); (Hole 1)])};
  Notation {name = "@@"; body = (App [(Hole 1); (Hole 2)])};
  Notation {name = "="; body = (App [(Id ("eq", I)); (Hole 1); (Hole 2)])};
  Notation {name = "`"; body = (App [(Id ("sing", I)); (Hole 1)])};
  Notation {name = "&&"; body = (Id ("and", I))};
  Notation {name = "||"; body = (Id ("or", I))};
  Notation {name = "+"; body = (App [(Id ("add", I)); (Hole 1); (Hole 2)])};
  Notation {name = "-"; body = (App [(Id ("sub", I)); (Hole 1); (Hole 2)])};
  Notation {name = "*"; body = (App [(Id ("mul", I)); (Hole 1); (Hole 2)])};
  Notation {name = "/"; body = (App [(Id ("div", I)); (Hole 1); (Hole 2)])};
  Notation {name = "%"; body = (App [(Id ("rem", I)); (Hole 1); (Hole 2)])};
  Notation {name = "^"; body = (App [(Id ("pow", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<"; body = (App [(Id ("lt", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">"; body = (App [(Id ("gt", I)); (Hole 1); (Hole 2)])};
  Notation {name = "<="; body = (App [(Id ("lte", I)); (Hole 1); (Hole 2)])};
  Notation {name = ">="; body = (App [(Id ("gte", I)); (Hole 1); (Hole 2)])};
  Notation {name = "\226\138\151";
    body =
    (App [(Inst ("prod", [(SId "_"); (SId "_"); L], I)); (Hole 1); (Hole 2)])};
  Notation {name = "::"; body = (App [(Id ("cons", I)); (Hole 1); (Hole 2)])};
  Notation {name = ";";
    body = (MLet ((Hole 1), (Binder ((PId "_"), (Hole 2)))))};
  Notation {name = "(,)"; body = (App [(Id ("pair", I)); (Hole 1); (Hole 2)])};
  Notation {name = "\226\159\168,{}\226\159\169";
    body = (App [(Id ("ex", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "unit"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)), [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
       ));
    view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "list"; relv = R;
    body =
    (Binder ([],
       (PBind ((Type U),
          (Binder ("A",
             (PBase
                ((TBase (Type U)),
                 [(DConstr ("nil",
                     (TBase (App [(Id ("list", I)); (Id ("A", I))])), 
                     []));
                   (DConstr ("cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (App [(Id ("list", I)); (Id ("A", I))]),
                               (Binder ("tl",
                                  (TBase
                                     (App [(Id ("list", I)); (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase
                              (App
                                 [(Id ("eq", I)); (Id ("m", I));
                                   (Id ("m", I))])),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "exists"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("ex",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (N,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("pf",
                                       (TBase
                                          (App
                                             [(Id ("exists", I));
                                               (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "s"))))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m",
                           (TBase (App [(Id ("sing", I)); (Id ("m", I))]))))
                        )),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Inductive {name = "prod"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Type (SId "r")),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("pair",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R, (Id ("B", I)),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("prod", I));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [E; E]};
  Definition {name = "exists_sing"; relv = R;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U,
                          (App
                             [(Inst ("exists",
                                 [(SId "_"); (SId "_"); (SId "t")], I));
                               (Fun (
                                  (Pi (R, U, (Id ("A", I)),
                                     (Binder ("a", IMeta)))),
                                  (Binder (None,
                                     [([(PId "a")],
                                       (Some (BOpr ("=", (Id ("a", I)),
                                                (Id ("m", I))))))
                                       ]
                                     )),
                                  []))
                               ]),
                          (Binder ("_", (UOpr ("`", (Id ("m", I))))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "exists_sing"),
              [([(PId "A"); (PId "m");
                  (PBOpr ("\226\159\168,{}\226\159\169", (PId "x"),
                     (PId "refl")))
                  ],
                (Some (App [(Id ("just", I)); (Id ("x", I))])))]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U,
                       (App
                          [(Inst ("exists",
                              [(SId "_"); (SId "_"); (SId "t")], I));
                            (Fun (
                               (Pi (R, U, (Id ("A", I)),
                                  (Binder ("a", IMeta)))),
                               (Binder (None,
                                  [([(PId "a")],
                                    (Some (BOpr ("=", (Id ("a", I)),
                                             (Id ("m", I))))))
                                    ]
                                  )),
                               []))
                            ]),
                       (Binder ("_", (UOpr ("`", (Id ("m", I))))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "sing_exists"; relv = R;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                          (Binder ("_",
                             (App
                                [(Inst ("exists",
                                    [(SId "_"); (SId "_"); (SId "t")], I));
                                  (Fun (
                                     (Pi (R, U, (Id ("A", I)),
                                        (Binder ("a", IMeta)))),
                                     (Binder (None,
                                        [([(PId "a")],
                                          (Some (BOpr ("=", (Id ("a", I)),
                                                   (Id ("m", I))))))
                                          ]
                                        )),
                                     []))
                                  ])
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_exists"),
              [([(PId "A"); (PId "m"); (PConstr ("just", [(PId "x")]))],
                (Some (BOpr ("\226\159\168,{}\226\159\169", (Id ("x", I)),
                         (Id ("refl", I))))))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                       (Binder ("_",
                          (App
                             [(Inst ("exists",
                                 [(SId "_"); (SId "_"); (SId "t")], I));
                               (Fun (
                                  (Pi (R, U, (Id ("A", I)),
                                     (Binder ("a", IMeta)))),
                                  (Binder (None,
                                     [([(PId "a")],
                                       (Some (BOpr ("=", (Id ("a", I)),
                                                (Id ("m", I))))))
                                       ]
                                     )),
                                  []))
                               ])
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "sing_exists_equiv1"; relv = N;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                          (Binder ("x",
                             (BOpr ("=",
                                (App
                                   [(Id ("exists_sing", I));
                                     (App
                                        [(Inst ("sing_exists",
                                            [(SId "_"); (SId "t")], I));
                                          (Id ("x", I))])
                                     ]),
                                (Id ("x", I))))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_exists_equiv1"),
              [([(PId "A"); (PId "m"); (PConstr ("just", [(PId "x")]))],
                (Some (Id ("refl", I))))]
              )),
           [E; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                       (Binder ("x",
                          (BOpr ("=",
                             (App
                                [(Id ("exists_sing", I));
                                  (App
                                     [(Inst ("sing_exists",
                                         [(SId "_"); (SId "t")], I));
                                       (Id ("x", I))])
                                  ]),
                             (Id ("x", I))))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "sing_exists_equiv2"; relv = N;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U,
                          (App
                             [(Inst ("exists",
                                 [(SId "_"); (SId "_"); (SId "t")], I));
                               (Fun (
                                  (Pi (R, U, (Id ("A", I)),
                                     (Binder ("a", IMeta)))),
                                  (Binder (None,
                                     [([(PId "a")],
                                       (Some (BOpr ("=", (Id ("a", I)),
                                                (Id ("m", I))))))
                                       ]
                                     )),
                                  []))
                               ]),
                          (Binder ("x",
                             (BOpr ("=",
                                (App
                                   [(Id ("sing_exists", I));
                                     (App
                                        [(Id ("exists_sing", I));
                                          (Id ("x", I))])
                                     ]),
                                (Id ("x", I))))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_exists_equiv2"),
              [([(PId "A"); (PId "m");
                  (PBOpr ("\226\159\168,{}\226\159\169", (PId "x"),
                     (PId "refl")))
                  ],
                (Some (Id ("refl", I))))]
              )),
           [E; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U,
                       (App
                          [(Inst ("exists",
                              [(SId "_"); (SId "_"); (SId "t")], I));
                            (Fun (
                               (Pi (R, U, (Id ("A", I)),
                                  (Binder ("a", IMeta)))),
                               (Binder (None,
                                  [([(PId "a")],
                                    (Some (BOpr ("=", (Id ("a", I)),
                                             (Id ("m", I))))))
                                    ]
                                  )),
                               []))
                            ]),
                       (Binder ("x",
                          (BOpr ("=",
                             (App
                                [(Id ("sing_exists", I));
                                  (App
                                     [(Id ("exists_sing", I)); (Id ("x", I))])
                                  ]),
                             (Id ("x", I))))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "sing_double"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                          (Binder ("_",
                             (Pi (R, L, (UOpr ("`", (Id ("m", I)))),
                                (Binder ("_",
                                   (BOpr ("\226\138\151", (Id ("A", I)),
                                      (Id ("A", I))))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_double"),
              [([(PId "A"); (PId "m"); (PConstr ("just", [(PId "x")]));
                  (PConstr ("just", [(PId "y")]))],
                (Some (Let (N,
                         (Ann ((Id ("refl", I)),
                            (BOpr ("=", (Id ("x", I)), (Id ("y", I)))))),
                         (Binder ((PId "pf"),
                            (BOpr ("(,)", (Id ("x", I)), (Id ("y", I))))))
                         ))))
                ]
              )),
           [E; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                       (Binder ("_",
                          (Pi (R, L, (UOpr ("`", (Id ("m", I)))),
                             (Binder ("_",
                                (BOpr ("\226\138\151", (Id ("A", I)),
                                   (Id ("A", I))))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "my_sing"; relv = R;
    body = (Binder ([], ((App [(Id ("just", I)); (Id ("true", I))]), IMeta)));
    view = []};
  Definition {name = "my_exists"; relv = R;
    body =
    (Binder ([],
       ((App [(Id ("sing_exists", I)); (Id ("my_sing", I))]),
        (App
           [(Inst ("exists", [(SId "_"); (SId "_"); U], I));
             (Fun ((Pi (R, U, (Id ("bool", I)), (Binder ("x", IMeta)))),
                (Binder (None,
                   [([(PId "x")],
                     (Some (BOpr ("=", (Id ("x", I)), (Id ("true", I))))))]
                   )),
                []))
             ]))
       ));
    view = []};
  Definition {name = "axiom_K"; relv = N;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type U),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (BOpr ("=", (Id ("m", I)), (Id ("m", I)))),
                          (Binder ("x",
                             (BOpr ("=", (Id ("x", I)), (Id ("refl", I))))))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "axiom_K"),
              [([(PId "A"); (PId "m"); (PId "refl")], (Some (Id ("refl", I))))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type U),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (BOpr ("=", (Id ("m", I)), (Id ("m", I)))),
                       (Binder ("x",
                          (BOpr ("=", (Id ("x", I)), (Id ("refl", I))))))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]}
  ]

-----------------------------------------

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_139 : nat_3) : nat_3

#[program]
inductive list_4‹› (A_140 : U): U where
| nil_6 : (list_4 A_140)
| cons_7 (hd_141 : A_140) (tl_142 : (list_4 A_140)) : (list_4 A_140)

#[logical]
inductive eq_5‹s_143› (A_144 : Type‹s_143›) (m_145 : A_144):
  A_144 -> U
where
| refl_8 : (eq_5‹??_1› ?_1[0;0] m_145 m_145)

#[program]
inductive exists_6‹s_147,r_148,t_149› (A_150 : Type‹s_147›) (B_151 : 
A_150 -> Type‹r_148›): Type‹t_149› where
| ex_9
    (m_153 : A_150) {pf_154 : ((B_151) m_153)}
    : (exists_6‹??_2,??_3,??_4› ?_2[0;0] B_151)

#[program]
inductive sing_7‹s_155› (A_156 : Type‹s_155›):
  A_156 -> Type‹s_155›
where
| just_10 (m_158 : A_156) : (sing_7‹??_5› ?_3[0;0] m_158)

#[program]
inductive prod_8‹s_159,r_160,t_161› (A_162 : Type‹s_159›) (B_163 : Type‹r_160›):
  Type‹t_161›
where
| pair_11
    (m_164 : A_162) (n_165 : B_163)
    : (prod_8‹??_6,??_7,??_8› A_162 B_163)

#[program]
def exists_sing_1‹s_166,t_167› :
  ∀ {A_168 : Type‹s_166›} ->
    ∀ {m_169 : A_168} ->
      (exists_6‹??_14,??_15,t_167›
        ?_11[0;0]
        function _171 : A_168 -> ?_9[0;0]
        | a_173 => (eq_5‹??_16› ?_10[0;0] a_173 m_169)) ->
        (sing_7‹??_17› ?_12[0;0] m_169)
:=
  function exists_sing_174 :
    ∀ {A_175 : Type‹s_166›} ->
      ∀ {m_176 : A_175} ->
        (exists_6‹??_9,??_10,t_167›
          ?_6[0;0]
          function _178 : A_175 -> ?_4[0;0]
          | a_180 => (eq_5‹??_11› ?_5[0;0] a_180 m_176)) ->
          (sing_7‹??_12› ?_7[0;0] m_176)
  | A_181 m_182 (ex_9 x_183 refl_8) => (just_10‹??_13› ?_8[0;0] x_183)

#[program]
def sing_exists_2‹s_184,t_185› :
  ∀ {A_186 : Type‹s_184›} ->
    ∀ {m_187 : A_186} ->
      (sing_7‹??_26› ?_21[0;0] m_187) ->
        (exists_6‹??_27,??_28,t_185›
          ?_24[0;0]
          function _189 : A_186 -> ?_22[0;0]
          | a_191 => (eq_5‹??_29› ?_23[0;0] a_191 m_187))
:=
  function sing_exists_192 :
    ∀ {A_193 : Type‹s_184›} ->
      ∀ {m_194 : A_193} ->
        (sing_7‹??_18› ?_13[0;0] m_194) ->
          (exists_6‹??_19,??_20,t_185›
            ?_16[0;0]
            function _196 : A_193 -> ?_14[0;0]
            | a_198 => (eq_5‹??_21› ?_15[0;0] a_198 m_194))
  | A_199 m_200 (just_10 x_201) =>
    (ex_9‹??_23,??_24,??_25›
      ?_19[0;0] ?_20[0;0] x_201 (refl_8‹??_22› ?_17[0;0] ?_18[0;0]))

#[logical]
def sing_exists_equiv1_3‹s_202,t_203› :
  ∀ {A_204 : Type‹s_202›} ->
    ∀ {m_205 : A_204} ->
      ∀ (x_206 : (sing_7‹??_36› ?_33[0;0] m_205)) ->
        (eq_5‹??_40›
          ?_38[0;0]
          ((exists_sing_1‹??_38,??_39›)
            ?_37[0;0] ?_36[0;0]
            ((sing_exists_2‹??_37,t_203›) ?_35[0;0] ?_34[0;0] x_206))
          x_206)
:=
  function sing_exists_equiv1_207 :
    ∀ {A_208 : Type‹s_202›} ->
      ∀ {m_209 : A_208} ->
        ∀ (x_210 : (sing_7‹??_30› ?_25[0;0] m_209)) ->
          (eq_5‹??_34›
            ?_30[0;0]
            ((exists_sing_1‹??_32,??_33›)
              ?_29[0;0] ?_28[0;0]
              ((sing_exists_2‹??_31,t_203›) ?_27[0;0] ?_26[0;0] x_210))
            x_210)
  | A_211 m_212 (just_10 x_213) => (refl_8‹??_35› ?_31[0;0] ?_32[0;0])

#[logical]
def sing_exists_equiv2_4‹s_214,t_215› :
  ∀ {A_216 : Type‹s_214›} ->
    ∀ {m_217 : A_216} ->
      ∀ (x_218 :
        (exists_6‹??_50,??_51,t_215›
          ?_51[0;0]
          function _219 : A_216 -> ?_49[0;0]
          | a_221 => (eq_5‹??_52› ?_50[0;0] a_221 m_217))) ->
        (eq_5‹??_57›
          ?_56[0;0]
          ((sing_exists_2‹??_55,??_56›)
            ?_55[0;0] ?_54[0;0]
            ((exists_sing_1‹??_53,??_54›) ?_53[0;0] ?_52[0;0] x_218))
          x_218)
:=
  function sing_exists_equiv2_222 :
    ∀ {A_223 : Type‹s_214›} ->
      ∀ {m_224 : A_223} ->
        ∀ (x_225 :
          (exists_6‹??_41,??_42,t_215›
            ?_41[0;0]
            function _226 : A_223 -> ?_39[0;0]
            | a_228 => (eq_5‹??_43› ?_40[0;0] a_228 m_224))) ->
          (eq_5‹??_48›
            ?_46[0;0]
            ((sing_exists_2‹??_46,??_47›)
              ?_45[0;0] ?_44[0;0]
              ((exists_sing_1‹??_44,??_45›) ?_43[0;0] ?_42[0;0] x_225))
            x_225)
  | A_229 m_230 (ex_9 x_231 refl_8) =>
    (refl_8‹??_49› ?_47[0;0] ?_48[0;0])

#[program]
def sing_double_5‹s_232› :
  ∀ {A_233 : Type‹s_232›} ->
    ∀ {m_234 : A_233} ->
      (sing_7‹??_67› ?_64[0;0] m_234) ->
        (sing_7‹??_68› ?_65[0;0] m_234) -o
          (prod_8‹??_69,??_70,L› A_233 A_233)
:=
  function sing_double_237 :
    ∀ {A_238 : Type‹s_232›} ->
      ∀ {m_239 : A_238} ->
        (sing_7‹??_58› ?_57[0;0] m_239) ->
          (sing_7‹??_59› ?_58[0;0] m_239) -o
            (prod_8‹??_60,??_61,L› A_238 A_238)
  | A_242 m_243 (just_10 x_244) (just_10 y_245) =>
    let {pf_246} :=
      ((refl_8‹??_62› ?_59[0;0] ?_60[0;0])
        : (eq_5‹??_63› ?_61[0;0] x_244 y_245))
    in (pair_11‹??_64,??_65,??_66› ?_62[0;0] ?_63[0;0] x_244 y_245)

#[program]
def my_sing_6‹› : ?_67[0;0] := (just_10‹??_71› ?_66[0;0] true_2)

#[program]
def my_exists_7‹› :
  (exists_6‹??_74,??_75,U›
    ?_72[0;0]
    function _247 : bool_2 -> ?_70[0;0]
    | x_249 => (eq_5‹??_76› ?_71[0;0] x_249 true_2))
:= ((sing_exists_2‹??_72,??_73›) ?_69[0;0] ?_68[0;0] my_sing_6)

#[logical]
def axiom_K_8‹› :
  ∀ {A_250 : U} ->
    ∀ {m_251 : A_250} ->
      ∀ (x_252 : (eq_5‹??_81› ?_79[0;0] m_251 m_251)) ->
        (eq_5‹??_83›
          ?_82[0;0] x_252 (refl_8‹??_82› ?_80[0;0] ?_81[0;0]))
:=
  function axiom_K_253 :
    ∀ {A_254 : U} ->
      ∀ {m_255 : A_254} ->
        ∀ (x_256 : (eq_5‹??_77› ?_73[0;0] m_255 m_255)) ->
          (eq_5‹??_79›
            ?_76[0;0] x_256 (refl_8‹??_78› ?_74[0;0] ?_75[0;0]))
  | A_257 m_258 refl_8 => (refl_8‹??_80› ?_77[0;0] ?_78[0;0])

-----------------------------------------

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_4193 : nat_3) : nat_3

#[program]
inductive list_4‹› (A_4194 : U): U where
| nil_6 : (list_4 A_4194)
| cons_7 (hd_4195 : A_4194) (tl_4196 : (list_4 A_4194)) : (list_4 A_4194)

#[logical]
inductive eq_5‹s_4197› (A_4198 : Type‹s_4197›) (m_4199 : A_4198):
  A_4198 -> U
where
| refl_8 : (eq_5‹s_4197› A_4198 m_4199 m_4199)

#[program]
inductive exists_6‹s_4201,r_4202,t_4203› (A_4204 : Type‹s_4201›) (B_4205 : 
A_4204 -> Type‹r_4202›): Type‹t_4203› where
| ex_9
    (m_4207 : A_4204) {pf_4208 : ((B_4205) m_4207)}
    : (exists_6‹s_4201,r_4202,t_4203› A_4204 B_4205)

#[program]
inductive sing_7‹s_4209› (A_4210 : Type‹s_4209›):
  A_4210 -> Type‹s_4209›
where
| just_10 (m_4212 : A_4210) : (sing_7‹s_4209› A_4210 m_4212)

#[program]
inductive prod_8‹s_4213,r_4214,t_4215› (A_4216 : Type‹s_4213›) (B_4217 : Type‹r_4214›):
  Type‹t_4215›
where
| pair_11
    (m_4218 : A_4216) (n_4219 : B_4217)
    : (prod_8‹s_4213,r_4214,t_4215› A_4216 B_4217)

#[program]
def exists_sing_1‹s_4220,t_4221› :
  ∀ {A_4222 : Type‹s_4220›} ->
    ∀ {m_4223 : A_4222} ->
      (exists_6‹s_4220,U,t_4221›
        A_4222
        function _4225 : A_4222 -> U
        | __4227 => (eq_5‹s_4220› A_4222 __4227 m_4223)) ->
        (sing_7‹s_4220› A_4222 m_4223)
:=
  function exists_sing_4228 :
    ∀ {A_4229 : Type‹s_4220›} ->
      ∀ {m_4230 : A_4229} ->
        (exists_6‹s_4220,U,t_4221›
          A_4229
          function _4232 : A_4229 -> U
          | __4234 => (eq_5‹s_4220› A_4229 __4234 m_4230)) ->
          (sing_7‹s_4220› A_4229 m_4230)
  | A_4235 m_4236 (ex_9 m_4237 refl_8) => (just_10‹s_4220› A_4235 m_4237)

#[program]
def sing_exists_2‹s_4238,t_4239› :
  ∀ {A_4240 : Type‹s_4238›} ->
    ∀ {m_4241 : A_4240} ->
      (sing_7‹s_4238› A_4240 m_4241) ->
        (exists_6‹s_4238,U,t_4239›
          A_4240
          function _4243 : A_4240 -> U
          | __4245 => (eq_5‹s_4238› A_4240 __4245 m_4241))
:=
  function sing_exists_4246 :
    ∀ {A_4247 : Type‹s_4238›} ->
      ∀ {m_4248 : A_4247} ->
        (sing_7‹s_4238› A_4247 m_4248) ->
          (exists_6‹s_4238,U,t_4239›
            A_4247
            function _4250 : A_4247 -> U
            | __4252 => (eq_5‹s_4238› A_4247 __4252 m_4248))
  | A_4253 m_4254 (just_10 m_4255) =>
    (ex_9‹s_4238,U,t_4239›
      A_4253
      function _4256 : A_4253 -> U
      | __4258 => (eq_5‹s_4238› A_4253 __4258 m_4255) m_4255
      (refl_8‹s_4238› A_4253 m_4255))

#[logical]
def sing_exists_equiv1_3‹s_4259,t_4260› :
  ∀ {A_4261 : Type‹s_4259›} ->
    ∀ {m_4262 : A_4261} ->
      ∀ (x_4263 : (sing_7‹s_4259› A_4261 m_4262)) ->
        (eq_5‹s_4259›
          (sing_7‹s_4259› A_4261 m_4262)
          ((exists_sing_1‹s_4259,t_4260›)
            A_4261 m_4262
            ((sing_exists_2‹s_4259,t_4260›) A_4261 m_4262 x_4263))
          x_4263)
:=
  function sing_exists_equiv1_4264 :
    ∀ {A_4265 : Type‹s_4259›} ->
      ∀ {m_4266 : A_4265} ->
        ∀ (x_4267 : (sing_7‹s_4259› A_4265 m_4266)) ->
          (eq_5‹s_4259›
            (sing_7‹s_4259› A_4265 m_4266)
            ((exists_sing_1‹s_4259,t_4260›)
              A_4265 m_4266
              ((sing_exists_2‹s_4259,t_4260›) A_4265 m_4266 x_4267))
            x_4267)
  | A_4268 m_4269 (just_10 m_4270) =>
    (refl_8‹s_4259›
      (sing_7‹s_4259› A_4268 m_4270)
      ((exists_sing_1‹s_4259,t_4260›)
        A_4268 m_4270
        ((sing_exists_2‹s_4259,t_4260›)
          A_4268 m_4270 (just_10‹s_4259› A_4268 m_4270))))

#[logical]
def sing_exists_equiv2_4‹s_4271,t_4272› :
  ∀ {A_4273 : Type‹s_4271›} ->
    ∀ {m_4274 : A_4273} ->
      ∀ (x_4275 :
        (exists_6‹s_4271,U,t_4272›
          A_4273
          function _4276 : A_4273 -> U
          | __4278 => (eq_5‹s_4271› A_4273 __4278 m_4274))) ->
        (eq_5‹t_4272›
          (exists_6‹s_4271,U,t_4272›
            A_4273
            function _4279 : A_4273 -> U
            | __4281 => (eq_5‹s_4271› A_4273 __4281 m_4274))
          ((sing_exists_2‹s_4271,t_4272›)
            A_4273 m_4274
            ((exists_sing_1‹s_4271,t_4272›) A_4273 m_4274 x_4275))
          x_4275)
:=
  function sing_exists_equiv2_4282 :
    ∀ {A_4283 : Type‹s_4271›} ->
      ∀ {m_4284 : A_4283} ->
        ∀ (x_4285 :
          (exists_6‹s_4271,U,t_4272›
            A_4283
            function _4286 : A_4283 -> U
            | __4288 => (eq_5‹s_4271› A_4283 __4288 m_4284))) ->
          (eq_5‹t_4272›
            (exists_6‹s_4271,U,t_4272›
              A_4283
              function _4289 : A_4283 -> U
              | __4291 => (eq_5‹s_4271› A_4283 __4291 m_4284))
            ((sing_exists_2‹s_4271,t_4272›)
              A_4283 m_4284
              ((exists_sing_1‹s_4271,t_4272›) A_4283 m_4284 x_4285))
            x_4285)
  | A_4292 m_4293 (ex_9 m_4294 refl_8) =>
    (refl_8‹t_4272›
      (exists_6‹s_4271,U,t_4272›
        A_4292
        function _4295 : A_4292 -> U
        | __4297 => (eq_5‹s_4271› A_4292 __4297 m_4294))
      ((sing_exists_2‹s_4271,t_4272›)
        A_4292 m_4294
        ((exists_sing_1‹s_4271,t_4272›)
          A_4292 m_4294
          (ex_9‹s_4271,U,t_4272›
            A_4292
            function _4298 : A_4292 -> U
            | __4300 => (eq_5‹s_4271› A_4292 __4300 m_4294) m_4294
            (refl_8‹s_4271› A_4292 m_4294)))))

#[program]
def sing_double_5‹s_4301› :
  ∀ {A_4302 : Type‹s_4301›} ->
    ∀ {m_4303 : A_4302} ->
      (sing_7‹s_4301› A_4302 m_4303) ->
        (sing_7‹s_4301› A_4302 m_4303) -o
          (prod_8‹s_4301,s_4301,L› A_4302 A_4302)
:=
  function sing_double_4306 :
    ∀ {A_4307 : Type‹s_4301›} ->
      ∀ {m_4308 : A_4307} ->
        (sing_7‹s_4301› A_4307 m_4308) ->
          (sing_7‹s_4301› A_4307 m_4308) -o
            (prod_8‹s_4301,s_4301,L› A_4307 A_4307)
  | A_4311 m_4312 (just_10 m_4313) (just_10 m_4314) =>
    let {pf_4315} :=
      ((refl_8‹s_4301› A_4311 m_4313)
        : (eq_5‹s_4301› A_4311 m_4313 m_4314))
    in (pair_11‹s_4301,s_4301,L› A_4311 A_4311 m_4313 m_4314)

#[program]
def my_sing_6‹› : (sing_7‹U› bool_2 true_2) :=
  (just_10‹U› bool_2 true_2)

#[program]
def my_exists_7‹› :
  (exists_6‹U,U,U›
    bool_2
    function _4316 : bool_2 -> U
    | __4318 => (eq_5‹U› bool_2 __4318 true_2))
:= ((sing_exists_2‹U,U›) bool_2 true_2 my_sing_6)

#[logical]
def axiom_K_8‹› :
  ∀ {A_4319 : U} ->
    ∀ {m_4320 : A_4319} ->
      ∀ (x_4321 : (eq_5‹U› A_4319 m_4320 m_4320)) ->
        (eq_5‹U›
          (eq_5‹U› A_4319 m_4320 m_4320) x_4321
          (refl_8‹U› A_4319 m_4320))
:=
  function axiom_K_4322 :
    ∀ {A_4323 : U} ->
      ∀ {m_4324 : A_4323} ->
        ∀ (x_4325 : (eq_5‹U› A_4323 m_4324 m_4324)) ->
          (eq_5‹U›
            (eq_5‹U› A_4323 m_4324 m_4324) x_4325
            (refl_8‹U› A_4323 m_4324))
  | A_4326 m_4327 refl_8 =>
    (refl_8‹U›
      (eq_5‹U› A_4326 m_4327 m_4327) (refl_8‹U› A_4326 m_4327))

-----------------------------------------

#[program]
inductive unit_1 where
| tt_1 of layout[]

#[program]
inductive bool_2 where
| true_2 of layout[]
| false_3 of layout[]

#[program]
inductive nat_3 where
| zero_4 of layout[]
| succ_5 of layout[R]

#[program]
inductive list_4 where
| nil_6 of layout[]
| cons_7 of layout[R, R]

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
inductive existsUUU_18 where
| exUUU_21 of layout[R, N]

#[program]
inductive existsUUL_17 where
| exUUL_20 of layout[R, N]

#[program]
inductive existsULU_16 where
| exULU_19 of layout[R, N]

#[program]
inductive existsULL_15 where
| exULL_18 of layout[R, N]

#[program]
inductive existsLUU_14 where


#[program]
inductive existsLUL_13 where
| exLUL_16 of layout[R, N]

#[program]
inductive existsLLU_12 where


#[program]
inductive existsLLL_11 where
| exLLL_14 of layout[R, N]

#[program]
inductive singU_20 where
| justU_23 of layout[R]

#[program]
inductive singL_19 where
| justL_22 of layout[R]

#[program]
inductive prodUUU_28 where
| pairUUU_31 of layout[R, R]

#[program]
inductive prodUUL_27 where
| pairUUL_30 of layout[R, R]

#[program]
inductive prodULU_26 where


#[program]
inductive prodULL_25 where
| pairULL_28 of layout[R, R]

#[program]
inductive prodLUU_24 where


#[program]
inductive prodLUL_23 where
| pairLUL_26 of layout[R, R]

#[program]
inductive prodLLU_22 where


#[program]
inductive prodLLL_21 where
| pairLLL_24 of layout[R, R]

#[program]
def exists_singUU_12 :=
  fun exists_sing_7196 {A_7197} -> {m_7198} -> (__7199) ->
    match __7199 with
    | exUUU_21 m_7200 pf_7201 =>
      match {NULL} with
      | reflU_13  => (justU_23 m_7200)
      end
    end

#[program]
def exists_singUL_11 :=
  fun exists_sing_7202 {A_7203} -> {m_7204} -> (__7205) ->
    match __7205 with
    | exUUL_20 m_7206 pf_7207 =>
      match {NULL} with
      | reflU_13  => (justU_23 m_7206)
      end
    end

#[program]
def exists_singLU_10 :=
  fun exists_sing_7208 {A_7209} -> {m_7210} -> (__7211) ->
    match __7211 with
    
    end

#[program]
def exists_singLL_9 :=
  fun exists_sing_7212 {A_7213} -> {m_7214} -> (__7215) ->
    match __7215 with
    | exLUL_16 m_7216 pf_7217 =>
      match {NULL} with
      | reflL_12  => (justL_22 m_7216)
      end
    end

#[program]
def sing_existsUU_16 :=
  fun sing_exists_7218 {A_7219} -> {m_7220} -> (__7221) ->
    match __7221 with
    | justU_23 m_7222 => (exUUU_21 m_7222 NULL)
    end

#[program]
def sing_existsUL_15 :=
  fun sing_exists_7223 {A_7224} -> {m_7225} -> (__7226) ->
    match __7226 with
    | justU_23 m_7227 => (exUUL_20 m_7227 NULL)
    end

#[program]
def sing_existsLL_13 :=
  fun sing_exists_7228 {A_7229} -> {m_7230} -> (__7231) ->
    match __7231 with
    | justL_22 m_7232 => (exLUL_16 m_7232 NULL)
    end

#[logical]
def sing_exists_equiv1UU_20 := NULL

#[logical]
def sing_exists_equiv1UL_19 := NULL

#[logical]
def sing_exists_equiv1LL_17 := NULL

#[logical]
def sing_exists_equiv2UU_24 := NULL

#[logical]
def sing_exists_equiv2UL_23 := NULL

#[logical]
def sing_exists_equiv2LL_21 := NULL

#[program]
def sing_doubleU_26 :=
  fun sing_double_7233 {A_7234} -> {m_7235} -> (__7236) -> (__7237) -o
    match __7236 with
    | justU_23 m_7238 =>
      match __7237 with
      | justU_23 m_7239 => (pairUUL_30 m_7238 m_7239)
      end
    end

#[program]
def sing_doubleL_25 :=
  fun sing_double_7240 {A_7241} -> {m_7242} -> (__7243) -> (__7244) -o
    match __7243 with
    | justL_22 m_7245 =>
      match __7244 with
      | justL_22 m_7246 => (pairLLL_24 m_7245 m_7246)
      end
    end

#[program]
def my_sing_6 := (justU_23 true_2)

#[program]
def my_exists_7 := ((sing_existsUU_16) NULL NULL my_sing_6)

#[logical]
def axiom_K_8 := NULL

-----------------------------------------

#[program]
inductive unit_1 where
| tt_1 of layout[]

#[program]
inductive bool_2 where
| true_2 of layout[]
| false_3 of layout[]

#[program]
inductive nat_3 where
| zero_4 of layout[]
| succ_5 of layout[R]

#[program]
inductive list_4 where
| nil_6 of layout[]
| cons_7 of layout[R, R]

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
inductive existsUUU_18 where
| exUUU_21 of layout[R, N]

#[program]
inductive existsUUL_17 where
| exUUL_20 of layout[R, N]

#[program]
inductive existsULU_16 where
| exULU_19 of layout[R, N]

#[program]
inductive existsULL_15 where
| exULL_18 of layout[R, N]

#[program]
inductive existsLUU_14 where


#[program]
inductive existsLUL_13 where
| exLUL_16 of layout[R, N]

#[program]
inductive existsLLU_12 where


#[program]
inductive existsLLL_11 where
| exLLL_14 of layout[R, N]

#[program]
inductive singU_20 where
| justU_23 of layout[R]

#[program]
inductive singL_19 where
| justL_22 of layout[R]

#[program]
inductive prodUUU_28 where
| pairUUU_31 of layout[R, R]

#[program]
inductive prodUUL_27 where
| pairUUL_30 of layout[R, R]

#[program]
inductive prodULU_26 where


#[program]
inductive prodULL_25 where
| pairULL_28 of layout[R, R]

#[program]
inductive prodLUU_24 where


#[program]
inductive prodLUL_23 where
| pairLUL_26 of layout[R, R]

#[program]
inductive prodLLU_22 where


#[program]
inductive prodLLL_21 where
| pairLLL_24 of layout[R, R]

#[program]
def exists_singUU_12 :=
  fun exists_sing_7298 {A_7299} -> {m_7300} -> (__7301) ->
    match __7301 with
    | exUUU_21 m_7302 pf_7303 => (justU_23 m_7302)
    end

#[program]
def exists_singUL_11 :=
  fun exists_sing_7304 {A_7305} -> {m_7306} -> (__7307) ->
    match __7307 with
    | exUUL_20 m_7308 pf_7309 => (justU_23 m_7308)
    end

#[program]
def exists_singLU_10 :=
  fun exists_sing_7310 {A_7311} -> {m_7312} -> (__7313) ->
    !!

#[program]
def exists_singLL_9 :=
  fun exists_sing_7314 {A_7315} -> {m_7316} -> (__7317) ->
    match __7317 with
    | exLUL_16 m_7318 pf_7319 => (justL_22 m_7318)
    end

#[program]
def sing_existsUU_16 :=
  fun sing_exists_7320 {A_7321} -> {m_7322} -> (__7323) ->
    match __7323 with
    | justU_23 m_7324 => (exUUU_21 m_7324 NULL)
    end

#[program]
def sing_existsUL_15 :=
  fun sing_exists_7325 {A_7326} -> {m_7327} -> (__7328) ->
    match __7328 with
    | justU_23 m_7329 => (exUUL_20 m_7329 NULL)
    end

#[program]
def sing_existsLL_13 :=
  fun sing_exists_7330 {A_7331} -> {m_7332} -> (__7333) ->
    match __7333 with
    | justL_22 m_7334 => (exLUL_16 m_7334 NULL)
    end

#[logical]
def sing_exists_equiv1UU_20 := NULL

#[logical]
def sing_exists_equiv1UL_19 := NULL

#[logical]
def sing_exists_equiv1LL_17 := NULL

#[logical]
def sing_exists_equiv2UU_24 := NULL

#[logical]
def sing_exists_equiv2UL_23 := NULL

#[logical]
def sing_exists_equiv2LL_21 := NULL

#[program]
def sing_doubleU_26 :=
  fun sing_double_7335 {A_7336} -> {m_7337} -> (__7338) -> (__7339) -o
    match __7338 with
    | justU_23 m_7340 =>
      match __7339 with
      | justU_23 m_7341 => (pairUUL_30 m_7340 m_7341)
      end
    end

#[program]
def sing_doubleL_25 :=
  fun sing_double_7342 {A_7343} -> {m_7344} -> (__7345) -> (__7346) -o
    match __7345 with
    | justL_22 m_7347 =>
      match __7346 with
      | justL_22 m_7348 => (pairLLL_24 m_7347 m_7348)
      end
    end

#[program]
def my_sing_6 := (justU_23 true_2)

#[program]
def my_exists_7 := ((sing_existsUU_16) NULL NULL my_sing_6)

#[logical]
def axiom_K_8 := NULL

-----------------------------------------

def exists_singUU_12 := fun exists_sing_7400 () -> () -> (__7401) -> __7401

def exists_singUL_11 := fun exists_sing_7402 () -> () -> (__7403) -> __7403

def exists_singLU_10 := fun exists_sing_7404 () -> () -> (__7405) -> !!

def exists_singLL_9 := fun exists_sing_7406 () -> () -> (__7407) -> __7407

def sing_existsUU_16 := fun sing_exists_7408 () -> () -> (__7409) -> __7409

def sing_existsUL_15 := fun sing_exists_7410 () -> () -> (__7411) -> __7411

def sing_existsLL_13 := fun sing_exists_7412 () -> () -> (__7413) -> __7413

def sing_doubleU_26 :=
  fun sing_double_7414 () -> () -> (__7415) -> (__7416) -o
    (pairUUL_30 __7415 __7416)

def sing_doubleL_25 :=
  fun sing_double_7417 () -> () -> (__7418) -> (__7419) -o
    (pairLLL_24 __7418 __7419)

def my_sing_6 := true_2

def my_exists_7 := ((sing_existsUU_16) () () my_sing_6)

-----------------------------------------

