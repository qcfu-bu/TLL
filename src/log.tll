[Definition {name = "DH"; relv = N;
   body =
   (Binder ([],
      ((Fun (
          (Pi (R, U, Int_t,
             (Binder ("p", (Pi (R, U, Int_t, (Binder ("g", Proto)))))))),
          (Binder ((Some "DH"),
             [([(PId "p"); (PId "g")],
               (Some (Act (N, true, Int_t,
                        (Binder ("a",
                           (Act (R, true, Int_t,
                              (Binder ("A",
                                 (Act (N, true,
                                    (BOpr ("=", (Id ("A", I)),
                                       (App
                                          [(Id ("powm", I)); (Id ("g", I));
                                            (Id ("a", I)); (Id ("p", I))])
                                       )),
                                    (Binder ("_",
                                       (Act (N, false, Int_t,
                                          (Binder ("b",
                                             (Act (R, false, Int_t,
                                                (Binder ("B",
                                                   (Act (N, false,
                                                      (BOpr ("=",
                                                         (Id ("B", I)),
                                                         (App
                                                            [(Id ("powm", I));
                                                              (Id ("g", I));
                                                              (Id ("b", I));
                                                              (Id ("p", I))])
                                                         )),
                                                      (Binder ("_", End))))
                                                   ))
                                                ))
                                             ))
                                          ))
                                       ))
                                    ))
                                 ))
                              ))
                           ))
                        ))))
               ]
             )),
          [E; E])),
       (Pi (R, U, Int_t,
          (Binder ("p", (Pi (R, U, Int_t, (Binder ("g", Proto)))))))))
      ));
   view = [E; E]};
  Definition {name = "DH_ch"; relv = N;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, Int_t,
              (Binder ("p", (Pi (R, U, Int_t, (Binder ("g", IMeta)))))))),
           (Binder ((Some "DH_ch"),
              [([(PId "p"); (PId "g")],
                (Some (Ch (true,
                         (App [(Id ("DH", I)); (Id ("p", I)); (Id ("g", I))])
                         ))))
                ]
              )),
           [E; E])),
        (Pi (R, U, Int_t,
           (Binder ("p", (Pi (R, U, Int_t, (Binder ("g", IMeta)))))))))
       ));
    view = [E; E]};
  Definition {name = "DH_hc"; relv = N;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, Int_t,
              (Binder ("p", (Pi (R, U, Int_t, (Binder ("g", IMeta)))))))),
           (Binder ((Some "DH_hc"),
              [([(PId "p"); (PId "g")],
                (Some (Ch (false,
                         (App [(Id ("DH", I)); (Id ("p", I)); (Id ("g", I))])
                         ))))
                ]
              )),
           [E; E])),
        (Pi (R, U, Int_t,
           (Binder ("p", (Pi (R, U, Int_t, (Binder ("g", IMeta)))))))))
       ));
    view = [E; E]};
  Definition {name = "alice"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, Int_t,
              (Binder ("a",
                 (Pi (R, U, Int_t,
                    (Binder ("p",
                       (Pi (R, U, Int_t,
                          (Binder ("g",
                             (Pi (R, U,
                                (App
                                   [(Id ("DH_ch", I)); (Id ("p", I));
                                     (Id ("g", I))]),
                                (Binder ("c", (IO (Id ("unit", I)))))))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "alice"),
              [([(PId "a"); (PId "p"); (PId "g"); (PId "c")],
                (Some (MLet ((App [(Send (Id ("c", I))); (Id ("a", I))]),
                         (Binder ((PId "c"),
                            (MLet (
                               (App
                                  [(Send (Id ("c", I)));
                                    (App
                                       [(Id ("powm", I)); (Id ("g", I));
                                         (Id ("a", I)); (Id ("p", I))])
                                    ]),
                               (Binder ((PId "c"),
                                  (MLet (
                                     (App
                                        [(Send (Id ("c", I)));
                                          (Id ("refl", I))]),
                                     (Binder ((PId "c"),
                                        (MLet ((Recv (Id ("c", I))),
                                           (Binder (
                                              (PBOpr (
                                                 "\226\159\168{},\226\159\169",
                                                 (PId "b"), (PId "c"))),
                                              (MLet ((Recv (Id ("c", I))),
                                                 (Binder (
                                                    (PBOpr (
                                                       "\226\159\168,\226\159\169",
                                                       (PId "B"), (PId "c"))),
                                                    (MLet (
                                                       (Recv (Id ("c", I))),
                                                       (Binder (
                                                          (PBOpr (
                                                             "\226\159\168{},\226\159\169",
                                                             (PId "pf"),
                                                             (PId "c"))),
                                                          (Close
                                                             (Id ("c", I)))
                                                          ))
                                                       ))
                                                    ))
                                                 ))
                                              ))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))))
                ]
              )),
           [E; E; E; E])),
        (Pi (R, U, Int_t,
           (Binder ("a",
              (Pi (R, U, Int_t,
                 (Binder ("p",
                    (Pi (R, U, Int_t,
                       (Binder ("g",
                          (Pi (R, U,
                             (App
                                [(Id ("DH_ch", I)); (Id ("p", I));
                                  (Id ("g", I))]),
                             (Binder ("c", (IO (Id ("unit", I)))))))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E; E; E]};
  Definition {name = "bob"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, Int_t,
              (Binder ("b",
                 (Pi (R, U, Int_t,
                    (Binder ("p",
                       (Pi (R, U, Int_t,
                          (Binder ("g",
                             (Pi (R, U,
                                (App
                                   [(Id ("DH_hc", I)); (Id ("p", I));
                                     (Id ("g", I))]),
                                (Binder ("c", (IO (Id ("unit", I)))))))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "bob"),
              [([(PId "b"); (PId "p"); (PId "g"); (PId "c")],
                (Some (MLet ((Recv (Id ("c", I))),
                         (Binder (
                            (PBOpr ("\226\159\168{},\226\159\169", (PId "a"),
                               (PId "c"))),
                            (MLet ((Recv (Id ("c", I))),
                               (Binder (
                                  (PBOpr ("\226\159\168,\226\159\169",
                                     (PId "A"), (PId "c"))),
                                  (MLet ((Recv (Id ("c", I))),
                                     (Binder (
                                        (PBOpr (
                                           "\226\159\168{},\226\159\169",
                                           (PId "pf"), (PId "c"))),
                                        (MLet (
                                           (App
                                              [(Send (Id ("c", I)));
                                                (Id ("b", I))]),
                                           (Binder ((PId "c"),
                                              (MLet (
                                                 (App
                                                    [(Send (Id ("c", I)));
                                                      (App
                                                         [(Id ("powm", I));
                                                           (Id ("g", I));
                                                           (Id ("b", I));
                                                           (Id ("p", I))])
                                                      ]),
                                                 (Binder ((PId "c"),
                                                    (MLet (
                                                       (App
                                                          [(Send
                                                              (Id ("c", I)));
                                                            (Id ("refl", I))]),
                                                       (Binder ((PId "c"),
                                                          (Close
                                                             (Id ("c", I)))
                                                          ))
                                                       ))
                                                    ))
                                                 ))
                                              ))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))))
                ]
              )),
           [E; E; E; E])),
        (Pi (R, U, Int_t,
           (Binder ("b",
              (Pi (R, U, Int_t,
                 (Binder ("p",
                    (Pi (R, U, Int_t,
                       (Binder ("g",
                          (Pi (R, U,
                             (App
                                [(Id ("DH_hc", I)); (Id ("p", I));
                                  (Id ("g", I))]),
                             (Binder ("c", (IO (Id ("unit", I)))))))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E; E; E]};
  Definition {name = "key_exchange"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("unit", I)), (Binder ("_", (IO (Id ("unit", I)))))
              )),
           (Binder ((Some "key_exchange"),
              [([(PId "_")],
                (Some (Let (R, (Int 23),
                         (Binder ((PId "p"),
                            (Let (R, (Int 5),
                               (Binder ((PId "g"),
                                  (MLet (
                                     (Fork
                                        (Fun (
                                           (Pi (R, L,
                                              (App
                                                 [(Id ("DH_ch", I));
                                                   (Id ("p", I));
                                                   (Id ("g", I))]),
                                              (Binder ("",
                                                 (IO (Id ("unit", I)))))
                                              )),
                                           (Binder (None,
                                              [([(PId "c")],
                                                (Some (App
                                                         [(Id ("alice", I));
                                                           (Int 4);
                                                           (Id ("p", I));
                                                           (Id ("g", I));
                                                           (Id ("c", I))])))
                                                ]
                                              )),
                                           []))),
                                     (Binder ((PId "c"),
                                        (MLet (
                                           (Fork
                                              (Fun (
                                                 (Pi (R, L,
                                                    (Ch (true,
                                                       (Act (R, false,
                                                          (App
                                                             [(Id ("DH_hc", I
                                                                 ));
                                                               (Id ("p", I));
                                                               (Id ("g", I))]),
                                                          (Binder ("_", End))
                                                          ))
                                                       )),
                                                    (Binder ("",
                                                       (IO (Id ("unit", I)))
                                                       ))
                                                    )),
                                                 (Binder (None,
                                                    [([(PId "c0")],
                                                      (Some (MLet (
                                                               (Recv
                                                                  (Id ("c0",
                                                                    I))),
                                                               (Binder (
                                                                  (PBOpr (
                                                                    "\226\159\168,\226\159\169",
                                                                    (PId "c"),
                                                                    (PId "c0")
                                                                    )),
                                                                  (BOpr (";",
                                                                    (Close
                                                                    (Id (
                                                                    "c0", I))),
                                                                    (App
                                                                    [(Id (
                                                                    "bob", I
                                                                    ));
                                                                    (Int 3);
                                                                    (Id ("p",
                                                                    I));
                                                                    (Id ("g",
                                                                    I));
                                                                    (Id ("c",
                                                                    I))])))
                                                                  ))
                                                               ))))
                                                      ]
                                                    )),
                                                 []))),
                                           (Binder ((PId "c0"),
                                              (MLet (
                                                 (App
                                                    [(Send (Id ("c0", I)));
                                                      (Id ("c", I))]),
                                                 (Binder ((PId "c0"),
                                                    (Close (Id ("c0", I)))))
                                                 ))
                                              ))
                                           ))
                                        ))
                                     ))
                                  ))
                               ))
                            ))
                         ))))
                ]
              )),
           [E])),
        (Pi (R, U, (Id ("unit", I)), (Binder ("_", (IO (Id ("unit", I))))))))
       ));
    view = [E]};
  Definition {name = "main"; relv = R;
    body =
    (Binder ([],
       ((App [(Id ("key_exchange", I)); (Id ("tt", I))]),
        (IO (Id ("unit", I))))
       ));
    view = []}
  ]

-----------------------------------------

#[logical]
inductive eq_1‹s_296› (A_297 : Type‹s_296›) (m_298 : A_297):
  A_297 -> U
where
| refl_1 : (eq_1‹??_1› ?_1[0;0] m_298 m_298)

#[program]
def rwl_1‹s_300,r_301› :
  ∀ {A_302 : Type‹s_300›} ->
    ∀ {m_303 : A_302} ->
      ∀ {n_304 : A_302} ->
        ∀ {B_305 : A_302 -> Type‹r_301›} ->
          {(eq_1‹??_3› ?_3[0;0] m_303 n_304)} ->
            ((B_305) m_303) -> ((B_305) n_304)
:=
  fun rwl_309 :
    ∀ {A_310 : Type‹s_300›} ->
      ∀ {m_311 : A_310} ->
        ∀ {n_312 : A_310} ->
          ∀ {B_313 : A_310 -> Type‹r_301›} ->
            {(eq_1‹??_2› ?_2[0;0] m_311 n_312)} ->
              ((B_313) m_311) -> ((B_313) n_312)
  | A_317 m_318 n_319 B_320 refl_1 x_321 => x_321

#[program]
def rwr_2‹s_322,r_323› :
  ∀ {A_324 : Type‹s_322›} ->
    ∀ {m_325 : A_324} ->
      ∀ {n_326 : A_324} ->
        ∀ {B_327 : A_324 -> Type‹r_323›} ->
          {(eq_1‹??_5› ?_5[0;0] m_325 n_326)} ->
            ((B_327) n_326) -> ((B_327) m_325)
:=
  fun rwr_331 :
    ∀ {A_332 : Type‹s_322›} ->
      ∀ {m_333 : A_332} ->
        ∀ {n_334 : A_332} ->
          ∀ {B_335 : A_332 -> Type‹r_323›} ->
            {(eq_1‹??_4› ?_4[0;0] m_333 n_334)} ->
              ((B_335) n_334) -> ((B_335) m_333)
  | A_339 m_340 n_341 B_342 refl_1 x_343 => x_343

#[program]
inductive sing_2‹s_344› (A_345 : Type‹s_344›):
  A_345 -> Type‹s_344›
where
| just_2 (m_347 : A_345) : (sing_2‹??_6› ?_6[0;0] m_347)

#[program]
inductive unit_3‹› : U where
| tt_3 : unit_3

#[program]
inductive bool_4‹› : U where
| true_4 : bool_4
| false_5 : bool_4

#[program]
inductive list_5‹s_348,t_349› (A_350 : Type‹s_348›): Type‹t_349›
where
| nil_6 : (list_5‹??_7,??_8› A_350)
| cons_7
    (hd_351 : A_350) (tl_352 : (list_5‹??_9,t_349› A_350))
    : (list_5‹??_10,??_11› A_350)

#[program]
inductive exists0_6‹s_353,r_354› (A_355 : Type‹s_353›) (B_356 : 
A_355 -> Type‹r_354›): L where
| ex0_8
    {m_358 : A_355} (n_359 : ((B_356) m_358))
    : (exists0_6‹??_12,??_13› A_355 B_356)

#[program]
inductive exists1_7‹s_360,r_361› (A_362 : Type‹s_360›) (B_363 : 
A_362 -> Type‹r_361›): L where
| ex1_9
    (m_365 : A_362) (n_366 : ((B_363) m_365))
    : (exists1_7‹??_14,??_15› A_362 B_363)

#[logical]
def prod0_3‹s_367,r_368› :
  Type‹s_367› -> Type‹r_368› -> ?_10[0;0]
:=
  fun prod0_371 : Type‹s_367› -> Type‹r_368› -> ?_7[0;0]
  | A_374 B_375 =>
    (exists0_6‹??_16,??_17›
      A_374 fun _376 : ?_8[0;0] -> ?_9[0;0]
            | _378 => B_375)

#[logical]
def prod1_4‹s_379,r_380› :
  Type‹s_379› -> Type‹r_380› -> ?_14[0;0]
:=
  fun prod1_383 : Type‹s_379› -> Type‹r_380› -> ?_11[0;0]
  | A_386 B_387 =>
    (exists1_7‹??_18,??_19›
      A_386 fun _388 : ?_12[0;0] -> ?_13[0;0]
            | _390 => B_387)

#[program]
def not_5‹› : bool_4 -> bool_4 :=
  fun not_392 : bool_4 -> bool_4
  | true_4 => false_5
  | false_5 => true_4

#[program]
def and_6‹› : bool_4 -> bool_4 -> bool_4 :=
  fun and_396 : bool_4 -> bool_4 -> bool_4
  | true_4 true_4 => true_4
  | _399 _400 => false_5

#[program]
def or_7‹› : bool_4 -> bool_4 -> bool_4 :=
  fun or_403 : bool_4 -> bool_4 -> bool_4
  | false_5 false_5 => false_5
  | _406 _407 => true_4

#[program]
def xor_8‹› : bool_4 -> bool_4 -o bool_4 :=
  fun xor_410 : bool_4 -> bool_4 -o bool_4
  | true_4 true_4 => false_5
  | false_5 false_5 => false_5
  | _413 _414 => true_4

#[program]
def pow_9‹› : int -> int -> int :=
  fun pow_417 : int -> int -> int
  | x_420 y_421 =>
    let loop_422 :=
      fun loop_423 : int -> int -> int
      | acc_426 y_427 =>
        match (__lte__ y_427 0) in ?_15[0;0] -o ?_16[0;0] with
        | true_4 => acc_426
        | false_5 => ((loop_423) (__mul__ x_420 acc_426) (__sub__ y_427 1))
    in ((loop_422) 1 y_421)

#[program]
def powm_10‹› : int -> int -> int -> int :=
  fun powm_432 : int -> int -> int -> int
  | x_436 y_437 m_438 =>
    let loop_439 :=
      fun loop_440 : int -> int -> int
      | acc_443 y_444 =>
        match (__lte__ y_444 0) in ?_17[0;0] -o ?_18[0;0] with
        | true_4 => acc_443
        | false_5 =>
          ((loop_440)
            (__mod__ (__mul__ x_436 acc_443) m_438) (__sub__ y_444 1))
    in ((loop_439) 1 y_437)

#[logical]
def DH_11‹› : int -> int -> proto :=
  fun DH_448 : int -> int -> proto
  | p_451 g_452 =>
    ⇑{a_453 : int} ⇒
      ⇑(A_454 : int) ⇒
        ⇑{__455 :
          (eq_1‹??_20› ?_19[0;0] A_454 ((powm_10) g_452 a_453 p_451))} ⇒
          ⇓{b_456 : int} ⇒
            ⇓(B_457 : int) ⇒
              ⇓{__458 :
                (eq_1‹??_21›
                  ?_20[0;0] B_457 ((powm_10) g_452 b_456 p_451))} ⇒
                •

#[logical]
def DH_ch_12‹› : int -> int -> ?_22[0;0] :=
  fun DH_ch_461 : int -> int -> ?_21[0;0]
  | p_464 g_465 => ch⟨((DH_11) p_464 g_465)⟩

#[logical]
def DH_hc_13‹› : int -> int -> ?_24[0;0] :=
  fun DH_hc_468 : int -> int -> ?_23[0;0]
  | p_471 g_472 => hc⟨((DH_11) p_471 g_472)⟩

#[program]
def alice_14‹› :
  int ->
    ∀ (p_474 : int) ->
      ∀ (g_475 : int) -> ((DH_ch_12) p_474 g_475) -> IO unit_3
:=
  fun alice_477 :
    int ->
      ∀ (p_479 : int) ->
        ∀ (g_480 : int) -> ((DH_ch_12) p_479 g_480) -> IO unit_3
  | a_482 p_483 g_484 c_485 =>
    let* c_486 := ((send c_485) a_482) in
    let* c_487 := ((send c_486) ((powm_10) g_484 a_482 p_483)) in
    let* c_488 := ((send c_487) (refl_1‹??_22› ?_25[0;0] ?_26[0;0])) in
    let* _489 := recv c_488 in
    match _489 in ?_32[0;0] -o ?_31[0;0] with
    | (ex0_8 b_491 c_492) =>
      let* _493 := recv c_492 in
      match _493 in ?_30[0;0] -o ?_29[0;0] with
      | (ex1_9 B_495 c_496) =>
        let* _497 := recv c_496 in
        match _497 in ?_28[0;0] -o ?_27[0;0] with
        | (ex0_8 pf_499 c_500) => close c_500

#[program]
def bob_15‹› :
  int ->
    ∀ (p_502 : int) ->
      ∀ (g_503 : int) -> ((DH_hc_13) p_502 g_503) -> IO unit_3
:=
  fun bob_505 :
    int ->
      ∀ (p_507 : int) ->
        ∀ (g_508 : int) -> ((DH_hc_13) p_507 g_508) -> IO unit_3
  | b_510 p_511 g_512 c_513 =>
    let* _514 := recv c_513 in
    match _514 in ?_40[0;0] -o ?_39[0;0] with
    | (ex0_8 a_516 c_517) =>
      let* _518 := recv c_517 in
      match _518 in ?_38[0;0] -o ?_37[0;0] with
      | (ex1_9 A_520 c_521) =>
        let* _522 := recv c_521 in
        match _522 in ?_36[0;0] -o ?_35[0;0] with
        | (ex0_8 pf_524 c_525) =>
          let* c_526 := ((send c_525) b_510) in
          let* c_527 := ((send c_526) ((powm_10) g_512 b_510 p_511)) in
          let* c_528 :=
            ((send c_527) (refl_1‹??_23› ?_33[0;0] ?_34[0;0]))
          in close c_528

#[program]
def key_exchange_16‹› : unit_3 -> IO unit_3 :=
  fun key_exchange_530 : unit_3 -> IO unit_3
  | _532 =>
    let p_533 := 23 in
    let g_534 := 5 in
    let* c_535 :=
      fork
        fun _536 : ((DH_ch_12) p_533 g_534) -o IO unit_3
        | c_538 => ((alice_14) 4 p_533 g_534 c_538)
    in
    let* c0_539 :=
      fork
        fun _540 :
          ch⟨⇓(__542 : ((DH_hc_13) p_533 g_534)) ⇒ •⟩ -o IO unit_3
        | c0_543 =>
          let* _544 := recv c0_543 in
          match _544 in ?_42[0;0] -o ?_41[0;0] with
          | (ex1_9 c_546 c0_547) =>
            let* __548 := close c0_547 in ((bob_15) 3 p_533 g_534 c_546)
    in let* c0_549 := ((send c0_539) c_535) in close c0_549

#[program]
def main_17‹› : IO unit_3 := ((key_exchange_16) tt_3)

-----------------------------------------

#[logical]
inductive eq_1‹s_5824› (A_5825 : Type‹s_5824›) (m_5826 : A_5825):
  A_5825 -> U
where
| refl_1 : (eq_1‹s_5824› A_5825 m_5826 m_5826)

#[program]
def rwl_1‹s_5828,r_5829› :
  ∀ {A_5830 : Type‹s_5828›} ->
    ∀ {m_5831 : A_5830} ->
      ∀ {n_5832 : A_5830} ->
        ∀ {B_5833 : A_5830 -> Type‹r_5829›} ->
          {(eq_1‹s_5828› A_5830 m_5831 n_5832)} ->
            ((B_5833) m_5831) -> ((B_5833) n_5832)
:=
  fun rwl_5837 :
    ∀ {A_5838 : Type‹s_5828›} ->
      ∀ {m_5839 : A_5838} ->
        ∀ {n_5840 : A_5838} ->
          ∀ {B_5841 : A_5838 -> Type‹r_5829›} ->
            {(eq_1‹s_5828› A_5838 m_5839 n_5840)} ->
              ((B_5841) m_5839) -> ((B_5841) n_5840)
  | A_5845 m_5846 n_5847 B_5848 refl_1 __5849 => __5849

#[program]
def rwr_2‹s_5850,r_5851› :
  ∀ {A_5852 : Type‹s_5850›} ->
    ∀ {m_5853 : A_5852} ->
      ∀ {n_5854 : A_5852} ->
        ∀ {B_5855 : A_5852 -> Type‹r_5851›} ->
          {(eq_1‹s_5850› A_5852 m_5853 n_5854)} ->
            ((B_5855) n_5854) -> ((B_5855) m_5853)
:=
  fun rwr_5859 :
    ∀ {A_5860 : Type‹s_5850›} ->
      ∀ {m_5861 : A_5860} ->
        ∀ {n_5862 : A_5860} ->
          ∀ {B_5863 : A_5860 -> Type‹r_5851›} ->
            {(eq_1‹s_5850› A_5860 m_5861 n_5862)} ->
              ((B_5863) n_5862) -> ((B_5863) m_5861)
  | A_5867 m_5868 n_5869 B_5870 refl_1 __5871 => __5871

#[program]
inductive sing_2‹s_5872› (A_5873 : Type‹s_5872›):
  A_5873 -> Type‹s_5872›
where
| just_2 (m_5875 : A_5873) : (sing_2‹s_5872› A_5873 m_5875)

#[program]
inductive unit_3‹› : U where
| tt_3 : unit_3

#[program]
inductive bool_4‹› : U where
| true_4 : bool_4
| false_5 : bool_4

#[program]
inductive list_5‹s_5876,t_5877› (A_5878 : Type‹s_5876›):
  Type‹t_5877›
where
| nil_6 : (list_5‹s_5876,t_5877› A_5878)
| cons_7
    (hd_5879 : A_5878) (tl_5880 : (list_5‹s_5876,t_5877› A_5878))
    : (list_5‹s_5876,t_5877› A_5878)

#[program]
inductive exists0_6‹s_5881,r_5882› (A_5883 : Type‹s_5881›) (B_5884 : 
A_5883 -> Type‹r_5882›): L where
| ex0_8
    {m_5886 : A_5883} (n_5887 : ((B_5884) m_5886))
    : (exists0_6‹s_5881,r_5882› A_5883 B_5884)

#[program]
inductive exists1_7‹s_5888,r_5889› (A_5890 : Type‹s_5888›) (B_5891 : 
A_5890 -> Type‹r_5889›): L where
| ex1_9
    (m_5893 : A_5890) (n_5894 : ((B_5891) m_5893))
    : (exists1_7‹s_5888,r_5889› A_5890 B_5891)

#[logical]
def prod0_3‹s_5895,r_5896› : Type‹s_5895› -> Type‹r_5896› -> L :=
  fun prod0_5899 : Type‹s_5895› -> Type‹r_5896› -> L
  | A_5902 B_5903 =>
    (exists0_6‹s_5895,r_5896›
      A_5902 fun _5904 : A_5902 -> Type‹r_5896›
             | __5906 => B_5903)

#[logical]
def prod1_4‹s_5907,r_5908› : Type‹s_5907› -> Type‹r_5908› -> L :=
  fun prod1_5911 : Type‹s_5907› -> Type‹r_5908› -> L
  | A_5914 B_5915 =>
    (exists1_7‹s_5907,r_5908›
      A_5914 fun _5916 : A_5914 -> Type‹r_5908›
             | __5918 => B_5915)

#[program]
def not_5‹› : bool_4 -> bool_4 :=
  fun not_5920 : bool_4 -> bool_4
  | true_4 => false_5
  | false_5 => true_4

#[program]
def and_6‹› : bool_4 -> bool_4 -> bool_4 :=
  fun and_5924 : bool_4 -> bool_4 -> bool_4
  | true_4 true_4 => true_4
  | true_4 false_5 => false_5
  | false_5 __5927 => false_5

#[program]
def or_7‹› : bool_4 -> bool_4 -> bool_4 :=
  fun or_5930 : bool_4 -> bool_4 -> bool_4
  | true_4 __5933 => true_4
  | false_5 true_4 => true_4
  | false_5 false_5 => false_5

#[program]
def xor_8‹› : bool_4 -> bool_4 -o bool_4 :=
  fun xor_5936 : bool_4 -> bool_4 -o bool_4
  | true_4 true_4 => false_5
  | true_4 false_5 => true_4
  | false_5 true_4 => true_4
  | false_5 false_5 => false_5

#[program]
def pow_9‹› : int -> int -> int :=
  fun pow_5941 : int -> int -> int
  | x_5944 y_5945 =>
    let loop_5946 :=
      fun loop_5947 : int -> int -> int
      | acc_5950 y_5951 =>
        match (__lte__ y_5951 0) in bool_4 -o int with
        | true_4 => acc_5950
        | false_5 =>
          ((loop_5947) (__mul__ x_5944 acc_5950) (__sub__ y_5951 1))
    in ((loop_5946) 1 y_5945)

#[program]
def powm_10‹› : int -> int -> int -> int :=
  fun powm_5956 : int -> int -> int -> int
  | x_5960 y_5961 m_5962 =>
    let loop_5963 :=
      fun loop_5964 : int -> int -> int
      | acc_5967 y_5968 =>
        match (__lte__ y_5968 0) in bool_4 -o int with
        | true_4 => acc_5967
        | false_5 =>
          ((loop_5964)
            (__mod__ (__mul__ x_5960 acc_5967) m_5962) (__sub__ y_5968 1))
    in ((loop_5963) 1 y_5961)

#[logical]
def DH_11‹› : int -> int -> proto :=
  fun DH_5972 : int -> int -> proto
  | p_5975 g_5976 =>
    ⇑{a_5977 : int} ⇒
      ⇑(A_5978 : int) ⇒
        ⇑{__5979 :
          (eq_1‹U› int A_5978 ((powm_10) g_5976 a_5977 p_5975))} ⇒
          ⇓{b_5980 : int} ⇒
            ⇓(B_5981 : int) ⇒
              ⇓{__5982 :
                (eq_1‹U› int B_5981 ((powm_10) g_5976 b_5980 p_5975))} ⇒
                •

#[logical]
def DH_ch_12‹› : int -> int -> L :=
  fun DH_ch_5985 : int -> int -> L
  | p_5988 g_5989 => ch⟨((DH_11) p_5988 g_5989)⟩

#[logical]
def DH_hc_13‹› : int -> int -> L :=
  fun DH_hc_5992 : int -> int -> L
  | p_5995 g_5996 => hc⟨((DH_11) p_5995 g_5996)⟩

#[program]
def alice_14‹› :
  int ->
    ∀ (p_5998 : int) ->
      ∀ (g_5999 : int) -> ((DH_ch_12) p_5998 g_5999) -> IO unit_3
:=
  fun alice_6001 :
    int ->
      ∀ (p_6003 : int) ->
        ∀ (g_6004 : int) -> ((DH_ch_12) p_6003 g_6004) -> IO unit_3
  | a_6006 p_6007 g_6008 c_6009 =>
    let* c_6010 := ((send c_6009) a_6006) in
    let* c_6011 := ((send c_6010) ((powm_10) g_6008 a_6006 p_6007)) in
    let* c_6012 :=
      ((send c_6011) (refl_1‹U› int ((powm_10) g_6008 a_6006 p_6007)))
    in
    let* _6013 := recv c_6012 in
    match _6013 in
      (exists0_6‹U,L›
        int
        fun _6015 : int -> L
        | b_6017 =>
          ch⟨⇓(B_6018 : int) ⇒
                 ⇓{__6019 :
                   (eq_1‹U› int B_6018 ((powm_10) g_6008 b_6017 p_6007))} ⇒
                   •⟩) -o
        IO unit_3
    with
    | (ex0_8 m_6020 n_6021) =>
      let* _6022 := recv n_6021 in
      match _6022 in
        (exists1_7‹U,L›
          int
          fun _6024 : int -> L
          | B_6026 =>
            ch⟨⇓{__6027 :
                   (eq_1‹U› int B_6026 ((powm_10) g_6008 m_6020 p_6007))} ⇒
                   •⟩) -o
          IO unit_3
      with
      | (ex1_9 m_6028 n_6029) =>
        let* _6030 := recv n_6029 in
        match _6030 in
          (exists0_6‹U,L›
            (eq_1‹U› int m_6028 ((powm_10) g_6008 m_6020 p_6007))
            fun _6032 :
              (eq_1‹U› int m_6028 ((powm_10) g_6008 m_6020 p_6007)) -> L
            | __6034 => ch⟨•⟩) -o IO unit_3
        with
        | (ex0_8 m_6035 n_6036) => close n_6036

#[program]
def bob_15‹› :
  int ->
    ∀ (p_6038 : int) ->
      ∀ (g_6039 : int) -> ((DH_hc_13) p_6038 g_6039) -> IO unit_3
:=
  fun bob_6041 :
    int ->
      ∀ (p_6043 : int) ->
        ∀ (g_6044 : int) -> ((DH_hc_13) p_6043 g_6044) -> IO unit_3
  | b_6046 p_6047 g_6048 c_6049 =>
    let* _6050 := recv c_6049 in
    match _6050 in
      (exists0_6‹U,L›
        int
        fun _6052 : int -> L
        | a_6054 =>
          hc⟨⇑(A_6055 : int) ⇒
                 ⇑{__6056 :
                   (eq_1‹U› int A_6055 ((powm_10) g_6048 a_6054 p_6047))} ⇒
                   ⇓{b_6057 : int} ⇒
                     ⇓(B_6058 : int) ⇒
                       ⇓{__6059 :
                         (eq_1‹U›
                           int B_6058 ((powm_10) g_6048 b_6057 p_6047))} ⇒
                         •⟩) -o
        IO unit_3
    with
    | (ex0_8 m_6060 n_6061) =>
      let* _6062 := recv n_6061 in
      match _6062 in
        (exists1_7‹U,L›
          int
          fun _6064 : int -> L
          | A_6066 =>
            hc⟨⇑{__6067 :
                   (eq_1‹U› int A_6066 ((powm_10) g_6048 m_6060 p_6047))} ⇒
                   ⇓{b_6068 : int} ⇒
                     ⇓(B_6069 : int) ⇒
                       ⇓{__6070 :
                         (eq_1‹U›
                           int B_6069 ((powm_10) g_6048 b_6068 p_6047))} ⇒
                         •⟩) -o
          IO unit_3
      with
      | (ex1_9 m_6071 n_6072) =>
        let* _6073 := recv n_6072 in
        match _6073 in
          (exists0_6‹U,L›
            (eq_1‹U› int m_6071 ((powm_10) g_6048 m_6060 p_6047))
            fun _6075 :
              (eq_1‹U› int m_6071 ((powm_10) g_6048 m_6060 p_6047)) -> L
            | __6077 =>
              hc⟨⇓{b_6078 : int} ⇒
                     ⇓(B_6079 : int) ⇒
                       ⇓{__6080 :
                         (eq_1‹U›
                           int B_6079 ((powm_10) g_6048 b_6078 p_6047))} ⇒
                         •⟩) -o
            IO unit_3
        with
        | (ex0_8 m_6081 n_6082) =>
          let* c_6083 := ((send n_6082) b_6046) in
          let* c_6084 := ((send c_6083) ((powm_10) g_6048 b_6046 p_6047)) in
          let* c_6085 :=
            ((send c_6084)
              (refl_1‹U› int ((powm_10) g_6048 b_6046 p_6047)))
          in close c_6085

#[program]
def key_exchange_16‹› : unit_3 -> IO unit_3 :=
  fun key_exchange_6087 : unit_3 -> IO unit_3
  | __6089 =>
    let p_6090 := 23 in
    let g_6091 := 5 in
    let* c_6092 :=
      fork
        fun _6093 : ((DH_ch_12) p_6090 g_6091) -o IO unit_3
        | _6095 => ((alice_14) 4 p_6090 g_6091 _6095)
    in
    let* c0_6096 :=
      fork
        fun _6097 :
          ch⟨⇓(__6099 : ((DH_hc_13) p_6090 g_6091)) ⇒ •⟩ -o
            IO unit_3
        | _6100 =>
          let* _6101 := recv _6100 in
          match _6101 in
            (exists1_7‹L,L›
              ((DH_hc_13) p_6090 g_6091)
              fun _6103 : ((DH_hc_13) p_6090 g_6091) -> L
              | __6105 => ch⟨•⟩) -o IO unit_3
          with
          | (ex1_9 m_6106 n_6107) =>
            let* __6108 := close n_6107 in ((bob_15) 3 p_6090 g_6091 m_6106)
    in let* c0_6109 := ((send c0_6096) c_6092) in close c0_6109

#[program]
def main_17‹› : IO unit_3 := ((key_exchange_16) tt_3)

-----------------------------------------

#[logical]
inductive eqU_9 where
| reflU_11 of layout[]

#[logical]
inductive eqL_8 where
| reflL_10 of layout[]

#[program]
def rwlUU_21 :=
  fun rwl_12059 {A_12060} -> {m_12061} -> {n_12062} -> {B_12063} ->
  {__12064} -> (__12065) ->
    match {NULL} with
    | reflU_11  => __12065
    end

#[program]
def rwlUL_20 :=
  fun rwl_12066 {A_12067} -> {m_12068} -> {n_12069} -> {B_12070} ->
  {__12071} -> (__12072) ->
    match {NULL} with
    | reflU_11  => __12072
    end

#[program]
def rwlLU_19 :=
  fun rwl_12073 {A_12074} -> {m_12075} -> {n_12076} -> {B_12077} ->
  {__12078} -> (__12079) ->
    match {NULL} with
    | reflL_10  => __12079
    end

#[program]
def rwlLL_18 :=
  fun rwl_12080 {A_12081} -> {m_12082} -> {n_12083} -> {B_12084} ->
  {__12085} -> (__12086) ->
    match {NULL} with
    | reflL_10  => __12086
    end

#[program]
def rwrUU_25 :=
  fun rwr_12087 {A_12088} -> {m_12089} -> {n_12090} -> {B_12091} ->
  {__12092} -> (__12093) ->
    match {NULL} with
    | reflU_11  => __12093
    end

#[program]
def rwrUL_24 :=
  fun rwr_12094 {A_12095} -> {m_12096} -> {n_12097} -> {B_12098} ->
  {__12099} -> (__12100) ->
    match {NULL} with
    | reflU_11  => __12100
    end

#[program]
def rwrLU_23 :=
  fun rwr_12101 {A_12102} -> {m_12103} -> {n_12104} -> {B_12105} ->
  {__12106} -> (__12107) ->
    match {NULL} with
    | reflL_10  => __12107
    end

#[program]
def rwrLL_22 :=
  fun rwr_12108 {A_12109} -> {m_12110} -> {n_12111} -> {B_12112} ->
  {__12113} -> (__12114) ->
    match {NULL} with
    | reflL_10  => __12114
    end

#[program]
inductive singU_11 where
| justU_13 of layout[R]

#[program]
inductive singL_10 where
| justL_12 of layout[R]

#[program]
inductive unit_3 where
| tt_3 of layout[]

#[program]
inductive bool_4 where
| true_4 of layout[]
| false_5 of layout[]

#[program]
inductive listUU_15 where
| nilUU_20 of layout[]
| consUU_21 of layout[R, R]

#[program]
inductive listUL_14 where
| nilUL_18 of layout[]
| consUL_19 of layout[R, R]

#[program]
inductive listLU_13 where
| nilLU_16 of layout[]

#[program]
inductive listLL_12 where
| nilLL_14 of layout[]
| consLL_15 of layout[R, R]

#[program]
inductive exists0UU_19 where
| ex0UU_25 of layout[N, R]

#[program]
inductive exists0UL_18 where
| ex0UL_24 of layout[N, R]

#[program]
inductive exists0LU_17 where
| ex0LU_23 of layout[N, R]

#[program]
inductive exists0LL_16 where
| ex0LL_22 of layout[N, R]

#[program]
inductive exists1UU_23 where
| ex1UU_29 of layout[R, R]

#[program]
inductive exists1UL_22 where
| ex1UL_28 of layout[R, R]

#[program]
inductive exists1LU_21 where
| ex1LU_27 of layout[R, R]

#[program]
inductive exists1LL_20 where
| ex1LL_26 of layout[R, R]

#[logical]
def prod0UU_29 := NULL

#[logical]
def prod0UL_28 := NULL

#[logical]
def prod0LU_27 := NULL

#[logical]
def prod0LL_26 := NULL

#[logical]
def prod1UU_33 := NULL

#[logical]
def prod1UL_32 := NULL

#[logical]
def prod1LU_31 := NULL

#[logical]
def prod1LL_30 := NULL

#[program]
def not_5 :=
  fun not_12115 (__12116) ->
    match __12116 with
    | true_4  => false_5 | false_5  => true_4
    end

#[program]
def and_6 :=
  fun and_12117 (__12118) -> (__12119) ->
    match __12118 with
    | true_4  =>
      match __12119 with
      | true_4  => true_4 | false_5  => false_5
      end
    | false_5  => false_5
    end

#[program]
def or_7 :=
  fun or_12120 (__12121) -> (__12122) ->
    match __12121 with
    | true_4  => true_4
    | false_5  =>
      match __12122 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def xor_8 :=
  fun xor_12123 (__12124) -> (__12125) -o
    match __12124 with
    | true_4  =>
      match __12125 with
      | true_4  => false_5 | false_5  => true_4
      end
    | false_5  =>
      match __12125 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def pow_9 :=
  fun pow_12126 (x_12127) -> (y_12128) ->
    let loop_12129 :=
      fun loop_12130 (acc_12131) -> (y_12132) ->
        match (__lte__ y_12132 0) with
        | true_4  => acc_12131
        | false_5  =>
          ((loop_12130) (__mul__ x_12127 acc_12131) (__sub__ y_12132 1))
        end
    in ((loop_12129) 1 y_12128)

#[program]
def powm_10 :=
  fun powm_12133 (x_12134) -> (y_12135) -> (m_12136) ->
    let loop_12137 :=
      fun loop_12138 (acc_12139) -> (y_12140) ->
        match (__lte__ y_12140 0) with
        | true_4  => acc_12139
        | false_5  =>
          ((loop_12138)
            (__mod__ (__mul__ x_12134 acc_12139) m_12136) (__sub__ y_12140 1))
        end
    in ((loop_12137) 1 y_12135)

#[logical]
def DH_11 := NULL

#[logical]
def DH_ch_12 := NULL

#[logical]
def DH_hc_13 := NULL

#[program]
def alice_14 :=
  fun alice_12141 (a_12142) -> (p_12143) -> (g_12144) -> (c_12145) ->
    let* c_12146 := ((send[N,U] c_12145) NULL) in
    let* c_12147 := ((send[R,U] c_12146) ((powm_10) g_12144 a_12142 p_12143))
    in
    let* c_12148 := ((send[N,U] c_12147) NULL) in
    let* _12149 := recv[N,U] c_12148 in
    match _12149 with
    | ex0UL_24 m_12150 n_12151 =>
      let* _12152 := recv[R,U] n_12151 in
      match _12152 with
      | ex1UL_28 m_12153 n_12154 =>
        let* _12155 := recv[N,U] n_12154 in
        match _12155 with
        | ex0UL_24 m_12156 n_12157 => close[true] n_12157
        end
      end
    end

#[program]
def bob_15 :=
  fun bob_12158 (b_12159) -> (p_12160) -> (g_12161) -> (c_12162) ->
    let* _12163 := recv[N,U] c_12162 in
    match _12163 with
    | ex0UL_24 m_12164 n_12165 =>
      let* _12166 := recv[R,U] n_12165 in
      match _12166 with
      | ex1UL_28 m_12167 n_12168 =>
        let* _12169 := recv[N,U] n_12168 in
        match _12169 with
        | ex0UL_24 m_12170 n_12171 =>
          let* c_12172 := ((send[N,U] n_12171) NULL) in
          let* c_12173 :=
            ((send[R,U] c_12172) ((powm_10) g_12161 b_12159 p_12160))
          in
          let* c_12174 := ((send[N,U] c_12173) NULL) in close[false] c_12174
        end
      end
    end

#[program]
def key_exchange_16 :=
  fun key_exchange_12175 (__12176) ->
    let p_12177 := 23 in
    let g_12178 := 5 in
    let* c_12179 :=
      fork fun _12180 (_12181) -o
             ((alice_14) 4 p_12177 g_12178 _12181)
    in
    let* c0_12182 :=
      fork
        fun _12183 (_12184) -o
          let* _12185 := recv[R,L] _12184 in
          match _12185 with
          | ex1LL_26 m_12186 n_12187 =>
            let* __12188 := close[true] n_12187 in
            ((bob_15) 3 p_12177 g_12178 m_12186)
          end
    in
    let* c0_12189 := ((send[R,L] c0_12182) c_12179) in close[false] c0_12189

#[program]
def main := ((key_exchange_16) tt_3)

-----------------------------------------

#[logical]
inductive eqU_9 where
| reflU_11 of layout[]

#[logical]
inductive eqL_8 where
| reflL_10 of layout[]

#[program]
def rwlUU_21 :=
  fun rwl_12321 {A_12322} -> {m_12323} -> {n_12324} -> {B_12325} ->
  {__12326} -> (__12327) ->
    __12327

#[program]
def rwlUL_20 :=
  fun rwl_12328 {A_12329} -> {m_12330} -> {n_12331} -> {B_12332} ->
  {__12333} -> (__12334) ->
    __12334

#[program]
def rwlLU_19 :=
  fun rwl_12335 {A_12336} -> {m_12337} -> {n_12338} -> {B_12339} ->
  {__12340} -> (__12341) ->
    __12341

#[program]
def rwlLL_18 :=
  fun rwl_12342 {A_12343} -> {m_12344} -> {n_12345} -> {B_12346} ->
  {__12347} -> (__12348) ->
    __12348

#[program]
def rwrUU_25 :=
  fun rwr_12349 {A_12350} -> {m_12351} -> {n_12352} -> {B_12353} ->
  {__12354} -> (__12355) ->
    __12355

#[program]
def rwrUL_24 :=
  fun rwr_12356 {A_12357} -> {m_12358} -> {n_12359} -> {B_12360} ->
  {__12361} -> (__12362) ->
    __12362

#[program]
def rwrLU_23 :=
  fun rwr_12363 {A_12364} -> {m_12365} -> {n_12366} -> {B_12367} ->
  {__12368} -> (__12369) ->
    __12369

#[program]
def rwrLL_22 :=
  fun rwr_12370 {A_12371} -> {m_12372} -> {n_12373} -> {B_12374} ->
  {__12375} -> (__12376) ->
    __12376

#[program]
inductive singU_11 where
| justU_13 of layout[R]

#[program]
inductive singL_10 where
| justL_12 of layout[R]

#[program]
inductive unit_3 where
| tt_3 of layout[]

#[program]
inductive bool_4 where
| true_4 of layout[]
| false_5 of layout[]

#[program]
inductive listUU_15 where
| nilUU_20 of layout[]
| consUU_21 of layout[R, R]

#[program]
inductive listUL_14 where
| nilUL_18 of layout[]
| consUL_19 of layout[R, R]

#[program]
inductive listLU_13 where
| nilLU_16 of layout[]

#[program]
inductive listLL_12 where
| nilLL_14 of layout[]
| consLL_15 of layout[R, R]

#[program]
inductive exists0UU_19 where
| ex0UU_25 of layout[N, R]

#[program]
inductive exists0UL_18 where
| ex0UL_24 of layout[N, R]

#[program]
inductive exists0LU_17 where
| ex0LU_23 of layout[N, R]

#[program]
inductive exists0LL_16 where
| ex0LL_22 of layout[N, R]

#[program]
inductive exists1UU_23 where
| ex1UU_29 of layout[R, R]

#[program]
inductive exists1UL_22 where
| ex1UL_28 of layout[R, R]

#[program]
inductive exists1LU_21 where
| ex1LU_27 of layout[R, R]

#[program]
inductive exists1LL_20 where
| ex1LL_26 of layout[R, R]

#[logical]
def prod0UU_29 := NULL

#[logical]
def prod0UL_28 := NULL

#[logical]
def prod0LU_27 := NULL

#[logical]
def prod0LL_26 := NULL

#[logical]
def prod1UU_33 := NULL

#[logical]
def prod1UL_32 := NULL

#[logical]
def prod1LU_31 := NULL

#[logical]
def prod1LL_30 := NULL

#[program]
def not_5 :=
  fun not_12377 (__12378) ->
    match __12378 with
    | true_4  => false_5 | false_5  => true_4
    end

#[program]
def and_6 :=
  fun and_12379 (__12380) -> (__12381) ->
    match __12380 with
    | true_4  =>
      match __12381 with
      | true_4  => true_4 | false_5  => false_5
      end
    | false_5  => false_5
    end

#[program]
def or_7 :=
  fun or_12382 (__12383) -> (__12384) ->
    match __12383 with
    | true_4  => true_4
    | false_5  =>
      match __12384 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def xor_8 :=
  fun xor_12385 (__12386) -> (__12387) -o
    match __12386 with
    | true_4  =>
      match __12387 with
      | true_4  => false_5 | false_5  => true_4
      end
    | false_5  =>
      match __12387 with
      | true_4  => true_4 | false_5  => false_5
      end
    end

#[program]
def pow_9 :=
  fun pow_12388 (x_12389) -> (y_12390) ->
    let loop_12391 :=
      fun loop_12392 (acc_12393) -> (y_12394) ->
        match (__lte__ y_12394 0) with
        | true_4  => acc_12393
        | false_5  =>
          ((loop_12392) (__mul__ x_12389 acc_12393) (__sub__ y_12394 1))
        end
    in ((loop_12391) 1 y_12390)

#[program]
def powm_10 :=
  fun powm_12395 (x_12396) -> (y_12397) -> (m_12398) ->
    let loop_12399 :=
      fun loop_12400 (acc_12401) -> (y_12402) ->
        match (__lte__ y_12402 0) with
        | true_4  => acc_12401
        | false_5  =>
          ((loop_12400)
            (__mod__ (__mul__ x_12396 acc_12401) m_12398) (__sub__ y_12402 1))
        end
    in ((loop_12399) 1 y_12397)

#[logical]
def DH_11 := NULL

#[logical]
def DH_ch_12 := NULL

#[logical]
def DH_hc_13 := NULL

#[program]
def alice_14 :=
  fun alice_12403 (a_12404) -> (p_12405) -> (g_12406) -> (c_12407) ->
    let* c_12408 := ((send[N,U] c_12407) NULL) in
    let* c_12409 := ((send[R,U] c_12408) ((powm_10) g_12406 a_12404 p_12405))
    in
    let* c_12410 := ((send[N,U] c_12409) NULL) in
    let* _12411 := recv[N,U] c_12410 in
    match _12411 with
    | ex0UL_24 m_12412 n_12413 =>
      let* _12414 := recv[R,U] n_12413 in
      match _12414 with
      | ex1UL_28 m_12415 n_12416 =>
        let* _12417 := recv[N,U] n_12416 in
        match _12417 with
        | ex0UL_24 m_12418 n_12419 => close[true] n_12419
        end
      end
    end

#[program]
def bob_15 :=
  fun bob_12420 (b_12421) -> (p_12422) -> (g_12423) -> (c_12424) ->
    let* _12425 := recv[N,U] c_12424 in
    match _12425 with
    | ex0UL_24 m_12426 n_12427 =>
      let* _12428 := recv[R,U] n_12427 in
      match _12428 with
      | ex1UL_28 m_12429 n_12430 =>
        let* _12431 := recv[N,U] n_12430 in
        match _12431 with
        | ex0UL_24 m_12432 n_12433 =>
          let* c_12434 := ((send[N,U] n_12433) NULL) in
          let* c_12435 :=
            ((send[R,U] c_12434) ((powm_10) g_12423 b_12421 p_12422))
          in
          let* c_12436 := ((send[N,U] c_12435) NULL) in close[false] c_12436
        end
      end
    end

#[program]
def key_exchange_16 :=
  fun key_exchange_12437 (__12438) ->
    let p_12439 := 23 in
    let g_12440 := 5 in
    let* c_12441 :=
      fork fun _12442 (_12443) -o
             ((alice_14) 4 p_12439 g_12440 _12443)
    in
    let* c0_12444 :=
      fork
        fun _12445 (_12446) -o
          let* _12447 := recv[R,L] _12446 in
          match _12447 with
          | ex1LL_26 m_12448 n_12449 =>
            let* __12450 := close[true] n_12449 in
            ((bob_15) 3 p_12439 g_12440 m_12448)
          end
    in
    let* c0_12451 := ((send[R,L] c0_12444) c_12441) in close[false] c0_12451

#[program]
def main := ((key_exchange_16) tt_3)

-----------------------------------------

def rwlUU_21 :=
  fun rwl_12600 {A_12601} -> {m_12602} -> {n_12603} -> {B_12604} ->
  {__12605} -> (__12606) -> __12606

def rwlUL_20 :=
  fun rwl_12607 {A_12608} -> {m_12609} -> {n_12610} -> {B_12611} ->
  {__12612} -> (__12613) -> __12613

def rwlLU_19 :=
  fun rwl_12614 {A_12615} -> {m_12616} -> {n_12617} -> {B_12618} ->
  {__12619} -> (__12620) -> __12620

def rwlLL_18 :=
  fun rwl_12621 {A_12622} -> {m_12623} -> {n_12624} -> {B_12625} ->
  {__12626} -> (__12627) -> __12627

def rwrUU_25 :=
  fun rwr_12628 {A_12629} -> {m_12630} -> {n_12631} -> {B_12632} ->
  {__12633} -> (__12634) -> __12634

def rwrUL_24 :=
  fun rwr_12635 {A_12636} -> {m_12637} -> {n_12638} -> {B_12639} ->
  {__12640} -> (__12641) -> __12641

def rwrLU_23 :=
  fun rwr_12642 {A_12643} -> {m_12644} -> {n_12645} -> {B_12646} ->
  {__12647} -> (__12648) -> __12648

def rwrLL_22 :=
  fun rwr_12649 {A_12650} -> {m_12651} -> {n_12652} -> {B_12653} ->
  {__12654} -> (__12655) -> __12655

def not_5 :=
  fun not_12656 (__12657) ->
    match __12657 with
    | true_4 => false_5 | false_5 => true_4
    end

def and_6 :=
  fun and_12658 (__12659) -> (__12660) ->
    match __12659 with
    | true_4 =>
      match __12660 with
      | true_4 => true_4 | false_5 => false_5
      end
    | false_5 => false_5
    end

def or_7 :=
  fun or_12661 (__12662) -> (__12663) ->
    match __12662 with
    | true_4 => true_4
    | false_5 =>
      match __12663 with
      | true_4 => true_4 | false_5 => false_5
      end
    end

def xor_8 :=
  fun xor_12664 (__12665) -> (__12666) -o
    match __12665 with
    | true_4 =>
      match __12666 with
      | true_4 => false_5 | false_5 => true_4
      end
    | false_5 =>
      match __12666 with
      | true_4 => true_4 | false_5 => false_5
      end
    end

def pow_9 :=
  fun pow_12667 (x_12668) -> (y_12669) ->
    let loop_12670 :=
      fun loop_12671 (acc_12672) -> (y_12673) ->
        match (__lte__ y_12673 0) with
        | true_4 => acc_12672
        | false_5 =>
          ((loop_12671) (__mul__ x_12668 acc_12672) (__sub__ y_12673 1))
        end
    in ((loop_12670) 1 y_12669)

def powm_10 :=
  fun powm_12674 (x_12675) -> (y_12676) -> (m_12677) ->
    let loop_12678 :=
      fun loop_12679 (acc_12680) -> (y_12681) ->
        match (__lte__ y_12681 0) with
        | true_4 => acc_12680
        | false_5 =>
          ((loop_12679)
            (__mod__ (__mul__ x_12675 acc_12680) m_12677) (__sub__ y_12681 1))
        end
    in ((loop_12678) 1 y_12676)

def alice_14 :=
  fun alice_12682 (a_12683) -> (p_12684) -> (g_12685) -> (c_12686) ->
    lazy(let c_12687 := force(((lam (x_12688) -> lazy(c_12686)) NULL)) in
         let c_12689 :=
           force(((lam (x_12690) -> lazy(send(c_12687, x_12690)))
                   ((powm_10) g_12685 a_12683 p_12684)))
         in
         let c_12691 := force(((lam (x_12692) -> lazy(c_12689)) NULL)) in
         let _12693 := force(lazy(c_12691)) in
         force(lazy(let _12694 := force(lazy(recv[U](_12693))) in
                    force(match _12694 with
                          | ex1UL_28 m_12695 n_12696 =>
                            lazy(let _12697 := force(lazy(n_12696)) in
                                 force(lazy(close[true] _12697)))
                          end))))

def bob_15 :=
  fun bob_12698 (b_12699) -> (p_12700) -> (g_12701) -> (c_12702) ->
    lazy(let _12703 := force(lazy(c_12702)) in
         force(lazy(let _12704 := force(lazy(recv[U](_12703))) in
                    force(match _12704 with
                          | ex1UL_28 m_12705 n_12706 =>
                            lazy(let _12707 := force(lazy(n_12706)) in
                                 force(lazy(let c_12708 :=
                                              force(((lam (x_12709) ->
                                                        lazy(_12707))
                                                      NULL))
                                            in
                                            let c_12710 :=
                                              force(((lam (x_12711) ->
                                                        lazy(send(c_12708, x_12711)))
                                                      ((powm_10)
                                                        g_12701 b_12699
                                                          p_12700)))
                                            in
                                            let c_12712 :=
                                              force(((lam (x_12713) ->
                                                        lazy(c_12710))
                                                      NULL))
                                            in
                                            force(lazy(close[false] c_12712)))))
                          end))))

def key_exchange_16 :=
  fun key_exchange_12714 (__12715) ->
    let p_12716 := 23 in
    let g_12717 := 5 in
    lazy(let c_12718 :=
           force(lazy(fork
                        fun _12719 (_12720) -o
                          ((alice_14) 4 p_12716 g_12717 _12720)))
         in
         let c0_12721 :=
           force(lazy(fork
                        fun _12722 (_12723) -o
                          lazy(let _12724 := force(lazy(recv[L](_12723))) in
                               force(match _12724 with
                                     | ex1LL_26 m_12725 n_12726 =>
                                       lazy(let __12727 :=
                                              force(lazy(close[true] n_12726))
                                            in
                                            force(((bob_15)
                                                    3 p_12716 g_12717 m_12725)))
                                     end))))
         in
         let c0_12728 :=
           force(((lam (x_12729) -> lazy(send(c0_12721, x_12729))) c_12718))
         in force(lazy(close[false] c0_12728)))

def main := ((key_exchange_16) tt_3)

-----------------------------------------

def rwlUU_21 :=
  lam {A_12883} -> {m_12884} -> {n_12885} -> {B_12886} -> {__12887} ->
  (__12888) -> __12888

def rwlUL_20 :=
  lam {A_12889} -> {m_12890} -> {n_12891} -> {B_12892} -> {__12893} ->
  (__12894) -> __12894

def rwlLU_19 :=
  lam {A_12895} -> {m_12896} -> {n_12897} -> {B_12898} -> {__12899} ->
  (__12900) -> __12900

def rwlLL_18 :=
  lam {A_12901} -> {m_12902} -> {n_12903} -> {B_12904} -> {__12905} ->
  (__12906) -> __12906

def rwrUU_25 :=
  lam {A_12907} -> {m_12908} -> {n_12909} -> {B_12910} -> {__12911} ->
  (__12912) -> __12912

def rwrUL_24 :=
  lam {A_12913} -> {m_12914} -> {n_12915} -> {B_12916} -> {__12917} ->
  (__12918) -> __12918

def rwrLU_23 :=
  lam {A_12919} -> {m_12920} -> {n_12921} -> {B_12922} -> {__12923} ->
  (__12924) -> __12924

def rwrLL_22 :=
  lam {A_12925} -> {m_12926} -> {n_12927} -> {B_12928} -> {__12929} ->
  (__12930) -> __12930

def not_5 :=
  lam (__12931) ->
    match __12931 with
    | true_4 => false_5 | false_5 => true_4
    end

def and_6 :=
  lam (__12932) -> (__12933) ->
    match __12932 with
    | true_4 =>
      match __12933 with
      | true_4 => true_4 | false_5 => false_5
      end
    | false_5 => false_5
    end

def or_7 :=
  lam (__12934) -> (__12935) ->
    match __12934 with
    | true_4 => true_4
    | false_5 =>
      match __12935 with
      | true_4 => true_4 | false_5 => false_5
      end
    end

def xor_8 :=
  lam (__12936) -> (__12937) -o
    match __12936 with
    | true_4 =>
      match __12937 with
      | true_4 => false_5 | false_5 => true_4
      end
    | false_5 =>
      match __12937 with
      | true_4 => true_4 | false_5 => false_5
      end
    end

def pow_9 :=
  lam (x_12938) -> (y_12939) ->
    let loop_12940 :=
      fun loop_12941 (acc_12942) -> (y_12943) ->
        match (__lte__ y_12943 0) with
        | true_4 => acc_12942
        | false_5 =>
          ((loop_12941) (__mul__ x_12938 acc_12942) (__sub__ y_12943 1))
        end
    in ((loop_12940) 1 y_12939)

def powm_10 :=
  lam (x_12944) -> (y_12945) -> (m_12946) ->
    let loop_12947 :=
      fun loop_12948 (acc_12949) -> (y_12950) ->
        match (__lte__ y_12950 0) with
        | true_4 => acc_12949
        | false_5 =>
          ((loop_12948)
            (__mod__ (__mul__ x_12944 acc_12949) m_12946) (__sub__ y_12950 1))
        end
    in ((loop_12947) 1 y_12945)

def alice_14 :=
  lam (a_12951) -> (p_12952) -> (g_12953) -> (c_12954) ->
    lazy(let c_12955 := send(c_12954, ((powm_10) g_12953 a_12951 p_12952)) in
         let _12956 := recv[U](c_12955) in
         match _12956 with
         | ex1UL_28 m_12957 n_12958 => close[true] n_12958
         end)

def bob_15 :=
  lam (b_12959) -> (p_12960) -> (g_12961) -> (c_12962) ->
    lazy(let _12963 := recv[U](c_12962) in
         match _12963 with
         | ex1UL_28 m_12964 n_12965 =>
           let c_12966 := send(n_12965, ((powm_10) g_12961 b_12959 p_12960))
           in close[false] c_12966
         end)

def key_exchange_16 :=
  lam (__12967) ->
    let p_12968 := 23 in
    let g_12969 := 5 in
    lazy(let c_12970 :=
           fork lam (_12971) -o ((alice_14) 4 p_12968 g_12969 _12971)
         in
         let c0_12972 :=
           fork
             lam (_12973) -o
               lazy(let _12974 := recv[L](_12973) in
                    match _12974 with
                    | ex1LL_26 m_12975 n_12976 =>
                      let __12977 := close[true] n_12976 in
                      force(((bob_15) 3 p_12968 g_12969 m_12975))
                    end)
         in let c0_12978 := send(c0_12972, c_12970) in close[false] c0_12978)

def main := ((key_exchange_16) tt_3)

-----------------------------------------

