[Inductive {name = "unit"; relv = R;
   body =
   (Binder ([],
      (PBase
         ((TBase (Type U)), [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
      ));
   view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "list"; relv = R;
    body =
    (Binder ([],
       (PBind ((Type U),
          (Binder ("A",
             (PBase
                ((TBase (Type U)),
                 [(DConstr ("nil",
                     (TBase (App [(Id ("list", I)); (Id ("A", I))])), 
                     []));
                   (DConstr ("cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (App [(Id ("list", I)); (Id ("A", I))]),
                               (Binder ("tl",
                                  (TBase
                                     (App [(Id ("list", I)); (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Notation {name = "::"; body = (App [(Id ("cons", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "eq"; relv = N;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Id ("A", I)),
                (Binder ("m",
                   (PBase
                      ((TBind (R, (Id ("A", I)),
                          (Binder ("_", (TBase (Type U)))))),
                       [(DConstr ("refl",
                           (TBase
                              (App
                                 [(Id ("eq", I)); (Id ("m", I));
                                   (Id ("m", I))])),
                           []))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Notation {name = "="; body = (App [(Id ("eq", I)); (Hole 1); (Hole 2)])};
  Inductive {name = "exists"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind (
                (Pi (R, U, (Id ("A", I)), (Binder ("_", (Type (SId "r")))))),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("ex",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (N,
                                    (App [(Id ("B", I)); (Id ("m", I))]),
                                    (Binder ("pf",
                                       (TBase
                                          (App
                                             [(Id ("exists", I));
                                               (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [I; E]};
  Inductive {name = "sing"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBind (R, (Id ("A", I)),
                    (Binder ("_", (TBase (Type (SId "s"))))))),
                 [(DConstr ("just",
                     (TBind (R, (Id ("A", I)),
                        (Binder ("m",
                           (TBase (App [(Id ("sing", I)); (Id ("m", I))]))))
                        )),
                     [E]))
                   ]))
             ))
          ))
       ));
    view = [I]};
  Notation {name = "`"; body = (App [(Id ("sing", I)); (Hole 1)])};
  Inductive {name = "prod"; relv = R;
    body =
    (Binder (["s"; "r"; "t"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBind ((Type (SId "r")),
                (Binder ("B",
                   (PBase
                      ((TBase (Type (SId "t"))),
                       [(DConstr ("pair",
                           (TBind (R, (Id ("A", I)),
                              (Binder ("m",
                                 (TBind (R, (Id ("B", I)),
                                    (Binder ("n",
                                       (TBase
                                          (App
                                             [(Id ("prod", I));
                                               (Id ("A", I)); (Id ("B", I))]))
                                       ))
                                    ))
                                 ))
                              )),
                           [E; E]))
                         ]))
                   ))
                ))
             ))
          ))
       ));
    view = [E; E]};
  Notation {name = "**";
    body =
    (App [(Inst ("prod", [(SId "_"); (SId "_"); L], I)); (Hole 1); (Hole 2)])};
  Definition {name = "exists_sing"; relv = R;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U,
                          (App
                             [(Inst ("exists",
                                 [(SId "_"); (SId "_"); (SId "t")], I));
                               (Fun (
                                  (Pi (R, U, (Id ("A", I)),
                                     (Binder ("a", IMeta)))),
                                  (Binder (None,
                                     [([(PId "a")],
                                       (Some (BOpr ("=", (Id ("a", I)),
                                                (Id ("m", I))))))
                                       ]
                                     )),
                                  []))
                               ]),
                          (Binder ("_", (UOpr ("`", (Id ("m", I))))))))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "exists_sing"),
              [([(PId "A"); (PId "m");
                  (PConstr ("ex", [(PId "x"); (PId "refl")]))],
                (Some (App [(Id ("just", I)); (Id ("x", I))])))]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U,
                       (App
                          [(Inst ("exists",
                              [(SId "_"); (SId "_"); (SId "t")], I));
                            (Fun (
                               (Pi (R, U, (Id ("A", I)),
                                  (Binder ("a", IMeta)))),
                               (Binder (None,
                                  [([(PId "a")],
                                    (Some (BOpr ("=", (Id ("a", I)),
                                             (Id ("m", I))))))
                                    ]
                                  )),
                               []))
                            ]),
                       (Binder ("_", (UOpr ("`", (Id ("m", I))))))))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "sing_exists"; relv = R;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                          (Binder ("_",
                             (App
                                [(Inst ("exists",
                                    [(SId "_"); (SId "_"); (SId "t")], I));
                                  (Fun (
                                     (Pi (R, U, (Id ("A", I)),
                                        (Binder ("a", IMeta)))),
                                     (Binder (None,
                                        [([(PId "a")],
                                          (Some (BOpr ("=", (Id ("a", I)),
                                                   (Id ("m", I))))))
                                          ]
                                        )),
                                     []))
                                  ])
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_exists"),
              [([(PId "A"); (PId "m"); (PConstr ("just", [(PId "x")]))],
                (Some (App [(Id ("ex", I)); (Id ("x", I)); (Id ("refl", I))])))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                       (Binder ("_",
                          (App
                             [(Inst ("exists",
                                 [(SId "_"); (SId "_"); (SId "t")], I));
                               (Fun (
                                  (Pi (R, U, (Id ("A", I)),
                                     (Binder ("a", IMeta)))),
                                  (Binder (None,
                                     [([(PId "a")],
                                       (Some (BOpr ("=", (Id ("a", I)),
                                                (Id ("m", I))))))
                                       ]
                                     )),
                                  []))
                               ])
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Definition {name = "sing_exists_equiv1"; relv = N;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                          (Binder ("x",
                             (BOpr ("=",
                                (App
                                   [(Id ("exists_sing", I));
                                     (App
                                        [(Inst ("sing_exists",
                                            [(SId "_"); (SId "t")], I));
                                          (Id ("x", I))])
                                     ]),
                                (Id ("x", I))))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_exists_equiv1"),
              [([(PId "A"); (PId "m"); (PConstr ("just", [(PId "x")]))],
                (Some (Id ("refl", I))))]
              )),
           [E; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                       (Binder ("x",
                          (BOpr ("=",
                             (App
                                [(Id ("exists_sing", I));
                                  (App
                                     [(Inst ("sing_exists",
                                         [(SId "_"); (SId "t")], I));
                                       (Id ("x", I))])
                                  ]),
                             (Id ("x", I))))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "sing_exists_equiv2"; relv = N;
    body =
    (Binder (["s"; "t"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U,
                          (App
                             [(Inst ("exists",
                                 [(SId "_"); (SId "_"); (SId "t")], I));
                               (Fun (
                                  (Pi (R, U, (Id ("A", I)),
                                     (Binder ("a", IMeta)))),
                                  (Binder (None,
                                     [([(PId "a")],
                                       (Some (BOpr ("=", (Id ("a", I)),
                                                (Id ("m", I))))))
                                       ]
                                     )),
                                  []))
                               ]),
                          (Binder ("x",
                             (BOpr ("=",
                                (App
                                   [(Id ("sing_exists", I));
                                     (App
                                        [(Id ("exists_sing", I));
                                          (Id ("x", I))])
                                     ]),
                                (Id ("x", I))))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_exists_equiv2"),
              [([(PId "A"); (PId "m");
                  (PConstr ("ex", [(PId "x"); (PId "refl")]))],
                (Some (Id ("refl", I))))]
              )),
           [E; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U,
                       (App
                          [(Inst ("exists",
                              [(SId "_"); (SId "_"); (SId "t")], I));
                            (Fun (
                               (Pi (R, U, (Id ("A", I)),
                                  (Binder ("a", IMeta)))),
                               (Binder (None,
                                  [([(PId "a")],
                                    (Some (BOpr ("=", (Id ("a", I)),
                                             (Id ("m", I))))))
                                    ]
                                  )),
                               []))
                            ]),
                       (Binder ("x",
                          (BOpr ("=",
                             (App
                                [(Id ("sing_exists", I));
                                  (App
                                     [(Id ("exists_sing", I)); (Id ("x", I))])
                                  ]),
                             (Id ("x", I))))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "sing_double"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                          (Binder ("_",
                             (Pi (R, L, (UOpr ("`", (Id ("m", I)))),
                                (Binder ("_",
                                   (BOpr ("**", (Id ("A", I)), (Id ("A", I))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "sing_double"),
              [([(PId "A"); (PId "m"); (PConstr ("just", [(PId "x")]));
                  (PConstr ("just", [(PId "y")]))],
                (Some (Let (N,
                         (Ann ((Id ("refl", I)),
                            (BOpr ("=", (Id ("x", I)), (Id ("y", I)))))),
                         (Binder ("pf",
                            (App
                               [(Id ("pair", I)); (Id ("x", I));
                                 (Id ("y", I))])
                            ))
                         ))))
                ]
              )),
           [E; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (UOpr ("`", (Id ("m", I)))),
                       (Binder ("_",
                          (Pi (R, L, (UOpr ("`", (Id ("m", I)))),
                             (Binder ("_",
                                (BOpr ("**", (Id ("A", I)), (Id ("A", I))))))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E]};
  Definition {name = "axiom_K"; relv = N;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type U),
              (Binder ("A",
                 (Pi (N, U, (Id ("A", I)),
                    (Binder ("m",
                       (Pi (R, U, (BOpr ("=", (Id ("m", I)), (Id ("m", I)))),
                          (Binder ("x",
                             (BOpr ("=", (Id ("x", I)), (Id ("refl", I))))))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "axiom_K"),
              [([(PId "A"); (PId "m"); (PId "refl")], (Some (Id ("refl", I))))
                ]
              )),
           [I; I])),
        (Pi (N, U, (Type U),
           (Binder ("A",
              (Pi (N, U, (Id ("A", I)),
                 (Binder ("m",
                    (Pi (R, U, (BOpr ("=", (Id ("m", I)), (Id ("m", I)))),
                       (Binder ("x",
                          (BOpr ("=", (Id ("x", I)), (Id ("refl", I))))))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [I; I]};
  Notation {name = "|>"; body = (App [(Hole 2); (Hole 1)])};
  Definition {name = "test"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (N, U, (Type U),
              (Binder ("A",
                 (Pi (N, U, (Type U),
                    (Binder ("B",
                       (Pi (N, U, (Type U),
                          (Binder ("C",
                             (Pi (R, U, (Id ("A", I)),
                                (Binder ("m",
                                   (Pi (R, U,
                                      (Pi (R, U, (Id ("A", I)),
                                         (Binder ("_", (Id ("B", I)))))),
                                      (Binder ("f",
                                         (Pi (R, U,
                                            (Pi (R, U, (Id ("B", I)),
                                               (Binder ("_", (Id ("C", I))))
                                               )),
                                            (Binder ("g", IMeta))))
                                         ))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              )),
           (Binder ((Some "test"),
              [([(PId "A"); (PId "B"); (PId "C"); (PId "m"); (PId "f");
                  (PId "g")],
                (Some (BOpr ("|>",
                         (BOpr ("|>", (Id ("m", I)), (Id ("f", I)))),
                         (Id ("g", I))))))
                ]
              )),
           [E; E; E; E; E; E])),
        (Pi (N, U, (Type U),
           (Binder ("A",
              (Pi (N, U, (Type U),
                 (Binder ("B",
                    (Pi (N, U, (Type U),
                       (Binder ("C",
                          (Pi (R, U, (Id ("A", I)),
                             (Binder ("m",
                                (Pi (R, U,
                                   (Pi (R, U, (Id ("A", I)),
                                      (Binder ("_", (Id ("B", I)))))),
                                   (Binder ("f",
                                      (Pi (R, U,
                                         (Pi (R, U, (Id ("B", I)),
                                            (Binder ("_", (Id ("C", I)))))),
                                         (Binder ("g", IMeta))))
                                      ))
                                   ))
                                ))
                             ))
                          ))
                       ))
                    ))
                 ))
              ))
           )))
       ));
    view = [E; E; E; E; E; E]}
  ]

-----------------------------------------

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_158 : nat_3) : nat_3

#[program]
inductive list_4‹› (A_159 : U): U where
| nil_6 : (list_4 A_159)
| cons_7 (hd_160 : A_159) (tl_161 : (list_4 A_159)) : (list_4 A_159)

#[logical]
inductive eq_5‹s_162› (A_163 : Type‹s_162›) (m_164 : A_163):
  A_163 -> U
where
| refl_8 : (eq_5‹??_1› ?_1[0;0] m_164 m_164)

#[program]
inductive exists_6‹s_166,r_167,t_168› (A_169 : Type‹s_166›) (B_170 : 
A_169 -> Type‹r_167›): Type‹t_168› where
| ex_9
    (m_172 : A_169) {pf_173 : ((B_170) m_172)}
    : (exists_6‹??_2,??_3,??_4› ?_2[0;0] B_170)

#[program]
inductive sing_7‹s_174› (A_175 : Type‹s_174›):
  A_175 -> Type‹s_174›
where
| just_10 (m_177 : A_175) : (sing_7‹??_5› ?_3[0;0] m_177)

#[program]
inductive prod_8‹s_178,r_179,t_180› (A_181 : Type‹s_178›) (B_182 : Type‹r_179›):
  Type‹t_180›
where
| pair_11
    (m_183 : A_181) (n_184 : B_182)
    : (prod_8‹??_6,??_7,??_8› A_181 B_182)

#[program]
def exists_sing_1‹s_185,t_186› :
  ∀ {A_187 : Type‹s_185›} ->
    ∀ {m_188 : A_187} ->
      (exists_6‹??_14,??_15,t_186›
        ?_11[0;0]
        function _190 : A_187 -> ?_9[0;0]
        | a_192 => (eq_5‹??_16› ?_10[0;0] a_192 m_188)) ->
        (sing_7‹??_17› ?_12[0;0] m_188)
:=
  function exists_sing_193 :
    ∀ {A_194 : Type‹s_185›} ->
      ∀ {m_195 : A_194} ->
        (exists_6‹??_9,??_10,t_186›
          ?_6[0;0]
          function _197 : A_194 -> ?_4[0;0]
          | a_199 => (eq_5‹??_11› ?_5[0;0] a_199 m_195)) ->
          (sing_7‹??_12› ?_7[0;0] m_195)
  | A_200 m_201 (ex_9 x_202 refl_8) => (just_10‹??_13› ?_8[0;0] x_202)

#[program]
def sing_exists_2‹s_203,t_204› :
  ∀ {A_205 : Type‹s_203›} ->
    ∀ {m_206 : A_205} ->
      (sing_7‹??_26› ?_21[0;0] m_206) ->
        (exists_6‹??_27,??_28,t_204›
          ?_24[0;0]
          function _208 : A_205 -> ?_22[0;0]
          | a_210 => (eq_5‹??_29› ?_23[0;0] a_210 m_206))
:=
  function sing_exists_211 :
    ∀ {A_212 : Type‹s_203›} ->
      ∀ {m_213 : A_212} ->
        (sing_7‹??_18› ?_13[0;0] m_213) ->
          (exists_6‹??_19,??_20,t_204›
            ?_16[0;0]
            function _215 : A_212 -> ?_14[0;0]
            | a_217 => (eq_5‹??_21› ?_15[0;0] a_217 m_213))
  | A_218 m_219 (just_10 x_220) =>
    (ex_9‹??_23,??_24,??_25›
      ?_19[0;0] ?_20[0;0] x_220 (refl_8‹??_22› ?_17[0;0] ?_18[0;0]))

#[logical]
def sing_exists_equiv1_3‹s_221,t_222› :
  ∀ {A_223 : Type‹s_221›} ->
    ∀ {m_224 : A_223} ->
      ∀ (x_225 : (sing_7‹??_36› ?_33[0;0] m_224)) ->
        (eq_5‹??_40›
          ?_38[0;0]
          ((exists_sing_1‹??_38,??_39›)
            ?_37[0;0] ?_36[0;0]
            ((sing_exists_2‹??_37,t_222›) ?_35[0;0] ?_34[0;0] x_225))
          x_225)
:=
  function sing_exists_equiv1_226 :
    ∀ {A_227 : Type‹s_221›} ->
      ∀ {m_228 : A_227} ->
        ∀ (x_229 : (sing_7‹??_30› ?_25[0;0] m_228)) ->
          (eq_5‹??_34›
            ?_30[0;0]
            ((exists_sing_1‹??_32,??_33›)
              ?_29[0;0] ?_28[0;0]
              ((sing_exists_2‹??_31,t_222›) ?_27[0;0] ?_26[0;0] x_229))
            x_229)
  | A_230 m_231 (just_10 x_232) => (refl_8‹??_35› ?_31[0;0] ?_32[0;0])

#[logical]
def sing_exists_equiv2_4‹s_233,t_234› :
  ∀ {A_235 : Type‹s_233›} ->
    ∀ {m_236 : A_235} ->
      ∀ (x_237 :
        (exists_6‹??_50,??_51,t_234›
          ?_51[0;0]
          function _238 : A_235 -> ?_49[0;0]
          | a_240 => (eq_5‹??_52› ?_50[0;0] a_240 m_236))) ->
        (eq_5‹??_57›
          ?_56[0;0]
          ((sing_exists_2‹??_55,??_56›)
            ?_55[0;0] ?_54[0;0]
            ((exists_sing_1‹??_53,??_54›) ?_53[0;0] ?_52[0;0] x_237))
          x_237)
:=
  function sing_exists_equiv2_241 :
    ∀ {A_242 : Type‹s_233›} ->
      ∀ {m_243 : A_242} ->
        ∀ (x_244 :
          (exists_6‹??_41,??_42,t_234›
            ?_41[0;0]
            function _245 : A_242 -> ?_39[0;0]
            | a_247 => (eq_5‹??_43› ?_40[0;0] a_247 m_243))) ->
          (eq_5‹??_48›
            ?_46[0;0]
            ((sing_exists_2‹??_46,??_47›)
              ?_45[0;0] ?_44[0;0]
              ((exists_sing_1‹??_44,??_45›) ?_43[0;0] ?_42[0;0] x_244))
            x_244)
  | A_248 m_249 (ex_9 x_250 refl_8) =>
    (refl_8‹??_49› ?_47[0;0] ?_48[0;0])

#[program]
def sing_double_5‹s_251› :
  ∀ {A_252 : Type‹s_251›} ->
    ∀ {m_253 : A_252} ->
      (sing_7‹??_67› ?_64[0;0] m_253) ->
        (sing_7‹??_68› ?_65[0;0] m_253) -o
          (prod_8‹??_69,??_70,L› A_252 A_252)
:=
  function sing_double_256 :
    ∀ {A_257 : Type‹s_251›} ->
      ∀ {m_258 : A_257} ->
        (sing_7‹??_58› ?_57[0;0] m_258) ->
          (sing_7‹??_59› ?_58[0;0] m_258) -o
            (prod_8‹??_60,??_61,L› A_257 A_257)
  | A_261 m_262 (just_10 x_263) (just_10 y_264) =>
    let {pf_265} :=
      ((refl_8‹??_62› ?_59[0;0] ?_60[0;0])
        : (eq_5‹??_63› ?_61[0;0] x_263 y_264))
    in (pair_11‹??_64,??_65,??_66› ?_62[0;0] ?_63[0;0] x_263 y_264)

#[logical]
def axiom_K_6‹› :
  ∀ {A_266 : U} ->
    ∀ {m_267 : A_266} ->
      ∀ (x_268 : (eq_5‹??_75› ?_72[0;0] m_267 m_267)) ->
        (eq_5‹??_77›
          ?_75[0;0] x_268 (refl_8‹??_76› ?_73[0;0] ?_74[0;0]))
:=
  function axiom_K_269 :
    ∀ {A_270 : U} ->
      ∀ {m_271 : A_270} ->
        ∀ (x_272 : (eq_5‹??_71› ?_66[0;0] m_271 m_271)) ->
          (eq_5‹??_73›
            ?_69[0;0] x_272 (refl_8‹??_72› ?_67[0;0] ?_68[0;0]))
  | A_273 m_274 refl_8 => (refl_8‹??_74› ?_70[0;0] ?_71[0;0])

#[program]
def test_7‹› :
  ∀ {A_275 : U} ->
    ∀ {B_276 : U} ->
      ∀ {C_277 : U} ->
        A_275 -> A_275 -> B_276 -> B_276 -> C_277 -> ?_77[0;0]
:=
  function test_283 :
    ∀ {A_284 : U} ->
      ∀ {B_285 : U} ->
        ∀ {C_286 : U} ->
          A_284 -> A_284 -> B_285 -> B_285 -> C_286 -> ?_76[0;0]
  | A_292 B_293 C_294 m_295 f_296 g_297 => ((g_297) ((f_296) m_295))

-----------------------------------------

#[program]
inductive unit_1‹› : U where
| tt_1 : unit_1

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_4417 : nat_3) : nat_3

#[program]
inductive list_4‹› (A_4418 : U): U where
| nil_6 : (list_4 A_4418)
| cons_7 (hd_4419 : A_4418) (tl_4420 : (list_4 A_4418)) : (list_4 A_4418)

#[logical]
inductive eq_5‹s_4421› (A_4422 : Type‹s_4421›) (m_4423 : A_4422):
  A_4422 -> U
where
| refl_8 : (eq_5‹s_4421› A_4422 m_4423 m_4423)

#[program]
inductive exists_6‹s_4425,r_4426,t_4427› (A_4428 : Type‹s_4425›) (B_4429 : 
A_4428 -> Type‹r_4426›): Type‹t_4427› where
| ex_9
    (m_4431 : A_4428) {pf_4432 : ((B_4429) m_4431)}
    : (exists_6‹s_4425,r_4426,t_4427› A_4428 B_4429)

#[program]
inductive sing_7‹s_4433› (A_4434 : Type‹s_4433›):
  A_4434 -> Type‹s_4433›
where
| just_10 (m_4436 : A_4434) : (sing_7‹s_4433› A_4434 m_4436)

#[program]
inductive prod_8‹s_4437,r_4438,t_4439› (A_4440 : Type‹s_4437›) (B_4441 : Type‹r_4438›):
  Type‹t_4439›
where
| pair_11
    (m_4442 : A_4440) (n_4443 : B_4441)
    : (prod_8‹s_4437,r_4438,t_4439› A_4440 B_4441)

#[program]
def exists_sing_1‹s_4444,t_4445› :
  ∀ {A_4446 : Type‹s_4444›} ->
    ∀ {m_4447 : A_4446} ->
      (exists_6‹s_4444,U,t_4445›
        A_4446
        function _4449 : A_4446 -> U
        | __4451 => (eq_5‹s_4444› A_4446 __4451 m_4447)) ->
        (sing_7‹s_4444› A_4446 m_4447)
:=
  function exists_sing_4452 :
    ∀ {A_4453 : Type‹s_4444›} ->
      ∀ {m_4454 : A_4453} ->
        (exists_6‹s_4444,U,t_4445›
          A_4453
          function _4456 : A_4453 -> U
          | __4458 => (eq_5‹s_4444› A_4453 __4458 m_4454)) ->
          (sing_7‹s_4444› A_4453 m_4454)
  | A_4459 m_4460 (ex_9 m_4461 refl_8) => (just_10‹s_4444› A_4459 m_4461)

#[program]
def sing_exists_2‹s_4462,t_4463› :
  ∀ {A_4464 : Type‹s_4462›} ->
    ∀ {m_4465 : A_4464} ->
      (sing_7‹s_4462› A_4464 m_4465) ->
        (exists_6‹s_4462,U,t_4463›
          A_4464
          function _4467 : A_4464 -> U
          | __4469 => (eq_5‹s_4462› A_4464 __4469 m_4465))
:=
  function sing_exists_4470 :
    ∀ {A_4471 : Type‹s_4462›} ->
      ∀ {m_4472 : A_4471} ->
        (sing_7‹s_4462› A_4471 m_4472) ->
          (exists_6‹s_4462,U,t_4463›
            A_4471
            function _4474 : A_4471 -> U
            | __4476 => (eq_5‹s_4462› A_4471 __4476 m_4472))
  | A_4477 m_4478 (just_10 m_4479) =>
    (ex_9‹s_4462,U,t_4463›
      A_4477
      function _4480 : A_4477 -> U
      | __4482 => (eq_5‹s_4462› A_4477 __4482 m_4479) m_4479
      (refl_8‹s_4462› A_4477 m_4479))

#[logical]
def sing_exists_equiv1_3‹s_4483,t_4484› :
  ∀ {A_4485 : Type‹s_4483›} ->
    ∀ {m_4486 : A_4485} ->
      ∀ (x_4487 : (sing_7‹s_4483› A_4485 m_4486)) ->
        (eq_5‹s_4483›
          (sing_7‹s_4483› A_4485 m_4486)
          ((exists_sing_1‹s_4483,t_4484›)
            A_4485 m_4486
            ((sing_exists_2‹s_4483,t_4484›) A_4485 m_4486 x_4487))
          x_4487)
:=
  function sing_exists_equiv1_4488 :
    ∀ {A_4489 : Type‹s_4483›} ->
      ∀ {m_4490 : A_4489} ->
        ∀ (x_4491 : (sing_7‹s_4483› A_4489 m_4490)) ->
          (eq_5‹s_4483›
            (sing_7‹s_4483› A_4489 m_4490)
            ((exists_sing_1‹s_4483,t_4484›)
              A_4489 m_4490
              ((sing_exists_2‹s_4483,t_4484›) A_4489 m_4490 x_4491))
            x_4491)
  | A_4492 m_4493 (just_10 m_4494) =>
    (refl_8‹s_4483›
      (sing_7‹s_4483› A_4492 m_4494)
      ((exists_sing_1‹s_4483,t_4484›)
        A_4492 m_4494
        ((sing_exists_2‹s_4483,t_4484›)
          A_4492 m_4494 (just_10‹s_4483› A_4492 m_4494))))

#[logical]
def sing_exists_equiv2_4‹s_4495,t_4496› :
  ∀ {A_4497 : Type‹s_4495›} ->
    ∀ {m_4498 : A_4497} ->
      ∀ (x_4499 :
        (exists_6‹s_4495,U,t_4496›
          A_4497
          function _4500 : A_4497 -> U
          | __4502 => (eq_5‹s_4495› A_4497 __4502 m_4498))) ->
        (eq_5‹t_4496›
          (exists_6‹s_4495,U,t_4496›
            A_4497
            function _4503 : A_4497 -> U
            | __4505 => (eq_5‹s_4495› A_4497 __4505 m_4498))
          ((sing_exists_2‹s_4495,t_4496›)
            A_4497 m_4498
            ((exists_sing_1‹s_4495,t_4496›) A_4497 m_4498 x_4499))
          x_4499)
:=
  function sing_exists_equiv2_4506 :
    ∀ {A_4507 : Type‹s_4495›} ->
      ∀ {m_4508 : A_4507} ->
        ∀ (x_4509 :
          (exists_6‹s_4495,U,t_4496›
            A_4507
            function _4510 : A_4507 -> U
            | __4512 => (eq_5‹s_4495› A_4507 __4512 m_4508))) ->
          (eq_5‹t_4496›
            (exists_6‹s_4495,U,t_4496›
              A_4507
              function _4513 : A_4507 -> U
              | __4515 => (eq_5‹s_4495› A_4507 __4515 m_4508))
            ((sing_exists_2‹s_4495,t_4496›)
              A_4507 m_4508
              ((exists_sing_1‹s_4495,t_4496›) A_4507 m_4508 x_4509))
            x_4509)
  | A_4516 m_4517 (ex_9 m_4518 refl_8) =>
    (refl_8‹t_4496›
      (exists_6‹s_4495,U,t_4496›
        A_4516
        function _4519 : A_4516 -> U
        | __4521 => (eq_5‹s_4495› A_4516 __4521 m_4518))
      ((sing_exists_2‹s_4495,t_4496›)
        A_4516 m_4518
        ((exists_sing_1‹s_4495,t_4496›)
          A_4516 m_4518
          (ex_9‹s_4495,U,t_4496›
            A_4516
            function _4522 : A_4516 -> U
            | __4524 => (eq_5‹s_4495› A_4516 __4524 m_4518) m_4518
            (refl_8‹s_4495› A_4516 m_4518)))))

#[program]
def sing_double_5‹s_4525› :
  ∀ {A_4526 : Type‹s_4525›} ->
    ∀ {m_4527 : A_4526} ->
      (sing_7‹s_4525› A_4526 m_4527) ->
        (sing_7‹s_4525› A_4526 m_4527) -o
          (prod_8‹s_4525,s_4525,L› A_4526 A_4526)
:=
  function sing_double_4530 :
    ∀ {A_4531 : Type‹s_4525›} ->
      ∀ {m_4532 : A_4531} ->
        (sing_7‹s_4525› A_4531 m_4532) ->
          (sing_7‹s_4525› A_4531 m_4532) -o
            (prod_8‹s_4525,s_4525,L› A_4531 A_4531)
  | A_4535 m_4536 (just_10 m_4537) (just_10 m_4538) =>
    let {pf_4539} :=
      ((refl_8‹s_4525› A_4535 m_4537)
        : (eq_5‹s_4525› A_4535 m_4537 m_4538))
    in (pair_11‹s_4525,s_4525,L› A_4535 A_4535 m_4537 m_4538)

#[logical]
def axiom_K_6‹› :
  ∀ {A_4540 : U} ->
    ∀ {m_4541 : A_4540} ->
      ∀ (x_4542 : (eq_5‹U› A_4540 m_4541 m_4541)) ->
        (eq_5‹U›
          (eq_5‹U› A_4540 m_4541 m_4541) x_4542
          (refl_8‹U› A_4540 m_4541))
:=
  function axiom_K_4543 :
    ∀ {A_4544 : U} ->
      ∀ {m_4545 : A_4544} ->
        ∀ (x_4546 : (eq_5‹U› A_4544 m_4545 m_4545)) ->
          (eq_5‹U›
            (eq_5‹U› A_4544 m_4545 m_4545) x_4546
            (refl_8‹U› A_4544 m_4545))
  | A_4547 m_4548 refl_8 =>
    (refl_8‹U›
      (eq_5‹U› A_4547 m_4548 m_4548) (refl_8‹U› A_4547 m_4548))

#[program]
def test_7‹› :
  ∀ {A_4549 : U} ->
    ∀ {B_4550 : U} ->
      ∀ {C_4551 : U} ->
        A_4549 -> A_4549 -> B_4550 -> B_4550 -> C_4551 -> C_4551
:=
  function test_4557 :
    ∀ {A_4558 : U} ->
      ∀ {B_4559 : U} ->
        ∀ {C_4560 : U} ->
          A_4558 -> A_4558 -> B_4559 -> B_4559 -> C_4560 -> C_4560
  | A_4566 B_4567 C_4568 m_4569 f_4570 g_4571 => ((g_4571) ((f_4570) m_4569))

-----------------------------------------

#[program]
inductive unit_1 where
| tt_1 of layout[]

#[program]
inductive bool_2 where
| true_2 of layout[]
| false_3 of layout[]

#[program]
inductive nat_3 where
| zero_4 of layout[]
| succ_5 of layout[R]

#[program]
inductive list_4 where
| nil_6 of layout[]
| cons_7 of layout[R, R]

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
inductive existsUUU_18 where
| exUUU_21 of layout[R, N]

#[program]
inductive existsUUL_17 where
| exUUL_20 of layout[R, N]

#[program]
inductive existsULU_16 where
| exULU_19 of layout[R, N]

#[program]
inductive existsULL_15 where
| exULL_18 of layout[R, N]

#[program]
inductive existsLUU_14 where


#[program]
inductive existsLUL_13 where
| exLUL_16 of layout[R, N]

#[program]
inductive existsLLU_12 where


#[program]
inductive existsLLL_11 where
| exLLL_14 of layout[R, N]

#[program]
inductive singU_20 where
| justU_23 of layout[R]

#[program]
inductive singL_19 where
| justL_22 of layout[R]

#[program]
inductive prodUUU_28 where
| pairUUU_31 of layout[R, R]

#[program]
inductive prodUUL_27 where
| pairUUL_30 of layout[R, R]

#[program]
inductive prodULU_26 where


#[program]
inductive prodULL_25 where
| pairULL_28 of layout[R, R]

#[program]
inductive prodLUU_24 where


#[program]
inductive prodLUL_23 where
| pairLUL_26 of layout[R, R]

#[program]
inductive prodLLU_22 where


#[program]
inductive prodLLL_21 where
| pairLLL_24 of layout[R, R]

#[program]
def exists_singUU_11 :=
  fun exists_sing_7530 {A_7531} -> {m_7532} -> (__7533) ->
    match __7533 with
    | exUUU_21 m_7534 pf_7535 =>
      match {NULL} with
      | reflU_13  => (justU_23 m_7534)
      end
    end

#[program]
def exists_singUL_10 :=
  fun exists_sing_7536 {A_7537} -> {m_7538} -> (__7539) ->
    match __7539 with
    | exUUL_20 m_7540 pf_7541 =>
      match {NULL} with
      | reflU_13  => (justU_23 m_7540)
      end
    end

#[program]
def exists_singLU_9 :=
  fun exists_sing_7542 {A_7543} -> {m_7544} -> (__7545) ->
    match __7545 with
    
    end

#[program]
def exists_singLL_8 :=
  fun exists_sing_7546 {A_7547} -> {m_7548} -> (__7549) ->
    match __7549 with
    | exLUL_16 m_7550 pf_7551 =>
      match {NULL} with
      | reflL_12  => (justL_22 m_7550)
      end
    end

#[program]
def sing_existsUU_15 :=
  fun sing_exists_7552 {A_7553} -> {m_7554} -> (__7555) ->
    match __7555 with
    | justU_23 m_7556 => (exUUU_21 m_7556 NULL)
    end

#[program]
def sing_existsUL_14 :=
  fun sing_exists_7557 {A_7558} -> {m_7559} -> (__7560) ->
    match __7560 with
    | justU_23 m_7561 => (exUUL_20 m_7561 NULL)
    end

#[program]
def sing_existsLL_12 :=
  fun sing_exists_7562 {A_7563} -> {m_7564} -> (__7565) ->
    match __7565 with
    | justL_22 m_7566 => (exLUL_16 m_7566 NULL)
    end

#[logical]
def sing_exists_equiv1UU_19 := NULL

#[logical]
def sing_exists_equiv1UL_18 := NULL

#[logical]
def sing_exists_equiv1LL_16 := NULL

#[logical]
def sing_exists_equiv2UU_23 := NULL

#[logical]
def sing_exists_equiv2UL_22 := NULL

#[logical]
def sing_exists_equiv2LL_20 := NULL

#[program]
def sing_doubleU_25 :=
  fun sing_double_7567 {A_7568} -> {m_7569} -> (__7570) -> (__7571) -o
    match __7570 with
    | justU_23 m_7572 =>
      match __7571 with
      | justU_23 m_7573 => (pairUUL_30 m_7572 m_7573)
      end
    end

#[program]
def sing_doubleL_24 :=
  fun sing_double_7574 {A_7575} -> {m_7576} -> (__7577) -> (__7578) -o
    match __7577 with
    | justL_22 m_7579 =>
      match __7578 with
      | justL_22 m_7580 => (pairLLL_24 m_7579 m_7580)
      end
    end

#[logical]
def axiom_K_6 := NULL

#[program]
def test_7 :=
  fun test_7581 {A_7582} -> {B_7583} -> {C_7584} -> (m_7585) -> (f_7586) ->
  (g_7587) -> ((g_7587) ((f_7586) m_7585))

-----------------------------------------

#[program]
inductive unit_1 where
| tt_1 of layout[]

#[program]
inductive bool_2 where
| true_2 of layout[]
| false_3 of layout[]

#[program]
inductive nat_3 where
| zero_4 of layout[]
| succ_5 of layout[R]

#[program]
inductive list_4 where
| nil_6 of layout[]
| cons_7 of layout[R, R]

#[logical]
inductive eqU_10 where
| reflU_13 of layout[]

#[logical]
inductive eqL_9 where
| reflL_12 of layout[]

#[program]
inductive existsUUU_18 where
| exUUU_21 of layout[R, N]

#[program]
inductive existsUUL_17 where
| exUUL_20 of layout[R, N]

#[program]
inductive existsULU_16 where
| exULU_19 of layout[R, N]

#[program]
inductive existsULL_15 where
| exULL_18 of layout[R, N]

#[program]
inductive existsLUU_14 where


#[program]
inductive existsLUL_13 where
| exLUL_16 of layout[R, N]

#[program]
inductive existsLLU_12 where


#[program]
inductive existsLLL_11 where
| exLLL_14 of layout[R, N]

#[program]
inductive singU_20 where
| justU_23 of layout[R]

#[program]
inductive singL_19 where
| justL_22 of layout[R]

#[program]
inductive prodUUU_28 where
| pairUUU_31 of layout[R, R]

#[program]
inductive prodUUL_27 where
| pairUUL_30 of layout[R, R]

#[program]
inductive prodULU_26 where


#[program]
inductive prodULL_25 where
| pairULL_28 of layout[R, R]

#[program]
inductive prodLUU_24 where


#[program]
inductive prodLUL_23 where
| pairLUL_26 of layout[R, R]

#[program]
inductive prodLLU_22 where


#[program]
inductive prodLLL_21 where
| pairLLL_24 of layout[R, R]

#[program]
def exists_singUU_11 :=
  fun exists_sing_7646 {A_7647} -> {m_7648} -> (__7649) ->
    match __7649 with
    | exUUU_21 m_7650 pf_7651 => (justU_23 m_7650)
    end

#[program]
def exists_singUL_10 :=
  fun exists_sing_7652 {A_7653} -> {m_7654} -> (__7655) ->
    match __7655 with
    | exUUL_20 m_7656 pf_7657 => (justU_23 m_7656)
    end

#[program]
def exists_singLU_9 :=
  fun exists_sing_7658 {A_7659} -> {m_7660} -> (__7661) -> !!

#[program]
def exists_singLL_8 :=
  fun exists_sing_7662 {A_7663} -> {m_7664} -> (__7665) ->
    match __7665 with
    | exLUL_16 m_7666 pf_7667 => (justL_22 m_7666)
    end

#[program]
def sing_existsUU_15 :=
  fun sing_exists_7668 {A_7669} -> {m_7670} -> (__7671) ->
    match __7671 with
    | justU_23 m_7672 => (exUUU_21 m_7672 NULL)
    end

#[program]
def sing_existsUL_14 :=
  fun sing_exists_7673 {A_7674} -> {m_7675} -> (__7676) ->
    match __7676 with
    | justU_23 m_7677 => (exUUL_20 m_7677 NULL)
    end

#[program]
def sing_existsLL_12 :=
  fun sing_exists_7678 {A_7679} -> {m_7680} -> (__7681) ->
    match __7681 with
    | justL_22 m_7682 => (exLUL_16 m_7682 NULL)
    end

#[logical]
def sing_exists_equiv1UU_19 := NULL

#[logical]
def sing_exists_equiv1UL_18 := NULL

#[logical]
def sing_exists_equiv1LL_16 := NULL

#[logical]
def sing_exists_equiv2UU_23 := NULL

#[logical]
def sing_exists_equiv2UL_22 := NULL

#[logical]
def sing_exists_equiv2LL_20 := NULL

#[program]
def sing_doubleU_25 :=
  fun sing_double_7683 {A_7684} -> {m_7685} -> (__7686) -> (__7687) -o
    match __7686 with
    | justU_23 m_7688 =>
      match __7687 with
      | justU_23 m_7689 => (pairUUL_30 m_7688 m_7689)
      end
    end

#[program]
def sing_doubleL_24 :=
  fun sing_double_7690 {A_7691} -> {m_7692} -> (__7693) -> (__7694) -o
    match __7693 with
    | justL_22 m_7695 =>
      match __7694 with
      | justL_22 m_7696 => (pairLLL_24 m_7695 m_7696)
      end
    end

#[logical]
def axiom_K_6 := NULL

#[program]
def test_7 :=
  fun test_7697 {A_7698} -> {B_7699} -> {C_7700} -> (m_7701) -> (f_7702) ->
  (g_7703) -> ((g_7703) ((f_7702) m_7701))

-----------------------------------------

