[Inductive {name = "unit"; relv = R;
   body =
   (Binder (["s"],
      (PBase
         ((TBase (Type (SId "s"))),
          [(DConstr ("tt", (TBase (Id ("unit", I))), []))]))
      ));
   view = []};
  Inductive {name = "bool"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("true", (TBase (Id ("bool", I))), []));
             (DConstr ("false", (TBase (Id ("bool", I))), []))]))
       ));
    view = []};
  Inductive {name = "nat"; relv = R;
    body =
    (Binder ([],
       (PBase
          ((TBase (Type U)),
           [(DConstr ("zero", (TBase (Id ("nat", I))), []));
             (DConstr ("succ",
                (TBind (R, (Id ("nat", I)),
                   (Binder ("pred", (TBase (Id ("nat", I))))))),
                [E]))
             ]))
       ));
    view = []};
  Inductive {name = "stream_node"; relv = R;
    body =
    (Binder (["s"],
       (PBind ((Type (SId "s")),
          (Binder ("A",
             (PBase
                ((TBase (Type L)),
                 [(DConstr ("stream_nil",
                     (TBase (App [(Id ("stream_node", I)); (Id ("A", I))])),
                     []));
                   (DConstr ("stream_cons",
                      (TBind (R, (Id ("A", I)),
                         (Binder ("hd",
                            (TBind (R,
                               (Pi (R, L, (Id ("bool", I)),
                                  (Binder ("b",
                                     (Match ([(R, (Id ("b", I)), None)],
                                        None,
                                        [([(PId "true")],
                                          (Some (App
                                                   [(Id ("stream_node", I));
                                                     (Id ("A", I))])));
                                          ([(PId "false")],
                                           (Some (Id ("unit", I))))
                                          ]
                                        ))
                                     ))
                                  )),
                               (Binder ("tl",
                                  (TBase
                                     (App
                                        [(Id ("stream_node", I));
                                          (Id ("A", I))]))
                                  ))
                               ))
                            ))
                         )),
                      [E; E]))
                   ]))
             ))
          ))
       ));
    view = [E]};
  Definition {name = "stream"; relv = N;
    body =
    (Binder (["s"],
       ((Fun ((Pi (R, U, (Type (SId "s")), (Binder ("A", IMeta)))),
           (Binder ((Some "stream"),
              [([(PId "A")],
                (Some (Pi (R, L, (Id ("bool", I)),
                         (Binder ("b",
                            (Match ([(R, (Id ("b", I)), None)], None,
                               [([(PId "true")],
                                 (Some (App
                                          [(Id ("stream_node", I));
                                            (Id ("A", I))])));
                                 ([(PId "false")], (Some (Id ("unit", I))))]
                               ))
                            ))
                         ))))
                ]
              )),
           [E])),
        (Pi (R, U, (Type (SId "s")), (Binder ("A", IMeta)))))
       ));
    view = [E]};
  Definition {name = "free_stream"; relv = R;
    body =
    (Binder (["s"],
       ((Fun (
           (Pi (N, U, (Type (SId "s")),
              (Binder ("A",
                 (Pi (R, U, (App [(Id ("stream", I)); (Id ("A", I))]),
                    (Binder ("st", (Inst ("unit", [U], I))))))
                 ))
              )),
           (Binder ((Some "free_stream"),
              [([(PId "A"); (PId "st")],
                (Some (Match (
                         [(R, (App [(Id ("st", I)); (Id ("false", I))]), None)
                           ],
                         None, [([(PId "tt")], (Some (Id ("tt", I))))]))))
                ]
              )),
           [I; E])),
        (Pi (N, U, (Type (SId "s")),
           (Binder ("A",
              (Pi (R, U, (App [(Id ("stream", I)); (Id ("A", I))]),
                 (Binder ("st", (Inst ("unit", [U], I))))))
              ))
           )))
       ));
    view = [I; E]};
  Definition {name = "nat_make"; relv = R;
    body =
    (Binder ([],
       ((Fun (
           (Pi (R, U, (Id ("nat", I)),
              (Binder ("n", (App [(Id ("stream", I)); (Id ("nat", I))]))))),
           (Binder ((Some "nat_make"),
              [([(PId "n")],
                (Some (Fun (IMeta,
                         (Binder (None,
                            [([(PId "true")],
                              (Some (App
                                       [(Id ("stream_cons", I));
                                         (Id ("n", I));
                                         (App
                                            [(Id ("nat_make", I));
                                              (App
                                                 [(Id ("succ", I));
                                                   (Id ("n", I))])
                                              ])
                                         ])));
                              ([(PId "false")], (Some (Id ("tt", I))))]
                            )),
                         []))))
                ]
              )),
           [E])),
        (Pi (R, U, (Id ("nat", I)),
           (Binder ("n", (App [(Id ("stream", I)); (Id ("nat", I))]))))))
       ));
    view = [E]};
  Definition {name = "nat_stream"; relv = R;
    body =
    (Binder ([], ((App [(Id ("nat_make", I)); (Id ("zero", I))]), IMeta)));
    view = []};
  Definition {name = "ok"; relv = R;
    body =
    (Binder ([],
       ((App [(Id ("free_stream", I)); (Id ("nat_stream", I))]), IMeta)));
    view = []}
  ]

-----------------------------------------

#[program]
inductive unit_1‹s_34› : Type‹s_34› where
| tt_1 : unit_1‹??_1›

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_35 : nat_3) : nat_3

#[program]
inductive stream_node_4‹s_36› (A_37 : Type‹s_36›): L where
| stream_nil_6 : (stream_node_4‹??_2› A_37)
| stream_cons_7
    (hd_38 : A_37)
    (tl_39 : ∀ (b_40 : bool_2) -o
               match b_40 in ∀ (_41 : ?_1) -o ?_2 with
               | true_2 => (stream_node_4‹??_3› A_37)
               | false_3 => unit_1‹??_4›)
    : (stream_node_4‹??_5› A_37)

#[logical]
def stream_1‹s_42› : ∀ (A_43 : Type‹s_42›) -> ?_6 :=
  function stream_44 : ∀ (A_45 : Type‹s_42›) -> ?_3
  | A_46 =>
    ∀ (b_47 : bool_2) -o
      match b_47 in ∀ (_48 : ?_4) -o ?_5 with
      | true_2 => (stream_node_4‹??_6› A_46)
      | false_3 => unit_1‹??_7›

#[program]
def free_stream_2‹s_49› :
  ∀ {A_50 : Type‹s_49›} ->
    ((stream_1‹??_10›) A_50) -> unit_1‹U›
:=
  function free_stream_52 :
    ∀ {A_53 : Type‹s_49›} ->
      ((stream_1‹??_8›) A_53) -> unit_1‹U›
  | A_55 st_56 =>
    match ((st_56) false_3) in ∀ (_57 : ?_7) -o ?_8 with
    | tt_1 => tt_1‹??_9›

#[program]
def nat_make_3‹› : nat_3 -> ((stream_1‹??_14›) nat_3) :=
  function nat_make_59 : nat_3 -> ((stream_1‹??_11›) nat_3)
  | n_61 =>
    function _62 : ?_9
    | true_2 =>
      (stream_cons_7‹??_12› n_61 ((nat_make_59) (succ_5‹› n_61)))
    | false_3 => tt_1‹??_13›

#[program]
def nat_stream_4‹› : ?_11 := ((nat_make_3) zero_4)

#[program]
def ok_5‹› : ?_13 := ((free_stream_2‹??_15›) ?_12 nat_stream_4)

-----------------------------------------

inductive-------------------------
infer_tm(unit_1‹??_1›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_65
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(bool_2)
infer_tm(bool_2)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_68
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(nat_3)
infer_tm(nat_3)
infer_tm(nat_3)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_70
    
  |}
  imeta_meta {|
    
  |}
  eqns {|
    
  |}
end_dump
----------------------------------

inductive-------------------------
infer_tm(Type‹s_72›)
infer_tm(Type‹s_74›)
assert_equal1( A_75, A_75)
assert_equal1_ok( A_75, A_75)
infer_tm((stream_node_4‹??_2› A_75))
check_tm( A_75, Type‹??_2›)
infer_tm(A_75)
assert_equal1( Type‹??_2›, Type‹s_74›)
assert_equal1_extend( Type‹??_2›, Type‹s_74›)
simpl_tm ~expand:false( Type‹??_2›, Type‹s_74›)
infer_tm(Type‹s_76›)
infer_tm(A_77)
infer_tm(∀ (b_80 : bool_2) -o
           match b_80 in ∀ (_81 : ?_1) -o ?_2 with
           | true_2 => (stream_node_4‹??_3› A_77)
           | false_3 => unit_1‹??_4›)
infer_tm(bool_2)
infer_tm(match b_82 in ∀ (_83 : ?_1) -o ?_2 with
         | true_2 => (stream_node_4‹??_3› A_77)
         | false_3 => unit_1‹??_4›)
infer_motive(b_82 : ?_1)
infer_tm(?_1)
delay_assert(?_14, ??_16)
check_tm( b_82, ?_1)
infer_tm(b_82)
assert_equal1( ?_1, bool_2)
assert_equal1_extend( ?_1, bool_2)
infer_tm(?_2)
simpl_tm ~expand:false( ?_1, bool_2)
simpl_tm ~expand:false( ?_14, Type‹??_16›)
delay_assert(?_15, ??_17)
simpl_tm ~expand:false( ?_15, Type‹??_17›)
check_cls {|
  prblm {| ;
    {|  ::: [true_2] =>? (stream_node_4‹??_3› A_77) |}
    {|  ::: [false_3] =>? unit_1‹??_4› |}
  |}
  a := ∀ (_85 : bool_2) -o ?_2
|}
case_intro
case_introed(_86 : bool_2)
case_splitting
splitting_on(true_2)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2);
    {|  ::: [] =>? (stream_node_4‹??_3› A_77) |}
  |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( (stream_node_4‹??_3› A_77), ?_2)
check_tm( (stream_node_4‹??_3› A_77), ?_2)
infer_tm((stream_node_4‹??_3› A_77))
check_tm( A_77, Type‹??_3›)
infer_tm(A_77)
assert_equal1( Type‹??_3›, Type‹s_76›)
assert_equal1_extend( Type‹??_3›, Type‹s_76›)
assert_equal1( ?_2, L)
assert_equal1_extend( ?_2, L)
splitting_on(false_3)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2); {|  ::: [] =>? unit_1‹??_4› |} |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
simpl_tm ~expand:false( ?_2, L)
simpl_tm ~expand:false( Type‹??_3›, Type‹s_76›)
case_coverage_ok( unit_1‹??_4›, L)
check_tm( unit_1‹??_4›, ?_2)
infer_tm(unit_1‹??_4›)
assert_equal1( ?_2, Type‹??_4›)
assert_equal1_extend( ?_2, Type‹??_4›)
simpl_tm ~expand:false( L, Type‹??_4›)
assert_equal1( A_77, A_77)
assert_equal1_ok( A_77, A_77)
infer_tm((stream_node_4‹??_5› A_77))
check_tm( A_77, Type‹??_5›)
infer_tm(A_77)
assert_equal1( Type‹??_5›, Type‹s_76›)
assert_equal1_extend( Type‹??_5›, Type‹s_76›)
simpl_tm ~expand:false( Type‹??_5›, Type‹s_76›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_88
    ??_2 <= s_89
    ??_3 <= s_90
    ??_4 <= L
    ??_5 <= s_92
    
  |}
  imeta_meta {|
    ?_1 <= bool_2
    ?_2 <= L
    ?_14 <= Type‹??_16›
    ?_15 <= Type‹??_17›
    
  |}
  eqns {|
    
  |}
end_dump
infer_tm(Type‹??_16›)
check_tm( bool_2, Type‹??_16›)
infer_tm(bool_2)
assert_equal1( Type‹??_16›, U)
assert_equal1_extend( Type‹??_16›, U)
simpl_tm ~expand:false( Type‹??_16›, U)
infer_tm(Type‹??_17›)
check_tm( L, Type‹??_17›)
infer_tm(L)
assert_equal1( Type‹??_17›, U)
assert_equal1_extend( Type‹??_17›, U)
simpl_tm ~expand:false( Type‹??_17›, U)
----------------------------------

definition-------------------------
infer_tm(∀ (A_129 : Type‹s_128›) -> ?_6)
infer_tm(Type‹s_128›)
infer_tm(?_6)
delay_assert(?_16, ??_18)
simpl_tm ~expand:false( ?_16, Type‹??_18›)
check_tm(
  function stream_131 : ∀ (A_132 : Type‹s_128›) -> ?_3
  | A_133 =>
    ∀ (b_134 : bool_2) -o
      match b_134 in ∀ (_135 : ?_4) -o ?_5 with
      | true_2 => (stream_node_4‹??_6› A_133)
      | false_3 => unit_1‹??_7›,
  ∀ (A_136 : Type‹s_128›) -> ?_6)
infer_tm(∀ (A_138 : Type‹s_128›) -> ?_3)
infer_tm(Type‹s_128›)
infer_tm(?_3)
delay_assert(?_17, ??_19)
simpl_tm ~expand:false( ?_17, Type‹??_19›)
assert_equal1( ∀ (A_140 : Type‹s_128›) -> ?_6,
  ∀ (A_141 : Type‹s_128›) -> ?_3)
assert_equal1_extend( ∀ (A_146 : Type‹s_128›) -> ?_6,
  ∀ (A_147 : Type‹s_128›) -> ?_3)
simpl_tm ~expand:false( ∀ (A_151 : Type‹s_128›) -> ?_6,
  ∀ (A_152 : Type‹s_128›) -> ?_3)
simpl_tm ~expand:false( Type‹s_128›, Type‹s_128›)
simpl_tm ~expand:false( ?_6, ?_3)
check_cls {|
  prblm {| ;
    {|  ::: [A_148] =>?
         ∀ (b_155 : bool_2) -o
           match b_155 in ∀ (_156 : ?_4) -o ?_5 with
           | true_2 => (stream_node_4‹??_6› #A_148)
           | false_3 => unit_1‹??_7›
    |}
  |}
  a := ∀ (A_157 : Type‹s_128›) -> ?_3
|}
case_intro
case_introed(A_158 : Type‹s_128›)
case_coverage{|
  prblm {| ;
    {| eq_pat?( #A_158, A_148 : Type‹s_128›) ::: [] =>?
         ∀ (b_159 : bool_2) -o
           match b_159 in ∀ (_160 : ?_4) -o ?_5 with
           | true_2 => (stream_node_4‹??_6› #A_148)
           | false_3 => unit_1‹??_7›
    |}
  |}
|}
unify_local( eq_pat?( #A_158, A_148 : Type‹s_128›) )
unify_global(  )
simpl_pprbm ~expand:false( #A_158, #A_148)
case_coverage_ok(
  ∀ (b_168 : bool_2) -o
    match b_168 in ∀ (_169 : ?_4) -o ?_5 with
    | true_2 => (stream_node_4‹??_6› A_158)
    | false_3 => unit_1‹??_7›,
  ?_3)
check_tm(
  ∀ (b_170 : bool_2) -o
    match b_170 in ∀ (_171 : ?_4) -o ?_5 with
    | true_2 => (stream_node_4‹??_6› A_158)
    | false_3 => unit_1‹??_7›,
  ?_3)
infer_tm(∀ (b_172 : bool_2) -o
           match b_172 in ∀ (_173 : ?_4) -o ?_5 with
           | true_2 => (stream_node_4‹??_6› A_158)
           | false_3 => unit_1‹??_7›)
infer_tm(bool_2)
infer_tm(match b_174 in ∀ (_175 : ?_4) -o ?_5 with
         | true_2 => (stream_node_4‹??_6› A_158)
         | false_3 => unit_1‹??_7›)
infer_motive(b_174 : ?_4)
infer_tm(?_4)
delay_assert(?_18, ??_20)
check_tm( b_174, ?_4)
infer_tm(b_174)
assert_equal1( ?_4, bool_2)
assert_equal1_extend( ?_4, bool_2)
infer_tm(?_5)
simpl_tm ~expand:false( ?_4, bool_2)
simpl_tm ~expand:false( ?_18, Type‹??_20›)
delay_assert(?_19, ??_21)
simpl_tm ~expand:false( ?_19, Type‹??_21›)
check_cls {|
  prblm {| ;
    {|  ::: [true_2] =>? (stream_node_4‹??_6› A_158) |}
    {|  ::: [false_3] =>? unit_1‹??_7› |}
  |}
  a := ∀ (_177 : bool_2) -o ?_5
|}
case_intro
case_introed(_178 : bool_2)
case_splitting
splitting_on(true_2)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2);
    {|  ::: [] =>? (stream_node_4‹??_6› A_158) |}
  |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( (stream_node_4‹??_6› A_158), ?_5)
check_tm( (stream_node_4‹??_6› A_158), ?_5)
infer_tm((stream_node_4‹??_6› A_158))
check_tm( A_158, Type‹??_6›)
infer_tm(A_158)
assert_equal1( Type‹??_6›, Type‹s_128›)
assert_equal1_extend( Type‹??_6›, Type‹s_128›)
assert_equal1( ?_5, L)
assert_equal1_extend( ?_5, L)
splitting_on(false_3)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2); {|  ::: [] =>? unit_1‹??_7› |} |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
simpl_tm ~expand:false( ?_5, L)
simpl_tm ~expand:false( Type‹??_6›, Type‹s_128›)
case_coverage_ok( unit_1‹??_7›, L)
check_tm( unit_1‹??_7›, ?_5)
infer_tm(unit_1‹??_7›)
assert_equal1( ?_5, Type‹??_7›)
assert_equal1_extend( ?_5, Type‹??_7›)
simpl_tm ~expand:false( L, Type‹??_7›)
assert_equal1( ?_3, L)
assert_equal1_extend( ?_3, L)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_184
    ??_2 <= s_185
    ??_3 <= s_186
    ??_4 <= L
    ??_5 <= s_188
    ??_6 <= s_189
    ??_7 <= L
    ??_16 <= U
    ??_17 <= U
    
  |}
  imeta_meta {|
    ?_1 <= bool_2
    ?_2 <= L
    ?_4 <= bool_2
    ?_5 <= L
    ?_6 <= ?_3
    ?_14 <= Type‹??_16›
    ?_15 <= Type‹??_17›
    ?_16 <= Type‹??_18›
    ?_17 <= Type‹??_19›
    ?_18 <= Type‹??_20›
    ?_19 <= Type‹??_21›
    
  |}
  eqns {|
    equal_tm? (?_3, L)
  |}
end_dump
simpl_tm ~expand:false( ?_3, L)
infer_tm(Type‹??_19›)
check_tm( L, Type‹??_19›)
infer_tm(L)
assert_equal1( Type‹??_19›, U)
assert_equal1_extend( Type‹??_19›, U)
simpl_tm ~expand:false( Type‹??_19›, U)
infer_tm(Type‹??_20›)
check_tm( bool_2, Type‹??_20›)
infer_tm(bool_2)
assert_equal1( Type‹??_20›, U)
assert_equal1_extend( Type‹??_20›, U)
simpl_tm ~expand:false( Type‹??_20›, U)
infer_tm(Type‹??_21›)
check_tm( L, Type‹??_21›)
infer_tm(L)
assert_equal1( Type‹??_21›, U)
assert_equal1_extend( Type‹??_21›, U)
simpl_tm ~expand:false( Type‹??_21›, U)
infer_tm(Type‹??_18›)
check_tm( L, Type‹??_18›)
infer_tm(L)
assert_equal1( Type‹??_18›, U)
assert_equal1_extend( Type‹??_18›, U)
simpl_tm ~expand:false( Type‹??_18›, U)
----------------------------------

definition-------------------------
infer_tm(∀ {A_242 : Type‹s_241›} ->
           ((stream_1‹??_10›) A_242) -> unit_1‹U›)
infer_tm(Type‹s_241›)
infer_tm(((stream_1‹??_10›) A_244) -> unit_1‹U›)
infer_tm(((stream_1‹??_10›) A_244))
infer_tm(stream_1‹??_10›)
check_tm( A_244, Type‹??_10›)
infer_tm(A_244)
assert_equal1( Type‹??_10›, Type‹s_241›)
assert_equal1_extend( Type‹??_10›, Type‹s_241›)
simpl_tm ~expand:false( Type‹??_10›, Type‹s_241›)
infer_tm(unit_1‹U›)
check_tm(
  function free_stream_248 :
    ∀ {A_249 : Type‹s_241›} ->
      ((stream_1‹??_8›) A_249) -> unit_1‹U›
  | A_251 st_252 =>
    match ((st_252) false_3) in ∀ (_253 : ?_7) -o ?_8 with
    | tt_1 => tt_1‹??_9›,
  ∀ {A_254 : Type‹s_241›} ->
    ((stream_1‹??_10›) A_254) -> unit_1‹U›)
infer_tm(∀ {A_257 : Type‹s_241›} ->
           ((stream_1‹??_8›) A_257) -> unit_1‹U›)
infer_tm(Type‹s_241›)
infer_tm(((stream_1‹??_8›) A_259) -> unit_1‹U›)
infer_tm(((stream_1‹??_8›) A_259))
infer_tm(stream_1‹??_8›)
check_tm( A_259, Type‹??_8›)
infer_tm(A_259)
assert_equal1( Type‹??_8›, Type‹s_241›)
assert_equal1_extend( Type‹??_8›, Type‹s_241›)
simpl_tm ~expand:false( Type‹??_8›, Type‹s_241›)
infer_tm(unit_1‹U›)
assert_equal1(
  ∀ {A_263 : Type‹s_241›} ->
    ((stream_1‹??_10›) A_263) -> unit_1‹U›,
  ∀ {A_265 : Type‹s_241›} ->
    ((stream_1‹??_8›) A_265) -> unit_1‹U›)
assert_equal1_extend(
  ∀ {A_272 : Type‹s_241›} ->
    ((stream_1‹??_10›) A_272) -> unit_1‹U›,
  ∀ {A_274 : Type‹s_241›} ->
    ((stream_1‹??_8›) A_274) -> unit_1‹U›)
simpl_tm ~expand:false(
  ∀ {A_282 : Type‹s_241›} ->
    ((stream_1‹s_241›) A_282) -> unit_1‹U›,
  ∀ {A_284 : Type‹s_241›} ->
    ((stream_1‹s_241›) A_284) -> unit_1‹U›)
simpl_tm ~expand:false( Type‹s_241›, Type‹s_241›)
simpl_tm ~expand:false( ((stream_1‹s_241›) A_286) -> unit_1‹U›,
  ((stream_1‹s_241›) A_286) -> unit_1‹U›)
simpl_tm ~expand:false( ((stream_1‹s_241›) A_286),
  ((stream_1‹s_241›) A_286))
simpl_tm ~expand:false( stream_1‹s_241›, stream_1‹s_241›)
simpl_tm ~expand:false( A_286, A_286)
simpl_tm ~expand:false( unit_1‹U›, unit_1‹U›)
check_cls {|
  prblm {| ;
    {|  ::: [A_276, st_277] =>?
         match ((#st_277) false_3) in ∀ (_292 : ?_7) -o ?_8 with
         | tt_1 => tt_1‹??_9›
    |}
  |}
  a := ∀ {A_293 : Type‹s_241›} ->
         ((stream_1‹s_241›) A_293) -> unit_1‹U›
|}
case_intro
case_introed(A_295 : Type‹s_241›)
case_intro
case_introed(st_296 : ((stream_1‹s_241›) #A_295))
case_coverage{|
  prblm {| ;
    {| eq_pat?( #A_295, A_276 : Type‹s_241›)
       eq_pat?( #st_296, st_277 : ((stream_1‹s_241›) #A_295)) ::: [] =>?
         match ((#st_277) false_3) in ∀ (_297 : ?_7) -o ?_8 with
         | tt_1 => tt_1‹??_9›
    |}
  |}
|}
unify_local(
  eq_pat?( #A_295, A_276 : Type‹s_241›)
  eq_pat?( #st_296, st_277 : ((stream_1‹s_241›) #A_295))
)
unify_global(  )
simpl_pprbm ~expand:false( #A_295, #A_276)
simpl_pprbm ~expand:false( #st_296, #st_277)
case_coverage_ok(
  match ((st_296) false_3) in ∀ (_302 : ?_7) -o ?_8 with
  | tt_1 => tt_1‹??_9›, unit_1‹U›)
check_tm(
  match ((st_296) false_3) in ∀ (_303 : ?_7) -o ?_8 with
  | tt_1 => tt_1‹??_9›, unit_1‹U›)
infer_tm(match ((st_296) false_3) in ∀ (_304 : ?_7) -o ?_8 with
         | tt_1 => tt_1‹??_9›)
infer_motive(((st_296) false_3) : ?_7)
infer_tm(?_7)
delay_assert(?_20, ??_22)
check_tm( ((st_296) false_3), ?_7)
infer_tm(((st_296) false_3))
infer_tm(st_296)
simpl_tm ~expand:false( ?_20, Type‹??_22›)
check_tm( false_3, bool_2)
infer_tm(false_3)
assert_equal1( bool_2, bool_2)
assert_equal1_ok( bool_2, bool_2)
assert_equal1( ?_7,
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹s_241› A_295)
  | false_3 => unit_1‹L›)
assert_equal1_extend( ?_7,
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹s_241› A_295)
  | false_3 => unit_1‹L›)
infer_tm(?_8)
simpl_tm ~expand:false( ?_7, unit_1‹L›)
delay_assert(?_21, ??_23)
simpl_tm ~expand:false( ?_21, Type‹??_23›)
check_cls {|
  prblm {| ; {|  ::: [tt_1] =>? tt_1‹??_9› |} |}
  a := ∀ (_309 : unit_1‹L›) -o ?_8
|}
case_intro
case_introed(_310 : unit_1‹L›)
case_splitting
splitting_on(tt_1)
case_coverage{|
  prblm {| eq_term?( unit_1‹L›, unit_1‹L›);
    {|  ::: [] =>? tt_1‹??_9› |}
  |}
|}
unify_local(  )
unify_global( eq_term?( unit_1‹L›, unit_1‹L›) )
simpl_pprbm ~expand:false( unit_1‹L›, unit_1‹L›)
case_coverage_ok( tt_1‹??_9›, ?_8)
check_tm( tt_1‹??_9›, ?_8)
infer_tm(tt_1‹??_9›)
assert_equal1( ?_8, unit_1‹??_9›)
assert_equal1_extend( ?_8, unit_1‹??_9›)
assert_equal1( unit_1‹U›, ?_8)
assert_equal1_extend( unit_1‹U›, ?_8)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_315
    ??_2 <= s_316
    ??_3 <= s_317
    ??_4 <= L
    ??_5 <= s_319
    ??_6 <= s_320
    ??_7 <= L
    ??_8 <= s_322
    ??_10 <= s_323
    ??_16 <= U
    ??_17 <= U
    ??_18 <= U
    ??_19 <= U
    ??_20 <= U
    ??_21 <= U
    
  |}
  imeta_meta {|
    ?_1 <= bool_2
    ?_2 <= L
    ?_3 <= L
    ?_4 <= bool_2
    ?_5 <= L
    ?_6 <= ?_3
    ?_7 <= unit_1‹L›
    ?_14 <= Type‹??_16›
    ?_15 <= Type‹??_17›
    ?_16 <= Type‹??_18›
    ?_17 <= Type‹??_19›
    ?_18 <= Type‹??_20›
    ?_19 <= Type‹??_21›
    ?_20 <= Type‹??_22›
    ?_21 <= Type‹??_23›
    
  |}
  eqns {|
    equal_tm? (unit_1‹U›, ?_8);
    equal_tm? (?_8, unit_1‹??_9›)
  |}
end_dump
simpl_tm ~expand:false( unit_1‹U›, ?_8)
simpl_tm ~expand:false( unit_1‹U›, unit_1‹??_9›)
infer_tm(Type‹??_22›)
check_tm( unit_1‹L›, Type‹??_22›)
infer_tm(unit_1‹L›)
assert_equal1( Type‹??_22›, L)
assert_equal1_extend( Type‹??_22›, L)
simpl_tm ~expand:false( Type‹??_22›, L)
infer_tm(Type‹??_23›)
check_tm( unit_1‹U›, Type‹??_23›)
infer_tm(unit_1‹U›)
assert_equal1( Type‹??_23›, U)
assert_equal1_extend( Type‹??_23›, U)
simpl_tm ~expand:false( Type‹??_23›, U)
----------------------------------

definition-------------------------
infer_tm(nat_3 -> ((stream_1‹??_14›) nat_3))
infer_tm(nat_3)
infer_tm(((stream_1‹??_14›) nat_3))
infer_tm(stream_1‹??_14›)
check_tm( nat_3, Type‹??_14›)
infer_tm(nat_3)
assert_equal1( Type‹??_14›, U)
assert_equal1_extend( Type‹??_14›, U)
simpl_tm ~expand:false( Type‹??_14›, U)
check_tm(
  function nat_make_398 : nat_3 -> ((stream_1‹??_11›) nat_3)
  | n_400 =>
    function _401 : ?_9
    | true_2 =>
      (stream_cons_7‹??_12› n_400 ((nat_make_398) (succ_5‹› n_400)))
    | false_3 => tt_1‹??_13›,
  nat_3 -> ((stream_1‹??_14›) nat_3))
infer_tm(nat_3 -> ((stream_1‹??_11›) nat_3))
infer_tm(nat_3)
infer_tm(((stream_1‹??_11›) nat_3))
infer_tm(stream_1‹??_11›)
check_tm( nat_3, Type‹??_11›)
infer_tm(nat_3)
assert_equal1( Type‹??_11›, U)
assert_equal1_extend( Type‹??_11›, U)
simpl_tm ~expand:false( Type‹??_11›, U)
assert_equal1( nat_3 -> ((stream_1‹??_14›) nat_3),
  nat_3 -> ((stream_1‹??_11›) nat_3))
assert_equal1_extend( nat_3 -> ((stream_1‹??_14›) nat_3),
  nat_3 -> ((stream_1‹??_11›) nat_3))
simpl_tm ~expand:false( nat_3 -> ((stream_1‹U›) nat_3),
  nat_3 -> ((stream_1‹U›) nat_3))
simpl_tm ~expand:false( nat_3, nat_3)
simpl_tm ~expand:false( ((stream_1‹U›) nat_3), ((stream_1‹U›) nat_3))
simpl_tm ~expand:false( stream_1‹U›, stream_1‹U›)
simpl_tm ~expand:false( nat_3, nat_3)
check_cls {|
  prblm {| ;
    {|  ::: [n_416] =>?
         function _423 : ?_9
         | true_2 =>
           (stream_cons_7‹??_12›
             #n_416 ((nat_make_403) (succ_5‹› #n_416)))
         | false_3 => tt_1‹??_13›
    |}
  |}
  a := nat_3 -> ((stream_1‹U›) nat_3)
|}
case_intro
case_introed(n_425 : nat_3)
case_coverage{|
  prblm {| ;
    {| eq_pat?( #n_425, n_416 : nat_3) ::: [] =>?
         function _426 : ?_9
         | true_2 =>
           (stream_cons_7‹??_12›
             #n_416 ((nat_make_403) (succ_5‹› #n_416)))
         | false_3 => tt_1‹??_13›
    |}
  |}
|}
unify_local( eq_pat?( #n_425, n_416 : nat_3) )
unify_global(  )
simpl_pprbm ~expand:false( #n_425, #n_416)
case_coverage_ok(
  function _430 : ?_9
  | true_2 =>
    (stream_cons_7‹??_12› n_425 ((nat_make_403) (succ_5‹› n_425)))
  | false_3 => tt_1‹??_13›, ((stream_1‹U›) nat_3))
check_tm(
  function _431 : ?_9
  | true_2 =>
    (stream_cons_7‹??_12› n_425 ((nat_make_403) (succ_5‹› n_425)))
  | false_3 => tt_1‹??_13›, ((stream_1‹U›) nat_3))
infer_tm(?_9)
delay_assert(?_22, ??_24)
assert_equal1( ((stream_1‹U›) nat_3), ?_9)
assert_equal1_extend( ((stream_1‹U›) nat_3), ?_9)
simpl_tm ~expand:false( ((stream_1‹U›) nat_3), ?_9)
simpl_tm ~expand:false( ?_22, Type‹??_24›)
check_cls {|
  prblm {| ;
    {|  ::: [true_2] =>?
         (stream_cons_7‹??_12›
           n_425 ((nat_make_403) (succ_5‹› n_425)))
    |} {|  ::: [false_3] =>? tt_1‹??_13› |}
  |}
  a := ((stream_1‹U›) nat_3)
|}
case_intro
case_introed(b_433 : bool_2)
case_splitting
splitting_on(true_2)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2);
    {|  ::: [] =>?
         (stream_cons_7‹??_12›
           n_425 ((nat_make_403) (succ_5‹› n_425)))
    |}
  |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok(
  (stream_cons_7‹??_12› n_425 ((nat_make_403) (succ_5‹› n_425))),
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
check_tm(
  (stream_cons_7‹??_12› n_425 ((nat_make_403) (succ_5‹› n_425))),
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
infer_tm((stream_cons_7‹??_12›
           n_425 ((nat_make_403) (succ_5‹› n_425))))
check_tm( ?_10, Type‹??_12›)
check_tm( n_425, ?_10)
infer_tm(n_425)
assert_equal1( ?_10, nat_3)
assert_equal1_extend( ?_10, nat_3)
check_tm( ((nat_make_403) (succ_5‹› n_425)),
  ∀ (b_441 : bool_2) -o
    match b_441 in bool_2 -o L with
    | true_2 => (stream_node_4‹??_12› ?_10)
    | false_3 => unit_1‹L›)
infer_tm(((nat_make_403) (succ_5‹› n_425)))
infer_tm(nat_make_403)
simpl_tm ~expand:false( ?_10, nat_3)
check_tm( (succ_5‹› n_425), nat_3)
infer_tm((succ_5‹› n_425))
check_tm( n_425, nat_3)
infer_tm(n_425)
assert_equal1( nat_3, nat_3)
assert_equal1_ok( nat_3, nat_3)
assert_equal1( nat_3, nat_3)
assert_equal1_ok( nat_3, nat_3)
assert_equal1(
  ∀ (b_444 : bool_2) -o
    match b_444 in bool_2 -o L with
    | true_2 => (stream_node_4‹??_12› ?_10)
    | false_3 => unit_1‹L›,
  ((stream_1‹U›) nat_3))
assert_equal1_extend(
  ∀ (b_449 : bool_2) -o
    match b_449 in bool_2 -o L with
    | true_2 => (stream_node_4‹??_12› ?_10)
    | false_3 => unit_1‹L›,
  ((stream_1‹U›) nat_3))
assert_equal1(
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›, (stream_node_4‹??_12› ?_10))
assert_equal1_extend(
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›, (stream_node_4‹??_12› ?_10))
splitting_on(false_3)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2); {|  ::: [] =>? tt_1‹??_13› |} |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
simpl_tm ~expand:false( (stream_node_4‹U› nat_3),
  (stream_node_4‹??_12› nat_3))
simpl_tm ~expand:false( nat_3, nat_3)
simpl_tm ~expand:false(
  ∀ (b_460 : bool_2) -o
    match b_460 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›,
  ((stream_1‹U›) nat_3))
simpl_tm ~expand:false(
  ∀ (b_462 : bool_2) -o
    match b_462 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›,
  stream_1‹U›)
simpl_tm ~expand:true(
  ∀ (b_464 : bool_2) -o
    match b_464 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›,
  function stream_466 : U -> L
  | A_468 =>
    ∀ (b_469 : bool_2) -o
      match b_469 in bool_2 -o L with
      | true_2 => (stream_node_4‹U› A_468)
      | false_3 => unit_1‹L›)
simpl_tm ~expand:true(
  ∀ (b_478 : bool_2) -o
    match b_478 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›,
  ∀ (b_480 : bool_2) -o
    match b_480 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›)
simpl_tm ~expand:false( bool_2, bool_2)
simpl_tm ~expand:false(
  match b_482 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›,
  match b_482 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
simpl_tm ~expand:false( b_482, b_482)
simpl_tm ~expand:false( bool_2 -o L, bool_2 -o L)
simpl_tm ~expand:false( bool_2, bool_2)
simpl_tm ~expand:false( L, L)
simpl_tm ~expand:false( (stream_node_4‹U› nat_3),
  (stream_node_4‹U› nat_3))
simpl_tm ~expand:false( nat_3, nat_3)
simpl_tm ~expand:false( unit_1‹L›, unit_1‹L›)
case_coverage_ok( tt_1‹??_13›,
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
check_tm( tt_1‹??_13›,
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
infer_tm(tt_1‹??_13›)
assert_equal1(
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›, unit_1‹??_13›)
assert_equal1_extend(
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›, unit_1‹??_13›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_493
    ??_2 <= s_494
    ??_3 <= s_495
    ??_4 <= L
    ??_5 <= s_497
    ??_6 <= s_498
    ??_7 <= L
    ??_8 <= s_500
    ??_9 <= U
    ??_10 <= s_502
    ??_11 <= U
    ??_12 <= U
    ??_14 <= U
    ??_16 <= U
    ??_17 <= U
    ??_18 <= U
    ??_19 <= U
    ??_20 <= U
    ??_21 <= U
    ??_22 <= L
    ??_23 <= U
    
  |}
  imeta_meta {|
    ?_1 <= bool_2
    ?_2 <= L
    ?_3 <= L
    ?_4 <= bool_2
    ?_5 <= L
    ?_6 <= ?_3
    ?_7 <= unit_1‹L›
    ?_8 <= unit_1‹U›
    ?_9 <= ((stream_1‹U›) nat_3)
    ?_10 <= nat_3
    ?_14 <= Type‹??_16›
    ?_15 <= Type‹??_17›
    ?_16 <= Type‹??_18›
    ?_17 <= Type‹??_19›
    ?_18 <= Type‹??_20›
    ?_19 <= Type‹??_21›
    ?_20 <= Type‹??_22›
    ?_21 <= Type‹??_23›
    ?_22 <= Type‹??_24›
    
  |}
  eqns {|
    equal_tm?
      (match false_3 in bool_2 -o L with
       | true_2 => (stream_node_4‹U› nat_3)
       | false_3 => unit_1‹L›,
      unit_1‹??_13›)
  |}
end_dump
simpl_tm ~expand:false( unit_1‹L›, unit_1‹??_13›)
infer_tm(Type‹??_24›)
check_tm( ((stream_1‹U›) nat_3), Type‹??_24›)
infer_tm(((stream_1‹U›) nat_3))
infer_tm(stream_1‹U›)
check_tm( nat_3, U)
infer_tm(nat_3)
assert_equal1( U, U)
assert_equal1_ok( U, U)
assert_equal1( Type‹??_24›, L)
assert_equal1_extend( Type‹??_24›, L)
simpl_tm ~expand:false( Type‹??_24›, L)
infer_tm(U)
check_tm( nat_3, U)
infer_tm(nat_3)
assert_equal1( U, U)
assert_equal1_ok( U, U)
----------------------------------

definition-------------------------
infer_tm(?_11)
delay_assert(?_23, ??_25)
check_tm( ((nat_make_3) zero_4), ?_11)
infer_tm(((nat_make_3) zero_4))
infer_tm(nat_make_3)
simpl_tm ~expand:false( ?_23, Type‹??_25›)
check_tm( zero_4, nat_3)
infer_tm(zero_4)
assert_equal1( nat_3, nat_3)
assert_equal1_ok( nat_3, nat_3)
assert_equal1( ?_11, ((stream_1‹U›) nat_3))
assert_equal1_extend( ?_11, ((stream_1‹U›) nat_3))
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_584
    ??_2 <= s_585
    ??_3 <= s_586
    ??_4 <= L
    ??_5 <= s_588
    ??_6 <= s_589
    ??_7 <= L
    ??_8 <= s_591
    ??_9 <= U
    ??_10 <= s_593
    ??_11 <= U
    ??_12 <= U
    ??_13 <= L
    ??_14 <= U
    ??_16 <= U
    ??_17 <= U
    ??_18 <= U
    ??_19 <= U
    ??_20 <= U
    ??_21 <= U
    ??_22 <= L
    ??_23 <= U
    ??_24 <= L
    
  |}
  imeta_meta {|
    ?_1 <= bool_2
    ?_2 <= L
    ?_3 <= L
    ?_4 <= bool_2
    ?_5 <= L
    ?_6 <= ?_3
    ?_7 <= unit_1‹L›
    ?_8 <= unit_1‹U›
    ?_9 <= ((stream_1‹U›) nat_3)
    ?_10 <= nat_3
    ?_14 <= Type‹??_16›
    ?_15 <= Type‹??_17›
    ?_16 <= Type‹??_18›
    ?_17 <= Type‹??_19›
    ?_18 <= Type‹??_20›
    ?_19 <= Type‹??_21›
    ?_20 <= Type‹??_22›
    ?_21 <= Type‹??_23›
    ?_22 <= Type‹??_24›
    ?_23 <= Type‹??_25›
    
  |}
  eqns {|
    equal_tm? (?_11, ((stream_1‹U›) nat_3))
  |}
end_dump
simpl_tm ~expand:false( ?_11, ((stream_1‹U›) nat_3))
infer_tm(Type‹??_25›)
check_tm( ((stream_1‹U›) nat_3), Type‹??_25›)
infer_tm(((stream_1‹U›) nat_3))
infer_tm(stream_1‹U›)
check_tm( nat_3, U)
infer_tm(nat_3)
assert_equal1( U, U)
assert_equal1_ok( U, U)
assert_equal1( Type‹??_25›, L)
assert_equal1_extend( Type‹??_25›, L)
simpl_tm ~expand:false( Type‹??_25›, L)
----------------------------------

definition-------------------------
infer_tm(?_13)
delay_assert(?_24, ??_26)
check_tm( ((free_stream_2‹??_15›) ?_12 nat_stream_4), ?_13)
infer_tm(((free_stream_2‹??_15›) ?_12 nat_stream_4))
infer_tm(((free_stream_2‹??_15›) ?_12))
infer_tm(free_stream_2‹??_15›)
simpl_tm ~expand:false( ?_24, Type‹??_26›)
check_tm( ?_12, Type‹??_15›)
check_tm( nat_stream_4, ((stream_1‹??_15›) ?_12))
infer_tm(nat_stream_4)
assert_equal1( ((stream_1‹??_15›) ?_12), ((stream_1‹U›) nat_3))
assert_equal1_extend( ((stream_1‹??_15›) ?_12),
  ((stream_1‹U›) nat_3))
assert_equal1( ?_13, unit_1‹U›)
assert_equal1_extend( ?_13, unit_1‹U›)
begin_dump
  mctx {|
    
  |}
  smeta_meta {|
    ??_1 <= s_668
    ??_2 <= s_669
    ??_3 <= s_670
    ??_4 <= L
    ??_5 <= s_672
    ??_6 <= s_673
    ??_7 <= L
    ??_8 <= s_675
    ??_9 <= U
    ??_10 <= s_677
    ??_11 <= U
    ??_12 <= U
    ??_13 <= L
    ??_14 <= U
    ??_16 <= U
    ??_17 <= U
    ??_18 <= U
    ??_19 <= U
    ??_20 <= U
    ??_21 <= U
    ??_22 <= L
    ??_23 <= U
    ??_24 <= L
    ??_25 <= L
    
  |}
  imeta_meta {|
    ?_1 <= bool_2
    ?_2 <= L
    ?_3 <= L
    ?_4 <= bool_2
    ?_5 <= L
    ?_6 <= ?_3
    ?_7 <= unit_1‹L›
    ?_8 <= unit_1‹U›
    ?_9 <= ((stream_1‹U›) nat_3)
    ?_10 <= nat_3
    ?_11 <= ((stream_1‹U›) nat_3)
    ?_14 <= Type‹??_16›
    ?_15 <= Type‹??_17›
    ?_16 <= Type‹??_18›
    ?_17 <= Type‹??_19›
    ?_18 <= Type‹??_20›
    ?_19 <= Type‹??_21›
    ?_20 <= Type‹??_22›
    ?_21 <= Type‹??_23›
    ?_22 <= Type‹??_24›
    ?_23 <= Type‹??_25›
    ?_24 <= Type‹??_26›
    
  |}
  eqns {|
    equal_tm? (?_13, unit_1‹U›);
    equal_tm? (((stream_1‹??_15›) ?_12), ((stream_1‹U›) nat_3))
  |}
end_dump
simpl_tm ~expand:false( ?_13, unit_1‹U›)
simpl_tm ~expand:false( ((stream_1‹??_15›) ?_12),
  ((stream_1‹U›) nat_3))
simpl_tm ~expand:false( stream_1‹??_15›, stream_1‹U›)
simpl_tm ~expand:false( ?_12, nat_3)
simpl_tm ~expand:false( nat_3, ?_12)
infer_tm(U)
check_tm( nat_3, U)
infer_tm(nat_3)
assert_equal1( U, U)
assert_equal1_ok( U, U)
infer_tm(Type‹??_26›)
check_tm( unit_1‹U›, Type‹??_26›)
infer_tm(unit_1‹U›)
assert_equal1( Type‹??_26›, U)
assert_equal1_extend( Type‹??_26›, U)
simpl_tm ~expand:false( Type‹??_26›, U)
----------------------------------

smeta_meta {|
  ??_1 <= s_747
  ??_2 <= s_748
  ??_3 <= s_749
  ??_4 <= L
  ??_5 <= s_751
  ??_6 <= s_752
  ??_7 <= L
  ??_8 <= s_754
  ??_9 <= U
  ??_10 <= s_756
  ??_11 <= U
  ??_12 <= U
  ??_13 <= L
  ??_14 <= U
  ??_15 <= U
  ??_16 <= U
  ??_17 <= U
  ??_18 <= U
  ??_19 <= U
  ??_20 <= U
  ??_21 <= U
  ??_22 <= L
  ??_23 <= U
  ??_24 <= L
  ??_25 <= L
  ??_26 <= U
  
|}
imeta_meta {|
  ?_1 <= bool_2
  ?_2 <= L
  ?_3 <= L
  ?_4 <= bool_2
  ?_5 <= L
  ?_6 <= ?_3
  ?_7 <= unit_1‹L›
  ?_8 <= unit_1‹U›
  ?_9 <= ((stream_1‹U›) nat_3)
  ?_10 <= nat_3
  ?_11 <= ((stream_1‹U›) nat_3)
  ?_12 <= nat_3
  ?_13 <= unit_1‹U›
  ?_14 <= Type‹??_16›
  ?_15 <= Type‹??_17›
  ?_16 <= Type‹??_18›
  ?_17 <= Type‹??_19›
  ?_18 <= Type‹??_20›
  ?_19 <= Type‹??_21›
  ?_20 <= Type‹??_22›
  ?_21 <= Type‹??_23›
  ?_22 <= Type‹??_24›
  ?_23 <= Type‹??_25›
  ?_24 <= Type‹??_26›
  
|}
#[program]
inductive unit_1‹s_877› : Type‹s_877› where
| tt_1 : unit_1‹s_877›

#[program]
inductive bool_2‹› : U where
| true_2 : bool_2
| false_3 : bool_2

#[program]
inductive nat_3‹› : U where
| zero_4 : nat_3
| succ_5 (pred_878 : nat_3) : nat_3

#[program]
inductive stream_node_4‹s_879› (A_880 : Type‹s_879›): L where
| stream_nil_6 : (stream_node_4‹s_879› A_880)
| stream_cons_7
    (hd_881 : A_880)
    (tl_882 : ∀ (b_883 : bool_2) -o
                match b_883 in bool_2 -o L with
                | true_2 => (stream_node_4‹s_879› A_880)
                | false_3 => unit_1‹L›)
    : (stream_node_4‹s_879› A_880)

#[logical]
def stream_1‹s_885› : Type‹s_885› -> L :=
  function stream_887 : Type‹s_885› -> L
  | A_889 =>
    ∀ (b_890 : bool_2) -o
      match b_890 in bool_2 -o L with
      | true_2 => (stream_node_4‹s_885› A_889)
      | false_3 => unit_1‹L›

#[program]
def free_stream_2‹s_892› :
  ∀ {A_893 : Type‹s_892›} ->
    ((stream_1‹s_892›) A_893) -> unit_1‹U›
:=
  function free_stream_895 :
    ∀ {A_896 : Type‹s_892›} ->
      ((stream_1‹s_892›) A_896) -> unit_1‹U›
  | A_898 st_899 =>
    match ((st_899) false_3) in unit_1‹L› -o unit_1‹U› with
    | tt_1 => tt_1‹U›

#[program]
def nat_make_3‹› : nat_3 -> ((stream_1‹U›) nat_3) :=
  function nat_make_902 : nat_3 -> ((stream_1‹U›) nat_3)
  | n_904 =>
    function _905 : ((stream_1‹U›) nat_3)
    | true_2 =>
      (stream_cons_7‹U› n_904 ((nat_make_902) (succ_5‹› n_904)))
    | false_3 => tt_1‹L›

#[program]
def nat_stream_4‹› : ((stream_1‹U›) nat_3) := ((nat_make_3) zero_4)

#[program]
def ok_5‹› : unit_1‹U› := ((free_stream_2‹U›) nat_3 nat_stream_4)

-----------------------------------------

Logical.infer_tm(unit_1‹L›)
Logical.infer_tm(unit_1‹U›)
Logical.infer_tm(bool_2)
Logical.infer_tm(bool_2)
Logical.infer_tm(nat_3)
Logical.infer_tm(nat_3)
Logical.infer_tm(nat_3)
Logical.infer_tm(L)
Logical.infer_tm(L)
Logical.infer_tm((stream_node_4‹L› A_908))
Logical.check_tm( A_908, L )
Logical.infer_tm(A_908)
Logical.infer_tm(L)
Logical.infer_tm(A_909)
Logical.infer_tm(∀ (b_912 : bool_2) -o
                   match b_912 in bool_2 -o L with
                   | true_2 => (stream_node_4‹L› A_909)
                   | false_3 => unit_1‹L›)
Logical.infer_tm(bool_2)
Logical.infer_tm(match b_914 in bool_2 -o L with
                 | true_2 => (stream_node_4‹L› A_909)
                 | false_3 => unit_1‹L›)
Logical.check_tm( b_914, bool_2 )
Logical.infer_tm(b_914)
Logical.infer_tm(bool_2)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2);
    {|  ::: [] =>? (stream_node_4‹L› A_909) |}
  |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( (stream_node_4‹L› A_909), L)
Logical.check_tm( (stream_node_4‹L› A_909), L )
Logical.infer_tm((stream_node_4‹L› A_909))
Logical.check_tm( A_909, L )
Logical.infer_tm(A_909)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2); {|  ::: [] =>? unit_1‹L› |} |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( unit_1‹L›, L)
Logical.check_tm( unit_1‹L›, L )
Logical.infer_tm(unit_1‹L›)
Logical.infer_tm((stream_node_4‹L› A_909))
Logical.check_tm( A_909, L )
Logical.infer_tm(A_909)
Logical.infer_tm(U)
Logical.infer_tm(U)
Logical.infer_tm((stream_node_4‹U› A_918))
Logical.check_tm( A_918, U )
Logical.infer_tm(A_918)
Logical.infer_tm(U)
Logical.infer_tm(A_919)
Logical.infer_tm(∀ (b_922 : bool_2) -o
                   match b_922 in bool_2 -o L with
                   | true_2 => (stream_node_4‹U› A_919)
                   | false_3 => unit_1‹L›)
Logical.infer_tm(bool_2)
Logical.infer_tm(match b_924 in bool_2 -o L with
                 | true_2 => (stream_node_4‹U› A_919)
                 | false_3 => unit_1‹L›)
Logical.check_tm( b_924, bool_2 )
Logical.infer_tm(b_924)
Logical.infer_tm(bool_2)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2);
    {|  ::: [] =>? (stream_node_4‹U› A_919) |}
  |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( (stream_node_4‹U› A_919), L)
Logical.check_tm( (stream_node_4‹U› A_919), L )
Logical.infer_tm((stream_node_4‹U› A_919))
Logical.check_tm( A_919, U )
Logical.infer_tm(A_919)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2); {|  ::: [] =>? unit_1‹L› |} |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( unit_1‹L›, L)
Logical.check_tm( unit_1‹L›, L )
Logical.infer_tm(unit_1‹L›)
Logical.infer_tm((stream_node_4‹U› A_919))
Logical.check_tm( A_919, U )
Logical.infer_tm(A_919)
Logical.infer_tm(L -> L)
Logical.infer_tm(L)
Logical.infer_tm(L)
Logical.check_tm(
  function stream_929 : L -> L
  | A_931 =>
    ∀ (b_932 : bool_2) -o
      match b_932 in bool_2 -o L with
      | true_2 => (stream_node_4‹L› A_931)
      | false_3 => unit_1‹L›,
  L -> L
)
Logical.infer_tm(function stream_935 : L -> L
                 | A_937 =>
                   ∀ (b_938 : bool_2) -o
                     match b_938 in bool_2 -o L with
                     | true_2 => (stream_node_4‹L› A_937)
                     | false_3 => unit_1‹L›)
Logical.infer_tm(L -> L)
Logical.infer_tm(L)
Logical.infer_tm(L)
Logical.infer_tm(L)
case_coverage{|
  prblm {| ;
    {| eq_pat?(R #A_944, A_943 : L) ::: [] =>?
         ∀ (b_946 : bool_2) -o
           match b_946 in bool_2 -o L with
           | true_2 => (stream_node_4‹L› #A_943)
           | false_3 => unit_1‹L›
    |}
  |}
|}
unify_local( eq_pat?(R #A_944, A_943 : L) )
unify_global(  )
simpl_pprbm ~expand:false( #A_944, #A_943)
case_coverage_ok(
  ∀ (b_951 : bool_2) -o
    match b_951 in bool_2 -o L with
    | true_2 => (stream_node_4‹L› A_944)
    | false_3 => unit_1‹L›,
  L)
Logical.check_tm(
  ∀ (b_953 : bool_2) -o
    match b_953 in bool_2 -o L with
    | true_2 => (stream_node_4‹L› A_944)
    | false_3 => unit_1‹L›,
  L
)
Logical.infer_tm(∀ (b_955 : bool_2) -o
                   match b_955 in bool_2 -o L with
                   | true_2 => (stream_node_4‹L› A_944)
                   | false_3 => unit_1‹L›)
Logical.infer_tm(bool_2)
Logical.infer_tm(match b_957 in bool_2 -o L with
                 | true_2 => (stream_node_4‹L› A_944)
                 | false_3 => unit_1‹L›)
Logical.check_tm( b_957, bool_2 )
Logical.infer_tm(b_957)
Logical.infer_tm(bool_2)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2);
    {|  ::: [] =>? (stream_node_4‹L› A_944) |}
  |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( (stream_node_4‹L› A_944), L)
Logical.check_tm( (stream_node_4‹L› A_944), L )
Logical.infer_tm((stream_node_4‹L› A_944))
Logical.check_tm( A_944, L )
Logical.infer_tm(A_944)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2); {|  ::: [] =>? unit_1‹L› |} |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( unit_1‹L›, L)
Logical.check_tm( unit_1‹L›, L )
Logical.infer_tm(unit_1‹L›)
Logical.infer_tm(U -> L)
Logical.infer_tm(U)
Logical.infer_tm(L)
Logical.check_tm(
  function stream_968 : U -> L
  | A_970 =>
    ∀ (b_971 : bool_2) -o
      match b_971 in bool_2 -o L with
      | true_2 => (stream_node_4‹U› A_970)
      | false_3 => unit_1‹L›,
  U -> L
)
Logical.infer_tm(function stream_974 : U -> L
                 | A_976 =>
                   ∀ (b_977 : bool_2) -o
                     match b_977 in bool_2 -o L with
                     | true_2 => (stream_node_4‹U› A_976)
                     | false_3 => unit_1‹L›)
Logical.infer_tm(U -> L)
Logical.infer_tm(U)
Logical.infer_tm(L)
Logical.infer_tm(U)
case_coverage{|
  prblm {| ;
    {| eq_pat?(R #A_983, A_982 : U) ::: [] =>?
         ∀ (b_985 : bool_2) -o
           match b_985 in bool_2 -o L with
           | true_2 => (stream_node_4‹U› #A_982)
           | false_3 => unit_1‹L›
    |}
  |}
|}
unify_local( eq_pat?(R #A_983, A_982 : U) )
unify_global(  )
simpl_pprbm ~expand:false( #A_983, #A_982)
case_coverage_ok(
  ∀ (b_990 : bool_2) -o
    match b_990 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› A_983)
    | false_3 => unit_1‹L›,
  L)
Logical.check_tm(
  ∀ (b_992 : bool_2) -o
    match b_992 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› A_983)
    | false_3 => unit_1‹L›,
  L
)
Logical.infer_tm(∀ (b_994 : bool_2) -o
                   match b_994 in bool_2 -o L with
                   | true_2 => (stream_node_4‹U› A_983)
                   | false_3 => unit_1‹L›)
Logical.infer_tm(bool_2)
Logical.infer_tm(match b_996 in bool_2 -o L with
                 | true_2 => (stream_node_4‹U› A_983)
                 | false_3 => unit_1‹L›)
Logical.check_tm( b_996, bool_2 )
Logical.infer_tm(b_996)
Logical.infer_tm(bool_2)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2);
    {|  ::: [] =>? (stream_node_4‹U› A_983) |}
  |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( (stream_node_4‹U› A_983), L)
Logical.check_tm( (stream_node_4‹U› A_983), L )
Logical.infer_tm((stream_node_4‹U› A_983))
Logical.check_tm( A_983, U )
Logical.infer_tm(A_983)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2); {|  ::: [] =>? unit_1‹L› |} |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( unit_1‹L›, L)
Logical.check_tm( unit_1‹L›, L )
Logical.infer_tm(unit_1‹L›)
Logical.infer_tm(∀ {A_1005 : L} ->
                   ((stream_1‹L›) A_1005) -> unit_1‹U›)
Logical.infer_tm(L)
Logical.infer_tm(((stream_1‹L›) A_1007) -> unit_1‹U›)
Logical.infer_tm(((stream_1‹L›) A_1007))
Logical.infer_tm(stream_1‹L›)
Logical.check_tm( A_1007, L )
Logical.infer_tm(A_1007)
Logical.infer_tm(unit_1‹U›)
Program.check_tm(
  function free_stream_1010 :
    ∀ {A_1011 : L} -> ((stream_1‹L›) A_1011) -> unit_1‹U›
  | A_1013 st_1014 =>
    match ((st_1014) false_3) in unit_1‹L› -o unit_1‹U› with
    | tt_1 => tt_1‹U›,
  ∀ {A_1016 : L} -> ((stream_1‹L›) A_1016) -> unit_1‹U›
)
Program.infer_tm(function free_stream_1018 :
                   ∀ {A_1019 : L} ->
                     ((stream_1‹L›) A_1019) -> unit_1‹U›
                 | A_1021 st_1022 =>
                   match ((st_1022) false_3) in
                     unit_1‹L› -o unit_1‹U›
                   with
                   | tt_1 => tt_1‹U›)
Logical.infer_tm(∀ {A_1025 : L} ->
                   ((stream_1‹L›) A_1025) -> unit_1‹U›)
Logical.infer_tm(L)
Logical.infer_tm(((stream_1‹L›) A_1027) -> unit_1‹U›)
Logical.infer_tm(((stream_1‹L›) A_1027))
Logical.infer_tm(stream_1‹L›)
Logical.check_tm( A_1027, L )
Logical.infer_tm(A_1027)
Logical.infer_tm(unit_1‹U›)
trans12.Program.case_intro(L)
Logical.infer_tm(L)
trans12.Program.case_intro(((stream_1‹L›) #A_1032))
Logical.infer_tm(((stream_1‹L›) A_1032))
Logical.infer_tm(stream_1‹L›)
Logical.check_tm( A_1032, L )
Logical.infer_tm(A_1032)
case_coverage{|
  prblm {| ;
    {| eq_pat?(N #A_1032, A_1030 : L)
       eq_pat?(R #st_1035, st_1031 : ((stream_1‹L›) #A_1032)) ::: [] =>?
         match ((#st_1031) false_3) in unit_1‹L› -o unit_1‹U› with
         | tt_1 => tt_1‹U›
    |}
  |}
|}
unify_local(
  eq_pat?(N #A_1032, A_1030 : L)
  eq_pat?(R #st_1035, st_1031 : ((stream_1‹L›) #A_1032))
)
unify_global(  )
simpl_pprbm ~expand:false( #A_1032, #A_1030)
simpl_pprbm ~expand:false( #st_1035, #st_1031)
case_coverage_ok(
  match ((st_1035) false_3) in unit_1‹L› -o unit_1‹U› with
  | tt_1 => tt_1‹U›, unit_1‹U›)
Program.check_tm(
  match ((st_1035) false_3) in unit_1‹L› -o unit_1‹U› with
  | tt_1 => tt_1‹U›, unit_1‹U›
)
Program.infer_tm(match ((st_1035) false_3) in unit_1‹L› -o unit_1‹U›
                 with
                 | tt_1 => tt_1‹U›)
Program.check_tm( ((st_1035) false_3), unit_1‹L› )
Program.infer_tm(((st_1035) false_3))
Program.infer_tm(st_1035)
Program.check_tm( false_3, bool_2 )
Program.infer_tm(false_3)
trans12.Program.case_intro(unit_1‹L›)
Logical.infer_tm(unit_1‹L›)
Logical.infer_tm(unit_1‹L›)
case_coverage{|
  prblm {| eq_term?( unit_1‹L›, unit_1‹L›);
    {|  ::: [] =>? tt_1‹U› |}
  |}
|}
unify_local(  )
unify_global( eq_term?( unit_1‹L›, unit_1‹L›) )
simpl_pprbm ~expand:false( unit_1‹L›, unit_1‹L›)
case_coverage_ok( tt_1‹U›, unit_1‹U›)
Program.check_tm( tt_1‹U›, unit_1‹U› )
Program.infer_tm(tt_1‹U›)
Logical.infer_tm(∀ {A_1056 : U} ->
                   ((stream_1‹U›) A_1056) -> unit_1‹U›)
Logical.infer_tm(U)
Logical.infer_tm(((stream_1‹U›) A_1058) -> unit_1‹U›)
Logical.infer_tm(((stream_1‹U›) A_1058))
Logical.infer_tm(stream_1‹U›)
Logical.check_tm( A_1058, U )
Logical.infer_tm(A_1058)
Logical.infer_tm(unit_1‹U›)
Program.check_tm(
  function free_stream_1061 :
    ∀ {A_1062 : U} -> ((stream_1‹U›) A_1062) -> unit_1‹U›
  | A_1064 st_1065 =>
    match ((st_1065) false_3) in unit_1‹L› -o unit_1‹U› with
    | tt_1 => tt_1‹U›,
  ∀ {A_1067 : U} -> ((stream_1‹U›) A_1067) -> unit_1‹U›
)
Program.infer_tm(function free_stream_1069 :
                   ∀ {A_1070 : U} ->
                     ((stream_1‹U›) A_1070) -> unit_1‹U›
                 | A_1072 st_1073 =>
                   match ((st_1073) false_3) in
                     unit_1‹L› -o unit_1‹U›
                   with
                   | tt_1 => tt_1‹U›)
Logical.infer_tm(∀ {A_1076 : U} ->
                   ((stream_1‹U›) A_1076) -> unit_1‹U›)
Logical.infer_tm(U)
Logical.infer_tm(((stream_1‹U›) A_1078) -> unit_1‹U›)
Logical.infer_tm(((stream_1‹U›) A_1078))
Logical.infer_tm(stream_1‹U›)
Logical.check_tm( A_1078, U )
Logical.infer_tm(A_1078)
Logical.infer_tm(unit_1‹U›)
trans12.Program.case_intro(U)
Logical.infer_tm(U)
trans12.Program.case_intro(((stream_1‹U›) #A_1083))
Logical.infer_tm(((stream_1‹U›) A_1083))
Logical.infer_tm(stream_1‹U›)
Logical.check_tm( A_1083, U )
Logical.infer_tm(A_1083)
case_coverage{|
  prblm {| ;
    {| eq_pat?(N #A_1083, A_1081 : U)
       eq_pat?(R #st_1086, st_1082 : ((stream_1‹U›) #A_1083)) ::: [] =>?
         match ((#st_1082) false_3) in unit_1‹L› -o unit_1‹U› with
         | tt_1 => tt_1‹U›
    |}
  |}
|}
unify_local(
  eq_pat?(N #A_1083, A_1081 : U)
  eq_pat?(R #st_1086, st_1082 : ((stream_1‹U›) #A_1083))
)
unify_global(  )
simpl_pprbm ~expand:false( #A_1083, #A_1081)
simpl_pprbm ~expand:false( #st_1086, #st_1082)
case_coverage_ok(
  match ((st_1086) false_3) in unit_1‹L› -o unit_1‹U› with
  | tt_1 => tt_1‹U›, unit_1‹U›)
Program.check_tm(
  match ((st_1086) false_3) in unit_1‹L› -o unit_1‹U› with
  | tt_1 => tt_1‹U›, unit_1‹U›
)
Program.infer_tm(match ((st_1086) false_3) in unit_1‹L› -o unit_1‹U›
                 with
                 | tt_1 => tt_1‹U›)
Program.check_tm( ((st_1086) false_3), unit_1‹L› )
Program.infer_tm(((st_1086) false_3))
Program.infer_tm(st_1086)
Program.check_tm( false_3, bool_2 )
Program.infer_tm(false_3)
trans12.Program.case_intro(unit_1‹L›)
Logical.infer_tm(unit_1‹L›)
Logical.infer_tm(unit_1‹L›)
case_coverage{|
  prblm {| eq_term?( unit_1‹L›, unit_1‹L›);
    {|  ::: [] =>? tt_1‹U› |}
  |}
|}
unify_local(  )
unify_global( eq_term?( unit_1‹L›, unit_1‹L›) )
simpl_pprbm ~expand:false( unit_1‹L›, unit_1‹L›)
case_coverage_ok( tt_1‹U›, unit_1‹U›)
Program.check_tm( tt_1‹U›, unit_1‹U› )
Program.infer_tm(tt_1‹U›)
Logical.infer_tm(nat_3 -> ((stream_1‹U›) nat_3))
Logical.infer_tm(nat_3)
Logical.infer_tm(((stream_1‹U›) nat_3))
Logical.infer_tm(stream_1‹U›)
Logical.check_tm( nat_3, U )
Logical.infer_tm(nat_3)
Program.check_tm(
  function nat_make_1109 : nat_3 -> ((stream_1‹U›) nat_3)
  | n_1111 =>
    function _1112 : ((stream_1‹U›) nat_3)
    | true_2 =>
      (stream_cons_7‹U› n_1111 ((nat_make_1109) (succ_5‹› n_1111)))
    | false_3 => tt_1‹L›,
  nat_3 -> ((stream_1‹U›) nat_3)
)
Program.infer_tm(function nat_make_1114 : nat_3 -> ((stream_1‹U›) nat_3)
                 | n_1116 =>
                   function _1117 : ((stream_1‹U›) nat_3)
                   | true_2 =>
                     (stream_cons_7‹U›
                       n_1116 ((nat_make_1114) (succ_5‹› n_1116)))
                   | false_3 => tt_1‹L›)
Logical.infer_tm(nat_3 -> ((stream_1‹U›) nat_3))
Logical.infer_tm(nat_3)
Logical.infer_tm(((stream_1‹U›) nat_3))
Logical.infer_tm(stream_1‹U›)
Logical.check_tm( nat_3, U )
Logical.infer_tm(nat_3)
trans12.Program.case_intro(nat_3)
Logical.infer_tm(nat_3)
case_coverage{|
  prblm {| ;
    {| eq_pat?(R #n_1122, n_1121 : nat_3) ::: [] =>?
         function _1124 : ((stream_1‹U›) nat_3)
         | true_2 =>
           (stream_cons_7‹U›
             #n_1121 ((nat_make_1118) (succ_5‹› #n_1121)))
         | false_3 => tt_1‹L›
    |}
  |}
|}
unify_local( eq_pat?(R #n_1122, n_1121 : nat_3) )
unify_global(  )
simpl_pprbm ~expand:false( #n_1122, #n_1121)
case_coverage_ok(
  function _1127 : ((stream_1‹U›) nat_3)
  | true_2 =>
    (stream_cons_7‹U› n_1122 ((nat_make_1118) (succ_5‹› n_1122)))
  | false_3 => tt_1‹L›, ((stream_1‹U›) nat_3))
Program.check_tm(
  function _1128 : ((stream_1‹U›) nat_3)
  | true_2 =>
    (stream_cons_7‹U› n_1122 ((nat_make_1118) (succ_5‹› n_1122)))
  | false_3 => tt_1‹L›, ((stream_1‹U›) nat_3)
)
Program.infer_tm(function _1129 : ((stream_1‹U›) nat_3)
                 | true_2 =>
                   (stream_cons_7‹U›
                     n_1122 ((nat_make_1118) (succ_5‹› n_1122)))
                 | false_3 => tt_1‹L›)
Logical.infer_tm(((stream_1‹U›) nat_3))
Logical.infer_tm(stream_1‹U›)
Logical.check_tm( nat_3, U )
Logical.infer_tm(nat_3)
trans12.Program.case_intro(bool_2)
Logical.infer_tm(bool_2)
Logical.infer_tm(bool_2)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2);
    {|  ::: [] =>?
         (stream_cons_7‹U›
           n_1122 ((nat_make_1118) (succ_5‹› n_1122)))
    |}
  |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok(
  (stream_cons_7‹U› n_1122 ((nat_make_1118) (succ_5‹› n_1122))),
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
Program.check_tm(
  (stream_cons_7‹U› n_1122 ((nat_make_1118) (succ_5‹› n_1122))),
  match true_2 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›
)
Program.infer_tm((stream_cons_7‹U›
                   n_1122 ((nat_make_1118) (succ_5‹› n_1122))))
Logical.check_tm( nat_3, U )
Logical.infer_tm(nat_3)
Program.check_tm( n_1122, nat_3 )
Program.infer_tm(n_1122)
Program.check_tm( ((nat_make_1118) (succ_5‹› n_1122)),
  ∀ (b_1140 : bool_2) -o
    match b_1140 in bool_2 -o L with
    | true_2 => (stream_node_4‹U› nat_3)
    | false_3 => unit_1‹L›
)
Program.infer_tm(((nat_make_1118) (succ_5‹› n_1122)))
Program.infer_tm(nat_make_1118)
Program.check_tm( (succ_5‹› n_1122), nat_3 )
Program.infer_tm((succ_5‹› n_1122))
Program.check_tm( n_1122, nat_3 )
Program.infer_tm(n_1122)
case_coverage{|
  prblm {| eq_term?( bool_2, bool_2); {|  ::: [] =>? tt_1‹L› |} |}
|}
unify_local(  )
unify_global( eq_term?( bool_2, bool_2) )
simpl_pprbm ~expand:false( bool_2, bool_2)
case_coverage_ok( tt_1‹L›,
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›)
Program.check_tm( tt_1‹L›,
  match false_3 in bool_2 -o L with
  | true_2 => (stream_node_4‹U› nat_3)
  | false_3 => unit_1‹L›
)
Program.infer_tm(tt_1‹L›)
Logical.infer_tm(((stream_1‹U›) nat_3))
Logical.infer_tm(stream_1‹U›)
Logical.check_tm( nat_3, U )
Logical.infer_tm(nat_3)
Program.check_tm( ((nat_make_3) zero_4), ((stream_1‹U›) nat_3) )
Program.infer_tm(((nat_make_3) zero_4))
Program.infer_tm(nat_make_3)
Program.check_tm( zero_4, nat_3 )
Program.infer_tm(zero_4)
Logical.infer_tm(unit_1‹U›)
Program.check_tm( ((free_stream_2‹U›) nat_3 nat_stream_4), unit_1‹U›
)
Program.infer_tm(((free_stream_2‹U›) nat_3 nat_stream_4))
Program.infer_tm(((free_stream_2‹U›) nat_3))
Program.infer_tm(free_stream_2‹U›)
Logical.check_tm( nat_3, U )
Logical.infer_tm(nat_3)
Program.check_tm( nat_stream_4, ((stream_1‹U›) nat_3) )
Program.infer_tm(nat_stream_4)
inductive unitU_6 where
| ttU_9 of size(0)

inductive unitL_5 where
| ttL_8 of size(0)

inductive bool_2 where
| true_2 of size(0) | false_3 of size(0)

inductive nat_3 where
| zero_4 of size(0) | succ_5 of size(1)

inductive stream_nodeU_8 where
| stream_nilU_12 of size(0) | stream_consU_13 of size(2)

inductive stream_nodeL_7 where
| stream_nilL_10 of size(0) | stream_consL_11 of size(2)

def streamU_7 = NULL

def streamL_6 = NULL

def free_streamU_9 =
  fun free_stream_1151 (A_1152, st_1153) =>
    match ((st_1153) false_3) with
    | ttL_8  => ttU_9
    end

def free_streamL_8 =
  fun free_stream_1154 (A_1155, st_1156) =>
    match ((st_1156) false_3) with
    | ttL_8  => ttU_9
    end

def nat_make_3 =
  fun nat_make_1157 (n_1158) =>
    fun _1159 (b_1160) =>
      match b_1160 with
      | true_2  => (stream_consU_13 n_1158 ((nat_make_1157) (succ_5 n_1158)))
      | false_3  => ttL_8
      end

def nat_stream_4 = ((nat_make_3) zero_4)

def ok_5 = ((free_streamU_9) NULL nat_stream_4)

-----------------------------------------

