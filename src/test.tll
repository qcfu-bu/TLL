#[program]
inductive nat : U where
| zero : nat
| succ (pred : nat) : nat


#[program]
inductive vec‹s,r› (A : Type‹s›) : nat -> Type‹r› where
| vnil : vec‹s,r›A zero
| #[additive]
  vcons {n : nat} (hd : A) (tl : vec‹s,r›A n) : vec‹s,r›A (succ n)

#[logical]
def add (x : nat) : nat -> nat
  | zero => x
  | succ n => succ (add x n)


#[program]
def add (m n : nat) : nat :=
  match
    {m} as x : nat,
    n as y : vec nat x
  in vec nat y with
  | zero, n => n
  | succ m, n => succ (add m n)
