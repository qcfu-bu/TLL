/- 
This file implements Red-Black Trees and verifies its BST invariant.
-/

inductive color : U where
  | Red   : color
  | Black : color

inductive tree‹s› (V : U) : Type‹s› where
  | Leaf : tree V
  | Node (c : color) (k : int) (v : V) (l r : tree‹s› V) : tree V

/-- Lookup a key (k0 : int) in the RB tree. -/
def lookup‹s› %{V : U} (k0 : int) : tree‹s› V -> option V ⊗ tree‹s› V
  | Leaf => ⟨None, Leaf⟩
  | Node c k v l r =>
    if k0 < k then
      let ⟨opt, l⟩ := lookup k0 l in
      ⟨opt, Node c k v l r⟩
    else if k < k0 then
      let ⟨opt, r⟩ := lookup k0 r in
      ⟨opt, Node c k v l r⟩
    else
      ⟨Some v, Node c k v l r⟩

/-- Balance RB tree (Purely Functional Data Structures, Okasaki 1996). -/
def balance‹s› %{V : U} 
  (c : color) (k : int) (vk : V) : tree‹s› V .-> tree‹s› V .-> tree‹s› V
| t1, t2 =>
  match c with
  | Red => Node Red k vk t1 t2
  | Black => 
    match t1 with
    | Node Red y vy (Node Red x vx a b) c =>
      Node Red y vy (Node Black x vx a b) (Node Black k vk c t2)
    | Node Red x vx a (Node Red y vy b c) =>
      Node Red y vy (Node Black x vx a b) (Node Black k vk c t2)
    | t1 => 
      match t2 with
      | Node Red z vz (Node Red y vy b c) d =>
        Node Red y vy (Node Black k vk t1 b) (Node Black z vz c d)
      | Node Red z vz b (Node Red y vy c d) =>
        Node Red z vz (Node Black k vk t1 b) (Node Black y vy c d)
      | t2 => Node Black k vk t1 t2

def ins‹s› %{V : U} (x : int) (vx : V) : tree‹s› V -> tree‹s› V
  | Leaf => Node Red x vx Leaf Leaf
  | Node c y vy a b =>
    if x < y then
      balance c y vy (ins x vx a) b
    else if y < x then
      balance c y vy a (ins x vx b)
    else
      Node c x vx a b

def blacken‹s› %{V : U} : tree‹s› V -> tree‹s› V
  | Leaf => Leaf
  | Node _ x vx a b => Node Black x vx a b

/-- Insert an element into the RB tree. -/
def insert‹s› %{V : U} (x : int) (vx : V) (t : tree‹s› V) :=
  blacken (ins x vx t)

/-- Verification of BST invariant. -/

/-- ForallT P t: all elements in t satisfy the predicate P.  -/
#[logical]
inductive ForallT‹s› %(V : U) (P : int -> V -> bool) : tree‹s› V -> U where
| ForallT_Leaf : ForallT‹s› P Leaf
| ForallT_Node (c : color) (x : int) (v : V) (l r : tree‹s› V)
  (HP : P x v = true) 
  (IHl : ForallT P l) 
  (IHr : ForallT P r) :
  ForallT‹s› P (Node c x v l r)

/-- Binary Search Tree (BST) invariant: 
All keys in the left-child are lesser than the root.
All keys in the right-child are greater than the root.
The left child and right child are BST.
-/
#[logical]
inductive BST‹s› %(V : U) : tree‹s› V -> U where
| BST_Leaf : BST Leaf
| BST_Node (c : color) (x : int) (v : V) (l r : tree‹s› V) 
  (Hl : ForallT (fn kl _ => kl < x) l)
  (Hr : ForallT (fn kr _ => kr > x) r)
  (IHl : BST l)
  (IHr : BST r) :
  BST (Node c x v l r)

theorem Leaf_BST‹s› (V : U) : BST (@Leaf‹s› V) := BST_Leaf

/-- Axioms for native integers. -/
theorem lt_gt %(x y : int) : x < y = true -> y > x = true := #magic
theorem gt_lt %(x y : int) : x > y = true -> y < x = true := #magic
theorem lte_gte %(x y : int) : x <= y = true -> y >= x = true := #magic
theorem gte_lte %(x y : int) : x >= y = true -> y <= x = true := #magic
theorem lt_false_gte %(x y : int) : x < y = false -> x >= y = true := #magic
theorem gt_false_lte %(x y : int) : x > y = false -> x <= y = true := #magic
theorem lte_gte_eq %(x y : int) : x <= y = true -> x >= y = true -> x = y := #magic
theorem lt_trans %(x y z : int) : x < y = true -> y < z = true -> x < z = true := #magic
theorem gt_trans %(x y z : int) : x > y = true -> y > z = true -> x > z = true := #magic

/-- Lemmas for ForallT. -/
theorem ForallT_imp‹s› %(V : U) (P Q : int -> V -> bool) (t : tree‹s› V) :
  ForallT P t -> 
  (∀ (k : int) (v : V) -> P k v = true -> Q k v = true) -> 
  ForallT Q t
| ForallT_Leaf, f => ForallT_Leaf
| ForallT_Node c k vk l r Hk IHl IHr, f =>
  let IHl := ForallT_imp _ _ _ IHl f in
  let IHr := ForallT_imp _ _ _ IHr f in
  let Hk := f _ _ Hk in 
  ForallT_Node _ _ _ _ _ Hk IHl IHr
  
theorem ForallT_gt‹s› %(V : U) %(t : tree‹s› V) %(k k0 : int) :
  ForallT (fn k1 _ => k1 > k) t ->
  k > k0 = true ->
  ForallT (fn k1 _ => k1 > k0) t :=
fn H h1 =>
  let f : ∀ (i : int) (v : V) -> ((fn k1 _ => k1 > k) i v = true) -> ((fn k1 _ => k1 > k0) i v = true) :=
    fn k v h2 => gt_trans h2 h1
  in
  ForallT_imp _ _ _ H f

theorem ForallT_lt‹s› %(V : U) %(t : tree‹s› V) %(k k0 : int) :
  ForallT (fn k1 _ => k1 < k) t ->
  k < k0 = true ->
  ForallT (fn k1 _ => k1 < k0) t :=
fn H h1 =>
  let f : ∀ (i : int) (v : V) -> ((fn k1 _ => k1 < k) i v = true) -> ((fn k1 _ => k1 < k0) i v = true) :=
    fn k v h2 => lt_trans h2 h1
  in
  ForallT_imp _ _ _ H f

/-- Balancing Lemmas. -/

theorem balance_ForallT‹s› %{V : U} (c : color) (k : int) (vk : V) (l r : tree‹s› V) :
  ∀ (P : int -> V -> bool) ->
    (P k vk = true) -> 
    ForallT P l -> 
    ForallT P r -> 
    ForallT P (balance c k vk l r) :=
fn P Hk Hl Hr =>
  match c as c0
     in ForallT P (balance c0 k vk l r) 
  with
  | Red => ForallT_Node Red k vk l r Hk Hl Hr
  | Black => 
    match l  as l0
        , Hl as _ : ForallT P l0
       in ForallT P (balance Black k vk l0 r)
    with
    | Node Red y vy (Node Red x vx a b) c, 
      ForallT_Node _ _ _ _ _ Hy (ForallT_Node _ _ _ _ _ Hx Ha Hb) Hc => 
      -- balances to: Node Red y vy (Node Black x vx a b) (Node Black k vk c t2)
      let H : ForallT P (Node Red y vy (Node Black x vx a b) (Node Black k vk c r)) :=
        ForallT_Node Red y vy _ _ Hy 
          (ForallT_Node _ _ _ _ _ Hx Ha Hb)
          (ForallT_Node _ _ _ _ _ Hk Hc Hr)
      in H
    | Node Red y vy (Node Red x vx a b) c, _ =>

    | Node Red x vx Leaf (Node Red y vy b c),
      ForallT_Node _ _ _ _ _ Hx Ha (ForallT_Node _ _ _ _ _ Hy Hb Hc) =>
      -- balances to: Node Red y vy (Node Black x vx a b) (Node Black k vk c t2)
      let H : ForallT P (Node Red y vy (Node Black x vx Leaf b) (Node Black k vk c r)) :=
        ForallT_Node Red y vy _ _ Hy
          (ForallT_Node _ _ _ _ _ Hx Ha Hb)
          (ForallT_Node _ _ _ _ _ Hk Hc Hr)
      in H
    | Node Red x vx (Node Black _ _ _ _) (Node Red y vy b c),
      ForallT_Node _ x1 _ _ _ Hx Ha (ForallT_Node _ _ _ _ _ Hy Hb Hc) =>
      let H : ForallT P (Node Red y vy (Node Black x vx _ b) (Node Black k vk c r)) :=
        ForallT_Node Red y vy _ _ Hy
          (ForallT_Node _ _ _ _ _ Hx Ha Hb)
          (ForallT_Node _ _ _ _ _ Hk Hc Hr)
      in H
    | Node Red x vx a (Node Red y vy b c), _ =>

    | l, Hl =>
      match r    as r0
          , Hr   as _ : ForallT P r0
        in ForallT P (balance Black k vk l r0)
      with
      | Node Red z vz (Node Red y vy b c) d,
        ForallT_Node _ _ _ _ _ Hz (ForallT_Node _ _ _ _ _ Hy Hb Hc) Hd =>
        let H : ForallT P (Node Red y vy (Node Black k vk l b) (Node Black z vz c d)) :=
          ForallT_Node Red y vy (Node Black k vk l b) (Node Black z vz c d) Hy
            (ForallT_Node Black k vk l b Hk Hl Hb)
            (ForallT_Node Black z vz c d Hz Hc Hd)
        in H
      | Node Red z vz (Node Red y vy b c) d, _ =>

      | Node Red z vz Leaf (Node Red y vy c d),
        ForallT_Node _ _ _ _ _ Hz Hb (ForallT_Node _ _ _ _ _ Hy Hc Hd) =>
        let H : ForallT P (Node Red z vz (Node Black k vk l Leaf) (Node Black y vy c d)) :=
          ForallT_Node Red z vz (Node Black k vk l Leaf) (Node Black y vy c d) Hz
            (ForallT_Node Black k vk l Leaf Hk Hl Hb)
            (ForallT_Node Black y vy c d Hy Hc Hd)
        in H
      | Node Red z vz (Node Black x vx a b) (Node Red y vy c d), 
        ForallT_Node _ _ _ _ _ Hz Hb (ForallT_Node _ _ _ _ _ Hy Hc Hd) =>
        let H : ForallT P (Node Red z vz (Node Black k vk l (Node Black x vx a b)) (Node Black y vy c d)) :=
          ForallT_Node Red z vz (Node Black k vk l (Node Black x vx a b)) (Node Black y vy c d) Hz
            (ForallT_Node Black k vk l (Node Black x vx a b) Hk Hl Hb)
            (ForallT_Node Black y vy c d Hy Hc Hd)
        in H
      | Node Red z vz a (Node Red y vy c d), _ =>

      | r, Hr => 
        -- balances to: Node Black k vk t1 t2
        ForallT_Node Black k vk l r Hk Hl Hr

theorem balance_BST‹s› %(V : U) (c : color) (k : int) (vk : V) (l r : tree‹s› V) :
  ForallT (fn i _ => i < k) l ->
  ForallT (fn i _ => i > k) r ->
  BST l ->
  BST r ->
  BST (balance c k vk l r) :=
fn Hl Hr IHl IHr =>
  match c    as c0 
     in BST (balance c0 k vk l r)
  with
  | Red => BST_Node Red k vk l r Hl Hr IHl IHr
  | Black => 
    match l   as l0
        , Hl  as _ : ForallT (fn i _ => i < k) l0
        , IHl as _ : BST l0
       in BST (balance Black k vk l0 r)
    with
    | Node Red y vy (Node Red x vx a b) c, 
      ForallT_Node _ _ _ _ _ Hyk _ Hkc,
      BST_Node _ _ _ _ _ 
        (ForallT_Node _ _ _ _ _ Hyx Hya Hyb) Hyc 
        (BST_Node _ _ _ _ _ Hxa Hxb IHa IHb) IHc =>
      let h1 : ForallT (fn i _ => i < y) (Node Black x vx a b) := 
        ForallT_Node Black x vx _ _ Hyx Hya Hyb
      in
      let h2 : ForallT (fn i _ => i > y) (Node Black k vk c r) :=
        let Hyk := lt_gt Hyk in
        ForallT_Node Black k vk _ _ Hyk Hyc (ForallT_gt Hr Hyk)
      in
      let bst1 : BST (Node Black x vx a b) :=
        BST_Node Black x vx _ _ Hxa Hxb IHa IHb
      in
      let bst2 : BST (Node Black k vk c r) :=
        BST_Node Black k vk _ _ Hkc Hr IHc IHr
      in
      -- balances to: Node Red y vy (Node Black x vx a b) (Node Black k vk c t2)
      let bst : BST (Node Red y vy (Node Black x vx a b) (Node Black k vk c r)) :=
        BST_Node Red y vy _ _ h1 h2 bst1 bst2
      in
      bst
    | Node Red y vy (Node Red x vx a b) c, _, _ =>

    | Node Red x vx Leaf (Node Red y vy b c),
      ForallT_Node _ _ _ _ _ Hxk _ (ForallT_Node _ _ _ _ _ Hky Hkb Hkc),
      BST_Node _ _ _ _ _
        Hxa (ForallT_Node _ _ _ _ _ Hxy Hxb Hxc) 
        IHa (BST_Node _ _ _ _ _ Hyb Hyc IHb IHc) =>
      let h1 : ForallT (fn i _ => i < y) (Node Black x vx Leaf b) :=
        let Hxy := gt_lt Hxy in
        ForallT_Node Black x vx _ _ Hxy (ForallT_lt Hxa Hxy) Hyb
      in
      let h2 : ForallT (fn i _ => i > y) (Node Black k vk c r) :=
        let Hky := lt_gt Hky in
        ForallT_Node Black k vk _ _ Hky Hyc (ForallT_gt Hr Hky)
      in
      let bst1 : BST (Node Black x vx Leaf b) :=
        BST_Node Black x vx _ _ Hxa Hxb IHa IHb
      in
      let bst2 : BST (Node Black k vk c r) :=
        BST_Node Black k vk _ _ Hkc Hr IHc IHr
      in
      -- balances to: Node Red y vy (Node Black x vx a b) (Node Black k vk c t2)
      let bst : BST (Node Red y vy (Node Black x vx Leaf b) (Node Black k vk c r)) :=
        BST_Node Red y vy _ _ h1 h2 bst1 bst2
      in
      bst
    | Node Red x vx (Node Black _ _ _ _) (Node Red y vy b c),
      ForallT_Node _ x1 _ _ _ Hxk _ (ForallT_Node _ _ _ _ _ Hky Hkb Hkc),
      BST_Node _ x2 _ _ _
        Hxa (ForallT_Node _ _ _ _ _ Hxy Hxb Hxc) 
        IHa (BST_Node _ _ _ _ _ Hyb Hyc IHb IHc) =>
      let h1 : ForallT (fn i _ => i < y) (Node Black x vx _ b) :=
        let Hxy := gt_lt Hxy in
        ForallT_Node Black x vx _ _ Hxy (ForallT_lt Hxa Hxy) Hyb
      in
      let h2 : ForallT (fn i _ => i > y) (Node Black k vk c r) :=
        let Hky := lt_gt Hky in
        ForallT_Node Black k vk _ _ Hky Hyc (ForallT_gt Hr Hky)
      in
      let bst1 : BST (Node Black x vx _ b) :=
        BST_Node Black x vx _ _ Hxa Hxb IHa IHb
      in
      let bst2 : BST (Node Black k vk c r) :=
        BST_Node Black k vk _ _ Hkc Hr IHc IHr
      in
      let bst : BST (Node Red y vy (Node Black x vx _ b) (Node Black k vk c r)) :=
        BST_Node Red y vy _ _ h1 h2 bst1 bst2
      in
      bst
    | Node Red x vx a (Node Red y vy b c), _, _ =>

    | l, Hl, IHl =>
      match r    as r0
          , Hr   as _ : ForallT (fn i _ => i > k) r0
          , IHr  as _ : BST r0
        in BST (balance Black k vk l r0)
      with
      | Node Red z vz (Node Red y vy b c) d,
        ForallT_Node _ _ _ _ _ Hkz (ForallT_Node _ _ _ _ _ Hky Hkb Hkc) Hkd,
        BST_Node _ _ _ _ _ 
          (ForallT_Node _ _ _ _ _ Hzy Hzb Hzc) Hzd 
          (BST_Node _ _ _ _ _ Hyb Hyc IHb IHc) IHd =>
        let h1 : ForallT (fn i _ => i < y) (Node Black k vk l b) :=
          let Hky : k < y = true := @gt_lt y k Hky in
          @ForallT_Node _ (fn i _ => i < y) Black k vk l b Hky 
            (@ForallT_lt _ l k y Hl Hky) Hyb
        in
        let h2 : ForallT (fn i _ => i > y) (Node Black z vz c d) :=
          let Hzy : z > y = true := @lt_gt y z Hzy in
          @ForallT_Node _ (fn i _ => i > y) Black z vz c d Hzy Hyc 
            (@ForallT_gt _ d z y Hzd Hzy)
        in
        let bst1 : BST (Node Black k vk l b) :=
          BST_Node Black k vk l b Hl Hkb IHl IHb
        in
        let bst2 : BST (Node Black z vz c d) :=
          BST_Node Black z vz c d Hzc Hzd IHc IHd
        in
        -- balances to: Node Red y vy (Node Black k vk t1 b) (Node Black z vz c d)
        let bst : BST (Node Red y vy (Node Black k vk l b) (Node Black z vz c d)) :=
          BST_Node Red y vy (Node Black k vk l b) (Node Black z vz c d) h1 h2 bst1 bst2
        in
        bst
      | Node Red z vz (Node Red y vy b c) d, _, _ =>

      | Node Red z vz Leaf (Node Red y vy c d),
        ForallT_Node _ _ _ _ _ Hkz Hkb (ForallT_Node _ _ _ _ _ Hky Hkc Hkd),
        BST_Node _ _ _ _ _
          Hb (ForallT_Node _ _ _ _ _ Hzy Hzc Hzd) 
          IHb (BST_Node _ _ _ _ _ Hyc Hyd IHc IHd) =>
        let h1 : ForallT (fn i _ => i < z) (Node Black k vk l Leaf) :=
          let Hkz : k < z = true := @gt_lt z k Hkz in 
          @ForallT_Node _ (fn i _ => i < z) Black k vk l Leaf 
            Hkz (@ForallT_lt _ l k z Hl Hkz) Hb
        in
        let h2 : ForallT (fn i _ => i > z) (Node Black y vy c d) :=
          @ForallT_Node _ (fn i _ => i > z) Black y vy c d
            Hzy Hzc Hzd
        in
        let bst1 : BST (Node Black k vk l Leaf) :=
          BST_Node Black k vk l Leaf Hl Hkb IHl IHb
        in
        let bst2 : BST (Node Black y vy c d) :=
          BST_Node Black y vy c d Hyc Hyd IHc IHd
        in
        -- balances to: Node Red z vz (Node Black k vk t1 b) (Node Black y vy c d)
        let bst : BST (Node Red z vz (Node Black k vk l Leaf) (Node Black y vy c d)) :=
          BST_Node Red z vz (Node Black k vk l Leaf) (Node Black y vy c d) h1 h2 bst1 bst2
        in
        bst
      | Node Red z vz (Node Black x vx a b) (Node Red y vy c d), 
        ForallT_Node _ _ _ _ _ Hkz Hkb (ForallT_Node _ _ _ _ _ Hky Hkc Hkd),
        BST_Node _ _ _ _ _
          Hb (ForallT_Node _ _ _ _ _ Hzy Hzc Hzd) 
          IHb (BST_Node _ _ _ _ _ Hyc Hyd IHc IHd) =>
        let h1 : ForallT (fn i _ => i < z) (Node Black k vk l (Node Black x vx a b)) :=
          let Hkz : k < z = true := @gt_lt z k Hkz in 
          @ForallT_Node _ (fn i _ => i < z) Black k vk l (Node Black x vx a b) 
            Hkz (@ForallT_lt _ l k z Hl Hkz) Hb
        in
        let h2 : ForallT (fn i _ => i > z) (Node Black y vy c d) :=
          @ForallT_Node _ (fn i _ => i > z) Black y vy c d
            Hzy Hzc Hzd
        in
        let bst1 : BST (Node Black k vk l (Node Black x vx a b)) :=
          BST_Node Black k vk l (Node Black x vx a b) Hl Hkb IHl IHb
        in
        let bst2 : BST (Node Black y vy c d) :=
          BST_Node Black y vy c d Hyc Hyd IHc IHd
        in
        -- balances to: Node Red z vz (Node Black k vk t1 b) (Node Black y vy c d)
        let bst : BST (Node Red z vz (Node Black k vk l (Node Black x vx a b)) (Node Black y vy c d)) :=
          BST_Node Red z vz (Node Black k vk l (Node Black x vx a b)) (Node Black y vy c d) h1 h2 bst1 bst2
        in
        bst
      | Node Red z vz a (Node Red y vy c d), _, _ =>

      | r, Hr, IHr => 
        -- balances to: Node Black k vk t1 t2
        BST_Node Black k vk l r Hl Hr IHl IHr

/-- Insertion Lemmas. -/

theorem ins_ForallT‹s› %{V : U} (x : int) (vx : V) (P : int -> V -> bool) (Hx : P x vx = true) :
  ∀ (t : tree‹s› V) -> ForallT P t -> ForallT P (ins x vx t)
| Leaf, ForallT_Leaf => 
  ForallT_Node Red x vx _ _ Hx ForallT_Leaf ForallT_Leaf
| Node c y vy a b, ForallT_Node _ _ _ _ _ Hy Ha Hb =>
  match x < y as b0 
      , refl  as _ : x < y = b0
     in ForallT P (if b0 then
                     balance c y vy (ins x vx a) b
                   else if y < x then
                     balance c y vy a (ins x vx b)
                   else
                     Node c x vx a b)
  with
  | true, pf => 
    let h := ins_ForallT x vx _ Hx a Ha in
    let H : ForallT P (balance c y vy (ins x vx a) b) := 
      balance_ForallT c y vy _ _ _ Hy h Hb
    in H
  | false, pf1 => 
    match y < x as b0 
        , refl  as _ : y < x = b0
       in ForallT P (if b0 then 
                       balance c y vy a (ins x vx b)
                     else
                       Node c x vx a b)
    with
    | true, pf => 
      let h := ins_ForallT x vx _ Hx b Hb in
      let H : ForallT P (balance c y vy a (ins x vx b)) :=
        balance_ForallT c y vy _ _ _ Hy Ha h
      in H
    | false, pf2 => 
      let H : ForallT P (Node c x vx a b) :=
        ForallT_Node c x vx a b Hx Ha Hb
      in H

theorem ins_BST‹s› %{V : U} (x : int) (vx : V) : 
  ∀ (t : tree‹s› V) -> BST t -> BST (ins x vx t)
| Leaf, BST_Leaf => 
  BST_Node Red x vx _ _ ForallT_Leaf ForallT_Leaf BST_Leaf BST_Leaf
| Node c y vy a b, BST_Node _ _ _ _ _ Ha Hb IHa IHb =>
  match x < y as b0 
      , refl  as _ : x < y = b0
     in BST (if b0 then
               balance c y vy (ins x vx a) b
             else if y < x then
               balance c y vy a (ins x vx b)
             else
               Node c x vx a b)
  with
  | true, pf =>
    let h1 : ForallT (fn i _ => i < y) (ins x vx a) :=
      ins_ForallT _ _ _ pf a Ha
    in
    let bst1 : BST (ins x vx a) := ins_BST x vx a IHa in
    let bst : BST (balance c y vy (ins x vx a) b) := 
      balance_BST c y vy (ins x vx a) b h1 Hb bst1 IHb
    in
    bst
  | false, pf1 =>
    match y < x as b0 
        , refl  as _ : y < x = b0
       in BST (if b0 then 
                 balance c y vy a (ins x vx b)
               else
                 Node c x vx a b)
    with
    | true, pf =>
      let h2 : ForallT (fn i _ => i > y) (ins x vx b) :=
        ins_ForallT _ _ _ (lt_gt pf) b Hb
      in
      let bst2 : BST (ins x vx b) := ins_BST x vx b IHb in
      let bst : BST (balance c y vy a (ins x vx b)) :=
        balance_BST c y vy a (ins x vx b) Ha h2 IHa bst2
      in
      bst
    | false, pf2 =>
      let pf1 : y <= x = true := gte_lte (lt_false_gte pf1) in
      let pf2 : y >= x = true := lt_false_gte pf2 in
      let eq : y = x:= lte_gte_eq pf1 pf2 in
      let Ha := rwl (fn y => ForallT (fn i _ => i < y) _) eq Ha in
      let Hb := rwl (fn y => ForallT (fn i _ => i > y) _) eq Hb in
      let bst : BST (Node c x vx a b) :=
        BST_Node c x vx a b Ha Hb IHa IHb
      in
      bst

theorem blacken_BST‹s› %{V : U} : ∀ (t : tree‹s› V) -> BST t -> BST (blacken t)
  | Leaf, BST_Leaf => BST_Leaf
  | Node _ x vx a b, BST_Node _ _ _ _ _ Ha Hb IHa IHb => 
    BST_Node Black x vx a b Ha Hb IHa IHb

/-- RB Tree Insertion Preserves BST. -/

theorem insert_BST‹s› %{V : U} (x : int) (vx : V) (t : tree‹s› V) : BST t -> BST (insert x vx t) :=
  fn bst =>
    let bst := ins_BST x vx t bst in
    let bst := blacken_BST _ bst in
    bst