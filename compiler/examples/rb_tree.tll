inductive color : U where
  | Red   : color
  | Black : color

inductive tree‹s› (V : U) : Type‹s› where
  | Leaf : tree V
  | Node (c : color) (k : int) (v : V) (l r : tree‹s› V) : tree V

def lookup‹s› %{V : U} (k0 : int) : tree‹s› V -> option V ⊗ tree‹s› V
  | Leaf => ⟨None, Leaf⟩
  | Node c k v l r =>
    if k0 < k then
      let ⟨opt, l⟩ := lookup k0 l in
      ⟨opt, Node c k v l r⟩
    else if k < k0 then
      let ⟨opt, r⟩ := lookup k0 r in
      ⟨opt, Node c k v l r⟩
    else
      ⟨Some v, Node c k v l r⟩

def balance‹s› %{V : U} 
  (c : color) (k : int) (vk : V) : tree‹s› V .-> tree‹s› V .-> tree‹s› V
| t1, t2 =>
  match c with
  | Red => Node Red k vk t1 t2
  | Black => 
    match t1 with
    | Node Red y vy (Node Red x vx a b) c =>
      Node Red y vy (Node Black x vx a b) (Node Black k vk c t2)
    | Node Red x vx a (Node Red y vy b c) =>
      Node Red y vy (Node Black x vx a b) (Node Black k vk c t2)
    | t1 => 
      match t2 with
      | Node Red z vz (Node Red y vy b c) d =>
        Node Red y vy (Node Black k vk t1 b) (Node Black z vz c d)
      | Node Red z vz b (Node Red y vy c d) =>
        Node Red z vz (Node Black k vk t1 b) (Node Black y vy c d)
      | t2 => Node Black k vk t1 t2

def ins‹s› %{V : U} (x : int) (vx : V) : tree‹s› V -> tree‹s› V
  | Leaf => Node Red x vx Leaf Leaf
  | Node c y vy a b =>
    if x < y then
      balance c y vy (ins x vx a) b
    else if y < x then
      balance c y vy a (ins x vx b)
    else
      Node c x vx a b

def make_black‹s› %{V : U} : tree‹s› V -> tree‹s› V
  | Leaf => Leaf
  | Node _ x vx a b => Node Black x vx a b

def insert‹s› %{V : U} (x : int) (vs : V) (t : tree‹s› V) :=
  make_black (ins x vs t)

#[logical]
inductive ForallT‹s› %(V : U) (P : int -> V -> bool) : tree‹s› V -> U where
| ForallT_Leaf : ForallT‹s› P Leaf
| ForallT_Node (c : color) (x : int) (v : V) (l r : tree‹s› V)
  (HP : P x v = true) 
  (IHl : ForallT P l) 
  (IHr : ForallT P r) :
  ForallT‹s› P (Node c x v l r)

#[logical]
inductive BST‹s› %(V : U) : tree‹s› V -> U where
| BST_Leaf : BST Leaf
| BST_Node (c : color) (x : int) (v : V) (l r : tree‹s› V) 
  (Hl : ForallT (fn kl _ => kl < x) l)
  (Hr : ForallT (fn kr _ => kr > x) r)
  (IHl : BST l)
  (IHr : BST r) :
  BST (Node c x v l r)

theorem Leaf_BST‹s› (V : U) : BST (@Leaf‹s› V) :=
  BST_Leaf

theorem lt_gt %(x y : int) : x < y = true -> y > x = true := #magic
theorem gt_lt %(x y : int) : x > y = true -> y < x = true := #magic
theorem lt_trans %(x y z : int) : x < y = true -> y < z = true -> x < z = true := #magic
theorem gt_trans %(x y z : int) : x > y = true -> y > z = true -> x > z = true := #magic


theorem ForallT_imp‹s› %(V : U) (P Q : int -> V -> bool) (t : tree‹s› V) :
  ForallT P t ->
  (∀ (k : int) (v : V) -> P k v = true -> Q k v = true) ->
  ForallT Q t :=
  #magic
  
theorem ForallT_gt‹s› %(V : U) %(t : tree‹s› V) %(k k0 : int) :
  ForallT (fn k1 _ => k1 > k) t ->
  k > k0 = true ->
  ForallT (fn k1 _ => k1 > k0) t :=
  #magic

theorem ForallT_lt‹s› %(V : U) %(t : tree‹s› V) %(k k0 : int) :
  ForallT (fn k1 _ => k1 < k) t ->
  k < k0 = true ->
  ForallT (fn k1 _ => k1 < k0) t :=
  #magic


theorem balance_BST‹s› %(V : U) (k : int) (vk : V) (c : color) (l r : tree‹s› V) :
  ForallT (fn i _ => i < k) l ->
  ForallT (fn i _ => i > k) r ->
  BST l ->
  BST r ->
  BST (balance c k vk l r) :=
fn Hl Hr IHl IHr =>
  match c    as c0 
     in BST (balance c0 k vk l r)
  with
  | Red => BST_Node Red k vk l r Hl Hr IHl IHr
  | Black => 
    match l   as l0
        , Hl  as _ : ForallT (fn i _ => i < k) l0
        , IHl as _ : BST l0
       in BST (balance Black k vk l0 r)
    with
    | Node Red y vy (Node Red x vx a b) c, 
      ForallT_Node _ _ _ _ _ Hyk _ Hkc,
      BST_Node _ _ _ _ _ 
        (ForallT_Node _ _ _ _ _ Hyx Hya Hyb) Hyc 
        (BST_Node _ _ _ _ _ Hxa Hxb IHa IHb) IHc =>
      let h1 : ForallT (fn i _ => i < y) (Node Black x vx a b) := 
        ForallT_Node Black x vx _ _ Hyx Hya Hyb
      in
      let h2 : ForallT (fn i _ => i > y) (Node Black k vk c r) :=
        let Hyk := lt_gt Hyk in
        ForallT_Node Black k vk _ _ Hyk Hyc (ForallT_gt Hr Hyk)
      in
      let bst1 : BST (Node Black x vx a b) :=
        BST_Node Black x vx _ _ Hxa Hxb IHa IHb
      in
      let bst2 : BST (Node Black k vk c r) :=
        BST_Node Black k vk _ _ Hkc Hr IHc IHr
      in
      -- balances to: Node Red y vy (Node Black x vx a b) (Node Black k vk c t2)
      let bst : BST (Node Red y vy (Node Black x vx a b) (Node Black k vk c r)) :=
        BST_Node Red y vy _ _ h1 h2 bst1 bst2
      in
      bst
    | Node Red y vy (Node Red x vx a b) c, _, _ =>

    | Node Red x vx Leaf (Node Red y vy b c),
      ForallT_Node _ _ _ _ _ Hxk _ (ForallT_Node _ _ _ _ _ Hky Hkb Hkc),
      BST_Node _ _ _ _ _
        Hxa (ForallT_Node _ _ _ _ _ Hxy Hxb Hxc) 
        IHa (BST_Node _ _ _ _ _ Hyb Hyc IHb IHc) =>
      let h1 : ForallT (fn i _ => i < y) (Node Black x vx Leaf b) :=
        let Hxy := gt_lt Hxy in
        ForallT_Node Black x vx _ _ Hxy (ForallT_lt Hxa Hxy) Hyb
      in
      let h2 : ForallT (fn i _ => i > y) (Node Black k vk c r) :=
        let Hky := lt_gt Hky in
        ForallT_Node Black k vk _ _ Hky Hyc (ForallT_gt Hr Hky)
      in
      let bst1 : BST (Node Black x vx Leaf b) :=
        BST_Node Black x vx _ _ Hxa Hxb IHa IHb
      in
      let bst2 : BST (Node Black k vk c r) :=
        BST_Node Black k vk _ _ Hkc Hr IHc IHr
      in
      -- balances to: Node Red y vy (Node Black x vx a b) (Node Black k vk c t2)
      let bst : BST (Node Red y vy (Node Black x vx Leaf b) (Node Black k vk c r)) :=
        BST_Node Red y vy _ _ h1 h2 bst1 bst2
      in
      bst
    | Node Red x vx (Node Black _ _ _ _) (Node Red y vy b c),
      ForallT_Node _ x1 _ _ _ Hxk _ (ForallT_Node _ _ _ _ _ Hky Hkb Hkc),
      BST_Node _ x2 _ _ _
        Hxa (ForallT_Node _ _ _ _ _ Hxy Hxb Hxc) 
        IHa (BST_Node _ _ _ _ _ Hyb Hyc IHb IHc) =>
      let h1 : ForallT (fn i _ => i < y) (Node Black x vx _ b) :=
        let Hxy := gt_lt Hxy in
        ForallT_Node Black x vx _ _ Hxy (ForallT_lt Hxa Hxy) Hyb
      in
      let h2 : ForallT (fn i _ => i > y) (Node Black k vk c r) :=
        let Hky := lt_gt Hky in
        ForallT_Node Black k vk _ _ Hky Hyc (ForallT_gt Hr Hky)
      in
      let bst1 : BST (Node Black x vx _ b) :=
        BST_Node Black x vx _ _ Hxa Hxb IHa IHb
      in
      let bst2 : BST (Node Black k vk c r) :=
        BST_Node Black k vk _ _ Hkc Hr IHc IHr
      in
      let bst : BST (Node Red y vy (Node Black x vx _ b) (Node Black k vk c r)) :=
        BST_Node Red y vy _ _ h1 h2 bst1 bst2
      in
      bst
    | Node Red x vx a (Node Red y vy b c), _, _ =>

    | l, Hl, IHl =>
      match r    as r0
          , Hr   as _ : ForallT (fn i _ => i > k) r0
          , IHr  as _ : BST r0
        in BST (balance Black k vk l r0)
      with
      | Node Red z vz (Node Red y vy b c) d,
        ForallT_Node _ _ _ _ _ Hkz (ForallT_Node _ _ _ _ _ Hky Hkb Hkc) Hkd,
        BST_Node _ _ _ _ _ 
          (ForallT_Node _ _ _ _ _ Hzy Hzb Hzc) Hzd 
          (BST_Node _ _ _ _ _ Hyb Hyc IHb IHc) IHd =>
        let h1 : ForallT (fn i _ => i < y) (Node Black k vk l b) :=
          let Hky : k < y = true := @gt_lt y k Hky in
          @ForallT_Node _ (fn i _ => i < y) Black k vk l b Hky 
            (@ForallT_lt _ l k y Hl Hky) Hyb
        in
        let h2 : ForallT (fn i _ => i > y) (Node Black z vz c d) :=
          let Hzy : z > y = true := @lt_gt y z Hzy in
          @ForallT_Node _ (fn i _ => i > y) Black z vz c d Hzy Hyc 
            (@ForallT_gt _ d z y Hzd Hzy)
        in
        let bst1 : BST (Node Black k vk l b) :=
          BST_Node Black k vk l b Hl Hkb IHl IHb
        in
        let bst2 : BST (Node Black z vz c d) :=
          BST_Node Black z vz c d Hzc Hzd IHc IHd
        in
        -- balances to: Node Red y vy (Node Black k vk t1 b) (Node Black z vz c d)
        let bst : BST (Node Red y vy (Node Black k vk l b) (Node Black z vz c d)) :=
          BST_Node Red y vy (Node Black k vk l b) (Node Black z vz c d) h1 h2 bst1 bst2
        in
        bst
      | Node Red z vz (Node Red y vy b c) d, _, _ =>

      | Node Red z vz Leaf (Node Red y vy c d),
        ForallT_Node _ _ _ _ _ Hkz Hkb (ForallT_Node _ _ _ _ _ Hky Hkc Hkd),
        BST_Node _ _ _ _ _
          Hb (ForallT_Node _ _ _ _ _ Hzy Hzc Hzd) 
          IHb (BST_Node _ _ _ _ _ Hyc Hyd IHc IHd) =>
        let h1 : ForallT (fn i _ => i < z) (Node Black k vk l Leaf) :=
          let Hkz : k < z = true := @gt_lt z k Hkz in 
          @ForallT_Node _ (fn i _ => i < z) Black k vk l Leaf 
            Hkz (@ForallT_lt _ l k z Hl Hkz) Hb
        in
        let h2 : ForallT (fn i _ => i > z) (Node Black y vy c d) :=
          @ForallT_Node _ (fn i _ => i > z) Black y vy c d
            Hzy Hzc Hzd
        in
        let bst1 : BST (Node Black k vk l Leaf) :=
          BST_Node Black k vk l Leaf Hl Hkb IHl IHb
        in
        let bst2 : BST (Node Black y vy c d) :=
          BST_Node Black y vy c d Hyc Hyd IHc IHd
        in
        -- balances to: Node Red z vz (Node Black k vk t1 b) (Node Black y vy c d)
        let bst : BST (Node Red z vz (Node Black k vk l Leaf) (Node Black y vy c d)) :=
          BST_Node Red z vz (Node Black k vk l Leaf) (Node Black y vy c d) h1 h2 bst1 bst2
        in
        bst
      | Node Red z vz (Node Black x vx a b) (Node Red y vy c d), 
        ForallT_Node _ _ _ _ _ Hkz Hkb (ForallT_Node _ _ _ _ _ Hky Hkc Hkd),
        BST_Node _ _ _ _ _
          Hb (ForallT_Node _ _ _ _ _ Hzy Hzc Hzd) 
          IHb (BST_Node _ _ _ _ _ Hyc Hyd IHc IHd) =>
        let h1 : ForallT (fn i _ => i < z) (Node Black k vk l (Node Black x vx a b)) :=
          let Hkz : k < z = true := @gt_lt z k Hkz in 
          @ForallT_Node _ (fn i _ => i < z) Black k vk l (Node Black x vx a b) 
            Hkz (@ForallT_lt _ l k z Hl Hkz) Hb
        in
        let h2 : ForallT (fn i _ => i > z) (Node Black y vy c d) :=
          @ForallT_Node _ (fn i _ => i > z) Black y vy c d
            Hzy Hzc Hzd
        in
        let bst1 : BST (Node Black k vk l (Node Black x vx a b)) :=
          BST_Node Black k vk l (Node Black x vx a b) Hl Hkb IHl IHb
        in
        let bst2 : BST (Node Black y vy c d) :=
          BST_Node Black y vy c d Hyc Hyd IHc IHd
        in
        -- balances to: Node Red z vz (Node Black k vk t1 b) (Node Black y vy c d)
        let bst : BST (Node Red z vz (Node Black k vk l (Node Black x vx a b)) (Node Black y vy c d)) :=
          BST_Node Red z vz (Node Black k vk l (Node Black x vx a b)) (Node Black y vy c d) h1 h2 bst1 bst2
        in
        bst
      | Node Red z vz a (Node Red y vy c d), _, _ =>

      | r, Hr, IHr => 
        -- balances to: Node Black k vk t1 t2
        BST_Node Black k vk l r Hl Hr IHl IHr