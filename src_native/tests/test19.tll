logical eq_sym‹s› (A : Type‹s›) (x y : A) : x ≡ y → y ≡ x =
  fn e ⇒ rew [y, _ ⇒ y ≡ x] e in refl

logical f_equal‹s,t› (A : Type‹s›) (B : Type‹t›) (f : A → B) (x y : A) : x ≡ y → f x ≡ f y =
  fn e ⇒ rew [y,p ⇒ f x ≡ f y] e in refl

logical bool_absurd (e : true ≡ false) : ⊥ =
  rew [x, _ ⇒ match x with
              | true ⇒ unit
              | false ⇒ ⊥
              end] e in ()

logical nat_absurd (n : nat) (e : S n ≡ O) : ⊥ =
  rew [x,_ ⇒ match x with
             | O ⇒ ⊥
             | S _ ⇒ unit
             end] e in ()

logical nat_inv (n1 n2 : nat) (e : S n1 ≡ S n2) : n1 ≡ n2 =
  f_equal _ _ pred _ _ e

logical eqn_reflect (m n : nat) : eqn m n ≡ true → m ≡ n =
  match m as m0 in eqn m0 n ≡ true → m0 ≡ n with
  | O ⇒
    match n as n0 in eqn 0 n0 ≡ true → 0 ≡ n0 with
    | O ⇒ fn _ ⇒ refl
    | S n ⇒ fn e ⇒ absurd_elim _ (bool_absurd (eq_sym _ _ _ e))
    end
  | S m ⇒
    match n as n0 in eqn (S m) n0 ≡ true → (S m) ≡ n0 with
    | O ⇒ fn e ⇒ absurd_elim _ (bool_absurd (eq_sym _ _ _ e))
    | S n ⇒ fn e ⇒ f_equal _ _ (fn x ⇒ S x) _ _ (eqn_reflect m n e)
    end
  end

inductive word : U =
| Word of (s : string) {pf : strlen s ≡ 5}

program string_diff (s1 s2 : string) : string =
  match s1 with
  | EmptyString ⇒ EmptyString
  | String c1 s1 ⇒
    match s2 with
    | EmptyString ⇒ EmptyString
    | String c2 s2 ⇒
      if eqc c1 c2 then
        "Y" ^ string_diff s1 s2
      else
        "N" ^ string_diff s1 s2
     end
   end

logical string_diff_len (n : nat) (s1 s2 : string) :
  n ≡ strlen s1 → n ≡ strlen s2 → n ≡ strlen (string_diff s1 s2) =
  match s1 as s0 in n ≡ strlen s0 → n ≡ strlen s2 → n ≡ strlen (string_diff s0 s2) with
  | EmptyString ⇒
    match s2 as s0 in n ≡ 0 → n ≡ strlen s0 → n ≡ 0 with
    | EmptyString ⇒ fn e1 _ ⇒ e1
    | String c2 s2 ⇒ fn e1 e2 ⇒
      let e3 = rew [n, _ ⇒ n ≡ 0] e2 in e1 in
      absurd_elim _ (nat_absurd _ e3)
    end
  | String c1 s1 ⇒ 
    match s2 as s0 in
      n ≡ strlen (String c1 s1) → n ≡ strlen s0 → n ≡ strlen (string_diff (String c1 s1) s0)
    with
    | EmptyString ⇒ fn e1 e2 ⇒
      let e3 = rew [n, _ ⇒ n ≡ 0] e1 in e2 in
      absurd_elim _ (nat_absurd _ e3)
    | String c2 s2 ⇒  fn e1 e2 ⇒
      match n as n0 in n ≡ n0 → n0 ≡ strlen (string_diff (String c1 s1) (String c2 s2)) with
      | O ⇒ fn e0 ⇒
        let e3 = rew [n, _ ⇒ n ≡ 0 ] e1 in e0 in
        absurd_elim _ (nat_absurd _ e3)
      | S n0 ⇒ fn e0 ⇒
        let e3 = rew [n1, _ ⇒ n1 ≡ S (strlen s1)] e0 in e1 in
        let e4 = rew [n1, _ ⇒ n1 ≡ S (strlen s2)] e0 in e2 in
        let e5 = nat_inv _ _ e3 in
        let e6 = nat_inv _ _ e4 in
        match eqc c1 c2 as b0 in
          S n0 ≡ strlen (if b0 then "Y" ^ string_diff s1 s2
                         else "N" ^ string_diff s1 s2)
        with
        | true ⇒ rew [n1, _ ⇒ S n0 ≡ S n1] (string_diff_len _ _ _ e5 e6) in refl
        | false ⇒ rew [n1, _ ⇒ S n0 ≡ S n1] (string_diff_len _ _ _ e5 e6) in refl
        end
      end refl
    end
  end

program word_diff (w1 w2 : word) : word =
  match w1 with Word s1 pf1 ⇒
  match w2 with Word s2 pf2 ⇒
    let {pf1} = eq_sym _ _ _ pf1 in
    let {pf2} = eq_sym _ _ _ pf2 in
    let {pf} = string_diff_len _ _ _ pf1 pf2 in
    Word (string_diff s1 s2) (eq_sym _ _ _ pf)
  end end

program eqw (w1 w2 : word) : bool =
  match w1 with Word s1 _ ⇒
  match w2 with Word s2 _ ⇒
    eqs s1 s2
  end end

logical wordle_loop (ans : word) (repeat : nat) : proto =
  match repeat with
  | O ⇒ ⇑(w : word) → ⇑{w ≡ ans} → •
  | S repeat ⇒
    ⇓(guess : word) →
    ⇑(b : bool) → ⇑{b ≡ eqw ans guess} →
    if b then •
    else ⇑(w : word) → ⇑{w ≡ word_diff ans guess} → wordle_loop ans repeat
  end

logical wordle : proto = ⇑{ans : word} → ⇑(repeat : nat) → wordle_loop ans repeat

logical loop_ch (ans : word) (repeat : nat) : L = ch⟨ wordle_loop ans repeat ⟩
logical loop_hc (ans : word) (repeat : nat) : L = hc⟨ wordle_loop ans repeat ⟩

logical wordle_ch : L = ch⟨ wordle ⟩
logical wordle_hc : L = hc⟨ wordle ⟩

program read_word (_ : unit) : IO word =
  let s ⇐ readline () in
  match eqn (strlen s) 5 as b0 in {eqn (strlen s) 5 ≡ b0} → IO word with
  | true ⇒ fn {e} ⇒ return (Word s (eqn_reflect _ _ e))
  | false ⇒ fn {_} ⇒
    print "please input a word with length of 5\n"; read_word ()
  end refl

program player_loop {ans : word} (repeat : nat) (c : loop_hc ans repeat) : IO unit =
  match repeat as repeat0 in loop_hc ans repeat0 → IO unit with
  | O ⇒ fn c ⇒
    let ⟨ans, c⟩ ⇐ recv c in
    let ⟨{pf}, c⟩ ⇐ recv c in
    match ans with Word s _ ⇒
      print ("You Lose! The answer is " ^ s ^ ".\n"); close c
    end
  | S repeat ⇒ fn c ⇒
    let guess ⇐ read_word () in
    let c ⇐ send c guess in
    let ⟨b, c⟩ ⇐ recv c in
    let ⟨{pf}, c⟩ ⇐ recv c in
    match b as b0 in
      hc⟨if b0 then •
         else ⇑(w : word) → ⇑{w ≡ word_diff ans guess} → wordle_loop ans repeat⟩
      ⊸ IO unit
    with
    | true ⇒ ln c ⇒
      print "You Win!\n"; close c
    | false ⇒ ln c ⇒
      let ⟨diff, c⟩ ⇐ recv c in
      let ⟨{pf}, c⟩ ⇐ recv c in
      match diff with Word s _ ⇒
        print ("Incorrect, hint: " ^ s ^ ". You have " ^ string_of_nat repeat ^ " more tries.\n");
        player_loop ans repeat c
      end
    end c
  end c

program player (c : wordle_hc) : IO unit =
  let ⟨{ans}, c⟩ ⇐ recv c in
  let ⟨repeat, c⟩ ⇐ recv c in
  print "Wordle Game\n";
  print "Please guess a word of length 5.\n";
  print ("You have " ^ string_of_nat repeat ^ " tries.\n");
  player_loop ans repeat c

program server_loop (ans : word) (repeat : nat) (c : loop_ch ans repeat) : IO unit =
  match repeat as repeat0 in loop_ch ans repeat0 → IO unit with
  | O ⇒ fn c ⇒
    let c ⇐ send c ans in
    let c ⇐ send c refl in
    close c
  | S repeat ⇒ fn c ⇒
    let ⟨guess, c⟩ ⇐ recv c in
    let b = eqw ans guess in
    let c ⇐ send c b in
    let c ⇐ send c refl in
    match b as b0 in
      ch⟨if b0 then •
         else ⇑(w : word) → ⇑{w ≡ word_diff ans guess} → wordle_loop ans repeat⟩
      ⊸ IO unit
    with
    | true ⇒ ln c ⇒ close c
    | false ⇒ ln c ⇒
      let c ⇐ send c (word_diff ans guess) in
      let c ⇐ send c refl in
      server_loop ans repeat c 
    end c
  end c
    
program server (c : wordle_ch) : IO unit =
  let repeat = 5 in
  let ans = Word "world" refl in
  let c ⇐ send c ans in
  let c ⇐ send c repeat in
  server_loop ans repeat c

program main : IO unit =
  let c ⇐
    fork (c : wordle_ch) in server c
  in
  let c0 ⇐
    fork (c0 : ch⟨⇓(wordle_hc) → ⇑(unit) → •⟩) in
      let ⟨c, c0⟩ ⇐ recv c0 in
      let _ ⇐ player c in
      let c0 ⇐ send c0 () in
      close c0
  in
  let c0 ⇐ send c0 c in
  let ⟨_, c0⟩ ⇐ recv c0 in
  close c0
